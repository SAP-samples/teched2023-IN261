/*! For license information please see solclient-debug.js.LICENSE.txt */
(function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === "object" && typeof module === "object") module.exports = factory(); else if (typeof define === "function" && define.amd) define("solace", [], factory); else if (typeof exports === "object") exports["solace"] = factory(); else root["solace"] = factory();
})(this, () => {
    /******/
    return (() => {
        // webpackBootstrap
        /******/ var __webpack_modules__ = {
            /***/ "./index.js": 
            /*!******************!*\
  !*** ./index.js ***!
  \******************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                // Node entry point
                //global.BUILD_ENV = require('./define.config.js');
                module.exports = __webpack_require__(/*! solclient-core */ "./modules/solclient-core/api.js");
                /***/
            },
            /***/ "./modules/solclient-convert/api.js": 
            /*!******************************************!*\
  !*** ./modules/solclient-convert/api.js ***!
  \******************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Base64
                } = __webpack_require__(/*! ./lib/base64 */ "./modules/solclient-convert/lib/base64.js");
                const {
                    Bits
                } = __webpack_require__(/*! ./lib/bits */ "./modules/solclient-convert/lib/bits.js");
                const {
                    Convert
                } = __webpack_require__(/*! ./lib/convert */ "./modules/solclient-convert/lib/convert.js");
                const {
                    Hex
                } = __webpack_require__(/*! ./lib/hex */ "./modules/solclient-convert/lib/hex.js");
                const {
                    Long
                } = __webpack_require__(/*! ./lib/long */ "./modules/solclient-convert/lib/long.js");
                module.exports.Base64 = Base64;
                module.exports.Bits = Bits;
                module.exports.Convert = Convert;
                module.exports.Hex = Hex;
                module.exports.Long = Long;
                /***/
            },
            /***/ "./modules/solclient-convert/lib/base64.js": 
            /*!*************************************************!*\
  !*** ./modules/solclient-convert/lib/base64.js ***!
  \*************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
                // This code was written by Tyler Akins and has been placed in the
                // public domain.  It would be nice if you left this header intact.
                // Base64 code from Tyler Akins -- http://rumkin.com
                // It has been modified by me (Edward Funnekotter) to improve its
                // efficiency
                // It has been modified by me (Justin Bowes) to avoid using it whenever
                // possible in favour of browser or buffer implementations.
                const KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                const ENC_LUT = [ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 99, -1, -1, 99, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 99, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 64, -1, -1, 
                // 64
                -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1, 
                // 128
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
                // 192
                -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 ];
                class DecodeError extends Error {}
                const LegacyEncoder = {
                    /**
   * Encodes a string in base64
   * @param {String} input The string to encode in base64.
   * @returns {String} base64 encoded input
   * @private
   */
                    base64_encode(input) {
                        let output = "";
                        let i = 0;
                        do {
                            const chr1 = input.charCodeAt(i++);
                            const chr2 = input.charCodeAt(i++);
                            const chr3 = input.charCodeAt(i++);
                            const enc1 = chr1 >> 2;
                            const enc2 = (chr1 & 3) << 4 | chr2 >> 4;
                            let enc3 = (chr2 & 15) << 2 | chr3 >> 6;
                            let enc4 = chr3 & 63;
                            if (isNaN(chr2)) {
                                enc3 = enc4 = 64;
                            } else if (isNaN(chr3)) {
                                enc4 = 64;
                            }
                            output += KEY_STR.charAt(enc1);
                            output += KEY_STR.charAt(enc2);
                            output += KEY_STR.charAt(enc3);
                            output += KEY_STR.charAt(enc4);
                        } while (i < input.length);
                        return output;
                    },
                    /**
   * Decodes a base64 string.
   * @param {String} input The base64 string to decode.
   * @returns {String} binary output
   * @private
   */
                    base64_decode(input) {
                        let output = "";
                        let i = 0;
                        do {
                            while (ENC_LUT[input.charCodeAt(i)] > 64) {
                                i++;
                            }
                            const enc1 = ENC_LUT[input.charCodeAt(i++)];
                            const enc2 = ENC_LUT[input.charCodeAt(i++)];
                            const enc3 = ENC_LUT[input.charCodeAt(i++)];
                            const enc4 = ENC_LUT[input.charCodeAt(i++)];
                            if (enc1 < 0 || enc2 < 0 || enc3 < 0 || enc4 < 0) {
                                // Invalid character in base64 text
                                // alert("enc at " + i + ": " + enc1 + ", " + enc2 + ", " + enc3 + ", " + enc4);
                                throw new DecodeError("Invalid base64 character");
                            }
                            const chr1 = enc1 << 2 | enc2 >> 4;
                            const chr2 = (enc2 & 15) << 4 | enc3 >> 2;
                            const chr3 = (enc3 & 3) << 6 | enc4;
                            output += String.fromCharCode(chr1);
                            if (enc3 !== 64) {
                                output += String.fromCharCode(chr2);
                            }
                            if (enc4 !== 64) {
                                output += String.fromCharCode(chr3);
                            }
                        } while (i < input.length - 3);
                        return output;
                    }
                };
                const isNode = typeof window === "undefined"; // !node
                const hasBuffer = typeof Buffer !== "undefined";
                const hasBlob = typeof Blob !== "undefined"; // !node, !ie9
                const BufferEncoder = hasBuffer && (hasBlob || isNode) ? {
                    base64_encode: str => Buffer.from(str, "binary").toString("base64"),
                    base64_decode: str => Buffer.from(str, "base64").toString("binary")
                } : {};
                /* eslint-env browser */
                /* eslint-disable dot-notation */
                const WindowEncoder = typeof window !== "undefined" ? {
                    base64_encode: window["btoa"] ? b => window["btoa"](b) : null,
                    base64_decode: window["atob"] ? a => window["atob"](a) : null
                } : {};
                /* eslint-enable dot-notation */
                const Base64 = {
                    encode: WindowEncoder.base64_encode || BufferEncoder.base64_encode || LegacyEncoder.base64_encode,
                    decode: WindowEncoder.base64_decode || BufferEncoder.base64_decode || LegacyEncoder.base64_decode
                };
                module.exports.Base64 = Base64;
                /***/
            },
            /***/ "./modules/solclient-convert/lib/bits.js": 
            /*!***********************************************!*\
  !*** ./modules/solclient-convert/lib/bits.js ***!
  \***********************************************/
            /***/ module => {
                const Bits = {
                    get(val, shift, numBits) {
                        return val >>> shift & (1 << numBits) - 1;
                    },
                    set(dataIn, val, shift, numBits) {
                        const curMask = (1 << numBits) - 1;
                        const shiftedVal = (val & curMask) << shift;
                        const data = dataIn & ~(curMask << shift);
                        return data | shiftedVal;
                    }
                };
                module.exports.Bits = Bits;
                /***/
            },
            /***/ "./modules/solclient-convert/lib/convert.js": 
            /*!**************************************************!*\
  !*** ./modules/solclient-convert/lib/convert.js ***!
  \**************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const Long = __webpack_require__(/*! long */ "./node_modules/long/umd/index.js");
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                // eslint-disable-next-line global-require
                const BufferImpl = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;
                /**
 * @module
 * ===========================================================================
 * Convert
 *
 * This collection of functions performs all required string to number and number to string
 * conversions
 * ============================================================================
 * @private
 */
                const TWO_ZEROES_STR = String.fromCharCode(0, 0);
                const THREE_ZEROES_STR = String.fromCharCode(0, 0, 0);
                const FOUR_ZEROES_STR = String.fromCharCode(0, 0, 0, 0);
                const BYTEARRAY_CONVERT_CHUNK = 8192;
                const UNSIGNED_LSHIFT_24 = 256 * 256 * 256;
                const ARRAY_BUFFER_CONVERT_CHUNK = 32768;
                function stringToUint8Array(data) {
                    const dataLength = data.length;
                    const arrayBuf = new ArrayBuffer(dataLength);
                    const uint8Array = new Uint8Array(arrayBuf, 0, dataLength);
                    for (let i = 0; i < dataLength; i++) {
                        uint8Array[i] = data.charCodeAt(i);
                    }
                    return uint8Array;
                }
                function arrayBufferToString(ab) {
                    if (!ab) return "";
                    const len = ab.byteLength;
                    const u8 = new Uint8Array(ab);
                    if (len < ARRAY_BUFFER_CONVERT_CHUNK) {
                        return String.fromCharCode.apply(null, u8);
                    }
                    let k = 0;
                    let r = "";
                    while (k < len) {
                        // slice is clamped, inclusive of startIndex, exclusive of lastIndex
                        r += String.fromCharCode.apply(null, u8.subarray(k, k + ARRAY_BUFFER_CONVERT_CHUNK));
                        k += ARRAY_BUFFER_CONVERT_CHUNK;
                    }
                    return r;
                }
                function stringToArrayBuffer(str) {
                    return stringToUint8Array(str).buffer;
                }
                function int8ToStr(int8) {
                    return String.fromCharCode(int8 & 255);
                }
                function int16ToStr(int16) {
                    return String.fromCharCode(int16 >> 8 & 255) + String.fromCharCode(int16 & 255);
                }
                function int24ToStr(int24) {
                    return String.fromCharCode(int24 >> 16 & 255) + String.fromCharCode(int24 >> 8 & 255) + String.fromCharCode(int24 & 255);
                }
                function int32ToStr(int32) {
                    // It is expected that there are a lot of small numbers
                    // being converted, so it is worth doing a few checks for
                    // efficiency (on firefox it is about 3 times quicker for small numbers
                    // to do the check - it is 2 times quicker for chrome)
                    if (int32 === 0) return FOUR_ZEROES_STR;
                    if (int32 > 0) {
                        if (int32 < 256) {
                            return THREE_ZEROES_STR + String.fromCharCode(int32);
                        }
                        if (int32 < 65536) {
                            return TWO_ZEROES_STR + String.fromCharCode(int32 >> 8) + String.fromCharCode(int32 & 255);
                        }
                    }
                    return String.fromCharCode(int32 >> 24 & 255) + String.fromCharCode(int32 >> 16 & 255) + String.fromCharCode(int32 >> 8 & 255) + String.fromCharCode(int32 & 255);
                }
                function int64ToStr(int64) {
                    if (typeof int64 !== "number") {
                        return int32ToStr(int64.high) + int32ToStr(int64.low);
                    }
                    // It is expected that there are a lot of small numbers
                    // being converted, so it is worth doing a few checks for
                    // efficiency (on firefox it is about 3 times quicker for small numbers
                    // to do the check - it is 2 times quicker for chrome)
                    if (int64 >= 0) {
                        if (int64 < 256) {
                            return FOUR_ZEROES_STR + THREE_ZEROES_STR + String.fromCharCode(int64);
                        }
                        if (int64 < 65536) {
                            return FOUR_ZEROES_STR + TWO_ZEROES_STR + String.fromCharCode(int64 >> 8) + String.fromCharCode(int64 & 255);
                        }
                        if (int64 < 4294967296) {
                            return FOUR_ZEROES_STR + (String.fromCharCode(int64 >> 24 & 255) + String.fromCharCode(int64 >> 16 & 255) + String.fromCharCode(int64 >> 8 & 255) + String.fromCharCode(int64 & 255));
                        }
                    }
                    return String.fromCharCode(int64 >> 56 & 255) + String.fromCharCode(int64 >> 48 & 255) + String.fromCharCode(int64 >> 40 & 255) + String.fromCharCode(int64 >> 32 & 255) + String.fromCharCode(int64 >> 24 & 255) + String.fromCharCode(int64 >> 16 & 255) + String.fromCharCode(int64 >> 8 & 255) + String.fromCharCode(int64 & 255);
                }
                function byteArrayToStr(byteArray) {
                    const len = byteArray.length;
                    if (len < BYTEARRAY_CONVERT_CHUNK) {
                        return String.fromCharCode.apply(null, byteArray);
                    }
                    let k = 0;
                    let r = "";
                    while (k < len) {
                        // slice is clamped, inclusive of startIndex, exclusive of lastIndex
                        r += String.fromCharCode.apply(null, byteArray.slice(k, k + BYTEARRAY_CONVERT_CHUNK));
                        k += BYTEARRAY_CONVERT_CHUNK;
                    }
                    return r;
                }
                function strToByteArray(str) {
                    const result = [];
                    let i;
                    for (i = 0; i < str.length; i++) {
                        result[i] = str.charCodeAt(i);
                    }
                    return result;
                }
                function strToHexArray(str) {
                    function toHex(c) {
                        return c.charCodeAt(0).toString(16);
                    }
                    return Array.prototype.map.call(str.split(""), toHex);
                }
                function strToInt8(data) {
                    return data.charCodeAt(0) & 255;
                }
                function strToInt16(data) {
                    return (data.charCodeAt(0) << 8) + data.charCodeAt(1);
                }
                function strToInt24(data) {
                    return (data.charCodeAt(0) << 16) + (data.charCodeAt(1) << 8) + data.charCodeAt(2);
                }
                function strToInt32(data) {
                    // SIGNED integer
                    return (data.charCodeAt(0) << 24) + (data.charCodeAt(1) << 16) + (data.charCodeAt(2) << 8) + data.charCodeAt(3);
                }
                function strToUInt32(data) {
                    // WARNING: you cannot use a << 24 to shift a byte into
                    // a 32-bit string, because all shifts in JS are signed
                    return data.charCodeAt(0) * UNSIGNED_LSHIFT_24 + (data.charCodeAt(1) << 16) + (data.charCodeAt(2) << 8) + data.charCodeAt(3);
                }
                function strToUInt64(data) {
                    return Long.fromBits(strToUInt32(data.substr(4, 4)), strToUInt32(data.substr(0, 4)), true);
                }
                function ucs2ToUtf8(ucs2) {
                    return unescape(encodeURIComponent(ucs2));
                }
                function utf8ToUcs2(utf8) {
                    return decodeURIComponent(escape(utf8));
                }
                function anythingToBuffer(value) {
                    if (BufferImpl.isBuffer(value)) {
                        return value;
                    }
                    if (typeof value === "string") {
                        return BufferImpl.from(value, "latin1");
                    }
                    if (value instanceof ArrayBuffer) {
                        return BufferImpl.from(value);
                    }
                    //TypedArrays and DataView:
                    if (value.buffer instanceof ArrayBuffer && typeof value.byteLength === "number" && typeof value.byteOffset === "number") {
                        if (value.byteOffset === 0 && value.byteLength === value.buffer.byteLength) {
                            // "full sice", no actual offset: just use the raw buffer.
                            return BufferImpl.from(value.buffer);
                        }
                        return BufferImpl.from(value.buffer, value.byteOffset, value.byteLength);
                    }
                    throw new OperationError("Parameter value failed validation", ErrorSubcode.PARAMETER_OUT_OF_RANGE, "Expecting Buffer/Uint8Array, also accepting string, ArrayBuffer, any TypedArray, or DataView.");
                }
                const Convert = {
                    arrayBufferToString: arrayBufferToString,
                    stringToArrayBuffer: stringToArrayBuffer,
                    stringToUint8Array: stringToUint8Array,
                    int8ToStr: int8ToStr,
                    strToInt8: strToInt8,
                    int16ToStr: int16ToStr,
                    strToInt16: strToInt16,
                    int24ToStr: int24ToStr,
                    strToInt24: strToInt24,
                    int32ToStr: int32ToStr,
                    strToInt32: strToInt32,
                    strToUInt32: strToUInt32,
                    int64ToStr: int64ToStr,
                    strToUInt64: strToUInt64,
                    byteArrayToStr: byteArrayToStr,
                    strToByteArray: strToByteArray,
                    strToHexArray: strToHexArray,
                    ucs2ToUtf8: ucs2ToUtf8,
                    utf8ToUcs2: utf8ToUcs2,
                    anythingToBuffer: anythingToBuffer
                };
                module.exports.Convert = Convert;
                /***/
            },
            /***/ "./modules/solclient-convert/lib/hex.js": 
            /*!**********************************************!*\
  !*** ./modules/solclient-convert/lib/hex.js ***!
  \**********************************************/
            /***/ module => {
                function numToHex(n) {
                    if (typeof n !== "number") {
                        return "";
                    }
                    const s = n.toString(16);
                    return s.length < 2 ? `0${s}` : s;
                }
                function formatHexString(obj) {
                    if (typeof obj === "number") {
                        return `0x${numToHex(obj)}`;
                    }
                    if (typeof obj === "object" && Array.isArray(obj)) {
                        return obj.map(numToHex).join();
                    }
                    if (typeof obj === "string") {
                        return Array.prototype.map.call(obj, (_, i) => numToHex(obj.charCodeAt(i))).join("");
                    }
                    return null;
                }
                const Hex = {
                    formatHexString: formatHexString
                };
                module.exports.Hex = Hex;
                /***/
            },
            /***/ "./modules/solclient-convert/lib/long.js": 
            /*!***********************************************!*\
  !*** ./modules/solclient-convert/lib/long.js ***!
  \***********************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                module.exports.Long = __webpack_require__(/*! long */ "./node_modules/long/umd/index.js");
                /***/
            },
            /***/ "./modules/solclient-core/api-internal.js": 
            /*!************************************************!*\
  !*** ./modules/solclient-core/api-internal.js ***!
  \************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /**
 * SolclientJS internal API for white-box integration testing
 * @private
 */
                /* _eslint-disable sort-requires/sort-requires */
                const Convert = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const Debug = __webpack_require__(/*! solclient-debug */ "./modules/solclient-debug/api.js");
                const Destination = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                const Error = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const ESKit = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                const Factory = __webpack_require__(/*! solclient-factory */ "./modules/solclient-factory/api.js");
                const FSM = __webpack_require__(/*! solclient-fsm */ "./modules/solclient-fsm/api.js");
                const Log = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const Message = __webpack_require__(/*! solclient-message */ "./modules/solclient-message/api.js");
                const Publisher = __webpack_require__(/*! solclient-message-publisher */ "./modules/solclient-message-publisher/api.js");
                const SDT = __webpack_require__(/*! solclient-sdt */ "./modules/solclient-sdt/api.js");
                const Session = __webpack_require__(/*! solclient-session */ "./modules/solclient-session/api.js");
                const SMF = __webpack_require__(/*! solclient-smf */ "./modules/solclient-smf/api.js");
                const SolcacheSession = __webpack_require__(/*! solclient-solcache-session */ "./modules/solclient-solcache-session/api.js");
                const TestEnv = __webpack_require__(/*! solclient-env */ "./modules/solclient-env/api.js");
                const Transport = __webpack_require__(/*! solclient-transport */ "./modules/solclient-transport/api.js");
                const Util = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const Validate = __webpack_require__(/*! solclient-validate */ "./modules/solclient-validate/api.js");
                module.exports = {
                    Convert: Convert,
                    Debug: Debug,
                    Destination: Destination,
                    Error: Error,
                    ESKit: ESKit,
                    Factory: Factory,
                    FSM: FSM,
                    Log: Log,
                    Message: Message,
                    Publisher: Publisher,
                    SDT: SDT,
                    Session: Session,
                    SMF: SMF,
                    SolcacheSession: SolcacheSession,
                    TestEnv: TestEnv,
                    Transport: Transport,
                    Util: Util,
                    Validate: Validate
                };
                /***/
            },
            /***/ "./modules/solclient-core/api.js": 
            /*!***************************************!*\
  !*** ./modules/solclient-core/api.js ***!
  \***************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /**
 * <h1> Overview </h1>
 *
 * This is the Solace Corporation Messaging API for JavaScript. Concepts defined in this API are
 * similar to those defined in other Solace Messaging APIs for Java, C, and .NET.
 *
 * <h1> Concepts </h1>
 *
 * Some general concepts:
 *
 * <li> All function calls are non-blocking; confirmation, if requested, is returned to the calling
 * client application in the form of callbacks. </li>
 *
 */
                /* _eslint-disable sort-requires/sort-requires */
                // -------------------------- Solclient Factory ------------------------------
                // Load me before the rest of the API as a plug-in point for modules
                const FactoryLib = __webpack_require__(/*! solclient-factory */ "./modules/solclient-factory/api.js");
                // ---------------------------------------------------------------------------
                const {
                    SolclientFactory,
                    SolclientFactoryProfiles,
                    SolclientFactoryProperties
                } = FactoryLib;
                const {
                    Long
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    Destination,
                    DestinationType,
                    Topic
                } = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                const {
                    ErrorSubcode,
                    NotImplementedError,
                    OperationError,
                    RequestError,
                    RequestEventCode
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    makeIterator
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                const {
                    ConsoleLogImpl,
                    LogImpl,
                    LogLevel
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    Message,
                    MessageCacheStatus,
                    MessageDeliveryModeType,
                    MessageDumpFlag,
                    MessageType,
                    MessageUserCosType,
                    ReplicationGroupMessageId
                } = __webpack_require__(/*! solclient-message */ "./modules/solclient-message/api.js");
                const {
                    MessageConsumer,
                    MessageConsumerAcknowledgeMode,
                    MessageConsumerEventName,
                    MessageConsumerProperties,
                    QueueBrowser,
                    QueueBrowserEventName,
                    QueueBrowserProperties
                } = __webpack_require__(/*! solclient-message-consumer */ "./modules/solclient-message-consumer/api.js");
                const {
                    ReplayStartLocation,
                    ReplayStartLocationBeginning
                } = __webpack_require__(/*! solclient-replaystart */ "./modules/solclient-replaystart/api.js");
                const {
                    MessagePublisherAcknowledgeMode,
                    MessagePublisherProperties
                } = __webpack_require__(/*! solclient-message-publisher */ "./modules/solclient-message-publisher/api.js");
                const {
                    AbstractQueueDescriptor,
                    QueueAccessType,
                    QueueDescriptor,
                    QueueDiscardBehavior,
                    QueuePermissions,
                    QueueProperties,
                    QueueType
                } = __webpack_require__(/*! solclient-queue */ "./modules/solclient-queue/api.js");
                const {
                    SDTField,
                    SDTFieldType,
                    SDTMapContainer,
                    SDTStreamContainer,
                    SDTUnsupportedValueError,
                    SDTValueErrorSubcode
                } = __webpack_require__(/*! solclient-sdt */ "./modules/solclient-sdt/api.js");
                const {
                    AuthenticationScheme,
                    CapabilityType,
                    MessageRxCBInfo,
                    MutableSessionProperty,
                    Session,
                    SessionEvent,
                    SessionEventCBInfo,
                    SessionEventCode,
                    SessionProperties,
                    SessionState,
                    SslDowngrade
                } = __webpack_require__(/*! solclient-session */ "./modules/solclient-session/api.js");
                const {
                    CacheCBInfo,
                    CacheLiveDataAction,
                    CacheRequestResult,
                    CacheReturnCode,
                    CacheReturnSubcode,
                    CacheSession,
                    CacheSessionProperties
                } = __webpack_require__(/*! solclient-solcache-session */ "./modules/solclient-solcache-session/api.js");
                const {
                    StatType
                } = __webpack_require__(/*! solclient-stats */ "./modules/solclient-stats/api.js");
                const {
                    TransportError,
                    TransportProtocol
                } = __webpack_require__(/*! solclient-transport */ "./modules/solclient-transport/api.js");
                const {
                    Version
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                // --------------------------- Internal API -- do not use --------------------
                // Load me last. I disappear in production mode
                const _internal = __webpack_require__(/*! ./api-internal.js */ "./modules/solclient-core/api-internal.js");
                // ---------------------------------------------------------------------------
                /**
 * @namespace
 * @public
 */
                const solace = {
                    AbstractQueueDescriptor: AbstractQueueDescriptor,
                    AuthenticationScheme: AuthenticationScheme,
                    CacheCBInfo: CacheCBInfo,
                    CacheLiveDataAction: CacheLiveDataAction,
                    CacheRequestResult: CacheRequestResult,
                    CacheReturnCode: CacheReturnCode,
                    CacheReturnSubcode: CacheReturnSubcode,
                    CacheSession: CacheSession,
                    CacheSessionProperties: CacheSessionProperties,
                    CapabilityType: CapabilityType,
                    ConsoleLogImpl: ConsoleLogImpl,
                    Destination: Destination,
                    DestinationType: DestinationType,
                    ErrorSubcode: ErrorSubcode,
                    LogImpl: LogImpl,
                    LogLevel: LogLevel,
                    Long: Long,
                    Message: Message,
                    MessageCacheStatus: MessageCacheStatus,
                    MessageConsumer: MessageConsumer,
                    MessageConsumerAcknowledgeMode: MessageConsumerAcknowledgeMode,
                    MessageConsumerEventName: MessageConsumerEventName,
                    MessageConsumerProperties: MessageConsumerProperties,
                    MessageDeliveryModeType: MessageDeliveryModeType,
                    MessageDumpFlag: MessageDumpFlag,
                    MessagePublisherAcknowledgeMode: MessagePublisherAcknowledgeMode,
                    MessagePublisherProperties: MessagePublisherProperties,
                    MessageRxCBInfo: MessageRxCBInfo,
                    MessageType: MessageType,
                    MessageUserCosType: MessageUserCosType,
                    MutableSessionProperty: MutableSessionProperty,
                    NotImplementedError: NotImplementedError,
                    OperationError: OperationError,
                    QueueAccessType: QueueAccessType,
                    QueueBrowser: QueueBrowser,
                    QueueBrowserEventName: QueueBrowserEventName,
                    QueueBrowserProperties: QueueBrowserProperties,
                    QueueDescriptor: QueueDescriptor,
                    QueueDiscardBehavior: QueueDiscardBehavior,
                    QueuePermissions: QueuePermissions,
                    QueueProperties: QueueProperties,
                    QueueType: QueueType,
                    ReplayStartLocation: ReplayStartLocation,
                    /*
   * This should not be here ReplayStartLocationBeginning should not be a publicly exposed type.
   * This type must remain for backwards compatibility however it was never indented for use
   * by applications.
   * */
                    ReplayStartLocationBeginning: ReplayStartLocationBeginning,
                    ReplicationGroupMessageId: ReplicationGroupMessageId,
                    RequestError: RequestError,
                    RequestEventCode: RequestEventCode,
                    SDTField: SDTField,
                    SDTFieldType: SDTFieldType,
                    SDTMapContainer: SDTMapContainer,
                    SDTStreamContainer: SDTStreamContainer,
                    SDTUnsupportedValueError: SDTUnsupportedValueError,
                    SDTValueErrorSubcode: SDTValueErrorSubcode,
                    Session: Session,
                    SessionEvent: SessionEvent,
                    SessionEventCBInfo: SessionEventCBInfo,
                    SessionEventCode: SessionEventCode,
                    SessionProperties: SessionProperties,
                    SessionState: SessionState,
                    SolclientFactory: SolclientFactory,
                    SolclientFactoryProfiles: SolclientFactoryProfiles,
                    SolclientFactoryProperties: SolclientFactoryProperties,
                    SslDowngrade: SslDowngrade,
                    StatType: StatType,
                    Topic: Topic,
                    TransportError: TransportError,
                    TransportProtocol: TransportProtocol,
                    Version: Version,
                    makeIterator: makeIterator,
                    _internal: _internal
                };
                Object.assign(module.exports, solace);
                /***/
            },
            /***/ "./modules/solclient-debug/api.js": 
            /*!****************************************!*\
  !*** ./modules/solclient-debug/api.js ***!
  \****************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Debug
                } = __webpack_require__(/*! ./lib/debug */ "./modules/solclient-debug/lib/debug.js");
                module.exports.Debug = Debug;
                /***/
            },
            /***/ "./modules/solclient-debug/lib/debug.js": 
            /*!**********************************************!*\
  !*** ./modules/solclient-debug/lib/debug.js ***!
  \**********************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /* eslint-disable global-require */
                // Do late binding for these debug utilities to break cyclic dependencies.
                const PRINTABLE_LUT = (() => {
                    const tmp = [];
                    for (let c = 0; c < 256; ++c) {
                        tmp[c] = c < 33 || c > 126 ? "." : String.fromCharCode(c);
                    }
                    return tmp;
                })();
                const SPACER = "   ";
                const UNPRINTABLE = ".";
                function formatDumpBytes(data, showDecode, leftPadding) {
                    const {
                        StringBuffer,
                        StringUtils
                    } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                    const {
                        isEmpty,
                        padLeft,
                        padRight
                    } = StringUtils;
                    if (isEmpty(data)) {
                        return null;
                    }
                    const output = new StringBuffer();
                    const ascii = new StringBuffer();
                    const line = new StringBuffer();
                    let lineBytes = 0;
                    const asciiOffset = 54;
                    for (let i = 0, dataLen = data.length; i < dataLen; ++i) {
                        const ccode = data.charCodeAt(i);
                        //const ccode = dataBuf.readInt8(i);
                        line.append(padLeft(ccode.toString(16), 2, "0"), " ");
                        ascii.append(PRINTABLE_LUT[ccode] || UNPRINTABLE);
                        lineBytes++;
                        if (lineBytes === 8) {
                            line.append(SPACER);
                        }
                        if (lineBytes === 16 || i === data.length - 1) {
                            if (leftPadding > 0) {
                                output.append(padRight("", leftPadding, " "));
                            }
                            output.append(padRight(line.toString(), asciiOffset, " "));
                            if (showDecode) {
                                output.append(ascii);
                            }
                            output.append("\n");
                            line.clear();
                            ascii.clear();
                            lineBytes = 0;
                        }
                    }
                    return output.toString();
                }
                function parseSMFStream(data) {
                    const {
                        Codec: {
                            Decode: {
                                decodeCompoundMessage
                            }
                        }
                    } = __webpack_require__(/*! solclient-smf */ "./modules/solclient-smf/api.js");
                    const {
                        LOG_WARN,
                        LOG_ERROR
                    } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                    if (data === null) {
                        LOG_ERROR("data null in debugParseSmfStream");
                        return;
                    }
                    let pos = 0;
                    LOG_WARN(`parseSMFStream(): Starting parse, length ${data.length}`);
                    while (pos < data.length) {
                        const incomingMsg = decodeCompoundMessage(data, pos);
                        const smf = incomingMsg ? incomingMsg.smfHeader : null;
                        if (!(incomingMsg && smf)) {
                            // couldn't decode! Lost SMF framing.
                            LOG_WARN("parseSMFStream(): couldn't decode message.");
                            LOG_WARN(`Position: ${pos} length: ${data.length}`);
                            return;
                        }
                        LOG_WARN(`>> Pos(${pos}) Protocol ${smf.smf_protocol}, Length: ${smf.messageLength}`);
                        pos += smf.messageLength;
                    }
                }
                const Debug = {
                    formatDumpBytes: formatDumpBytes,
                    parseSMFStream: parseSMFStream
                };
                module.exports.Debug = Debug;
                /***/
            },
            /***/ "./modules/solclient-destination/api.js": 
            /*!**********************************************!*\
  !*** ./modules/solclient-destination/api.js ***!
  \**********************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Destination
                } = __webpack_require__(/*! ./lib/destination */ "./modules/solclient-destination/lib/destination.js");
                const {
                    DestinationFromNetwork
                } = __webpack_require__(/*! ./lib/destination-from-network */ "./modules/solclient-destination/lib/destination-from-network.js");
                const {
                    DestinationType
                } = __webpack_require__(/*! ./lib/destination-type */ "./modules/solclient-destination/lib/destination-type.js");
                const {
                    DestinationUtil
                } = __webpack_require__(/*! ./lib/destination-util */ "./modules/solclient-destination/lib/destination-util.js");
                const {
                    Parameter
                } = __webpack_require__(/*! solclient-validate */ "./modules/solclient-validate/api.js");
                const {
                    Queue
                } = __webpack_require__(/*! ./lib/queue */ "./modules/solclient-destination/lib/queue.js");
                const {
                    SolclientFactory
                } = __webpack_require__(/*! solclient-factory */ "./modules/solclient-factory/api.js");
                const {
                    Topic
                } = __webpack_require__(/*! ./lib/topic */ "./modules/solclient-destination/lib/topic.js");
                /**
 * Creates a topic {@link solace.Destination} instance. When the returned Destination is set as
 * the destination of a message via {@link solace.Message#setDestination}, the message will be
 * delivered to direct subscribers or topic endpoints subscribed to the given topic.
 *
 * @param {String} topicName The topic string for the new topic.
 * @returns {solace.Destination} The newly created topic destination.
 * @method
 * @name solace.SolclientFactory.createTopicDestination
 */
                SolclientFactory.createTopicDestination = SolclientFactory.createFactory(topicName => {
                    Parameter.isString("topicName", topicName);
                    return Topic.createFromName(topicName);
                });
                /* @deprecated @*/
                SolclientFactory.createTopic = SolclientFactory.createFactory(topicName => new Topic(topicName));
                /**
 * Creates a durable queue {@link solace.Destination} instance. When the returned Destination is
 * set as the destination of a message via {@link solace.Message#setDestination}, the message will
 * be delivered to the Guaranteed Message queue on the Solace Message Router of the same name.
 *
 * @since 10.0.0
 * @param {String} queueName The queueName of the queue
 * @returns {solace.Destination} The newly created queue destination.
 * @method
 * @name solace.SolclientFactory.createDurableQueueDestination
 */
                SolclientFactory.createDurableQueueDestination = SolclientFactory.createFactory(queueName => {
                    Parameter.isString("queueName", queueName);
                    return Queue.createFromLocalName(queueName);
                });
                module.exports.Destination = Destination;
                module.exports.DestinationFromNetwork = DestinationFromNetwork;
                module.exports.DestinationType = DestinationType;
                module.exports.DestinationUtil = DestinationUtil;
                module.exports.Queue = Queue;
                module.exports.Topic = Topic;
                /***/
            },
            /***/ "./modules/solclient-destination/lib/destination-from-network.js": 
            /*!***********************************************************************!*\
  !*** ./modules/solclient-destination/lib/destination-from-network.js ***!
  \***********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    DestinationType
                } = __webpack_require__(/*! ./destination-type */ "./modules/solclient-destination/lib/destination-type.js");
                const {
                    DestinationUtil
                } = __webpack_require__(/*! ./destination-util */ "./modules/solclient-destination/lib/destination-util.js");
                const {
                    Queue
                } = __webpack_require__(/*! ./queue */ "./modules/solclient-destination/lib/queue.js");
                const {
                    Topic
                } = __webpack_require__(/*! ./topic */ "./modules/solclient-destination/lib/topic.js");
                const QUEUE_PREFIX = "#P2P/QUE/";
                const QUEUE_PREFIX_LEN = QUEUE_PREFIX.length;
                const TEMPORARY_QUEUE_PREFIX = "#P2P/QTMP/";
                function createDestinationFromName(networkTopicName, networkTopicBytes = undefined) {
                    if (networkTopicName === null || networkTopicName.length === 0) {
                        return null;
                    }
                    const spec = {
                        name: networkTopicName,
                        bytes: networkTopicBytes || DestinationUtil.encodeBytes(networkTopicName)
                    };
                    if (networkTopicName[0] === "#") {
                        if (networkTopicName.startsWith(QUEUE_PREFIX)) {
                            const offset = QUEUE_PREFIX_LEN;
                            spec.name = networkTopicName.substr(offset);
                            spec.type = DestinationType.QUEUE;
                            spec.offset = offset;
                            return new Queue(spec);
                        } else if (networkTopicName.startsWith(TEMPORARY_QUEUE_PREFIX)) {
                            spec.name = networkTopicName;
                            spec.type = DestinationType.TEMPORARY_QUEUE;
                            spec.offset = 0;
                            return new Queue(spec);
                        }
                    }
                    return new Topic(spec);
                }
                function createDestinationFromBytes(networkTopicBytes) {
                    if (networkTopicBytes === null || networkTopicBytes.length === 0) {
                        return null;
                    }
                    const networkTopicName = DestinationUtil.decodeBytes(networkTopicBytes);
                    return createDestinationFromName(networkTopicName, networkTopicBytes);
                }
                const DestinationFromNetwork = {
                    createDestinationFromBytes: createDestinationFromBytes,
                    createDestinationFromName: createDestinationFromName
                };
                module.exports.DestinationFromNetwork = DestinationFromNetwork;
                /***/
            },
            /***/ "./modules/solclient-destination/lib/destination-type.js": 
            /*!***************************************************************!*\
  !*** ./modules/solclient-destination/lib/destination-type.js ***!
  \***************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Enumerates destination types for destination objects.
 *
 * @enum {string}
 * @namespace
 * @memberof solace
 */
                const DestinationType = {
                    /**
   * A Topic destination.
   */
                    TOPIC: "topic",
                    /**
   * A queue destination.
   */
                    QUEUE: "queue",
                    /**
   * A temporary queue destination.
   */
                    TEMPORARY_QUEUE: "temporary_queue"
                };
                module.exports.DestinationType = Enum.new(DestinationType);
                /* eslint-disable */
                // Manually demangle these names; bug 70131
                module.exports.DestinationType._setCanonical({
                    TOPIC: DestinationType.TOPIC,
                    QUEUE: DestinationType.QUEUE,
                    TEMPORARY_QUEUE: DestinationType.TEMPORARY_QUEUE
                });
                /* eslint-enable */
                /***/
            },
            /***/ "./modules/solclient-destination/lib/destination-util.js": 
            /*!***************************************************************!*\
  !*** ./modules/solclient-destination/lib/destination-util.js ***!
  \***************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const SolclientFactoryLib = __webpack_require__(/*! solclient-factory */ "./modules/solclient-factory/api.js");
                const {
                    Convert
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    DestinationType
                } = __webpack_require__(/*! ./destination-type */ "./modules/solclient-destination/lib/destination-type.js");
                const {
                    LOG_ERROR
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    SubscriptionInfo
                } = __webpack_require__(/*! ./subscription-info */ "./modules/solclient-destination/lib/subscription-info.js");
                const {
                    UUID,
                    StringUtils
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const {
                    ucs2ToUtf8,
                    utf8ToUcs2
                } = Convert;
                const {
                    ProfileBinding
                } = SolclientFactoryLib;
                const {
                    toSafeChars,
                    stripNullTerminate
                } = StringUtils;
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const DESTINATION_PREFIX_FROM_TYPE = {
                    [DestinationType.QUEUE]: "#P2P/QUE/",
                    [DestinationType.TEMPORARY_QUEUE]: "#P2P/QTMP/"
                };
                function createTemporaryName(type, vrid, name) {
                    const id = name || UUID.generateUUID();
                    switch (type) {
                      case DestinationType.TOPIC:
                        return `#P2P/TTMP/${vrid}/${id}`;

                      case DestinationType.TEMPORARY_QUEUE:
                        return `#P2P/QTMP/${vrid}/${id}`;

                      default:
                        LOG_ERROR("Unknown/invalid destination type", DestinationType.describe(type));
                    }
                    return undefined;
                }
                function createPrefix(type) {
                    return DESTINATION_PREFIX_FROM_TYPE[type] || "";
                }
                function createOperationError(type, errorStr) {
                    return new OperationError(`Invalid ${type}: ${errorStr}`, ErrorSubcode.INVALID_TOPIC_SYNTAX);
                }
                // This function validates topics in all code paths -- legacy code paths that relied on validating
                // topics as they were used, and newer code paths that validate Destinations on construction.  We
                // must not add validation here that could break legacy apps that used the deprecated 'new Topic'
                // interface that doesn't perform validation, and subsequently rely on validate-on-use.
                //
                // More strict checks done during Destination construction should be placed in validateAndEncode.
                // @return { error, isWildcarded }.  isWildcarded will not be defined if erorr is defined.
                function legacyValidate(type, bytes, name, exceptionCreator = createOperationError.bind(null, type)) {
                    let error;
                    /*
    * TRB topics can contain any utf-8 character and must be <= 250 bytes
    * in length.
    * '*', if present in a level, must be the last character in that level.
    * May not have empty levels.
    */
                    // Check minimum length using name, since the bytes may include a destination type prefix.
                    // e.g. #P2P/QUE/ should fail on length, not empty level.
                    const nameLength = name.length;
                    if (nameLength < 1) {
                        error = exceptionCreator("Too short (must be >= 1 character).");
                        return {
                            error: error
                        };
                    }
                    // Check maximum length using encoded bytes, since UTF-8 is a variable length encoding.
                    const bytesLength = bytes.length;
                    if (bytesLength > 251) {
                        // null terminator doesn't count
                        error = exceptionCreator(`Too long (encoding must be <= 250 bytes); name is ${bytesLength - 1} bytes: '${name}'`);
                        return {
                            error: error
                        };
                    }
                    let isWildcarded = false;
                    if (name.charAt(nameLength - 1) === ">") {
                        isWildcarded = true;
                    }
                    for (let i = 0; i < nameLength; ++i) {
                        switch (name.charAt(i)) {
                          case "/":
                            if (i === 0 || i === nameLength - 1 || name.charAt(i - 1) === "/") {
                                error = exceptionCreator(`Empty level(s) in '${name}'@${i}.`);
                                return {
                                    error: error
                                };
                            }
                            break;

                          case "*":
                            if (i < nameLength - 1 && name.charAt(i + 1) !== "/") {
                                // must not have something other than '/' to the right
                                error = exceptionCreator(`Illegal wildcard(s) in '${name}'@${i}.`);
                                return {
                                    error: error
                                };
                            }
                            isWildcarded = true;
                            break;

                          default:
                            break;
                        }
                    }
                    return {
                        isWildcarded: isWildcarded
                    };
                }
                function encodeBytes(bytes) {
                    return ProfileBinding.value.topicUtf8Encode ? `${ucs2ToUtf8(bytes)}\u0000` : `${bytes}\u0000`;
                }
                function decodeBytes(bytes) {
                    return stripNullTerminate(ProfileBinding.value.topicUtf8Encode ? utf8ToUcs2(bytes) : bytes);
                }
                /**
 * @param {DestinationType} type The type of destination
 * @param {String} name The name of the destination
 * @returns {Object} {bytes, offset, networkName} The result of the encoding.
 *
 * @private
 */
                function encode(type, name) {
                    const prefix = createPrefix(type);
                    const offset = prefix.length;
                    const networkName = prefix + name;
                    const bytes = encodeBytes(networkName);
                    return {
                        bytes: bytes,
                        offset: offset,
                        networkName: networkName
                    };
                }
                /**
 * @param {DestinationType} type The type of destination
 * @param {String} name The name of the destination
 * @param {Function} [exceptionCreator=createOperationError] A function to create an exception if an
 *   error is encountered.
 * @returns {Object} {bytes, error, offset, isWildcarded} The result of the encoding and any
 *      validation error
 *
 * @private
 */
                function validateAndEncode(type, name, exceptionCreator = createOperationError.bind(null, type)) {
                    const {
                        bytes,
                        offset
                    } = encode(type, name);
                    const {
                        error: constError,
                        isWildcarded
                    } = legacyValidate(type, bytes, name, exceptionCreator);
                    let error = constError;
                    let subscriptionInfo = {};
                    subscriptionInfo.isWildcarded = isWildcarded;
                    // If there was no 'legacy' error, perform an additional check to see if the provided name starts
                    // with a reserved prefix.  It shouldn't.  Prefixes should always be added by us by encode().
                    if (!error) {
                        Object.keys(DESTINATION_PREFIX_FROM_TYPE).some(prefixType => {
                            const prefix = DESTINATION_PREFIX_FROM_TYPE[prefixType];
                            if (!name.startsWith(prefix)) {
                                return false; // keep processing more array elements.
                            }
                            error = exceptionCreator(`Reserved prefix '${prefix}' found at start of '${name}'`);
                            return true;
                        });
                    }
                    if (!error) {
                        // parse subscription information from destination name
                        const {
                            error: errorConst,
                            subInfo: subInfoConst
                        } = SubscriptionInfo.parseFromName(name, type);
                        error = errorConst;
                        subscriptionInfo = subInfoConst;
                    }
                    return {
                        bytes: bytes,
                        offset: offset,
                        error: error,
                        isWildcarded: isWildcarded,
                        subscriptionInfo: subscriptionInfo
                    };
                }
                const DestinationUtil = {
                    createPrefix: createPrefix,
                    createTemporaryName: createTemporaryName,
                    decodeBytes: decodeBytes,
                    encode: encode,
                    encodeBytes: encodeBytes,
                    legacyValidate: legacyValidate,
                    toSafeChars: toSafeChars,
                    validateAndEncode: validateAndEncode
                };
                module.exports.DestinationUtil = DestinationUtil;
                /***/
            },
            /***/ "./modules/solclient-destination/lib/destination.js": 
            /*!**********************************************************!*\
  !*** ./modules/solclient-destination/lib/destination.js ***!
  \**********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /* provided dependency */ var util_inspect = __webpack_require__(/*! browser-util-inspect */ "./node_modules/browser-util-inspect/index.js");
                const {
                    DestinationType
                } = __webpack_require__(/*! ./destination-type */ "./modules/solclient-destination/lib/destination-type.js");
                const {
                    DestinationUtil
                } = __webpack_require__(/*! ./destination-util */ "./modules/solclient-destination/lib/destination-util.js");
                /**
 * @classdesc
 * <b>This class is not exposed for construction by API users. Users should obtain an instances from
 * one of the following:</b>
 * * {@link solace.SolclientFactory.createTopicDestination}
 * * {@link solace.SolclientFactory.createDurableQueueDestination}
 * * {@link solace.MessageConsumer#getDestination}
 * * {@link solace.SDTField#getValue} when {@link solace.SDTField#getType} returns
 *   {@link solace.SDTFieldType.DESTINATION}.
 *
 * Represents a message destination.
 *
 * Publishers can send messages to topics or queues, to which subscribers can subscribe or
 * bind. A Destination specifies the target of such an operation.
 * @hideconstructor
 * @memberof solace
 */
                class Destination {
                    /*
   * @constructor
   * @param {String|solace.Destination|Object} spec The name of the destination, or, the
   *  destination to copy. If this is a {@link solace.Destination} then all other parameters are
   *  ignored.
   * @param {solace.DestinationType} [type=solace.DestinationType.Topic] The type of destination
   *  to create
   * @deprecated since 10.0 Applications should not call this constructor.
   *  Use the factory methods on {@link solace.SolclientFactory}.
   **/
                    constructor(spec, type = DestinationType.TOPIC) {
                        if (typeof spec === "object") {
                            this._name = spec.name;
                            this._type = spec.type;
                            this._bytes = spec.bytes;
                            this._offset = spec.offset;
                            if (spec.isValidated) {
                                this._isValidated = true;
                                this._isWildcarded = spec.isWildcarded;
                                this._subscriptionInfo = spec.subscriptionInfo || {};
                            } else {
                                this._isValidated = false;
                                this._subscriptionInfo = {};
                            }
                        } else {
                            this._name = spec;
                            this._type = type;
                            // Don't validate encoding for deprecated construction path.
                            // This path would have more restrictions now, and it allows
                            // sdkperf a path for arbitrary topic construction.
                            const result = DestinationUtil.encode(type, spec);
                            this._bytes = result.bytes;
                            this._offset = result.offset;
                            this._isValidated = false;
                            this._subscriptionInfo = {};
                        }
                    }
                    /**
   * @returns {String} The destination name specified at creation time.
   */
                    getName() {
                        return this._name;
                    }
                    /**
   * @type {String}
   * @readonly
   */
                    get name() {
                        return this.getName();
                    }
                    /**
   * @returns {solace.DestinationType} The destination type
   */
                    getType() {
                        return this._type;
                    }
                    /**
   * @type {solace.DestinationType}
   * @readonly
   */
                    get type() {
                        return this.getType();
                    }
                    /**
   * @returns {String} Returns the null-terminated UTF-8 encoded destination bytes.
   *
   * @private
   */
                    getBytes() {
                        return this._bytes;
                    }
                    get bytes() {
                        return this.getBytes();
                    }
                    getOffset() {
                        return this._offset;
                    }
                    get offset() {
                        return this.getOffset();
                    }
                    /**
   * This provides the legacy validation that was done post-creation and is used in some code paths
   * on use.  It is preferred to use non-deprecated ways of creating destinations, which do
   * validation on create instead.
   * @throws OperationError if the destination is not valid.
   * @private
   */
                    validate() {
                        if (this._isValidated) {
                            if (this._error) throw this._error;
                            return;
                        }
                        const {
                            error,
                            isWildcarded
                        } = DestinationUtil.legacyValidate(this.type, this.bytes, this.name);
                        this._isValidated = true;
                        if (error) {
                            this._error = error;
                            throw error;
                        }
                        this._isWildcarded = isWildcarded;
                    }
                    /**
   * This is really only useful for topics.  If a queue name contains a wildcarded construct, it is
   * up to the router what to do -- it would either reject it or treat the wildcard as literal.  But
   * it is included here for all destination types since we have the info.
   * @returns {Boolean} True if the underlying name represents a wildcarded topic; false otherwise.
   * @throws {OperationError} If the destination is not valid.
   * @private
   */
                    isWildcarded() {
                        this.validate();
                        return this._isWildcarded;
                    }
                    /**
   * @returns {Object} subscriptionInfo object or empty object
   * @private
   */
                    getSubscriptionInfo() {
                        return this._subscriptionInfo || {};
                    }
                    /**
   * @returns {String} A generic description of the Destination.
   */
                    toString() {
                        return util_inspect(this);
                    }
                    /**
   * @param {*} other The other object for comparison
   * @returns {Boolean} True if the passed destination is the same
   * @private
   */
                    equals(other) {
                        if (!(other instanceof Destination)) {
                            return false;
                        }
                        return this.toString().valueOf() === other.toString().valueOf();
                    }
                }
                module.exports.Destination = Destination;
                /***/
            },
            /***/ "./modules/solclient-destination/lib/queue.js": 
            /*!****************************************************!*\
  !*** ./modules/solclient-destination/lib/queue.js ***!
  \****************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const DestinationUtilLib = __webpack_require__(/*! ./destination-util */ "./modules/solclient-destination/lib/destination-util.js");
                const {
                    assert
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                const {
                    Destination
                } = __webpack_require__(/*! ./destination */ "./modules/solclient-destination/lib/destination.js");
                const {
                    DestinationType
                } = __webpack_require__(/*! ./destination-type */ "./modules/solclient-destination/lib/destination-type.js");
                /**
 * @classdesc
 * Represents a Queue, which is a type of {@link solace.Destination}.
 *
 * Instances should be acquired through
 * {@link solace.SolclientFactory.createDurableQueueDestination} or by calling
 * {@link solace.MessageConsumer#getDestination} on a consumer bound to a temporary queue.
 *
 * @extends solace.Destination
 * @memberof solace
 * @private
 */
                class Queue extends Destination {
                    /**
   * @param {Object} spec The spec for this instance
   * @private
   */
                    constructor(spec) {
                        assert(spec.name, "Queue name not supplied");
                        assert(spec.type === DestinationType.QUEUE || spec.type === DestinationType.TEMPORARY_QUEUE, "Queue spec.type is invalid");
                        assert(spec.bytes, "Queue spec missing bytes");
                        assert(spec.offset !== undefined, "Queue spec missing offset");
                        super(spec);
                    }
                    getOffset() {
                        return this._offset;
                    }
                    get offset() {
                        return this.getOffset();
                    }
                    ["inspect"]() {
                        return `[Queue ${this.getName()}]`;
                    }
                    /**
   * @static
   * @param {String} queueName The name of the queue (no prefix)
   * @returns {Queue} a Queue
   * @private
   */
                    static createFromLocalName(queueName) {
                        const encoding = DestinationUtilLib.DestinationUtil.validateAndEncode(DestinationType.QUEUE, queueName);
                        if (encoding.error) {
                            throw encoding.error;
                        }
                        return new Queue({
                            name: queueName,
                            type: DestinationType.QUEUE,
                            isValidated: true,
                            bytes: encoding.bytes,
                            offset: encoding.offset,
                            isWildcarded: encoding.isWildcarded,
                            /* probably don't need this until queues get subscription attributes */
                            subscriptionInfo: encoding.subscriptionInfo
                        });
                    }
                }
                module.exports.Queue = Queue;
                /***/
            },
            /***/ "./modules/solclient-destination/lib/subscription-info.js": 
            /*!****************************************************************!*\
  !*** ./modules/solclient-destination/lib/subscription-info.js ***!
  \****************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /* provided dependency */ var util_inspect = __webpack_require__(/*! browser-util-inspect */ "./node_modules/browser-util-inspect/index.js");
                const {
                    DestinationType
                } = __webpack_require__(/*! ./destination-type */ "./modules/solclient-destination/lib/destination-type.js");
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                /**
 * determines if subscription has the #noexport/ prefix
 *
 * @param {DestinationType} type The type of destination
 * @param {String} name The name of the destination
 * @param {ByteArray} bytes Encoded bytes of name
 * @param {Number} offset The index offset into the name to parse
 * @param {solace.SubscriptionInfo} result The attribute collector object for the parsed
 *   subscription
 * @param {Function} exceptionCreator The function to create an error for
 *   parsing
 * @returns {Object} {error, index, result} returns the parsing index and result
 *   where the result is a {solace.SubscriptionInfo} that contains information about the
 *   subscription like {Boolean} isNoExport
 * @private
 */
                function subscriptionParseNoExport(type, name, bytes, offset, result) {
                    const NOEXPORT_PREFIX = "#noexport/";
                    const NOEXPORT_PREFIX_LEN = NOEXPORT_PREFIX.length;
                    let index = offset;
                    let error;
                    if (name.length - index > NOEXPORT_PREFIX_LEN && !result.isNoExport) {
                        if (name.startsWith(NOEXPORT_PREFIX, index)) {
                            index += NOEXPORT_PREFIX_LEN;
                            result.isNoExport = true;
                        } else {
                            result.isNoExport = false;
                        }
                    } else {
                        result.isNoExport = false;
                    }
                    return {
                        error: error,
                        index: index,
                        result: result
                    };
                }
                /**
 * @param {DestinationType} type The type of destination
 * @param {String} name The name of the destination
 * @param {ByteArray} bytes Encoded bytes of name
 * @param {Number} offset The index offset into the name to parse
 * @param {solace.SubscriptionInfo} result The attribute collector object for the parsed
 *   subscription
 * @param {Function} exceptionCreator The function to create an error for
 *   parsing
 * @returns {Object} {error, index, result} returns the parsing index and result
 *   where the result is a {solace.SubscriptionInfo} that contains information about the
 *   subscription like {Boolean} isShared or {String} shareGroup or {Number}
 *   dispatchTopicIndex
 * @private
 */
                function subscriptionParseShare(type, name, bytes, offset, result, exceptionCreator) {
                    const SHARE_PREFIX = "#share/";
                    const SHARE_PREFIX_LEN = SHARE_PREFIX.length;
                    const LEVEL_DELIMETER = "/";
                    const LEVEL_DELIMETER_LEN = LEVEL_DELIMETER.length;
                    let index = offset;
                    let error;
                    let groupIndex = -1;
                    let shareGroup;
                    if (name.length - index > SHARE_PREFIX_LEN && !result.isShare) {
                        /* parse '#share/' prefix */
                        /*
     * name starts with '#share/' prefix
     * and has enough room for at least one character for share group
     */
                        if (name.startsWith(SHARE_PREFIX, offset) && name.length - (index + SHARE_PREFIX_LEN) > LEVEL_DELIMETER_LEN + 1) {
                            index += SHARE_PREFIX_LEN;
                            /* parse share group to next '/' */
                            groupIndex = index;
                            index = name.indexOf(LEVEL_DELIMETER, groupIndex);
                            if (index > 0) {
                                shareGroup = name.substring(groupIndex, index);
                                index += LEVEL_DELIMETER_LEN;
                                result.isShare = true;
                                result.shareGroup = shareGroup;
                                result.dispatchTopicIndex = index;
                            } else {
                                // error
                                error = exceptionCreator(`Illegal share Group in '${name}'@${groupIndex}.`);
                                result.isShare = true;
                            }
                        } else {
                            // not share subscription
                            result.isShare = false;
                        }
                    } else {
                        // not share subscription
                        result.isShare = false;
                    }
                    return {
                        error: error,
                        index: index,
                        result: result
                    };
                }
                /**
 * @param {Array.Function} layers The parsing functions executed from 0 to layers.length
 * @param {DestinationType} type The type of destination
 * @param {String} name The name of the destination
 * @param {ByteArray} bytes Encoded bytes of name
 * @param {solace.SubscriptionInfo} subInfo The attribute collector object for the parsed
 *   subscription
 * @param {Function} exceptionCreator The function to create an error for
 *   parsing
 * @returns {Object} {error, result} returns the parsed information in the SubscriptionInfo
 * object and error, when error is set result's values may be partially set
 * @private
 */
                function subscriptionStringParse(layers, type, name, bytes, subInfo, exceptionCreator) {
                    const parseLayers = layers.length || 0;
                    let offset = 0;
                    let error;
                    let result = subInfo || {};
                    for (let i = 0; i < parseLayers; ++i) {
                        const {
                            error: constError,
                            index: constOffset,
                            result: constResult
                        } = layers[i](type, name, bytes, offset, result, exceptionCreator);
                        offset = constOffset;
                        result = constResult;
                        error = constError;
                        if (error) break;
                    }
                    return {
                        error: error,
                        result: result
                    };
                }
                // Subscription parser map by DestinationType
                // Currently only Topics have subscription information to parse, but more can be added as needed
                // The _layers attribute for the parser defines the order of parsing destination names
                // The _layers are made up of functions that can execute with the signature:
                //   { error, index, result } function funcName(type, name, bytes, result[, exceptionCreator])
                // To add more subscription information parsing add more layers to _layers of the DestinationType
                const SUBSCRIPTION_LAYER_PARSER_FROM_TYPE = {
                    [DestinationType.TOPIC]: {
                        _layers: [ subscriptionParseNoExport, subscriptionParseShare ],
                        parse: function subParse(type, name, bytes, subInfo, exceptionCreator) {
                            const {
                                error,
                                result
                            } = subscriptionStringParse(this._layers, type, name, bytes, subInfo, exceptionCreator);
                            return {
                                error: error,
                                result: result
                            };
                        }
                    }
                };
                function createOperationError(type, errorStr) {
                    return new OperationError(`Invalid ${type}: ${errorStr}`, ErrorSubcode.INVALID_TOPIC_SYNTAX);
                }
                /**
 * @classdesc
 * <b> This class is not exposed. This object contains useful subscription information about
 * a {solace.Destination#name}</b>
 * @hideconstructor
 * @memberof solace
 * @private
 */
                class SubscriptionInfo {
                    /**
   * @constructor
   * @param {String} name The name of the destination to be used as a subscription
   * @private
   */
                    constructor(name) {
                        this._name = name;
                        // set default values
                        this._isShare = false;
                        this._isNoExport = false;
                        this._dispatchTopicIndex = -1;
                        this._shareGroup = null;
                    }
                    /**
   * @returns {String} The destination name specified at creation time
   */
                    getName() {
                        return this._name;
                    }
                    /**
   * @returns {String} subscription name
   * @readonly
   */
                    get name() {
                        return this.getName();
                    }
                    /**
   * @name solace.SubscriptionInfo#isShare
   * @type {Boolean}
   * @description Boolean Flag to indicate the {solace.SubscriptionInfo#name} is a shared
   * subscription
   * @default false
   */
                    get isShare() {
                        return this._isShare;
                    }
                    set isShare(value) {
                        this._isShare = value;
                    }
                    /**
   * @name solace.SubscriptionInfo#isNoExport
   * @type {Boolean}
   * @description Boolean Flag to indicate the {solace.SubscriptionInfo#name} is a no export
   * subscription
   * @default false
   */
                    get isNoExport() {
                        return this._isNoExport;
                    }
                    set isNoExport(value) {
                        this._isNoExport = value;
                    }
                    /**
   * @name solace.SubscriptionInfo#dispatchTopicIndex
   * @type {Number}
   * @description String index of the topic filter after subscription prefixes
   * @default 0, the whole name as the topic filter
   */
                    get dispatchTopicIndex() {
                        return this._dispatchTopicIndex < 0 ? 0 : this._dispatchTopicIndex;
                    }
                    set dispatchTopicIndex(value) {
                        this._dispatchTopicIndex = value < 0 ? -1 /* uninitialized*/ : value;
                    }
                    /**
   * @name solace.SubscriptionInfo#shareGroup
   * @type {?String}
   * @description The Share group of a shared subscription, should be null if
   * {solace.SubscriptionInfo#isShare} is false
   */
                    get shareGroup() {
                        return this.isShare ? this._shareGroup : null;
                    }
                    set shareGroup(value) {
                        if (this.isShare) {
                            this._shareGroup = value;
                        }
                    }
                    /**
   * @returns {String} A generic description of the SubscriptionInfo
   */
                    toString() {
                        return util_inspect(this);
                    }
                    /**
   * @static
   * @type {Object}
   * @param {String} name The name of the destination
   * @param {DestinationType} type The Destination type
   * @returns {Object} the subscription infomation from the destination name
   * @private
   */
                    static parseFromName(name, type = DestinationType.TOPIC) {
                        let subInfo = new SubscriptionInfo(name);
                        let error = null;
                        const parser = SUBSCRIPTION_LAYER_PARSER_FROM_TYPE[type];
                        if (parser) {
                            const {
                                error: errorConst,
                                result: subInfoConst
                            } = parser.parse(type, name, null, subInfo, createOperationError.bind(null, type));
                            subInfo = subInfoConst;
                            error = errorConst;
                        }
                        return {
                            error: error,
                            subInfo: subInfo
                        };
                    }
                }
                module.exports.SubscriptionInfo = SubscriptionInfo;
                /***/
            },
            /***/ "./modules/solclient-destination/lib/topic.js": 
            /*!****************************************************!*\
  !*** ./modules/solclient-destination/lib/topic.js ***!
  \****************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const DestinationUtilLib = __webpack_require__(/*! ./destination-util */ "./modules/solclient-destination/lib/destination-util.js");
                const {
                    Destination
                } = __webpack_require__(/*! ./destination */ "./modules/solclient-destination/lib/destination.js");
                const {
                    DestinationType
                } = __webpack_require__(/*! ./destination-type */ "./modules/solclient-destination/lib/destination-type.js");
                /**
 * @classdesc
 * Represents a Topic, which is a type of {@link solace.Destination}.
 *
 * @extends solace.Destination
 * @memberof solace
 * @deprecated since 10.0 Applications should not directly refer to this type.
 *  {@link solace.Destination} provides the full interface available to topic, and it can be
 *  determined whether the destination represents a topic if {@link solace.Destination#getType}
 *  returns {@link solace.DestinationType.TOPIC}.
 */
                class Topic extends Destination {
                    /**
   * @param {Object} spec The topic spec
   * @private
   */
                    constructor(spec) {
                        if (typeof spec === "object") {
                            super({
                                type: DestinationType.TOPIC,
                                name: spec.name,
                                bytes: spec.bytes,
                                offset: spec.offset,
                                isValidated: spec.isValidated,
                                isWildcarded: spec.isWildcarded,
                                subscriptionInfo: spec.subscriptionInfo
                            });
                        } else {
                            // Deprecated path -- super will do topic encode
                            super(spec, DestinationType.TOPIC);
                        }
                    }
                    ["inspect"]() {
                        return `[Topic ${this.getName()}]`;
                    }
                    /**
   * @static
   * @param {String} topicName The name for the topic
   * @returns {Topic} the Topic
   * @private
   */
                    static createFromName(topicName) {
                        const encoding = DestinationUtilLib.DestinationUtil.validateAndEncode(DestinationType.TOPIC, topicName);
                        if (encoding.error) {
                            throw encoding.error;
                        }
                        return new Topic({
                            name: topicName,
                            isValidated: true,
                            bytes: encoding.bytes,
                            offset: encoding.offset,
                            isWildcarded: encoding.isWildcarded,
                            subscriptionInfo: encoding.subscriptionInfo
                        });
                    }
                }
                module.exports.Topic = Topic;
                /***/
            },
            /***/ "./modules/solclient-env/api.js": 
            /*!**************************************!*\
  !*** ./modules/solclient-env/api.js ***!
  \**************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                function apiEnv(envObject) {
                    if (true) {
                        throw new Error("Test environment will not override build environment");
                    }
                    __webpack_require__.g.BUILD_ENV = Object.assign({}, envObject, {
                        TEST: true
                    });
                    return __webpack_require__.g.BUILD_ENV;
                }
                if (true) {
                    apiEnv.target = () => apiEnv();
                } else {}
                module.exports = apiEnv;
                /***/
            },
            /***/ "./modules/solclient-error/api.js": 
            /*!****************************************!*\
  !*** ./modules/solclient-error/api.js ***!
  \****************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ErrorResponseSubcodeMapper
                } = __webpack_require__(/*! ./lib/error-response-subcode-mapper */ "./modules/solclient-error/lib/error-response-subcode-mapper.js");
                const {
                    ErrorSubcode
                } = __webpack_require__(/*! ./lib/error-subcodes */ "./modules/solclient-error/lib/error-subcodes.js");
                const {
                    NotImplementedError
                } = __webpack_require__(/*! ./lib/not-implemented-error */ "./modules/solclient-error/lib/not-implemented-error.js");
                const {
                    OperationError
                } = __webpack_require__(/*! ./lib/operation-error */ "./modules/solclient-error/lib/operation-error.js");
                const {
                    RequestError
                } = __webpack_require__(/*! ./lib/request-error */ "./modules/solclient-error/lib/request-error.js");
                const {
                    RequestEventCode
                } = __webpack_require__(/*! ./lib/request-event-codes */ "./modules/solclient-error/lib/request-event-codes.js");
                const {
                    SolaceError
                } = __webpack_require__(/*! ./lib/solace-error */ "./modules/solclient-error/lib/solace-error.js");
                module.exports.ErrorResponseSubcodeMapper = ErrorResponseSubcodeMapper;
                module.exports.ErrorSubcode = ErrorSubcode;
                module.exports.NotImplementedError = NotImplementedError;
                module.exports.OperationError = OperationError;
                module.exports.RequestError = RequestError;
                module.exports.RequestEventCode = RequestEventCode;
                module.exports.SolaceError = SolaceError;
                /***/
            },
            /***/ "./modules/solclient-error/lib/error-response-subcode-mapper.js": 
            /*!**********************************************************************!*\
  !*** ./modules/solclient-error/lib/error-response-subcode-mapper.js ***!
  \**********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ErrorSubcode
                } = __webpack_require__(/*! ./error-subcodes */ "./modules/solclient-error/lib/error-subcodes.js");
                const {
                    makeMap
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /* eslint-disable max-len */
                const SC = ErrorSubcode;
                const ROOT_MAPPING = makeMap(400, makeMap("client name parse error", SC.CLIENT_NAME_INVALID, "document is too large", SC.MESSAGE_TOO_LARGE, "inactivity timeout", SC.INACTIVITY_TIMEOUT, "max num subscriptions exceeded", SC.SUBSCRIPTION_TOO_MANY, "message too long", SC.MESSAGE_TOO_LARGE, "nolocal discard", SC.NOLOCAL_DISCARD, "not enough space", SC.OUT_OF_RESOURCES, "subscription already exists", SC.SUBSCRIPTION_ALREADY_PRESENT, "subscription attributes conflict with existing subscription", SC.SUBSCRIPTION_ATTRIBUTES_CONFLICT, "subscription not found", SC.SUBSCRIPTION_NOT_FOUND, "subscription parse error", SC.SUBSCRIPTION_INVALID, "topic parse error", SC.INVALID_TOPIC_SYNTAX, "unknown transport session identifier", SC.UNKNOWN_TRANSPORT_SESSION_ID, "xml parse error", SC.XML_PARSE_ERROR, "unsupported ssl downgrade value", SC.LOGIN_FAILURE), 401, makeMap("", SC.LOGIN_FAILURE), 403, makeMap("basic authentication is shutdown", SC.BASIC_AUTHENTICATION_IS_SHUTDOWN, "client certificate authentication is shutdown", SC.CLIENT_CERTIFICATE_AUTHENTICATION_IS_SHUTDOWN, "client name already in use", SC.CLIENT_NAME_ALREADY_IN_USE, "client username is shutdown", SC.CLIENT_USERNAME_IS_SHUTDOWN, "dynamic clients not allowed", SC.DYNAMIC_CLIENTS_NOT_ALLOWED, "invalid virtual router address", SC.INVALID_VIRTUAL_ADDRESS, "forbidden", SC.CLIENT_ACL_DENIED, "message vpn not allowed", SC.MESSAGE_VPN_NOT_ALLOWED, "publish acl denied", SC.PUBLISH_ACL_DENIED, "replication is standby", SC.REPLICATION_IS_STANDBY, "selector does not match", SC.SELECTOR_DOES_NOT_MATCH, "subscription acl denied", SC.SUBSCRIPTION_ACL_DENIED, "subscription does not match", SC.SUBSCRIPTION_DOES_NOT_MATCH, "compression is shutdown", SC.LOGIN_FAILURE, "shared subscriptions not supported on topic endpoints", SC.SHARED_SUBSCRIPTIONS_ENDPOINT_NOT_ALLOWED, "shared subscriptions not supported on queues", SC.SHARED_SUBSCRIPTIONS_ENDPOINT_NOT_ALLOWED, "shared subscription permission denied", SC.SHARED_SUBSCRIPTIONS_NOT_ALLOWED), 404, makeMap("", SC.LOGIN_FAILURE), 503, makeMap("low priority msg congestion", SC.LOW_PRIORITY_MSG_CONGESTION, "message vpn unavailable", SC.MESSAGE_VPN_UNAVAILABLE, "replication is standby", SC.REPLICATION_IS_STANDBY, "service unavailable", SC.GM_UNAVAILABLE, "spool over quota", SC.SPOOL_OVER_QUOTA, "subscriber delete in progress", SC.CLIENT_DELETE_IN_PROGRESS, "too many clients", SC.TOO_MANY_CLIENTS, "too many connections for vpn", SC.TOO_MANY_CLIENTS, "max message usage exceeded", SC.MAX_MESSAGE_USAGE_EXCEEDED), 507, makeMap("ad not ready", SC.GM_NOT_READY));
                const AD_MAPPING = makeMap("PARENT", ROOT_MAPPING, 400, makeMap("already bound", SC.ALREADY_BOUND, "endpoint already exists", SC.ENDPOINT_ALREADY_EXISTS, "subscription already exists", SC.SUBSCRIPTION_ALREADY_PRESENT, "already exists", SC.ENDPOINT_ALREADY_EXISTS, "endpoint property mismatch", SC.ENDPOINT_PROPERTY_MISMATCH, "invalid durable topic endpoint name", SC.INVALID_DTE_NAME, "invalid selector", SC.INVALID_SELECTOR, "invalid topic name", SC.INVALID_TOPIC_NAME_FOR_TOPIC_ENDPOINT, "queue not found", SC.QUEUE_NOT_FOUND, "quota out of range", SC.QUOTA_OUT_OF_RANGE, "unknown flow name", SC.UNKNOWN_FLOW_NAME, "unsubscribe not allowed", SC.UNSUBSCRIBE_NOT_ALLOWED_CLIENTS_BOUND), 403, makeMap("permission not allowed", SC.PERMISSION_NOT_ALLOWED, "client initiated replay not allowed on non-exclusive topic endpoint", SC.CLIENT_INITIATED_REPLAY_NON_EXCLUSIVE_NOT_ALLOWED, "client initiated replay not allowed on non-exclusive queue", SC.CLIENT_INITIATED_REPLAY_NON_EXCLUSIVE_NOT_ALLOWED, "client initiated replay from inactive flow not allowed", SC.CLIENT_INITIATED_REPLAY_INACTIVE_FLOW_NOT_ALLOWED, "client initiated replay from browser flow not allowed", SC.CLIENT_INITIATED_REPLAY_BROWSER_FLOW_NOT_ALLOWED, "replay not supported on temporary topic endpoint", SC.REPLAY_TEMPORARY_NOT_SUPPORTED, "replay not supported on temporary queue", SC.REPLAY_TEMPORARY_NOT_SUPPORTED, "replay not supported on anonymous queue", SC.REPLAY_ANONYMOUS_QUEUE_NOT_SUPPORTED, "unknown start location type", SC.UNKNOWN_START_LOCATION_TYPE, "mismatched endpoint error id", SC.MISMATCHED_ENDPOINT_ERROR_ID, "replay start message unavailable", SC.REPLAY_START_MESSAGE_NOT_AVAILABLE), 503, makeMap("durable topic endpoint shutdown", SC.TOPIC_ENDPOINT_SHUTDOWN, "endpoint shutdown", SC.TOPIC_ENDPOINT_SHUTDOWN, "max clients exceeded for durable topic endpoint", SC.MAX_CLIENTS_FOR_TE, "max clients exceeded for queue", SC.MAX_CLIENTS_FOR_QUEUE, "no more non-durable queue or topic endpoint", SC.NO_MORE_NON_DURABLE_QUEUE_OR_TOPIC_ENDPOINT, "no subscription match", SC.NO_SUBSCRIPTION_MATCH, "queue shutdown", SC.QUEUE_SHUTDOWN, "te shutdown", SC.TOPIC_ENDPOINT_SHUTDOWN, "unknown durable topic endpoint", SC.UNKNOWN_TOPIC_ENDPOINT_NAME, "unknown queue", SC.UNKNOWN_QUEUE_NAME, "replay disabled", SC.REPLAY_DISABLED, "replay cancelled", SC.REPLAY_CANCELLED, "replay message unavailable", SC.REPLAY_MESSAGE_UNAVAILABLE, "replay started", SC.REPLAY_STARTED, "replayed message rejected by topic endpoint", SC.REPLAY_MESSAGE_REJECTED, 'replayed message rejected by queue"', SC.REPLAY_MESSAGE_REJECTED, "replay log modified", SC.REPLAY_LOG_MODIFIED, "mismatched endpoint error id", SC.MISMATCHED_ENDPOINT_ERROR_ID, "out of replay resources", SC.OUT_OF_REPLAY_RESOURCES, "topic or selector modified on durable topic endpoint", SC.TOPIC_OR_SELECTOR_MODIFIED_ON_DURABLE_TOPIC_ENDPOINT, "replay failed", SC.REPLAY_FAILED, "replay start time not available", SC.REPLAY_START_TIME_NOT_AVAILABLE, "replay start message unavailable", SC.REPLAY_START_MESSAGE_NOT_AVAILABLE));
                function getSubcodeMappingInner(root, respErrorCode, respStr) {
                    if (respErrorCode === 200) {
                        // success response, error subcode is 0 -  transport session use 0 as OK
                        return 0;
                    }
                    const codeMap = root[respErrorCode] || {};
                    const searchKey = (respStr || "").toLowerCase();
                    const foundKey = Object.keys(codeMap).find(mapKey => mapKey === searchKey || searchKey.indexOf(mapKey) >= 0);
                    if (foundKey) {
                        return codeMap[foundKey];
                    }
                    if (codeMap[""]) {
                        return codeMap[""];
                    }
                    /* eslint-disable dot-notation */
                    // Don't access string keys via dot properties
                    if (root["PARENT"]) {
                        return getSubcodeMappingInner(root["PARENT"], respErrorCode, respStr);
                    }
                    /* eslint-enable dot-notation */
                    return undefined;
                }
                function getSubcodeMapping(root, respErrorCode, respStr) {
                    const result = getSubcodeMappingInner(root, respErrorCode, respStr);
                    if (result === undefined) {
                        return SC.UNKNOWN_ERROR;
                    }
                    return result;
                }
                /**
 * @classdesc
 * Return {ErrorSubcode} based on response code and response string
 * from the router.
 * @private
 */
                const ErrorResponseSubcodeMapper = {
                    /**
   * @param {Number} respErrorCode The response code (an HTTP-like integer) to use in the lookup.
   * @param {String} respStr The response string to use in the lookup.
   * @returns {solace.ErrorSubcode} The subcode found, or ErrorSubcode.UNKNOWN_ERROR if not found.
   * @static
   * @private
   */
                    getErrorSubcode(respErrorCode, respStr) {
                        return getSubcodeMapping(ROOT_MAPPING, respErrorCode, respStr);
                    },
                    getADErrorSubcode(respErrorCode, respStr) {
                        return getSubcodeMapping(AD_MAPPING, respErrorCode, respStr);
                    }
                };
                module.exports.ErrorResponseSubcodeMapper = ErrorResponseSubcodeMapper;
                /***/
            },
            /***/ "./modules/solclient-error/lib/error-subcodes.js": 
            /*!*******************************************************!*\
  !*** ./modules/solclient-error/lib/error-subcodes.js ***!
  \*******************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Defines an error subcode enumeration which is returned as a property of
 * the errors/exceptions thrown by the API. The subcode provides more detailed
 * error information.
 *
 * The following subcodes can apply to error responses resulting from
 * any API method.
 * * {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}
 * * {@link solace.ErrorSubcode.PARAMETER_CONFLICT}
 * * {@link solace.ErrorSubcode.INTERNAL_ERROR}
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
                const ErrorSubcode = {
                    /////////////
                    // SESSION //
                    /////////////
                    /**
   * Errors that do not have a proper subcode.
   */
                    UNKNOWN_ERROR: 4294967295,
                    /**
   * No error is associated with this event.
   */
                    NO_ERROR: 0,
                    /**
   * The session is already connected.
   */
                    // SESSION_ALREADY_CONNECTED: 1,
                    /**
   * The session is not connected.
   */
                    SESSION_NOT_CONNECTED: 2,
                    /**
   * The performed session operation is invalid given the state
   * or configuration of the session.
   * @deprecated Use {@link solace.ErrorSubCode.INVALID_OPERATION}
   */
                    INVALID_SESSION_OPERATION: 3,
                    /**
   * The performed session operation is invalid given the state
   * or configuration of the session.
   */
                    INVALID_OPERATION: 3,
                    /**
   * An API call failed due to a timeout.
   */
                    TIMEOUT: 4,
                    /////////////////
                    // MESSAGE VPN //
                    /////////////////
                    /**
   * The Message VPN name configured for the session does not exist.
   *
   * Causes:
   *  * 403 Message VPN Not Allowed
   */
                    MESSAGE_VPN_NOT_ALLOWED: 5,
                    /**
   * The Message VPN name set for the session (or the default VPN if none
   * was set) is currently shutdown on the router.
   *
   * Causes:
   *  * 503 Message VPN Unavailable
   */
                    MESSAGE_VPN_UNAVAILABLE: 6,
                    ////////////
                    // CLIENT //
                    ////////////
                    /**
   * The username for the client is administratively shutdown
   * on the router.
   *
   * Causes:
   *  * 403 Client Username Is Shutdown
   */
                    CLIENT_USERNAME_IS_SHUTDOWN: 7,
                    /**
   * The username for the session has not been set and dynamic
   * clients are not allowed.
   *
   * Causes:
   *  * 403 Dynamic Clients Not Allowed
   */
                    DYNAMIC_CLIENTS_NOT_ALLOWED: 8,
                    /**
   * The session is attempting to use a client name that is
   * in use by another client, and the router is configured to reject the
   * new session.
   * A client name cannot be used by multiple clients in the same Message
   * VPN.
   *
   * Causes:
   *  * 403 Client Name Already In Use
   */
                    CLIENT_NAME_ALREADY_IN_USE: 9,
                    /**
   * The client name chosen has been rejected as invalid by the router.
   *
   * Causes:
   *  * 400 Client Name Parse Error
   */
                    CLIENT_NAME_INVALID: 10,
                    /**
   * The client login is not currently possible because a previous
   * instance of same client was being deleted.
   *
   * Causes:
   *  * 503 Subscriber Delete In Progress
   */
                    CLIENT_DELETE_IN_PROGRESS: 11,
                    /**
   * The client login is not currently possible because the maximum
   * number of active clients on router has already been reached.
   *
   * Causes:
   *  * 503 Too Many Clients
   *  * 503 Too Many Connections for VPN
   */
                    TOO_MANY_CLIENTS: 12,
                    /**
   * The client could not log into the router.
   *
   * Causes:
   *  * 401 error codes
   *  * 404 error codes
   *  * Failed to send a session setup message in the transport.
   */
                    LOGIN_FAILURE: 13,
                    //////////
                    // VRID //
                    //////////
                    /**
   * An attempt was made to connect to the wrong IP address on
   * the router (must use CVRID if configured), or the router CVRID has
   * changed and this was detected on reconnect.
   *
   * Causes:
   *  * 403 Invalid Virtual Router Address
   */
                    INVALID_VIRTUAL_ADDRESS: 14,
                    /////////
                    // ACL //
                    /////////
                    /**
   * The client login to the router was denied because the
   * IP address/netmask combination used for the client is designated in the
   * ACL (Access Control List) profile associated with that client.
   *
   * Causes:
   *  * 403 Forbidden
   */
                    CLIENT_ACL_DENIED: 15,
                    /**
   * Adding a subscription was denied because it matched a
   * subscription that was defined as denied on the ACL (Access Control List)
   * profile associated with the client.
   *
   * Causes:
   *  * 403 Subscription ACL Denied
   */
                    SUBSCRIPTION_ACL_DENIED: 16,
                    /**
   * A message could not be published because its topic matched
   * a topic defined as denied on the ACL (Access Control List) profile
   * associated with the client.
   *
   * Causes:
   *  * 403 Publish ACL Denied
   */
                    PUBLISH_ACL_DENIED: 17,
                    ////////////////
                    // VALIDATION //
                    ////////////////
                    /**
   * An API call was made with an out-of-range parameter.
   */
                    PARAMETER_OUT_OF_RANGE: 18,
                    /**
   * An API call was made with a parameter combination
   * that is not valid.
   */
                    PARAMETER_CONFLICT: 19,
                    /**
   * An API call was made with a parameter of incorrect type.
   */
                    PARAMETER_INVALID_TYPE: 20,
                    //////////////////
                    // FATAL ERRORS //
                    //////////////////
                    /**
   *  An API call had an internal error (not an application fault).
   */
                    INTERNAL_ERROR: 21,
                    /**
   * An API call failed due to insufficient space in the transport
   * buffer to accept more data,
   * or due to exhaustion of the Guaranteed Messaging Window on a publisher.
   * After an insufficient space error of either kind, the
   * listeners on the {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}
   * event are notified when it is possible to retry the failed operation.
   */
                    INSUFFICIENT_SPACE: 22,
                    /**
   * The message router has rejected the request. All available
   * resources of the requested type are in use.
   *
   * Causes:
   *  * 400 Not Enough Space
   */
                    OUT_OF_RESOURCES: 23,
                    /**
   * An API call failed due to a protocol error with the router
   * (not an application fault).
   */
                    PROTOCOL_ERROR: 24,
                    /**
   * An API call failed due to a communication error. This typically indicates the
   * transport connection to the message router has been unexpectedly closed.
   */
                    COMMUNICATION_ERROR: 25,
                    ////////////////
                    // KEEP ALIVE //
                    ////////////////
                    /**
   * The session keep-alive detected a failed session.
   */
                    KEEP_ALIVE_FAILURE: 26,
                    /////////////////////
                    // MESSAGE RELATED //
                    /////////////////////
                    /**
   * An attempt was made to use a topic which is longer
   * than the maximum that is supported.
   */
                    // TOPIC_TOO_LARGE: 27,
                    /**
   * A send call was made that did not have a topic in a mode
   * where one is required (for example, client mode).
   */
                    TOPIC_MISSING: 28,
                    /**
   *  An attempt was made to send a message with a total
   * size greater than that supported by the protocol. (???)
   */
                    //  MAX_TOTAL_MSGSIZE_EXCEEDED: 29,
                    /**
   * An attempt was made to send a message with user data larger
   * than the maximum that is supported.
   */
                    // USER_DATA_TOO_LARGE: 30,
                    /**
   * An attempt was made to use a topic which has a syntax that
   * is not supported.
   *
   * Causes:
   *  * 400 Topic Parse Error
   */
                    INVALID_TOPIC_SYNTAX: 31,
                    /**
   * The client attempted to send a message larger than that
   * supported by the router.
   *
   * Causes:
   *  * 400 Document Is Too Large
   *  * 400 Message Too Long
   */
                    MESSAGE_TOO_LARGE: 32,
                    /**
   * The router could not parse an XML message.
   *
   * Causes:
   *  * 400 XML Parse Error
   */
                    XML_PARSE_ERROR: 33,
                    ///////////////////
                    // SUBSCRIPTIONS //
                    ///////////////////
                    /**
   * The client attempted to add a subscription that already
   * exists. This subcode is only returned if the session property
   * 'IgnoreDuplicateSubscriptionError' is not enabled.
   *
   * Causes:
   * 400 Subscription Already Exists)
   */
                    SUBSCRIPTION_ALREADY_PRESENT: 34,
                    /**
   * The client attempted to remove a subscription which did not exist.
   * This subcode is only returned if the session property
   * 'IgnoreDuplicateSubscriptionError' is not enabled.
   *
   * Causes:
   * 400 Subscription Not Found)
   */
                    SUBSCRIPTION_NOT_FOUND: 35,
                    /**
   * The client attempted to add/remove a subscription that
   * is not valid.
   *
   * Causes:
   *  * 400 Subscription Parse Error
   */
                    SUBSCRIPTION_INVALID: 36,
                    /**
   * The router rejected a subscription add or remove request
   * for a reason not separately enumerated.
   */
                    SUBSCRIPTION_ERROR_OTHER: 37,
                    /**
   * The client attempted to add a subscription that
   * exceeded the maximum number allowed.
   *
   * Causes:
   *  * 400 Max Num Subscriptions Exceeded
   */
                    SUBSCRIPTION_TOO_MANY: 38,
                    /**
   *  The client attempted to add a subscription which already
   * exists but it has different properties.
   *
   * Causes:
   *  * 400 Subscription Attributes Conflict With Existing Subscription
   */
                    SUBSCRIPTION_ATTRIBUTES_CONFLICT: 39,
                    /**
   * The client attempted to establish a session with No Local
   * enabled and the capability is not supported by the router.
   */
                    NO_LOCAL_NOT_SUPPORTED: 40,
                    ////////////////////
                    // UNKNOWN ERRORS //
                    ////////////////////
                    /**
   * The router rejected a control message for another reason
   * not separately enumerated.
   */
                    // CONTROL_ERROR_OTHER: 41,
                    /**
   * The router rejected a data message for a reason
   * not separately enumerated.
   */
                    DATA_ERROR_OTHER: 42,
                    //////////////////////
                    // TRANSPORT ERRORS //
                    //////////////////////
                    /**
   * Failed to create the HTTP connection.
   */
                    CREATE_XHR_FAILED: 43,
                    /**
   * Failed to create the transport.
   */
                    CONNECTION_ERROR: 44,
                    /**
   * Failed to decode the data.
   */
                    DATA_DECODE_ERROR: 45,
                    /**
   * @deprecated
   * The session was inactive for too long.
   *
   * Causes:
   * * 400 Inactivity Timeout
   */
                    INACTIVITY_TIMEOUT: 46,
                    /**
   * @deprecated
   * The router does not know this session's identifier.
   *
   * Causes:
   * * 400 Unknown Transport Session Identfier
   */
                    UNKNOWN_TRANSPORT_SESSION_ID: 47,
                    /**
   * @deprecated This subcode is not used since 10.0.0.
   * Guaranteed Messages (with a delivery mode other than DIRECT) are not supported.
   */
                    AD_MESSAGING_NOT_SUPPORTED: 48,
                    /**
   * @deprecated
   * Creating the WebSocket transport failed.
   */
                    CREATE_WEBSOCKET_FAILED: 49,
                    /**
   * An attempt to perform an operation using a VPN that is configured to be
   * STANDBY for replication.
   *
   * Causes:
   * * 403 Replication Is Standby
   */
                    REPLICATION_IS_STANDBY: 50,
                    ////////////////////
                    // Authentication //
                    ////////////////////
                    /**
   * Basic authentication is administratively shut down on the
   * router.
   *
   * Causes:
   *  * 403 Basic Authentication is Shutdown
   */
                    BASIC_AUTHENTICATION_IS_SHUTDOWN: 51,
                    /**
   * Client certificate authentication is administratively
   * shut down on the router.
   *
   * Causes:
   *  * 403 Client Certificate Authentication Is Shutdown
   */
                    CLIENT_CERTIFICATE_AUTHENTICATION_IS_SHUTDOWN: 52,
                    //////////////////////
                    // Guaranteed Messaging //
                    //////////////////////
                    /**
   * Guaranteed Messaging services are not enabled on the router.
   *
   * Causes:
   *  * 503 Service Unavailable
   */
                    GM_UNAVAILABLE: 100,
                    /**
   * The session attempted to connect to a Guaranteed Message Publisher
   * that does not exist on this router.
   * All unacked messages held by the API are renumbered and redelivered. This subCode
   * is handled internally and will not be seen by the application. After successfully
   * renumbereing and redelivering the messages, if any messages are resent, listeners
   * on the @{link solace.SessionEventCode#event:REPUBLISHING_UNACKED_MESSAGES} event are
   * invoked.
   *
   * Causes:
   * * 400 Unknown Flow Name
   * @private
   */
                    UNKNOWN_FLOW_NAME: 111,
                    /**
   * Already bound to the Queue or not authorized to bind to the Queue.
   *
   * Causes:
   *  * 400 Already Bound
   */
                    ALREADY_BOUND: 112,
                    /**
   * An attempt was made to bind to a Guaranteed Messaging Topic Endpoint with an
   * invalid topic.
   *
   * Causes:
   *  * 400 Invalid Topic Name
   */
                    INVALID_TOPIC_NAME_FOR_TOPIC_ENDPOINT: 113,
                    /**
   * An attempt was made to bind to an unknown Queue name (for example, not
   * configured on the router).
   *
   * Causes:
   *  * 503 Unknown Queue
   */
                    UNKNOWN_QUEUE_NAME: 114,
                    /**
   * An attempt was made to perform an operation on an unknown Guaranteed Messaging
   * Topic Endpoint name (for example, not configured on router).
   *
   * Causes:
   *  * 503 Unknown Durable Topic Endpoint
   */
                    UNKNOWN_TOPIC_ENDPOINT_NAME: 115,
                    /**
   * An attempt was made to bind to a Guaranteed Messaging Queue that has already reached
   * its maximum number of clients.
   *
   * Causes:
   *  * 503 Max clients exceeded for Queue
   */
                    MAX_CLIENTS_FOR_QUEUE: 116,
                    /**
   * An attempt was made to bind to a Guaranteed Messaging Topic Endpoint that has already
   * reached its maximum number of clients.
   *
   * Causes:
   *  * 503 Max clients exceeded for durable Topic Endpoint
   */
                    MAX_CLIENTS_FOR_TE: 117,
                    /**
   * An unexpected unbind response was received for a Guaranteed Messaging Queue or Topic
   * Endpoint (for example, the Queue or Topic Endpoint was deleted from the router).
   */
                    UNEXPECTED_UNBIND: 118,
                    /**
   * The specified Guaranteed Messaging Queue was not found when publishing a message.
   *
   * Causes:
   *  * 400 Queue Not Found
   */
                    QUEUE_NOT_FOUND: 119,
                    /**
   * Message was not delivered because the Guaranteed Message spool is over its
   * allotted space quota.
   *
   * Causes:
   *  * 503 Spool Over Quota
   */
                    SPOOL_OVER_QUOTA: 120,
                    /**
   * An attempt was made to operate on a shutdown Guaranteed Messaging queue.
   *
   * Causes:
   *  * 503 Queue Shutdown
   */
                    QUEUE_SHUTDOWN: 121,
                    /**
   * An attempt was made to operate on a shutdown Guaranteed Messaging Topic Endpoint.
   *
   * Causes:
   *  * 503 Durable Topic Endpoint Shutdown
   *  * 503 TE Shutdown
   *  * 503 Endpoint Shutdown
   */
                    TOPIC_ENDPOINT_SHUTDOWN: 122,
                    /**
   * An attempt was made to bind to a non-durable Guaranteed Messaging Queue or Topic
   * Endpoint, and the router is out of resources.
   *
   * Causes:
   *  * 503 No More Non-Durable Queue or Topic Endpoint
   */
                    NO_MORE_NON_DURABLE_QUEUE_OR_TOPIC_ENDPOINT: 123,
                    /**
   * An attempt was made to create a Queue or Topic Endpoint that already exists.
   * This subcode is only returned if
   * {@link solace.SessionProperties.ignoreProvisionEndpointExists} was not set for the current
   * session.
   *
   * Causes:
   *  * 400 Endpoint Already Exists
   */
                    ENDPOINT_ALREADY_EXISTS: 124,
                    /**
   * An attempt was made to delete or create a Queue or Topic Endpoint when the
   * Session does not have authorization for the action. This subcode is also returned when an
   * attempt is made to remove a message from an endpoint when the Session does not have 'consume'
   * authorization, or when an attempt is made to add or remove a Topic subscription from a Queue
   * when the Session does not have 'modify-topic' authorization.
   *
   * Causes:
   *  * 403 Permission Not Allowed
   */
                    PERMISSION_NOT_ALLOWED: 125,
                    /**
   * An attempt was made to bind to a Queue or Topic Endpoint with an invalid
   * selector.
   *
   * Causes:
   *  * 400 Invalid Selector
   */
                    INVALID_SELECTOR: 126,
                    /**
   * Publishing the message was denied due to exceeding the maximum spooled message
   * count.
   *
   * Causes:
   *  * 503 Max message usage exceeded
   */
                    MAX_MESSAGE_USAGE_EXCEEDED: 127,
                    /**
   * An attempt was made to create a dynamic durable endpoint, and it was found to
   * exist with different properties.
   *
   * Causes:
   *  * 400 Endpoint Property Mismatch
   */
                    ENDPOINT_PROPERTY_MISMATCH: 128,
                    /**
   * The client attempted to publish an Guaranteed Messaging message to a topic that
   * did not have any guaranteed subscription matches, or only matched a replicated topic.
   *
   * Causes:
   *  * 503 No Subscription Match
   */
                    NO_SUBSCRIPTION_MATCH: 129,
                    /**
   * The application attempted to acknowledge a message that arrived via a delivery
   * mode that does not allow acknowledgements.
   */
                    MESSAGE_DELIVERY_MODE_MISMATCH: 130,
                    /**
   * The message was already acknowledged.
   */
                    MESSAGE_ALREADY_ACKNOWLEDGED: 131,
                    /**
   * The API-supplied subscription did not match when attempting to bind to a
   * non-exclusive durable topic endoint.
   *
   * Causes:
   *  * 403 Subscription Does Not Match
   */
                    SUBSCRIPTION_DOES_NOT_MATCH: 133,
                    /**
   * The API-supplied selector did not match when attempting to bind to a
   * non-exclusive durable topic endpoint.
   *
   * Causes:
   *  * 403 Selector Does Not Match
   */
                    SELECTOR_DOES_NOT_MATCH: 134,
                    /**
   * The subscriber has provided an incorrectly formatted durable topic endpoint name.
   *
   * Causes:
   *  * 400 Invalid Durable Topic Endpoint Name
   */
                    INVALID_DTE_NAME: 135,
                    /**
   * The unsubscribe request was denied by the router because the durable topic endpoint
   * had one or more clients bound.
   *
   * Causes:
   *  * 400 Unsubscribe Not Allowed, Client(s) Bound To DTE
   */
                    UNSUBSCRIBE_NOT_ALLOWED_CLIENTS_BOUND: 136,
                    /**
   * An application callback threw an error back to the API. The reason property describes
   * the error that occurred.
   */
                    CALLBACK_ERROR: 137,
                    /**
   * A published message was discarded by the router because it will not be published
   * anywhere based on the NoLocal properties. This can be considered normal.
   *
   * Causes:
   * * 400 Nolocal Discard
   */
                    NOLOCAL_DISCARD: 138,
                    /**
   * The operation is delayed because Guaranteed Messaging is not ready on the router.
   *
   * Causes:
   * 507 Ad Not Ready
   */
                    GM_NOT_READY: 140,
                    /**
   * The message was rejected because one or more matching endpoints'
   * reject-low-priority-msg-limit was exceeded.
   *
   * Causes:
   * * 503 Low Priority Msg Congestion
   */
                    LOW_PRIORITY_MSG_CONGESTION: 141,
                    /**
   * The specified endpoint quota was out of range.
   *
   * Causes:
   * 400 Quota Out Of Range
   */
                    QUOTA_OUT_OF_RANGE: 142,
                    /**
   * Unable to load the certificate from the TrustStore for a SSL
   * secured session.
   */
                    FAILED_LOADING_TRUSTSTORE: 143,
                    /**
   * The client failed to load certificate and/or private key files.
   */
                    FAILED_LOADING_CERTIFICATE_AND_KEY: 144,
                    /**
   * DNS resolution failed for all hostnames.
   */
                    UNRESOLVED_HOSTS: 145,
                    /**
   * Replay is not supported on the Solace Message Router
   */
                    REPLAY_NOT_SUPPORTED: 146,
                    /**
   *  Replay is not enabled in the message-vpn
   */
                    REPLAY_DISABLED: 147,
                    /**
   *  The client attempted to start replay on a flow bound to a non-exclusive endpoint
   */
                    CLIENT_INITIATED_REPLAY_NON_EXCLUSIVE_NOT_ALLOWED: 148,
                    /**
   *  The client attempted to start replay on an inactive flow
   */
                    CLIENT_INITIATED_REPLAY_INACTIVE_FLOW_NOT_ALLOWED: 149,
                    /**
   *  N/A - Browser Flows are not supported.
   */
                    CLIENT_INITIATED_REPLAY_BROWSER_FLOW_NOT_ALLOWED: 150,
                    /**
   *  Replay is not supported on temporary endpoints
   */
                    REPLAY_TEMPORARY_NOT_SUPPORTED: 151,
                    /**
   *  The client attempted to start a replay but provided an unknown start location type.
   */
                    UNKNOWN_START_LOCATION_TYPE: 152,
                    /**
   *  A replay in progress on a flow was administratively cancelled, causing the flow to be unbound
   */
                    REPLAY_CANCELLED: 153,
                    /**
   *  A replay in progress on a flow failed because messages to be replayed were trimmed
   *  from the replay log
   */
                    REPLAY_MESSAGE_UNAVAILABLE: 154,
                    /**
   *  A replay was requested but the requested start time is not available in the replay log
   */
                    REPLAY_START_TIME_NOT_AVAILABLE: 155,
                    /**
   *  The Solace Message Router attempted to replay a message, but the queue/topic
   *  endpoint rejected the message to the sender
   */
                    REPLAY_MESSAGE_REJECTED: 156,
                    /**
   *  A replay in progress on a flow failed because the replay log was modified
   */
                    REPLAY_LOG_MODIFIED: 157,
                    /**
   * Endpoint error ID in the bind request does not match the endpoint's error ID.
   */
                    MISMATCHED_ENDPOINT_ERROR_ID: 158,
                    /**
   * A replay was requested, but the router does not have sufficient resources
   * to fulfill the request, due to too many active replays.
   */
                    OUT_OF_REPLAY_RESOURCES: 159,
                    /**
   * A replay was in progress on a Durable Topic Endpoint (DTE)
   * when its topic or selector was modified, causing the replay to fail.
   */
                    TOPIC_OR_SELECTOR_MODIFIED_ON_DURABLE_TOPIC_ENDPOINT: 160,
                    /**
   *  A replay in progress on a flow failed
   */
                    REPLAY_FAILED: 161,
                    /**
   *  A replay was started on the queue or DTE, either by another client or by the router.
   */
                    REPLAY_STARTED: 162,
                    /**
   * Router does not support Compressed TLS
   */
                    COMPRESSED_TLS_NOT_SUPPORTED: 163,
                    /**
   * The client attempted to add a shared subscription, but the capability is not supported
   * by the appliance.
   */
                    SHARED_SUBSCRIPTIONS_NOT_SUPPORTED: 164,
                    /**
   * The client attempted to add a shared subscription on a client that is not permitted to
   * use shared subscriptions.
   */
                    SHARED_SUBSCRIPTIONS_NOT_ALLOWED: 165,
                    /**
   * The client attempted to add a shared subscription to a queue or topic endpoint.
   */
                    SHARED_SUBSCRIPTIONS_ENDPOINT_NOT_ALLOWED: 166,
                    /**
   * A replay was requested but the requested start message is not available in the replay log.
   */
                    REPLAY_START_MESSAGE_NOT_AVAILABLE: 167,
                    /**
   * Replication Group Message Id are not comparable.
   * Messages must be published to the same broker or HA pair for their Replicaton Group
   * Message Id to be comparable.
   */
                    MESSAGE_ID_NOT_COMPARABLE: 168,
                    /**
   *  Replay is not supported on anonymous queue
   * - 403 Replay Not Supported on Anonymous Queue
   */
                    REPLAY_ANONYMOUS_QUEUE_NOT_SUPPORTED: 169
                };
                module.exports.ErrorSubcode = Enum.new(ErrorSubcode);
                /***/
            },
            /***/ "./modules/solclient-error/lib/not-implemented-error.js": 
            /*!**************************************************************!*\
  !*** ./modules/solclient-error/lib/not-implemented-error.js ***!
  \**************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    SolaceError
                } = __webpack_require__(/*! ./solace-error */ "./modules/solclient-error/lib/solace-error.js");
                /**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 * An error thrown when calling an API that has not been implemented.
 * @hideconstructor
 * @extends {solace.SolaceError}
 *
 * @memberof solace
 */
                class NotImplementedError extends SolaceError {
                    /*
   * Creates an instance of NotImplementedError.
   * @param {any} message The message to include in the error.
   * @memberof NotImplementedError
   */
                    constructor(message) {
                        super("NotImplementedError", message || "", NotImplementedError);
                    }
                    /**
   * The name of the error.
   * @name solace.NotImplementedError#name
   * @type {String}
   * @readonly
   * @description 'NotImplementedError'
   */
                }
                module.exports.NotImplementedError = NotImplementedError;
                /***/
            },
            /***/ "./modules/solclient-error/lib/operation-error.js": 
            /*!********************************************************!*\
  !*** ./modules/solclient-error/lib/operation-error.js ***!
  \********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    SolaceError
                } = __webpack_require__(/*! ./solace-error */ "./modules/solclient-error/lib/solace-error.js");
                /**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 * An error thrown by the API when an operational error is encountered.
 * @memberof solace
 * @extends {solace.SolaceError}
 * @hideconstructor
 */
                class OperationError extends SolaceError {
                    /*
   * @constructor
   * @param {String} message The message to include in the error.
   * @param {Number} [subcode] The subcode. See {@link ErrorSubcode} for valid values
   * @param {Object} [reason] Embedded error or exception (optional)
   */
                    constructor(message, subcode, reason) {
                        /**
     * The name of the error.
     * @name solace.OperationError#name
     * @type {String}
     * @readonly
     * @description 'OperationError'
     */
                        super("OperationError", message, OperationError);
                        /**
     * The subcode for the error. @see {@link solace.ErrorSubcode}
     * @name solace.OperationError#subcode
     * @type {solace.ErrorSubcode}
     */
                        this.subcode = subcode;
                        /**
     * The reason for the error: an embedded error object or exception.
     * @name solace.OperationError#reason
     * @type {Object}
     */
                        this.reason = reason;
                    }
                }
                module.exports.OperationError = OperationError;
                /***/
            },
            /***/ "./modules/solclient-error/lib/request-error.js": 
            /*!******************************************************!*\
  !*** ./modules/solclient-error/lib/request-error.js ***!
  \******************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /* provided dependency */ var util_inspect = __webpack_require__(/*! browser-util-inspect */ "./node_modules/browser-util-inspect/index.js");
                const {
                    ErrorSubcode
                } = __webpack_require__(/*! ./error-subcodes */ "./modules/solclient-error/lib/error-subcodes.js");
                const {
                    OperationError
                } = __webpack_require__(/*! ./operation-error */ "./modules/solclient-error/lib/operation-error.js");
                const {
                    RequestEventCode
                } = __webpack_require__(/*! ./request-event-codes */ "./modules/solclient-error/lib/request-event-codes.js");
                const SUBCODE_FROM_EC = {
                    [RequestEventCode.REQUEST_ABORTED]: ErrorSubcode.SESSION_NOT_CONNECTED,
                    [RequestEventCode.REQUEST_TIMEOUT]: ErrorSubcode.TIMEOUT
                };
                /**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 *
 * Represents a request failure event; request failure events are passed to the application
 * event handling callback provided when sending the request {@link solace.Session#sendRequest}
 * @memberof solace
 * @extends solace.OperationError
 * @hideconstructor
 */
                class RequestError extends OperationError {
                    /*
   * <b>This class is not exposed for construction by API users.</b> Instances of this object will
   * be passed to the application in calls to the application's
   * {@link solace.Session.requestFailedCallback}, provided when invoking
   * {@link solace.Session.sendReqeust}.
   * @constructor
   * @param {String} message Information string
   * @param {solace.RequestEventCode} eventCode The event code
   * @param {Object} [correlationKey] Any associated correlation key
   * @param {Object} [reason] Any additional information
   * @private
   */
                    constructor(message, eventCode, correlationKey, reason) {
                        super(message, SUBCODE_FROM_EC[eventCode], reason);
                        /**
     * The name of the error.
     * @name solace.RequestError#name
     * @type {String}
     * @readonly
     * @description 'RequestError'
     */
                        this.name = "RequestError";
                        this._eventCode = eventCode;
                        this._correlationKey = correlationKey;
                    }
                    /**
   * @type {solace.SessionEventCode}
   * @name solace.RequestError#requestEventCode
   * @description A code that provides more information about the error event.
   */
                    get requestEventCode() {
                        return this._requestEventCode;
                    }
                    /**
   * @deprecated Use {@link solace.RequestError#subcode}
   * @type {?solace.ErrorSubcode}
   * @description if applicable, an error subcode. Defined in {@link ErrorSubcode}
   */
                    get errorSubcode() {
                        return super.subcode;
                    }
                    ["inspect"]() {
                        const superObj = super["inspect"] ? super["inspect"]() : {};
                        return Object.assign(superObj, {
                            requestEventCode: RequestEventCode.describe(this.requestEventCode),
                            infoStr: this.infoStr,
                            correlationKey: this.correlationKey
                        });
                    }
                    toString() {
                        return util_inspect(this);
                    }
                }
                module.exports.RequestError = RequestError;
                /***/
            },
            /***/ "./modules/solclient-error/lib/request-event-codes.js": 
            /*!************************************************************!*\
  !*** ./modules/solclient-error/lib/request-event-codes.js ***!
  \************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * An attribute of {@link solace.RequestError}. This enumeration represents the
 * different errors emitted by
 * {@link solace.Session.requestFailedCallback}
 * when a {@link solace.Session#sendRequest} fails.
 *
 * The client application receives a request error with event code
 * {@link solace.RequestEventCode.REQUEST_ABORTED}
 * when the underlying connection is successfully closed, or closed as a result
 * of a communication error.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
                const RequestEventCode = {
                    /**
   * A request was aborted because the session is disconnected.
   */
                    REQUEST_ABORTED: 8,
                    /**
   * The event represents a timed-out request API call.
   */
                    REQUEST_TIMEOUT: 9
                };
                module.exports.RequestEventCode = Enum.new(RequestEventCode);
                /***/
            },
            /***/ "./modules/solclient-error/lib/solace-error.js": 
            /*!*****************************************************!*\
  !*** ./modules/solclient-error/lib/solace-error.js ***!
  \*****************************************************/
            /***/ module => {
                /**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 * The base class for all errors thrown by the API.
 * @hideconstructor
 * @extends {Error}
 *
 * @memberof solace
 */
                class SolaceError extends Error {
                    constructor(type, message, constructor) {
                        super(message || "");
                        /**
     * Error Message.
     * @name solace.SolaceError#message
     * @type {String}
     */
                        this.message = message; // force set
                        /**
     * The name of the error.
     * @name solace.SolaceError#name
     * @type {String}
     */
                        this.name = type;
                        // ES6 error semantics are disappointing
                        // Cleaner stack capture for V8-based VMs
                        if (Error.captureStackTrace) {
                            Error.captureStackTrace(this, constructor);
                        } else {
                            this.stack = new Error().stack;
                        }
                    }
                }
                module.exports.SolaceError = SolaceError;
                /***/
            },
            /***/ "./modules/solclient-eskit/api.js": 
            /*!****************************************!*\
  !*** ./modules/solclient-eskit/api.js ***!
  \****************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ArrayOperations
                } = __webpack_require__(/*! ./lib/array-operations */ "./modules/solclient-eskit/lib/array-operations.js");
                const {
                    assert
                } = __webpack_require__(/*! ./lib/assert */ "./modules/solclient-eskit/lib/assert.js");
                const {
                    BidiMap
                } = __webpack_require__(/*! ./lib/bidi-map */ "./modules/solclient-eskit/lib/bidi-map.js");
                const {
                    Enum
                } = __webpack_require__(/*! ./lib/enum */ "./modules/solclient-eskit/lib/enum.js");
                const {
                    Iterator
                } = __webpack_require__(/*! ./lib/iterator */ "./modules/solclient-eskit/lib/iterator.js");
                const {
                    Lazy
                } = __webpack_require__(/*! ./lib/lazy */ "./modules/solclient-eskit/lib/lazy.js");
                const {
                    makeMap
                } = __webpack_require__(/*! ./lib/make-map */ "./modules/solclient-eskit/lib/make-map.js");
                const {
                    Mixin
                } = __webpack_require__(/*! ./lib/mixin */ "./modules/solclient-eskit/lib/mixin.js");
                const {
                    Resolver
                } = __webpack_require__(/*! ./lib/resolver */ "./modules/solclient-eskit/lib/resolver.js");
                const {
                    SetOperations
                } = __webpack_require__(/*! ./lib/set-operations */ "./modules/solclient-eskit/lib/set-operations.js");
                module.exports.assert = assert;
                module.exports.ArrayOperations = ArrayOperations;
                module.exports.BidiMap = BidiMap;
                module.exports.Enum = Enum;
                module.exports.Iterator = Iterator;
                module.exports.Lazy = Lazy;
                module.exports.makeIterator = Iterator.makeIterator;
                module.exports.makeMap = makeMap;
                module.exports.Mixin = Mixin;
                module.exports.mixin = Mixin.mixin;
                module.exports.Resolver = Resolver;
                module.exports.resolve = Resolver.resolve;
                module.exports.SetOperations = SetOperations;
                /***/
            },
            /***/ "./modules/solclient-eskit/lib/array-operations.js": 
            /*!*********************************************************!*\
  !*** ./modules/solclient-eskit/lib/array-operations.js ***!
  \*********************************************************/
            /***/ module => {
                /* eslint-disable no-nested-ternary */
                function defaultComparator(a, b) {
                    const astr = String(a);
                    const bstr = String(b);
                    return astr > bstr ? 1 : astr < bstr ? -1 : 0;
                }
                function insertOrdered(array, element, comparator = defaultComparator) {
                    const result = [ ...array ];
                    return this.inplaceInsertOrdered(result, element, comparator);
                }
                function inplaceInsertOrdered(array, element, comparator = defaultComparator) {
                    let index = 0;
                    let min = 0;
                    let max = array.length;
                    // Optimize for empty array
                    if (max > 0) {
                        // Optimize for append
                        if (comparator(element, array[max - 1]) > 0) {
                            index = max;
                        } else {
                            // Binary search
                            index = min + max >> 1; // math.floor((min + max) / 2)
                            while (max > min) {
                                if (comparator(element, array[index]) < 0) {
                                    max = index;
                                } else {
                                    min = index + 1;
                                }
                                index = min + max >> 1; // math.floor((min + max) / 2)
                            }
                        }
                    }
                    array.splice(index, 0, element);
                }
                module.exports = {
                    ArrayOperations: {
                        defaultComparator: defaultComparator,
                        insertOrdered: insertOrdered,
                        inplaceInsertOrdered: inplaceInsertOrdered
                    }
                };
                /***/
            },
            /***/ "./modules/solclient-eskit/lib/assert.js": 
            /*!***********************************************!*\
  !*** ./modules/solclient-eskit/lib/assert.js ***!
  \***********************************************/
            /***/ module => {
                let assert;
                /**
 * Browsers and Node share a common console.assert interface, console.assert(assertion, ...);
 * In Node, console.assert throws AssertionError if its assertion is falsy.
 * In browsers, they print to the console.
 * Extend browser behaviour to also throw.
 */
                if (true) {
                    let internalAssert;
                    if (false) {} else {
                        internalAssert = function browserAssert(assertion, ...args) {
                            if (!assertion) {
                                throw new Error(`Assertion error: ${typeof assertion} ${assertion} (${args.join(" ")})`);
                            }
                        };
                    }
                    // Now, wrap the assert in a catch and rethrow to give us a single place
                    // to set assert breakpoints.
                    assert = function outerAssert(...args) {
                        // eslint-disable-next-line no-useless-catch
                        try {
                            internalAssert(...args);
                        } catch (e) {
                            // if (BUILD_ENV.MODE_DEBUG) debugger;
                            throw e;
                        }
                    };
                } else {}
                module.exports.assert = assert;
                /***/
            },
            /***/ "./modules/solclient-eskit/lib/bidi-map.js": 
            /*!*************************************************!*\
  !*** ./modules/solclient-eskit/lib/bidi-map.js ***!
  \*************************************************/
            /***/ module => {
                /**
 * @private
 */
                class BidiMap {
                    constructor(...pairs) {
                        this.forward = new Map();
                        this.reverse = new Map();
                        pairs.forEach(p => {
                            this.setValues(p[0], p[1]);
                        });
                    }
                    /**
   * Sets the key => value and value => key relationships for the supplied parameters.
   *
   * Method name is #set, not #put, for alignment with ES map method names.
   * @param {*} key The key for the forward mapping (value in the reverse mapping)
   * @param {*} value The value for the forward mapping (key in the reverse mapping)
   */
                    setValues(key, value) {
                        this.forward.set(key, value);
                        this.reverse.set(value, key);
                    }
                }
                module.exports.BidiMap = BidiMap;
                /***/
            },
            /***/ "./modules/solclient-eskit/lib/enum.js": 
            /*!*********************************************!*\
  !*** ./modules/solclient-eskit/lib/enum.js ***!
  \*********************************************/
            /***/ module => {
                function enumName(instance, keys, value) {
                    const matches = keys.filter(k => instance[k] === value);
                    return matches.length ? matches[0] : null;
                }
                function enumValues(instance, keys) {
                    return Array.from(new Set(keys.map(k => instance[k])));
                }
                /**
 * The base for all enumerated types. Provides common functionality such as
 * collections of keys and values, reverse mapping, and readable descriptions. Also
 * supports overriding the canonical key-value mapping to maintain readability in
 * minified environments.
 *
 * @mixin
 * @memberof solace
 */
                class Enum {
                    /**
   * Creates an Enum with the given key-value mapping.
   *
   * @param {Object} values The key-value mapping to use. This mapping is set as the initial
   * canonical key-value mapping. To override, use {@link solace.Enum#_setCanonical}.
   */
                    constructor(values) {
                        Object.defineProperties(this, {
                            _canonical: {
                                value: null,
                                enumerable: false,
                                writable: true,
                                configurable: true
                            }
                        });
                        this._setCanonical(values);
                    }
                    /**
   * Resets the canonical key value mapping for the enumeration. Using this method,
   * you add additional sets of keys that map to the same values, and specify that
   * these new keys take precedence for reverse mapping. Any older set of keys is made
   * non-canonical and non-enumerable.
   *
   * @example
   * const c = new Enum({ HELLO: 'world' });
   * c._setCanonical({ MAD: 'world' });
   * c.nameOf('world') === 'MAD'; // true
   *
   * @param {Object} values The new key-value mapping to add to the object and set as canonical.
   * @param {Boolean} final Whether this enumeration should accept further reconfiguration.
   * @private
   */
                    _setCanonical(values, final = false) {
                        this._canonical = Object.assign({}, values);
                        Object.keys(this).forEach(key => {
                            const descriptor = Object.getOwnPropertyDescriptor(this, key);
                            if (descriptor.value !== undefined) {
                                Object.defineProperty(this, key, {
                                    enumerable: false,
                                    writable: true,
                                    configurable: true,
                                    value: descriptor.value
                                });
                            }
                        });
                        Object.keys(values).forEach(key => {
                            Object.defineProperty(this, key, {
                                enumerable: true,
                                writable: !final,
                                configurable: !final,
                                value: values[key]
                            });
                        });
                    }
                    /**
   * Create a human-readable string describing the given enumeration value. This
   * result is informational and may vary between SDK versions.
   *
   * Currently, it either returns the value provided (if the associated key is
   * the same), or a string of the form `key (value)`.
   *
   * @example
   * console.log(new Enum({ ANSWER: 42 }).describe(42)); // ANSWER (42)
   * console.log(new Enum({ ECHO: 'ECHO' })).describe('ECHO'); // ECHO
   *
   * @param {any} enumValue The value on which to perform reverse mapping.
   * @param {String} [noneValue=''] The string to return if the enumeration value is
   *    undefined or null.
   * @param {String} [unknownValue='<unknown>'] The string to return if the enumeration
   *    value was not found in any of the canonical keys.
   * @returns {String} A human-readable description of the reverse mapping for the value.
   */
                    describe(enumValue, noneValue = "<none>", unknownValue = "<unknown>") {
                        if (enumValue === null || enumValue === undefined) return noneValue;
                        const name = enumName(this._canonical, Object.keys(this._canonical || {}), enumValue) || unknownValue;
                        return name === enumValue ? name : `${name} (${enumValue})`;
                    }
                    /**
   * Returns the canonical name in this enumeration for the given value. This function is
   * designed to facilitate reflection, whereas for display
   *
   * @param {any} enumValue The value for which to get the enumeration key.
   * @returns {String} The name for the given value.
   */
                    nameOf(enumValue) {
                        return enumName(this._canonical, Object.keys(this._canonical || {}), enumValue);
                    }
                    /**
   * Returns all canonical names/keys in this enumeration.
   *
   * @readonly
   * @returns {Array.<String>} All canonical names in this enumeration.
   */
                    get names() {
                        return Object.keys(this._canonical || {});
                    }
                    /**
   * Returns all values assigned to canonical keys in this enumeration.
   *
   * @readonly
   * @returns {Array} All values defined for enumeration keys.
   */
                    get values() {
                        return enumValues(this._canonical, Object.keys(this._canonical || {}));
                    }
                    /**
   * A property returning true to faciliate duck-typing with {solace.Enum} objects.
   *
   * @readonly
   * @returns {Boolean} true This is an enumeration.
   */
                    get isEnum() {
                        // eslint-disable-line class-methods-use-this
                        return true;
                    }
                    /**
   * Returns the name of an enuerated value given the
   * enumeration and the value.
   *
   * @param {Object} instance The enumeration instance.
   * @param {*} value The value for which to return the key name.
   * @returns {String} The key name for the given enumeration value.
   */
                    static nameOf(instance, value) {
                        return instance.nameOf(value);
                    }
                    /**
   * Returns values defined on this enumeration for the given keys. To get the enumeration keys,
   * use {@link Object#keys}.
   * @param {Object} instance The enumeration on which to return values.
   * @returns {Array} The values defined on the given enumeration.
   **/
                    static values(instance) {
                        return instance.values();
                    }
                    /**
   * Alternate construction method for enumerations.
   *
   * @static
   * @param {Object} values Initial key-value mapping
   * @returns {solace.Enum} A new enumeration instance
   * @private
   */
                    static new(values) {
                        return new Enum(values);
                    }
                    /**
   * Constructs a private enumeration in which the values are equal to the keys.
   *
   * @static
   * @param {Array.<String>} strings Key names. The values will be equal to the keys.
   * @returns {solace.Enum} An enumeration instance of the given strings
   * @private
   */
                    static ofStrings(strings) {
                        const map = {};
                        strings.forEach(s => {
                            map[s] = s;
                        });
                        return Enum.new(map);
                    }
                    /**
   * Constructs an enumeration in which each key is assigned a distinct integer value.
   * Enums created this way are subject to renumbering if keys are reordered.
   *
   * @static
   * @param {Array.<String>} keys Key names. The values will be sequential from zero.
   * @returns {solace.Enum} An enumeration instance of the given values
   * @private
   */
                    static ofNumbers(keys) {
                        const map = {};
                        keys.forEach((key, index) => {
                            map[key] = index;
                        });
                        return Enum.new(map);
                    }
                }
                module.exports.Enum = Enum;
                /***/
            },
            /***/ "./modules/solclient-eskit/lib/iterator.js": 
            /*!*************************************************!*\
  !*** ./modules/solclient-eskit/lib/iterator.js ***!
  \*************************************************/
            /***/ module => {
                /**
 * An object managing a traversal of an Array-like object.
 *
 * @memberof solace
 * @property {function} deref Returns the value the iterator is
 *      referencing.
 * @property {function} incr Increments the iterator's reference in the
 *      iterator's data set.
 * @property {function} end Tests whether the iterator is at the end of
 *      the data set.  This MUST return false when calling deref() or
 *      incr().
 * @private
 */
                class Iterator {
                    /**
   * Creates an iterator to forward iterate over a specific contiguous
   * section of an array, specifically in the range [start, end)
   * @param {Array} arr The array to iterate over
   * @param {Number} [start=0] The first item the iterator should
   *  dereference
   * @param {Number} [end=arr.length] One beyond the last item in the array
   *  that the iterator should dereference.
   * @constructor
   */
                    constructor(arr, start = 0, end = arr.length) {
                        /**
     * The array being iterated.
     * @type {Array}
     * @private
     */
                        this._arr = arr;
                        /**
     * The current index of the enumeration.
     * @private
     * @type {Number}
     */
                        this._index = start;
                        /**
     * The exclusive end index, or the length, of the array.
     * @type {Number}
     */
                        this._end = end;
                    }
                    /**
   * Returns the element at the iterator's position.
   * @returns {Object} The array element at the current position.
   */
                    deref() {
                        return this._arr[this._index];
                    }
                    /**
   * Increments the iterator.
   * @returns {Number} The new position of the iterator.
   */
                    incr() {
                        return ++this._index;
                    }
                    /**
   * Reports whether the iterator has completed its iteration.
   * @returns {Boolean} True if the iterator has reached the end of the iteration.
   */
                    end() {
                        return this._index >= this._end;
                    }
                    /**
   * Creates an iterator to forward iterate over a specific contiguous
   * section of an array, specifically in the range [start, end)
   *
   * @param {Array} arr The array to iterate over
   * @param {Number} [start=0] The first item the iterator should
   *  dereference
   * @param {Number} [end=arr.length] One beyond the last item in the array
   *  that the iterator should dereference.
   * @returns {solace.Iterator} An iterator to the specified set of data.
   */
                    static makeIterator(arr, start = 0, end = arr.length) {
                        return new Iterator(arr, start, end);
                    }
                }
                // Expose both the static constructor function and the class.
                module.exports.Iterator = Iterator;
                /***/
            },
            /***/ "./modules/solclient-eskit/lib/lazy.js": 
            /*!*********************************************!*\
  !*** ./modules/solclient-eskit/lib/lazy.js ***!
  \*********************************************/
            /***/ module => {
                const DEFAULT_PROPERTY_OPTIONS = {
                    enumerable: true
                };
                function setPropertyValue(target, key, value, options = null) {
                    Object.defineProperty(target, key, Object.assign({
                        value: value
                    }, DEFAULT_PROPERTY_OPTIONS, options));
                }
                function lazyProperty(target, key, evalFn) {
                    Object.defineProperty(target, key, Object.assign({
                        configurable: true,
                        // Allow replacing this property with resolved value.
                        get: () => {
                            // The getter evaluates the function provided.
                            // It replaces itself with the value it resolves.
                            const result = evalFn(target, key);
                            setPropertyValue(target, key, result);
                            return result;
                        },
                        set: value => {
                            setPropertyValue(target, key, value);
                        }
                    }, DEFAULT_PROPERTY_OPTIONS));
                    return target;
                }
                function lazyProperties(target, obj) {
                    Object.keys(obj).forEach(k => {
                        lazyProperty(target, k, obj[k]);
                    });
                    return obj;
                }
                function lazyValue(evalFn) {
                    return lazyProperty({}, "value", evalFn);
                }
                const Lazy = {
                    lazyProperties: lazyProperties,
                    lazyProperty: lazyProperty,
                    lazyValue: lazyValue
                };
                module.exports.Lazy = Lazy;
                /***/
            },
            /***/ "./modules/solclient-eskit/lib/make-map.js": 
            /*!*************************************************!*\
  !*** ./modules/solclient-eskit/lib/make-map.js ***!
  \*************************************************/
            /***/ module => {
                // Avoid closure compiler nonsense
                module.exports.makeMap = function makeMap(...keyValuePairs) {
                    const result = {};
                    for (let i = 0; i < keyValuePairs.length; i += 2) {
                        result[keyValuePairs[i]] = keyValuePairs[i + 1];
                    }
                    return result;
                };
                /***/
            },
            /***/ "./modules/solclient-eskit/lib/mixin.js": 
            /*!**********************************************!*\
  !*** ./modules/solclient-eskit/lib/mixin.js ***!
  \**********************************************/
            /***/ module => {
                const Mixin = {};
                /**
   * @param  {Object} target The class to augment
   * @param  {Object} add The class to mix in.
   * @returns {Object} The augmented class
   */
                Mixin.mixin = function mixin(target, add) {
                    const targetProto = target.prototype;
                    const addProto = add.prototype;
                    Object.getOwnPropertyNames(addProto).forEach(name => {
                        if (name === "constructor") return;
                        Object.defineProperty(targetProto, name, Object.getOwnPropertyDescriptor(addProto, name));
                    });
                    return target;
                };
                module.exports.Mixin = Mixin;
                /***/
            },
            /***/ "./modules/solclient-eskit/lib/resolver.js": 
            /*!*************************************************!*\
  !*** ./modules/solclient-eskit/lib/resolver.js ***!
  \*************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Lazy
                } = __webpack_require__(/*! ./lazy */ "./modules/solclient-eskit/lib/lazy.js");
                const {
                    lazyProperty
                } = Lazy;
                function traversePath(commonSource, keySource, pathArr) {
                    return pathArr.reduce((source, value) => {
                        if (typeof value === "string") {
                            return source[value];
                        }
                        return value;
                    }, keySource);
                }
                /**
 * @classdesc
 * Deferred resolution for imports. A heavyweight method of breaking circular dependencies.
 * Each specified key (see below) is resolved once by a function that lazily evaluates a
 * path.
 * <pre>
 * const resolved = new Resolver({
 *  foo: [FooLib, 'fooContainer'],        // Resolves foo from FooLib.fooContainer.foo lazily
 *  bar: ['foo'],                         // Resolves bar from previously defined foo lazily
 *  'baz,quux': [FooLib, 'bazsAndQuuxes'] // baz = FooLib.bazsAndQuuxes.baz,
 *                                        // quux = FooLib.bazsAndQuuxes.quux
 * });
 * </pre>
 * In most cases this is equivalent to using FooLib.fooContainer.foo, et cetera, directly.
 * Prefer that approach unless the dependencies are deeply hierarchical. Prefer the Resolver
 * when one-time evaluation and aliasing a path makes the code more DRY and readable.
 * @private
 */
                class Resolver {
                    constructor(options, source) {
                        // For every key...
                        Object.keys(options).forEach(compoundKey => {
                            // Split out key names if multiple were provided
                            compoundKey.split(",").map(k => k.trim()).forEach(key => {
                                // Build a path array. The key name is the implicit last element.
                                const rawPath = options[compoundKey];
                                const path = typeof rawPath === "string" ? rawPath.split(".") : rawPath;
                                const pathArr = (Array.isArray(path) ? path : [ path ]).concat(key);
                                // Create a defer for this key.
                                lazyProperty(this, key, () => traversePath(source, this, pathArr));
                            });
                        });
                    }
                    static resolve(options, source) {
                        return new Resolver(options, source);
                    }
                }
                module.exports.Resolver = Resolver;
                /***/
            },
            /***/ "./modules/solclient-eskit/lib/set-operations.js": 
            /*!*******************************************************!*\
  !*** ./modules/solclient-eskit/lib/set-operations.js ***!
  \*******************************************************/
            /***/ module => {
                /* eslint-disable no-restricted-syntax */
                function isSuperset(set, subset) {
                    return Array.from(subset).every(elem => set.has(elem));
                }
                function inplaceUnion(setA, setB) {
                    setB.forEach(elem => {
                        setA.add(elem);
                    });
                    return setA;
                }
                function union(setA, setB) {
                    return inplaceUnion(new Set(setA), setB);
                }
                function inplaceIntersection(setA, setB) {
                    setA.forEach(elem => {
                        if (!setB.has(elem)) {
                            setA.delete(elem);
                        }
                    });
                    return setA;
                }
                function intersection(setA, setB) {
                    return new Set(Array.from(setA).filter(elem => setB.has(elem)));
                }
                function inplaceDifference(setA, setB) {
                    setB.forEach(elem => {
                        setA.delete(elem);
                    });
                    return setA;
                }
                function difference(setA, setB) {
                    return new Set(Array.from(setA).filter(elem => !setB.has(elem)));
                }
                module.exports = {
                    SetOperations: {
                        inplaceDifference: inplaceDifference,
                        inplaceIntersection: inplaceIntersection,
                        inplaceUnion: inplaceUnion,
                        isSuperset: isSuperset,
                        difference: difference,
                        intersection: intersection,
                        union: union
                    }
                };
                /***/
            },
            /***/ "./modules/solclient-events/api.js": 
            /*!*****************************************!*\
  !*** ./modules/solclient-events/api.js ***!
  \*****************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    EventEmitter
                } = __webpack_require__(/*! ./lib/event-emitter */ "./modules/solclient-events/lib/event-emitter.js");
                const {
                    Timer
                } = __webpack_require__(/*! ./lib/timer */ "./modules/solclient-events/lib/timer.js");
                module.exports = {
                    EventEmitter: EventEmitter,
                    Timer: Timer
                };
                /***/
            },
            /***/ "./modules/solclient-events/lib/event-emitter.js": 
            /*!*******************************************************!*\
  !*** ./modules/solclient-events/lib/event-emitter.js ***!
  \*******************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const NodeEventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;
                const {
                    ArrayUtils
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    LOG_WARN
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    flatten,
                    includes
                } = ArrayUtils;
                const NODE_DEFAULT_EVENTS = [ "error", "newListener", "removeListener" ];
                const BLACKLIST_DIRECT = [ "newListener", "removeListener" ];
                function buildFilter(emits) {
                    if (typeof emits === "function") return k => includes(NODE_DEFAULT_EVENTS, k) || emits(k);
                    if (!Array.isArray(emits)) return null;
                    const emitSet = new Set(flatten(emits));
                    NODE_DEFAULT_EVENTS.forEach(el => emitSet.add(el));
                    const emitArray = Array.from(emitSet);
                    return k => includes(emitArray, k);
                }
                const DISABLED_ACTIONS = {
                    ignore() {},
                    fail() {
                        throw new Error("Emitter disabled");
                    }
                };
                class EventEmitter extends NodeEventEmitter {
                    /**
   * Creates an instance of EventEmitter.
   *
   * An EventEmitter is an object that periodically emits events that cause function objects, known
   * as listeners, to be called. It exposes functions to attach passed functions to named events.
   *
   * Typically, event names are camel-cased strings, but any valid JavaScript property key can be
   * used.
   *
   * @param {?Object} options Options for the emitter
   * @param {String} [options.direct] An event that is to be directly dispatched when possible.
   *  Direct dispatch is a performance optimization that minimizes EventEmitter overhead. Direct
   *  dispatch skips the safe error handling path; use _formatErrorEvent if required.
   * @param {Array.<string>} [options.emits] Valid event names. If specified, listeners for other
   *  events are rejected. Array can be nested, e.g. `['foo', ['bar1', 'bar2']]`
   * @param {Boolean} [options.unsafe] Determines whether dispatch is less exception-safe.
   *  * When `false`, if an event listener throws an error, the error is thrown all the way back
   *    to the emitting stack frame. This makes it the emitter's responsibility to catch exceptions
   *    in listeners. This avoids a try-catch frame and may be more performant.
   *  * When `true`, if an event listener throws an error, and an `error` listener exists, the
   *    exception is dispatched to that listener wrapped in an {@link solace.OperationError},
   *    `subcode={@link solace.ErrorSubcode.CALLBACK_ERROR}`. The originating event and the error
   *    thrown by the listener are available on `event` and `error` fields respectively.
   *
   *  In all cases, throwing an exception in a listener prevents the event being received by
   *  later listeners.
   *
   *  This option does not affect any event selected for `options.direct`, which always uses
   *  unsafe dispatch.
   *
   * @memberof solace
   * @extends {EventEmitter}
   * @private
   */
                    constructor(options) {
                        super();
                        const {
                            direct,
                            emits,
                            unsafe,
                            formatEventName
                        } = options || {};
                        this.formatEventName = formatEventName || (name => name);
                        // Direct mode path:
                        //  emit --> (direct emit || bareEmit).
                        const bareEmit = this.emit.bind(this);
                        this._installDirectFilter(direct, bareEmit);
                        // Indirect mode path:
                        //  verifier -> error handlers -> emit --> bareEmit
                        this._installErrorHandlers(unsafe);
                        this._installEmitVerifier();
                        this._listenerVerificationFilter = buildFilter(emits);
                        this._emits = emits;
                    }
                    _installDirectFilter(direct, bareEmit) {
                        if (!direct) return;
                        // Direct mode class instance modifications
                        if (includes(BLACKLIST_DIRECT, direct)) {
                            throw new OperationError(`Cannot configure listener collection events [${BLACKLIST_DIRECT.join(", ")}] as direct`, ErrorSubcode.INTERNAL_ERROR);
                        }
                        // The default direct emitter is the base emitter. Skip any overrides we installed.
                        this._defaultEmitDirect = (...args) => bareEmit(direct, ...args);
                        // Initally not direct for 0 listeners
                        this.emitDirect = this._defaultEmitDirect;
                        this._directEventName = direct;
                        this.on = (eventName, listener) => {
                            this._verifyListenerEvent(eventName);
                            const ret = super.on(eventName, listener);
                            this._setEmitDirect(eventName, true, listener);
                            return ret;
                        };
                        this.addListener = (eventName, listener) => this.on(eventName, listener);
                        this.once = (eventName, listener) => {
                            this._verifyListenerEvent(eventName);
                            const ret = super.once(eventName, listener);
                            this._setEmitDirect(eventName, false);
                            return ret;
                        };
                        this.prependListener = (eventName, listener) => {
                            this._verifyListenerEvent(eventName);
                            const ret = super.prependListener(eventName, listener);
                            this._setEmitDirect(eventName, true, listener);
                            return ret;
                        };
                        this.prependOnceListener = (eventName, listener) => {
                            this._verifyListenerEvent(eventName);
                            const ret = super.prependOnceListener(eventName, listener);
                            this._setEmitDirect(eventName, false);
                            return ret;
                        };
                        this.removeAllListeners = eventName => {
                            const ret = super.removeAllListeners(eventName);
                            if (eventName === this._directEventName || eventName === undefined) {
                                this.emitDirect = this._defaultEmitDirect;
                            }
                            return ret;
                        };
                        this.removeListener = (eventName, listener) => {
                            const ret = super.removeListener(eventName, listener);
                            if (eventName === this._directEventName && this.listenerCount(eventName) === 0) {
                                this.emitDirect = this._defaultEmitDirect;
                            }
                            return ret;
                        };
                        this.directListenerCount = () => this.listenerCount(this._directEventName);
                        this.setOnFirstDirectListener = firstDirect => {
                            this._onFirstDirectListener = firstDirect;
                        };
                    }
                    _setEmitDirect(eventName, onListener, listener) {
                        if (eventName !== this._directEventName) {
                            return;
                        }
                        if (onListener && this.directListenerCount() === 1) {
                            this.emitDirect = listener;
                        } else {
                            this.emitDirect = this._defaultEmitDirect;
                        }
                        if (this.directListenerCount() === 1 && this._onFirstDirectListener !== undefined) {
                            this._onFirstDirectListener();
                        }
                    }
                    _verifyListenerEvent(event) {
                        if (!this._listenerVerificationFilter) return;
                        if (event === undefined || event === null) {
                            this.throwInternal(new OperationError(`Emitter rejects listener for no-name event: ${event}`, ErrorSubcode.PARAMETER_OUT_OF_RANGE));
                        }
                        if (!this._listenerVerificationFilter(event)) {
                            this.throwInternal(new OperationError(`Emitter rejects listeners for ${event}, emits ${this._emits}`, ErrorSubcode.PARAMETER_OUT_OF_RANGE));
                        }
                    }
                    _installEmitVerifier() {
                        if (true) {
                            // Debug mode: always add assert for empty event name
                            const emitBase = this.emit.bind(this);
                            this.emit = (name, ...args) => {
                                if (name === undefined || name === null) {
                                    this.throwInternal(new OperationError(`Emitter rejects no-name event: ${name}`));
                                }
                                emitBase(name, ...args);
                            };
                        }
                    }
                    _installErrorHandlers(unsafe) {
                        if (unsafe) {
                            // If unsafe, there's no try/catch/emit so throwInternal just throws
                            this.throwInternal = err => {
                                throw err;
                            };
                            return;
                        }
                        // Install try/catch/emit-as-event if not unsafe mode.
                        // Introduces throwInternal, which sets the _internalError flag restore
                        // orignal throw-to-emitter functionality in case of internal error
                        const emitBase = this.emit.bind(this);
                        this.throwInternal = function throwInternal(err) {
                            this._internalError = true;
                            throw err;
                        };
                        this.emit = (name, ...args) => {
                            try {
                                emitBase(name, ...args);
                            } catch (ex) {
                                if (this._internalError) {
                                    this._internalError = undefined;
                                    throw ex; // rethrow
                                }
                                const err = this.formatErrorEvent(ex, name, ...args);
                                try {
                                    LOG_WARN(`Listener for '${err.info.event.formattedName}' threw exception, dispatching to 'error'`);
                                    emitBase("error", err);
                                } catch (innerEx) {
                                    LOG_WARN("Listener for 'error' threw exception:", innerEx, "\nOriginal exception:", ex);
                                }
                            }
                        };
                    }
                    get isDirect() {
                        return this.emitDirect && this.emitDirect !== this._defaultEmitDirect;
                    }
                    formatErrorEvent(ex, name, ...args) {
                        const formattedName = this.formatEventName(name);
                        return Object.assign(new OperationError(`Unhandled error in event handler for '${formattedName}'`, ErrorSubcode.CALLBACK_ERROR, `On event: ${[ name, ...args ]} ${ex}`), {
                            stack: ex.stack,
                            info: {
                                event: {
                                    name: name,
                                    formattedName: formattedName,
                                    args: args
                                },
                                error: ex
                            }
                        });
                    }
                    disableEmitter() {
                        this._defaultEmitDirect = DISABLED_ACTIONS.ignore;
                        // If this is a direct-enabled emitter, this will also cause emitDirect to be set to
                        // _defaultEmitDirect, which is now DISALBED_ACTIONS.ignore.
                        this.removeAllListeners();
                        this.emit = DISABLED_ACTIONS.ignore;
                        // Freeze listeners by first disabling remove, then add.
                        this.addListener("removeListener", DISABLED_ACTIONS.fail);
                        this.addListener("newListener", DISABLED_ACTIONS.fail);
                    }
                }
                module.exports.EventEmitter = EventEmitter;
                /***/
            },
            /***/ "./modules/solclient-events/lib/timer.js": 
            /*!***********************************************!*\
  !*** ./modules/solclient-events/lib/timer.js ***!
  \***********************************************/
            /***/ module => {
                /**
 * @private
 */
                class Timer {
                    /**
   * Creates an instance of Timer.
   * @param {function} cancel The action to perform on cancellation
   */
                    constructor(cancel) {
                        this.cancel = () => {
                            this.cancel = () => {}; // change to no-op
                            cancel();
                        };
                    }
                    /**
   * @static
   * @param {Number} interval The interval for the timer, in milliseconds.
   * @param {function} onInterval The function to invoke on expiration.
   * @param {any} [args] Any arguments to pass to the onExpire callback.
   * @returns {Timer} A new timer object.
   */
                    static newInterval(interval, onInterval, ...args) {
                        const timerRef = setInterval(onInterval, interval, ...args);
                        return new Timer(() => clearInterval(timerRef));
                    }
                    /**
   * @static
   * @param {Number} timeout The timeout for the timer, in milliseconds.
   * @param {function} onExpire The function to invoke on expiration.
   * @param {any} [args] Any arguments to pass to the onExpire callback.
   * @returns {Timer} A new timer object.
   */
                    static newTimeout(timeout, onExpire, ...args) {
                        const timerRef = setTimeout(onExpire, timeout, ...args);
                        return new Timer(() => clearTimeout(timerRef));
                    }
                }
                module.exports.Timer = Timer;
                /***/
            },
            /***/ "./modules/solclient-factory/api.js": 
            /*!******************************************!*\
  !*** ./modules/solclient-factory/api.js ***!
  \******************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    FactoryProfile,
                    SolclientFactoryProfiles
                } = __webpack_require__(/*! ./lib/solclient-factory-profiles */ "./modules/solclient-factory/lib/solclient-factory-profiles.js");
                const {
                    ProfileBinding
                } = __webpack_require__(/*! ./lib/profile-binding */ "./modules/solclient-factory/lib/profile-binding.js");
                const {
                    SolclientFactory
                } = __webpack_require__(/*! ./lib/solclient-factory */ "./modules/solclient-factory/lib/solclient-factory.js");
                const {
                    SolclientFactoryProperties
                } = __webpack_require__(/*! ./lib/solclient-factory-properties */ "./modules/solclient-factory/lib/solclient-factory-properties.js");
                module.exports.FactoryProfile = FactoryProfile;
                module.exports.ProfileBinding = ProfileBinding;
                module.exports.SolclientFactoryProfiles = SolclientFactoryProfiles;
                module.exports.SolclientFactoryProperties = SolclientFactoryProperties;
                module.exports.SolclientFactory = SolclientFactory;
                /***/
            },
            /***/ "./modules/solclient-factory/lib/profile-binding.js": 
            /*!**********************************************************!*\
  !*** ./modules/solclient-factory/lib/profile-binding.js ***!
  \**********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                let binding = null;
                const ProfileBinding = {
                    get value() {
                        if (binding === null) {
                            throw new OperationError("Profile binding not initialized. Call solace.SolclientFactory.init");
                        }
                        return binding;
                    },
                    set value(value) {
                        // private, so we'll allow it for testing
                        binding = value;
                    }
                };
                module.exports.ProfileBinding = ProfileBinding;
                /***/
            },
            /***/ "./modules/solclient-factory/lib/solclient-factory-profiles.js": 
            /*!*********************************************************************!*\
  !*** ./modules/solclient-factory/lib/solclient-factory-profiles.js ***!
  \*********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /* provided dependency */ var util_inspect = __webpack_require__(/*! browser-util-inspect */ "./node_modules/browser-util-inspect/index.js");
                // Preferred configuration for the profile system:
                // End user:
                //  opaque profiles, property-style access
                // API implementation:
                //  inherited properties, property-style access
                // A root, forward compatible profile
                // A legacy, backwards compatible profile
                // Feature/milestone profiles that inherit from one of these two configurations
                // The lowest-friction way of doing this is using prototype inheritance.
                // Also considered:
                //  getProperty() with child->parent pointers -- mixes string
                //    and property access
                //  ES6 proxies -- not universal and not shimmable
                // Necessary to abuse prototype inheritance for static property inheritance:
                /* eslint-disable class-methods-use-this */
                /**
 * @classdesc
 * <b>This class is not exposed for construction by API users. Users should obtain an instance from
 * {@link solace.SolclientFactoryProfiles}.</b>
 *
 * A factory profile determines the default functionality of the API. Profiles are predefined
 * combinations of capabilities that represent a mutually-consistent, valid configuration state
 * for API features.
 *
 * The factory may be initialized exactly once, with a single factory profile.
 *
 * Changing which factory profile is used by {@link solace.SolclientFactory.init} may result in
 * different default property values, validation, function signatures and implementations.
 *
 * Changing the factory profile will not change relationships between API methods. That is,
 * assuming all properties and arguments are explicitly set, an application may call the
 * API with the same values as before to cause the same result, unless explicitly noted.
 *
 * If no profile is specified, the default will provide equivalent functionality to
 * SolclientJS version 7.x. New applications are encouraged to use the
 * {@link solace.SolclientFactoryProfiles.version10_5} profile for the best compatibility with
 * other APIs (excluding 7.x JavaScript APIs).
 *
 * @memberof solace
 * @private
 */
                class FactoryProfile {
                    /**
   * Returns whether Guaranteed Messaging is enabled for the API. When `true`,
   * AD publishing capability is enabled by default.
   *
   * @type {Boolean}
   * @readonly
   */
                    get guaranteedMessagingEnabled() {
                        return undefined;
                    }
                    /**
   * Returns whether the API will allow Comet (long-held HTTP request) transports
   * to be used. If this is `true`, transport protocols may fall back to HTTP
   * if a connection cannot be established with a preferred protocol.
   *
   *  * NOTE: Guaranteed Messaging cannot be enabled if Comet is enabled.
   *
   * @type {Boolean}
   * @readonly
   * @target browser
   */
                    get cometEnabled() {
                        return undefined;
                    }
                    /**
   * Returns whether the API performs UTF-8 encoding on user strings where the SMF
   * spec requires it.
   *  * When this is `true`, the API will correctly interoperate with other Solace APIs that send
   *    UTF-8 encoded topics.
   *  * When this is `false`, the API will interoperate correctly with 7.x and earlier JavaScript
   *    APIs, that used an arbitrary encoding for such strings.
   *
   * @type {Boolean}
   * @readonly
   */
                    get topicUtf8Encode() {
                        return undefined;
                    }
                    /**
   * Returns whether the API returns BYTEARRAY SDT values as Strings.
   *
   * In older versions (before 10.5) of the API,
   * an SDTField with type BYTEARRAY returned a String from getValue().
   * Newer versions (since 10.5),
   * getValue() for the same type returns an actual ByteArray, unless this property is `true`.
   *
   *  * When this is `true`, SDTField.getValue() returns a String for a BYTEARRAY.
   *  * When this is `false`, SDTField.getValue() returns a ByteArray for a BYTEARRAY.
   *
   * @type {Boolean}
   * @readonly
   */
                    get byteArrayAsString() {
                        return undefined;
                    }
                    ["inspect"]() {
                        return {
                            guaranteedMessagingEnabled: this.guaranteedMessagingEnabled,
                            cometEnabled: this.cometEnabled,
                            topicUtf8Encode: this.topicUtf8Encode,
                            byteArrayAsString: this.byteArrayAsString
                        };
                    }
                    toString() {
                        return util_inspect(this);
                    }
                }
                /**
 * The Version 7 profile for SolclientJS. This profile sets factory and session default values
 * that provide SolclientJS 7.x behaviour, and interoperability with SolclientJS 7.x clients.
 *
 * @namespace
 * @type {solace.FactoryProfile}
 * @name version7
 * @memberof solace.SolclientFactoryProfiles
 * @private
 * @FactoryProfile
 */
                class Version7Profile extends FactoryProfile {
                    /**
   * Returns `false`: Guaranteed Messaging is disabled by default to maintain availability of Comet
   * HTTP transports by default.
   *
   * @name solace.SolclientFactoryProfiles.version7.guaranteedMessagingEnabled
   * @type {Boolean}
   * @readonly
   * @target browser
   */
                    /**
   * Returns `true`: Guaranteed Messaging is enabled for the API. Note that version 7.x SolclientJS
   * clients cannot send or receive any messages using Guaranteed Messaging features.
   *
   * @name solace.SolclientFactoryProfiles.version7.guaranteedMessagingEnabled
   * @type {Boolean}
   * @readonly
   * @target node
   */
                    get guaranteedMessagingEnabled() {
                        return !!false;
                    }
                    /**
   * Returns true: Comet HTTP transports are enabled for the API. The API user may, by default,
   * select Comet HTTP transport protocol, and the API may fall back to these protocols during a
   * connection attempt.
   *
   * @name solace.SolclientFactoryProfiles.version7.cometEnabled
   * @type {Boolean}
   * @readonly
   * @target browser
   */
                    /**
   * Returns false: Comet HTTP transports are not present in Node.js.
   *
   * @name solace.SolclientFactoryProfiles.version7.cometEnabled
   * @type {Boolean}
   * @readonly
   * @target node
   */
                    get cometEnabled() {
                        return !!true;
                    }
                    /**
   * Returns false: topic UTF-8 encoding is disabled for the API. The network encoding of topics is
   * compatible with other SolclientJS 7.x clients, and may not be interoperable with other
   * Solace Messaging APIs.
   *
   * @name solace.SolclientFactoryProfiles.version7.topicUtf8Encode
   * @type {Boolean}
   * @readonly
   */
                    get topicUtf8Encode() {
                        return false;
                    }
                    /**
   * Returns true: getValue() of SDTFields of type BYTEARRAY return a string,
   * and so does getBinaryAttachment().
   *
   * @name solace.SolclientFactoryProfiles.version7.byteArrayAsString
   * @type {Boolean}
   * @readonly
   */
                    get byteArrayAsString() {
                        return true;
                    }
                }
                const legacyInstance = new Version7Profile();
                /**
 * The Version 10 profile for SolclientJS. This profile sets factory and session default values
 * that provide the full capability of the API as of version 10.0, including interoperability with
 * other Solace Messaging products.
 *
 * @namespace
 * @name version10
 * @memberof solace.SolclientFactoryProfiles
 * @private
 * @FactoryProfile
 */
                class Version10Profile extends FactoryProfile {
                    /**
   * Returns `true`: Guaranteed Messaging is enabled for the API,
   * with the result that {@link solace.MessagePublisherProperties#enabled} is `true` by default
   * on platforms that support Guaranteed Messaging publishing.
   *
   * Where the {@link solace.TransportType.WS_BINARY} transport is unavailable,
   * {@link solace.MessagePublisherProperties#enabled} is `false` by
   * default.
   *
   * @name solace.SolclientFactoryProfiles.version10.guaranteedMessagingEnabled
   * @type {Boolean}
   * @readonly
   * @target browser
   */
                    /**
   * Returns `true`: Guaranteed Messaging is enabled by default for the API.
   *
   * @name solace.SolclientFactoryProfiles.version10.guaranteedMessagingEnabled
   * @type {Boolean}
   * @readonly
   * @target node
   */
                    get guaranteedMessagingEnabled() {
                        return true;
                    }
                    /**
   * Returns `false`: Comet HTTP transports are disabled for the API. The API will not select or
   * fall back to HTTP Comet transport protocols, which are mutually exclusive of Guaranteed
   * Messaging features.
   *
   * @name solace.SolclientFactoryProfiles.version10.cometEnabled
   * @type {Boolean}
   * @readonly
   * @target browser
   */
                    /**
   * Returns false: Comet HTTP transports are not present in Node.js.
   *
   * @name solace.SolclientFactoryProfiles.version10.cometEnabled
   * @type {Boolean}
   * @readonly
   * @target node
   */
                    get cometEnabled() {
                        return false;
                    }
                    /**
   * Returns `true`: the API will encode topics for interoperability with other Solace Messaging
   * products. SolclientJS 7.x clients may fail to correctly decode when topic names that include
   * multi-byte UTF-8 code points.
   *
   * @name solace.SolclientFactoryProfiles.version10.topicUtf8Encode
   * @type {Boolean}
   * @readonly
   */
                    get topicUtf8Encode() {
                        return true;
                    }
                    /**
   * Returns true: getValue() of SDTFields of type BYTEARRAY return a string,
   * and so does getBinaryAttachment().
   *
   * @name solace.SolclientFactoryProfiles.version10.byteArrayAsString
   * @type {Boolean}
   * @readonly
   */
                    get byteArrayAsString() {
                        return true;
                    }
                }
                const v10Instance = new Version10Profile();
                /**
 * The Version 10.5 profile for SolclientJS. This profile sets factory and session default values
 * that provide the full capability of the API as of version 10.5, including interoperability with
 * other Solace Messaging products.
 *
 * @namespace
 * @name version10_5
 * @memberof solace.SolclientFactoryProfiles
 * @private
 * @FactoryProfile
 */
                class Version105Profile extends FactoryProfile {
                    /**
   * Returns `true`: Guaranteed Messaging is enabled for the API,
   * with the result that {@link solace.MessagePublisherProperties#enabled} is `true` by default
   * on platforms that support Guaranteed Messaging publishing.
   *
   * Where the {@link solace.TransportType.WS_BINARY} transport is unavailable,
   * {@link solace.MessagePublisherProperties#enabled} is `false` by
   * default.
   *
   * @name solace.SolclientFactoryProfiles.version10_5.guaranteedMessagingEnabled
   * @type {Boolean}
   * @readonly
   * @target browser
   */
                    /**
   * Returns `true`: Guaranteed Messaging is enabled by default for the API.
   *
   * @name solace.SolclientFactoryProfiles.version10_5.guaranteedMessagingEnabled
   * @type {Boolean}
   * @readonly
   * @target node
   */
                    get guaranteedMessagingEnabled() {
                        return true;
                    }
                    /**
   * Returns `false`: Comet HTTP transports are disabled for the API. The API will not select or
   * fall back to HTTP Comet transport protocols, which are mutually exclusive of Guaranteed
   * Messaging features.
   *
   * @name solace.SolclientFactoryProfiles.version10_5.cometEnabled
   * @type {Boolean}
   * @readonly
   * @target browser
   */
                    /**
   * Returns false: Comet HTTP transports are not present in Node.js.
   *
   * @name solace.SolclientFactoryProfiles.version10_5.cometEnabled
   * @type {Boolean}
   * @readonly
   * @target node
   */
                    get cometEnabled() {
                        return false;
                    }
                    /**
   * Returns `true`: the API will encode topics for interoperability with other Solace Messaging
   * products. SolclientJS 7.x clients may fail to correctly decode when topic names that include
   * multi-byte UTF-8 code points.
   *
   * @name solace.SolclientFactoryProfiles.version10_5.topicUtf8Encode
   * @type {Boolean}
   * @readonly
   */
                    get topicUtf8Encode() {
                        return true;
                    }
                    /**
   * Returns false: getValue() of SDTFields of type BYTEARRAY return a Uint8Array,
   * and so does getBinaryAttachment().
   *
   * @name solace.SolclientFactoryProfiles.version10_5.byteArrayAsString
   * @type {Boolean}
   * @readonly
   */
                    get byteArrayAsString() {
                        return false;
                    }
                }
                const forwardInstance = new Version105Profile();
                /**
 * The collection of predefined factory profiles available for application use.
 *
 * See each member for a description of its configuration.
 *
 * @namespace
 * @memberof solace
 * @FactoryProfile
 */
                const SolclientFactoryProfiles = {
                    _legacy: legacyInstance,
                    _v10: v10Instance,
                    _forward: forwardInstance,
                    _default: legacyInstance,
                    /**
   * The version 7 profile for browsers. {@link solace.SolclientFactoryProfiles.version7}
   *
   * The version 7 profile configures API defaults for interoperability with the
   * SolclientJS 7.x API, and applications that use it.
   *
   * {@link solace.SolclientFactoryProfiles.version7}
   *
   * @name version7
   * @memberof solace.SolclientFactoryProfiles
   * @type {solace.FactoryProfile}
   * @target browser
   * @FactoryProfile
   */
                    /**
   * The version 7 profile for Node.JS. {@link solace.SolclientFactoryProfiles.version7}
   *
   * A version 7 profile configures API defaults for interoperability with the
   * SolclientJS 7.x API, and applications that use it.
   *
   * {@link solace.SolclientFactoryProfiles.version7}
   *
   * @name version7
   * @memberof solace.SolclientFactoryProfiles
   * @type {solace.FactoryProfile}
   * @target node
   * @FactoryProfile
   */
                    version7: legacyInstance,
                    /**
   * The version 10 profile for Node.JS.
   *
   * The version 10 profile configures API defaults for use with Guaranteed Messaging, and other
   * Solace Messaging APIs.
   * It provides a backwards-compatibility mode for existing applications
   * expecting SDTField.getValue() to return a string for BYTEARRAYs.
   *
   * {@link solace.SolclientFactoryProfiles.version10}
   *
   * @name version10
   * @memberof solace.SolclientFactoryProfiles
   * @type {solace.FactoryProfile}
   * @target node
   * @FactoryProfile
   */
                    /**
   * The version 10 profile for browsers.
   *
   * The version 10 profile configures API defaults for use with Guaranteed Messaging, and other
   * Solace Messaging APIs.
   * It provides a backwards-compatibility mode for existing applications
   * expecting SDTField.getValue() to return a string for BYTEARRAYs.
   *
   * {@link solace.SolclientFactoryProfiles.version10}
   *
   * @name version10
   * @memberof solace.SolclientFactoryProfiles
   * @type {solace.FactoryProfile}
   * @target browser
   * @FactoryProfile
   */
                    version10: v10Instance,
                    /**
   * The version 10.5 profile for browsers.
   *
   * The version 10.5 profile configures API defaults for use with Guaranteed Messaging, and other
   * Solace Messaging APIs.
   *
   * {@link solace.SolclientFactoryProfiles.version10_5}
   *
   * @name version10_5
   * @memberof solace.SolclientFactoryProfiles
   * @type {solace.FactoryProfile}
   * @target browser
   * @FactoryProfile
   */
                    /**
   * The version 10.5 profile for Node.JS.
   *
   * The version 10.5 profile configures API defaults for use with Guaranteed Messaging, and other
   * Solace Messaging APIs.
   *
   * {@link solace.SolclientFactoryProfiles.version10_5}
   *
   * @name version10_5
   * @memberof solace.SolclientFactoryProfiles
   * @type {solace.FactoryProfile}
   * @target node
   * @FactoryProfile
   */
                    version10_5: forwardInstance,
                    ["inspect"]() {
                        return {
                            version7: this.version7,
                            version10: this.version10,
                            version10_5: this.version10_5
                        };
                    },
                    toString() {
                        return util_inspect(this);
                    }
                };
                module.exports.FactoryProfile = FactoryProfile;
                module.exports.SolclientFactoryProfiles = SolclientFactoryProfiles;
                /***/
            },
            /***/ "./modules/solclient-factory/lib/solclient-factory-properties.js": 
            /*!***********************************************************************!*\
  !*** ./modules/solclient-factory/lib/solclient-factory-properties.js ***!
  \***********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /* provided dependency */ var util_inspect = __webpack_require__(/*! browser-util-inspect */ "./node_modules/browser-util-inspect/index.js");
                const {
                    APIProperties
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const {
                    Check
                } = __webpack_require__(/*! solclient-validate */ "./modules/solclient-validate/api.js");
                function getDefaultLogLevel() {
                    // break dependency loop
                    // eslint-disable-next-line global-require
                    const {
                        LogLevel
                    } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                    return LogLevel.INFO;
                }
                /**
 * @classdesc
 * Properties used during initialization of {@link solace.SolclientFactory}.
 *
 * @memberof solace
 */
                class SolclientFactoryProperties extends APIProperties {
                    /**
   * Creates an instance of SolclientFactoryProperties.
   *
   * @param {Object} [options] The property names and values to apply to this instance
   * @param {solace.LogLevel} [options.logLevel]  logLevel (default={@link solace.LogLevel.INFO}
   * @param {solace.LogImpl} [options.logger]     log implementation (default=NULL)
   * @param {solace.SolclientFactoryProfiles} [options.profile] Javascript profile
   *  (default={@link solace.SolclientFactoryProfiles.version7})
   * @memberOf SolclientFactoryProperties
   */
                    constructor(options) {
                        super({
                            logLevel: getDefaultLogLevel(),
                            logger: null
                        }, options);
                    }
                    /**
   * The factory profile to use. The following factory profiles are available:
   * * {@link solace.SolclientFactoryProfiles.version7}, a backwards-compatible profile
   *      for existing solClientJS 7.x applications
   * * {@link solace.SolclientFactoryProfiles.version10}, the recommended profile
   *      for new applications
   *
   * @type {solace.SolclientFactoryProfiles}
   */
                    get profile() {
                        return this._profile;
                    }
                    set profile(profile) {
                        this._profile = profile;
                    }
                    /**
   * The logging level to use for filtering log events. Messages with a level of lesser importance
   * than this will be filtered out and not logged.
   * @type {solace.LogLevel}
   */
                    get logLevel() {
                        return Check.number(this._logLevel) ? this._logLevel : getDefaultLogLevel();
                    }
                    set logLevel(val) {
                        this._logLevel = val;
                    }
                    /**
   * The logging implementation to use. In the debug API, the log implementation will be called
   * for every log statement not filtered out by the log level. If no implementation is supplied,
   * the default implementation will be used, which logs to the global console object.
   * @type {solace.LogImpl}
   */
                    get logger() {
                        return this._logger || null;
                    }
                    set logger(val) {
                        this._logger = val;
                    }
                    ["inspect"]() {
                        // break dependency loop
                        // eslint-disable-next-line global-require
                        const {
                            LogLevel
                        } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                        return {
                            logLevel: LogLevel.describe(this._logLevel),
                            profile: this._profile
                        };
                    }
                    toString() {
                        return util_inspect(this);
                    }
                }
                module.exports.SolclientFactoryProperties = SolclientFactoryProperties;
                /***/
            },
            /***/ "./modules/solclient-factory/lib/solclient-factory.js": 
            /*!************************************************************!*\
  !*** ./modules/solclient-factory/lib/solclient-factory.js ***!
  \************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    FactoryProfile,
                    SolclientFactoryProfiles
                } = __webpack_require__(/*! ./solclient-factory-profiles */ "./modules/solclient-factory/lib/solclient-factory-profiles.js");
                const {
                    Parameter
                } = __webpack_require__(/*! solclient-validate */ "./modules/solclient-validate/api.js");
                const {
                    ProfileBinding
                } = __webpack_require__(/*! ./profile-binding */ "./modules/solclient-factory/lib/profile-binding.js");
                const {
                    SolclientFactoryProperties
                } = __webpack_require__(/*! ./solclient-factory-properties */ "./modules/solclient-factory/lib/solclient-factory-properties.js");
                const factoryState = {
                    initializeCount: 0,
                    initializers: []
                };
                /**
 * @global
 * @name solClientJS
 * @description
 * <b>solClientJS</b> is a full functioned Solace Messaging API written entirely in JavaScript.
 * Applications using the <i>solClientJS</i> API can access all the features of a
 * Solace Message Router.
 *
 * The API is intended for use by applications written in JavaScript, targetting
 * either <b>NODE</b> or a traditional web browser.
 *
 * All classes, objects, methods of the API are encapsulated in the {@link solace} namespace.
 * The starting point for all applications is {@link solace.SolclientFactory}. This factory object
 * generates the {@link solace.Session} for connecting to the Solace Message Router.
 * {@link solace.SolclientFactory} also generates the {@link solace.Message} object
 * which enncapsulates the messages and {@link solace.Destination} the application will use
 * to send and receive data.
 * @summary The Solace Message Router Messaging API for Javascript.
 * @importTypeDefinitions import {EventEmitter} from 'events';
 * @importTypeDefinitions import {Long} from 'long';
 */
                /**
 * A singleton used as the main factory for the messaging APIs. The very first operation by
 * any application must be to initialize the API:
 * * {@link solace.SolclientFactory.init}
 *
 * <i>SolclientFactory</i> provides methods to construct:
 * * {@link solace.Session}
 * * {@link solace.Message}
 * * {@link solace.Destination}
 *
 * Additionally <i>SolclientFactory</i> manages the
 * logging level in the API.
 * @namespace
 * @public
 * @memberof solace
 */
                const SolclientFactory = {
                    /**
   * Adds a function to be called on factory initialization
   * @param {function(factoryProps, factoryState)} func initializer function to be called
   * @internal
   */
                    addInitializer(func) {
                        factoryState.initializers.push(func);
                    },
                    /**
   * @param {function} func function to wrap
   * @returns {function} new factory method
   * @internal
   */
                    createFactory(func) {
                        return function factoryMethod(...args) {
                            if (factoryState.initializeCount === 0) {
                                throw new OperationError("SolclientFactory not initialized", ErrorSubcode.INVALID_OPERATION);
                            }
                            return func(...args);
                        };
                    },
                    /**
   * Initialize global properties. This function must be called before any other API call is made.
   *
   * Note: After the first call to this method, subsequent calls have no effect.
   *
   * @param {solace.SolclientFactoryProperties} [factoryProps] The initialization properties for
   *  the factory, if required.
   * @param {solace.LogImpl} [factoryProps.logger] A logging implementation
   * @param {solace.LogLevel}[factoryProps.logLevel] The logging level to use
   *  for filtering log events.
   * @param {solace.SolclientFactoryProfiles}
   *  [factoryProps.profile=solace.SolclientFactoryProfiles.version7]
   *     The factory profile. This class cannot be created by an API user; choose one of the static
   *     instances from {@link solace.SolclientFactoryProfiles}.
   * @throws {solace.OperationError} Invalid logger implementation
   * @returns {solace.SolclientFactory} For method chaining
   */
                    init(factoryProps) {
                        if (factoryState.initializeCount > 0) {
                            return this;
                        }
                        const props = new SolclientFactoryProperties(factoryProps);
                        const profile = factoryProps && factoryProps.profile || SolclientFactoryProfiles.version7;
                        Parameter.isInstanceOf("factoryProps.profile", profile, FactoryProfile);
                        ProfileBinding.value = profile;
                        factoryState.initializers.forEach(initializer => {
                            initializer.call(this, props, factoryState);
                        });
                        ++factoryState.initializeCount;
                        if (factoryProps !== undefined && factoryProps !== null) {
                            // Factory should not depend on other packages at file scope
                            // eslint-disable-next-line global-require
                            const {
                                LOG_DEBUG
                            } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                            LOG_DEBUG("Factory properties:\n", factoryProps);
                        }
                        return this;
                    },
                    /**
   * @private
   */
                    reset() {
                        factoryState.initializeCount = 0;
                    },
                    /**
   * @returns {Number} Count of factory initializations.
   *    Nonzero means cannot be initialized again.
   * @internal
   */
                    _getInitializeCount() {
                        return factoryState.initializeCount;
                    },
                    /**
   * @private
   * @name solace.SolclientFactory.profiles
   * @type {solace.SolclientFactoryProfiles}
   * @readonly
   * @description The collection of {@link solace.FactoryProfile}. See a description of
   * each in {@link solace.SolclientFactoryProfiles}.
   */
                    get profiles() {
                        return SolclientFactoryProfiles;
                    }
                };
                module.exports.SolclientFactory = SolclientFactory;
                /***/
            },
            /***/ "./modules/solclient-flow/api.js": 
            /*!***************************************!*\
  !*** ./modules/solclient-flow/api.js ***!
  \***************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Flow
                } = __webpack_require__(/*! ./lib/flow */ "./modules/solclient-flow/lib/flow.js");
                const {
                    FlowOperation
                } = __webpack_require__(/*! ./lib/flow-operation */ "./modules/solclient-flow/lib/flow-operation.js");
                const {
                    PrivateFlowEventName
                } = __webpack_require__(/*! ./lib/private-flow-event-names */ "./modules/solclient-flow/lib/private-flow-event-names.js");
                module.exports.Flow = Flow;
                module.exports.FlowOperation = FlowOperation;
                module.exports.PrivateFlowEventName = PrivateFlowEventName;
                /***/
            },
            /***/ "./modules/solclient-flow/lib/flow-operation.js": 
            /*!******************************************************!*\
  !*** ./modules/solclient-flow/lib/flow-operation.js ***!
  \******************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                const FlowOperation = {
                    CONNECT: "FlowOperation_CONNECT",
                    DISCONNECT: "FlowOperation_DISCONNECT",
                    START: "FlowOperation_START",
                    STOP: "FlowOperation_STOP",
                    DISPOSE: "FlowOperation_DESTROY",
                    GET_STATS: "FlowOperation_GET_STATS",
                    RESET_STATS: "FlowOperation_RESET_STATS",
                    GET_PROPERTIES: "FlowOperation_GET_PROPERTIES",
                    GET_DESTINATION: "FlowOperation_GET_DESTINATION"
                };
                module.exports.FlowOperation = Enum.new(FlowOperation);
                /***/
            },
            /***/ "./modules/solclient-flow/lib/flow.js": 
            /*!********************************************!*\
  !*** ./modules/solclient-flow/lib/flow.js ***!
  \********************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ErrorSubcode,
                    NotImplementedError,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    EventEmitter
                } = __webpack_require__(/*! solclient-events */ "./modules/solclient-events/api.js");
                const {
                    FlowOperation
                } = __webpack_require__(/*! ./flow-operation */ "./modules/solclient-flow/lib/flow-operation.js");
                const {
                    LogFormatter
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    PrivateFlowEventName
                } = __webpack_require__(/*! ./private-flow-event-names */ "./modules/solclient-flow/lib/private-flow-event-names.js");
                const {
                    Stats
                } = __webpack_require__(/*! solclient-stats */ "./modules/solclient-stats/api.js");
                // Unless flow is disposed, these operations are always allowed
                const ALWAYS_OPS = [ FlowOperation.DISPOSE, FlowOperation.GET_STATS, FlowOperation.GET_PROPERTIES, FlowOperation.RESET_STATS ];
                /**
 * @classdesc Flow
 * * <b>This class is not exposed for construction by API users.</b>
 * A Flow is an abstract base class. A Flow represents a guaranteed message connection to the
 * Solace Message Router. There may be many Guaranteed Message
 * Consumers on a {@link solace.Session}, each
 * instantiated as a {@link solace.MessageConsumer}.
 * @memberof solace
 * @extends {solace.EventEmitter}
 * @private
 */
                class Flow extends EventEmitter {
                    /**
   * Creates a Flow instance.
   * @constructor Flow
   * @param {APIProperties} flowProperties The properties object for this flow.
   * @param {Object} sessionInterfaceFactory Function that creates session interface methods
   * @param {Object} [emitterOptions] The options to pass to the EventEmitter constructor.
   * @private
   */
                    constructor(flowProperties, sessionInterfaceFactory, emitterOptions) {
                        const emitterOptionsFull = Object.assign({}, emitterOptions);
                        emitterOptionsFull.emits = (emitterOptionsFull.emits || []).concat(PrivateFlowEventName.values);
                        super(emitterOptionsFull);
                        const sessionInterface = sessionInterfaceFactory(this);
                        const self = this;
                        this.logger = new LogFormatter((...args) => [ `[session=${sessionInterface.sessionIdHex}]`, `[flow=${self.flowIdDec}]`, ...args ]);
                        this.log = this.logger.wrap(this.log, this);
                        // dispose() was called on this flow.
                        // It is not always executed immediately, leaving time for the auto-ack.
                        this._disposing = false;
                        // The flow truly was destroyed, no more delays.
                        this._disposed = false;
                        this._userDisconnected = true;
                        this._properties = flowProperties;
                        this._sessionInterface = sessionInterface;
                        this._stats = new Stats(sessionInterface);
                        this._privateEventEmitter = new EventEmitter(emitterOptionsFull);
                    }
                    // Private event emitter functions, hidden from the public interface.
                    _emit(type, ...args) {
                        this._privateEventEmitter.emit(type, ...args);
                        this.emit(type, ...args);
                    }
                    _on(type, listener) {
                        this._privateEventEmitter.on(type, listener);
                    }
                    _once(type, listener) {
                        this._privateEventEmitter.once(type, listener);
                    }
                    _removeListener(type, listener) {
                        this._privateEventEmitter.removeListener(type, listener);
                    }
                    /**
   * Clears all statistics for this Guaranteed Message Connection. All previous Guaranteed
   * Message Connection statistics are lost
   * when this is called.
   * @throws {solace.OperationError}
   *  * if the Message Consumer is disposed. subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   */
                    clearStats() {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Clearing stats");
                        this._operationCheck(FlowOperation.RESET_STATS);
                        this._stats.resetStats();
                    }
                    /**
   * Establish a Guaranteed Messaging connection.
   * The Messge Consumer may immediately begin emitting events. The application is expected to
   * add listeners for events on this Message Consumer before calling this method.
   */
                    connect() {
                        const {
                            LOG_DEBUG
                        } = this.logger;
                        LOG_DEBUG("Connecting");
                        this.userDisconnected = false;
                        this._operationCheck(FlowOperation.CONNECT);
                    }
                    /**
   * Disposes the Guaranteed Message connection, removing all listeners and releasing references.
   */
                    dispose() {
                        const {
                            LOG_TRACE,
                            LOG_DEBUG
                        } = this.logger;
                        // The session may dispose the publisher or consumer, so be tolerant of
                        // multiple attempts to do so.
                        if (this._disposed || this._disposing) {
                            LOG_TRACE("Ignoring #dispose on disposed Guaranteed Message connection");
                            return;
                        }
                        LOG_TRACE("Disposing");
                        this._operationCheck(FlowOperation.DISPOSE);
                        this._disposing = true;
                        const terminate = () => {
                            this._disposed = true;
                            this._properties = null;
                            this._userDisconnected = true;
                            this._emit(this.getDisposedEvent());
                            this.disableEmitter();
                            this._privateEventEmitter.disableEmitter();
                            LOG_DEBUG("Disposed");
                        };
                        if (this._fsm._midDispatch) {
                            // weird case, dispose was called by the user from a message callback:
                            // Guard this in a timeout
                            const terminateWithRunningFSM = () => {
                                this._fsm.terminateFsm();
                                terminate();
                            };
                            //setImmediate(() => terminateWithRunningFSM());
                            setTimeout(() => terminateWithRunningFSM(), 0);
                        } else {
                            // normal case:
                            terminate();
                        }
                    }
                    /**
   * Disconnects the Message Consumer in such a way that it can be reconnected.
   */
                    disconnect() {
                        this._operationCheck(FlowOperation.DISCONNECT);
                        const {
                            LOG_DEBUG
                        } = this.logger;
                        LOG_DEBUG("Disconnecting");
                        this.userDisconnected = true;
                    }
                    /**
   *
   * Begins a disconnect that is not user-initiated.
   *
   * Must be overridden.
   *
   * @private
   * @memberof Flow
   */
                    _disconnectSession() {
                        this._operationCheck(FlowOperation.DISCONNECT);
                    }
                    /**
   * Gets the event to be returned when the Consumer or Publisher is disposed.
   *
   * Must be overridden.
   *
   * @private
   * @memberof Flow
   */
                    getDisposedEvent() {
                        // eslint-disable-line class-methods-use-this
                        throw new NotImplementedError("Abstract method");
                    }
                    /**
   * Creates and returns copy of the properties for this object.
   * @returns {?} The properties object
   * @internal
   */
                    getProperties() {
                        this._operationCheck(FlowOperation.GET_PROPERTIES);
                        return this._properties.clone();
                    }
                    /**
   * Returns a statistic for this Guaranteed Message connection.
   *
   * @param {solace.StatType} statType The statistic to return.
   * @returns {Number} The value for the statistic.
   */
                    getStat(statType) {
                        this._operationCheck(FlowOperation.GET_STATS);
                        return this._stats.getStat(statType);
                    }
                    /**
   * @param {AdMessage} message The message to be handled by this Consumer or Publisher
   * @private
   */
                    handleUncorrelatedControlMessage(message) {
                        // eslint-disable-line class-methods-use-this
                        throw new NotImplementedError("Guaranteed Message Connection does not implement a control message handler", message);
                    }
                    /**
   * @param {StatType} statType The stat to increment
   * @param {Number} [value] The value to add to the statistic.
   * @private
   */
                    incStat(statType, value) {
                        this._stats.incStat(statType, value);
                    }
                    /**
   * @param {any} event The event to be handled by this objects's FSM
   * @private
   */
                    processFSMEvent(event) {
                        this._fsm.processEvent(event);
                    }
                    /**
   * @returns {String} An inspection of this object's properties
   * @private
   */
                    ["inspect"]() {
                        return {
                            flowId: this.flowIdDec
                        };
                    }
                    /**
   * @returns {String} A description of this Guaranteed Message Connection
   */
                    toString() {
                        return this["inspect"]();
                    }
                    /**
   * @returns {Boolean} Whether this Publisher or Consumer can be connected.
   * @readonly
   * @private
   */
                    get canAck() {
                        return !this.disposed;
                    }
                    /**
   * Returns `true` if this Guaranteed Message Consumer was disposed.
   * @readonly
   * @type {Boolean}
   */
                    get disposed() {
                        return this._disposed;
                    }
                    get flowIdDec() {
                        return this.flowId || "(N/A)";
                    }
                    /**
   * @returns {Number} The ID for this flow
   * @readonly
   * @private
   */
                    get flowId() {
                        // eslint-disable-line class-methods-use-this
                        return new NotImplementedError("Flow does not implement ID accessor");
                    }
                    /**
   * @returns {solace.Session} The owning session for this MessageConsumer.
   * @readonly
   */
                    get session() {
                        return this._session;
                    }
                    get userDisconnected() {
                        return this._userDisconnecte;
                    }
                    set userDisconnected(value) {
                        this._userDisconnected = value;
                    }
                    /**
   * @param {FlowOperation} operation The operation to check
   * @returns {Boolean} `true` if the operation is allowed.
   * @throws {@link solace.OperationError} if the operation is not allowed.
   * @private
   */
                    _operationCheck(operation) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE(`Checking operation ${FlowOperation.describe(operation)}`);
                        if (this._disposed) {
                            throw new OperationError("Operation is invalid for Message Consumer in disposed state", ErrorSubcode.INVALID_OPERATION);
                        }
                        // Any read-only operation is always valid unless the object was disposed
                        // (which purges properties)
                        if (ALWAYS_OPS.some(v => v === operation)) return true;
                        if (operation === FlowOperation.DISCONNECT && this._isDisconnected()) {
                            throw new OperationError("Operation is invalid for Message Consumer in disconnected state", ErrorSubcode.INVALID_OPERATION);
                        }
                        return undefined;
                    }
                    _isDisconnected() {
                        // eslint-disable-line class-methods-use-this
                        throw new NotImplementedError("Flow#_isDisconnected not implemented");
                    }
                }
                module.exports.Flow = Flow;
                /***/
            },
            /***/ "./modules/solclient-flow/lib/private-flow-event-names.js": 
            /*!****************************************************************!*\
  !*** ./modules/solclient-flow/lib/private-flow-event-names.js ***!
  \****************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                const PrivateFlowEventName = {
                    BIND_WAITING: "PrivateFlowEventName_bindWaiting"
                };
                module.exports.PrivateFlowEventName = Enum.new(PrivateFlowEventName);
                /***/
            },
            /***/ "./modules/solclient-fsm/api.js": 
            /*!**************************************!*\
  !*** ./modules/solclient-fsm/api.js ***!
  \**************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /**
 * @module solace/fsm
 */
                const {
                    FsmEvent
                } = __webpack_require__(/*! ./lib/event */ "./modules/solclient-fsm/lib/event.js");
                const {
                    State
                } = __webpack_require__(/*! ./lib/state */ "./modules/solclient-fsm/lib/state.js");
                const {
                    StateMachine
                } = __webpack_require__(/*! ./lib/state-machine */ "./modules/solclient-fsm/lib/state-machine.js");
                module.exports.FsmEvent = FsmEvent;
                module.exports.State = State;
                module.exports.StateMachine = StateMachine;
                /***/
            },
            /***/ "./modules/solclient-fsm/lib/entry-point.js": 
            /*!**************************************************!*\
  !*** ./modules/solclient-fsm/lib/entry-point.js ***!
  \**************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const StateLib = __webpack_require__(/*! ./state */ "./modules/solclient-fsm/lib/state.js");
                const {
                    FsmObject
                } = __webpack_require__(/*! ./object */ "./modules/solclient-fsm/lib/object.js");
                /**
 * @classdesc
 * This object type represents an entryPoint for a particular FSM state.
 *
 * Note this initial implementation isn't particularly efficient, but it is
 * very simple by making use of two state objects (one just inside of and
 * one just outside of) the state the entryPoint belongs to.  If necessary, we
 * could optimize this if we wish.
 * @extends FsmObject
 * @private
 */
                class EntryPoint extends FsmObject {
                    /**
  * @constructor
  * @param {Object} spec The object specifier used to implement the named
  *      parameter idiom.
  * @param {fsm.State} spec.state The state that the entryPoint belongs
  *      to.
  * @param {String} spec.entryPointName The name of the entryPoint.
  * @param {fsm.StateContext~reactionCallback} spec.func The reaction
  *      function for the entryPoint, which defines where to transition to
  *      after state has been entered.
  */
                    constructor(spec) {
                        super({
                            name: spec.entryPointName
                        });
                        let innerState;
                        this.impl = this.impl || {};
                        // The outer portion of the entryPoint accepts incoming transitions before
                        // entering the entryPoint's state.  Then the entryPoint's state is
                        // entered through the use of the outerEntryPoint's initial transition.
                        this.impl.outerState = new StateLib.State({
                            name: `${spec.state.getName()} outerEntryPoint: ${spec.entryPointName}`,
                            parentContext: spec.state.getParent()
                        }).initial(() => spec.state.transitionTo(innerState));
                        // The job of the inner portion of the entryPoint is to follow a
                        // transition as specified by the application's reaction function.
                        innerState = new StateLib.State({
                            name: `${spec.state.getName()} innerEntryPoint: ${spec.entryPointName}`,
                            parentContext: spec.state
                        }).initial(spec.func);
                    }
                    /**
   * @returns {fsm.State} The destination state for a transition to the
   *      EntryPoint.
   */
                    getDestState() {
                        return this.impl.outerState;
                    }
                }
                module.exports.EntryPoint = EntryPoint;
                /***/
            },
            /***/ "./modules/solclient-fsm/lib/event.js": 
            /*!********************************************!*\
  !*** ./modules/solclient-fsm/lib/event.js ***!
  \********************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    FsmObject
                } = __webpack_require__(/*! ./object */ "./modules/solclient-fsm/lib/object.js");
                class FsmEvent extends FsmObject {}
                module.exports.FsmEvent = FsmEvent;
                /***/
            },
            /***/ "./modules/solclient-fsm/lib/exit-point.js": 
            /*!*************************************************!*\
  !*** ./modules/solclient-fsm/lib/exit-point.js ***!
  \*************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const StateLib = __webpack_require__(/*! ./state */ "./modules/solclient-fsm/lib/state.js");
                const {
                    FsmObject
                } = __webpack_require__(/*! ./object */ "./modules/solclient-fsm/lib/object.js");
                /**
 * @classdesc
 * This object type represents an exitPoint for a particular FSM state.
 *
 * Note this initial implementation isn't particularly efficient, but it is
 * very simple by making use of two state objects (one just inside of and
 * one just outside of) the state the exitPoint belongs to.  If necessary, we
 * could optimize this if we wish.
 * @private
 */
                class ExitPoint extends FsmObject {
                    /**
  * @constructor
  * @param {Object} spec The object specifier used to implement the named
  *      parameter idiom.
  * @param {fsm.State} spec.state The state that the exitPoint belongs
  *      to.
  * @param {String} spec.exitPointName The name of the exitPoint.
  * @param {fsm.StateContext~reactionCallback} spec.func The reaction
  *      function for the exitPoint, which defines where to transition to
  *      after state has been exited.
  */
                    constructor(spec) {
                        super({
                            name: spec.exitPointName
                        });
                        let outerState;
                        // The inner portion of the exitPoint accepts incoming transitions before
                        // exiting the exitPoint's state.  Then the exitPoint's state is exited
                        // through the use of the innerExitPoint's initial transition.
                        this.impl.innerState = new StateLib.State({
                            name: `${spec.state.getName()} innerExitPoint: ${spec.exitPointName}`,
                            parentContext: spec.state
                        }).initial(() => spec.state.transitionTo(outerState));
                        // The job of the outer portion of the exitPoint is to follow a
                        // transition as specified by the application's reaction function.
                        outerState = new StateLib.State({
                            name: `${spec.state.getName()} outerExitPoint: ${spec.exitPointName}`,
                            parentContext: spec.state.getParent()
                        }).initial(spec.func);
                    }
                    getDestState() {
                        return this.impl.innerState;
                    }
                }
                module.exports.ExitPoint = ExitPoint;
                /***/
            },
            /***/ "./modules/solclient-fsm/lib/object.js": 
            /*!*********************************************!*\
  !*** ./modules/solclient-fsm/lib/object.js ***!
  \*********************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                /**
 * @classdesc
 * This is a base class for various FSM-related objects.
 * @private
 */
                class FsmObject {
                    /**
   * @constructor
   * @param {Object} spec The object specifier used to implement the named
   *      parameter idiom.
   * @param {String} spec.name The name of the object.
   */
                    constructor(spec) {
                        if (!spec) {
                            throw new OperationError("No spec provided");
                        }
                        if (!spec.name) {
                            throw new OperationError("No name provided for spec");
                        }
                        this.impl = {
                            name: spec.name
                        };
                    }
                    /**
   * @returns {String} A string representation of the object.
   */
                    toString() {
                        let extraStringInfo = this.getExtraStringInfo();
                        if (extraStringInfo.length > 0) {
                            extraStringInfo = `; ${extraStringInfo}`;
                        }
                        return `{${this.constructor.name}: ${this.getName()}${extraStringInfo}}`;
                    }
                    /**
   * This is overridden by classes wanting to add more data, typically in the
   * form of 'name: value; name: value'.
   * @returns {String} Extra string information to be included in the object's
   *      toString() output.
   */
                    getExtraStringInfo() {
                        // eslint-disable-line class-methods-use-this
                        return "";
                    }
                    /**
   * @returns {?String} The name passed into the object specifier.
   */
                    getName() {
                        return this.impl.name;
                    }
                }
                module.exports.FsmObject = FsmObject;
                /***/
            },
            /***/ "./modules/solclient-fsm/lib/state-context.js": 
            /*!****************************************************!*\
  !*** ./modules/solclient-fsm/lib/state-context.js ***!
  \****************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const StateLib = __webpack_require__(/*! ./state */ "./modules/solclient-fsm/lib/state.js");
                const {
                    FsmObject
                } = __webpack_require__(/*! ./object */ "./modules/solclient-fsm/lib/object.js");
                const {
                    Iterator
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                const {
                    LOG_TRACE
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    makeIterator
                } = Iterator;
                /**
 * React to an event.
 * @callback StateContext.reactionCallback
 * @param {FsmEvent} event The event to react to.
 * @returns {StateContext.ReactionResult} One of the many possible
 *      reaction results that can be created by one of the following methods:
 *          - {@link StateContext#transitionTo}
 *          - {@link FsmState#internalTransition}
 *          - {@link FsmState#externalTransitionTo}
 *          - {@link FsmState#terminate}
 *          - {@link FsmState#eventUnhandled}
 */
                /**
 * @classdesc
 * This abstract class can host one or more states.  Concrete examples would
 * be a state, which can host one or more inner states, or a state machine,
 * which would typically have multiple top-level states.  It also serves as a
 * context in which transitions can occur.
 * @memberof solace
 * @private
 */
                class StateContext extends FsmObject {
                    /**
   * @constructor
   * @param {Object} spec Object specifier used to implement the named parameter
   *  idiom.
   * @param {String} spec.name The name of the context.
   */
                    constructor(spec) {
                        super(spec);
                        this.impl = this.impl || {};
                        this.impl.logPadding = "";
                    }
                    /**
   * Gets the state-machine that hosts this state context.
   * @returns {StateMachine} The FSM that hosts this context.
   */
                    getStateMachine() {
                        return this.impl.ancestorList[0];
                    }
                    /**
   * Sets the initial reaction for the state context.
   * @param {StateContext.reactionCallback} func The reaction callback to be
   *      called after the state is entered as the deepest state of a
   *      transition, or for a state machine when it is started.
   * @returns {StateContext} The object this function was called on
   */
                    initial(func) {
                        if (this.impl.initialReaction) {
                            this.log(`Replacing ${this} initialReaction ${this.impl.initialReaction} with ${func}`);
                        }
                        this.impl.initialReaction = func.bind(this);
                        return this;
                    }
                    /**
   * This is used for 'local' transitions.  However, we extend the formal
   * definition of local transitions here.  The formal definition is that
   * the dest state is within the src state, and the src state is not
   * exited.  We extend this definition to include states where the src
   * state is within dest. In this case, a local transition means that dest
   * will not be exited and entered and the transition will occur in the
   * context of dest before executing dest's initial transition.  Note that
   * this definition of local transition matches that of
   * {@link https://en.wikipedia.org/wiki/UML_state_machine#Local_versus_external_transitions|Wikipedia}.
   * But it does not match figure 14.34 or section 14.5.12 of the
   * {@link http://www.omg.org/spec/UML/2.5/PDF/|Formal UML Specification v2.5}.
   * Nevertheless, it does seem helpful to be able to express a transition
   * that does leave the destination state vs. a transition that does not.
   *
   * If neither the source nor the dest states are within the other, the
   * behaviour is the same as an external transition -- src is always exited
   * and dest is always entered.
   *
   * This is included in the StateContext instead of within the State itself
   * since this can be used by the initial reaction for a state machine.
   *
   * @param {State} state The state to transition to.
   * @param {StateContext.actionCallback} [action] Optional The action to perform as
   *      part of the transition, if desired.
   * @returns {StateContext.ReactionResult} the result object used
   *      internally for further processing of the event.
   */
                    transitionTo(state, action) {
                        return new StateContext.ReactionResult({
                            caller: this,
                            destState: state,
                            action: action
                        });
                    }
                    /**
   * Used to terminate the FSM.
   * @param {StateContext.actionCallback} action An optional action to
   *      take within the FSM context after all states have been exited.
   * @returns {StateContext.ReactionResult} The reaction result for the termination.
   */
                    terminate(action) {
                        return new StateContext.ReactionResult({
                            caller: this,
                            destState: this.getStateMachine().getFinalState(),
                            action: action
                        });
                    }
                    /**
   * A callback to execute an action as part of a transition in the
   * appropriate context.
   *
   * To be used only by the FSM infrastructure or unit tests.
   *
   * @callback StateContext.actionCallback
   * @param {StateContext} context The context within which the action is
   *      executed.  When the active state changes, this is done after
   *      states are exited and before states are entered.  It is the
   *      deepest context that contains the last exited and first entered
   *      state as part of the transition.
   * @param {FsmEvent} event The event that triggered the transition.
   * @returns {Array.<StateContext>} The context's ancestor list.
   * @protected
   */
                    getAncestorList() {
                        return this.impl.ancestorList;
                    }
                    /**
   * Perform a debug log with appropriate padding for the context.  The padding
   * helps to visualize the level within the hierarchical state machine.
   * @protected
   */
                    log(...args) {
                        LOG_TRACE(this.impl.logPadding, ...args);
                    }
                    /**
   * Called when the initial transition for the context needs to be taken.
   * @param {FsmEvent} [event] The event causing this transition; undefined for the
   *      FSM's initial transition.
   * @returns {StateContext.ReactionResult} the result to be processed by
   *      the FSM infrastructure.
   * @protected
   */
                    onInitial(event) {
                        let result;
                        if (this.impl.initialReaction) {
                            this.log(`Initial: for ${this}`);
                            result = this.impl.initialReaction(event);
                            if (result.external) {
                                throw new Error(`Initial reaction for ${this} returned external transitions`);
                            }
                            return result;
                        }
                        if (!(this instanceof StateLib.State)) {
                            throw new Error(`Missing initial reaction for ${this}`);
                        }
                        // If there is no initial reaction, then we just enter this state.
                        // Technically this is a malformed FSM if there are inner states and
                        // this state has no initial reaction.  We won't police this since it
                        // isn't easily done with the data we are otherwise maintaining (we only
                        // know about parent states, not children), and such a problem would be
                        // easily caught by testing of the FSM.
                        return this.transitionTo(this);
                    }
                    /**
   * After a reaction function has been called, this function processes the
   * returned {@link StateContext.ReactionResult}.
   * @param {StateContext.ReactionResult} result The result of a reaction.
   * @param {FsmEvent|undefined} e The event that triggered the reaction;
   *      undefined if this was due to the initial reaction.
   * @returns {State} The active state of the FSM after the ReactionResult was
   *      processed.
   * @protected
   */
                    processReactionResult(result, e) {
                        let curContext = this;
                        if (!result.destState) {
                            return this;
                        }
                        const destStateIter = this.lowestCommonAncestor(result);
                        // exit states until we get to the LCA
                        while (curContext !== destStateIter.deref()) {
                            curContext.onExit();
                            curContext = curContext.getParent();
                        }
                        // perform the transition
                        if (result.action) {
                            result.action(curContext, e);
                        }
                        curContext.log(`Action: transition to ${result.destState} in context ${curContext}`);
                        // Start by incrementing the iterator so we don't enter the
                        // context, which we are already in.  Then enter remaining states
                        // in the list.
                        for (destStateIter.incr(); !destStateIter.end(); destStateIter.incr()) {
                            curContext = destStateIter.deref();
                            curContext.onEntry();
                        }
                        // execute the initial transition in the destState.
                        const destInitial = curContext.onInitial(e);
                        if (destInitial.destState !== curContext) {
                            return curContext.processReactionResult(destInitial, e);
                        }
                        return curContext;
                    }
                    /**
   * For a given reactionResult, this function returns an iterator to the
   * context in which to process a transition from 'self' to
   * 'reactionResult.destState'.  Advancing the iterator provides the states
   * that need to be entered after the transition is processed.
   * @param {ReactionResult} reactionResult An object created with one of the
   *                                        reaction result methods defined in
   *                                        either a state context or a state.
   * @returns {Iterator} The iterator where the first element is the
   * context in which to execute the transaction, and subsequent elements are
   * to be entered after executing the transaction.
   * @protected
   */
                    lowestCommonAncestor(reactionResult) {
                        const ancestorList = this.impl.ancestorList;
                        const destAncestorList = reactionResult.destState.getAncestorList();
                        let i;
                        // Make sure the states belong to the same state machine
                        if (ancestorList[0] !== destAncestorList[0]) {
                            throw new Error(`No common ancestor between (${this} in ${ancestorList[0]}) and (${reactionResult.destState} in ${destAncestorList[0]})`);
                        }
                        // Optimize case where the two states are the same.  This would be the
                        // case for internal and self-transitions.
                        if (this === reactionResult.destState) {
                            i = ancestorList.length;
                            if (reactionResult.external) {
                                // self-transition, must exit then re-enter state.  Therefore,
                                // the context is our parent.
                                --i;
                            }
                        } else {
                            for (i = 1; i < ancestorList.length; ++i) {
                                if (ancestorList[i] !== destAncestorList[i]) {
                                    break;
                                }
                            }
                            // Check if one state is within the other state.
                            if (i === ancestorList.length || i === destAncestorList.length) {
                                // One state within the other. Check whether this is a local
                                // or an external transition.
                                if (reactionResult.external) {
                                    --i; // Need to exit/re-enter the outermost state
                                }
                            }
                        }
                        // Here 'i' points to the first state to be entered after executing the
                        // transition.  We make the iterator with 'i-1' so that the first element
                        // is the context within which to execute the transition.
                        return makeIterator(destAncestorList, i - 1);
                    }
                    setLogPadding(padding) {
                        this.impl.logPadding = padding;
                    }
                }
                /**
 * @classdesc
 * A ReactionResult is suitable as a return value from a reaction function
 * or an initial reaction.
 * @private
 */
                StateContext.ReactionResult = class {
                    /**
   * The ReactionResult constructor should never be invoked by users of the
   * infrastructure. It should only be used by various public methods of
   * StateContext or State, which return a ReactionResult.
   *
   * @param {Object} spec Defined according to members described below for
   *      events that are handled by the reaction function; undefined if the
   *      event was not handled by the reaction function.  For initial
   *      reactions, spec must NOT be undefined.
   * @param {StateContext} spec.caller The state context from which
   *      {StateContext.ReactionResult} is being constructed.
   * @param {State} spec.destState The destination state to
   *      transition to.
   * @param {StateContext.actionCallback} [spec.action] The function to call in
   *      the transition context after the appropriate states have been
   *      exited, if desired; undefined if no action is to be performed as a
   *      result of the transition.
   * @param {Boolean} spec.external True if the transition is an external
   *      transition; false or undefined otherwise.
   * @constructor
   */
                    constructor(spec) {
                        if (!spec || !spec.caller || !(spec.caller instanceof StateContext)) {
                            throw new Error("spec.caller is required to be a StateContext");
                        }
                        if (!spec.caller.getStateMachine().isRunning()) {
                            throw new Error("ReactionResult objects can only be created while processing events");
                        }
                        if (spec.destState) {
                            if (!(spec.destState instanceof StateLib.State)) {
                                throw new Error("destState must be a State object");
                            }
                            if (spec.action && typeof spec.action !== "function") {
                                throw new Error("action must be a function");
                            }
                            this.destState = spec.destState;
                            this.action = spec.action;
                            this.external = spec.external;
                        }
                    }
                };
                module.exports.StateContext = StateContext;
                /***/
            },
            /***/ "./modules/solclient-fsm/lib/state-machine.js": 
            /*!****************************************************!*\
  !*** ./modules/solclient-fsm/lib/state-machine.js ***!
  \****************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    LOG_ERROR
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    State
                } = __webpack_require__(/*! ./state */ "./modules/solclient-fsm/lib/state.js");
                const {
                    StateContext
                } = __webpack_require__(/*! ./state-context */ "./modules/solclient-fsm/lib/state-context.js");
                /**
 * @classdesc
 * This is a state machine that can host states.  States themselves can also
 * host inner states in a hierarchical manner.  This class also provides the
 * basic interface for manipulating the current state via processing of
 * events, and querying the current state through 'getActiveState' methods.
 *
 * @private
 * @memberof solace
 */
                class StateMachine extends StateContext {
                    /**
   * @constructor
   *
   * @param {Object} spec The object specifier for the FSM.
   * @param {String} spec.name The name of the FSM, used in debug logs.
   */
                    constructor(spec) {
                        if (spec.parentContext) {
                            throw new Error(`State machine cannot have parent state: ${spec.parentContext}`);
                        }
                        super(spec);
                        this.impl.ancestorList = [ this ];
                        this.impl.eventQueue = [];
                        this.impl.finalState = new State({
                            name: "impl.final",
                            parentContext: this
                        });
                        this.impl.handleUncaughtException = (ev, exc) => {
                            LOG_ERROR(`Uncaught exception in ${this} while processing ${ev}: ${exc.stack}`);
                            return this.terminate();
                        };
                    }
                    /**
   * This method enqueues the given function, and begins execution of queued functions if
   * they aren't already executing.
   * @param {Function} func The function to enqueue and execute.
   * @returns {Boolean} `true` if the supplied function has completed; false if it was deferred.
   */
                    process(func) {
                        const {
                            impl
                        } = this;
                        const {
                            eventQueue
                        } = impl;
                        eventQueue.push(func);
                        if (impl.processingEvents) {
                            return false;
                        }
                        impl.processingEvents = true;
                        while (eventQueue.length) {
                            const evt = eventQueue.shift();
                            evt.apply(this);
                        }
                        impl.processingEvents = false;
                        this._onEventCompletion();
                        return true;
                    }
                    /**
   * This method starts a state machine after it has been created and states
   * have been associated and configured any time getCurrentState() returns
   * undefined.  This would be after initial creation and after the state
   * machine has terminated (i.e. transitioned to the final state).
   */
                    start() {
                        if (this.getCurrentState()) {
                            throw new Error(`Cannot start ${this.getName()}; it is already started.`);
                        }
                        this.process(() => {
                            const result = this.onInitial();
                            // A state machine's onInitial must specify a destState, the state
                            // cannot be the state machine itself, and the state must have the
                            // state machine as the top ancestor.
                            if (result.destState === undefined) {
                                throw new Error(`Missing destination state from initial transition for ${this}`);
                            }
                            if (result.destState === this) {
                                throw new Error(`Destination state for initial transition for ${this} cannot be the FSM.`);
                            }
                            const destAncestorList = result.destState.getAncestorList();
                            if (destAncestorList[0] !== this) {
                                throw new Error(`Invalid destination state (${result.destState}) from initial transition for state machine (${this}); destState ancestor (${destAncestorList[0]})`);
                            }
                            this.impl.currentState = this.processReactionResult(result);
                        });
                    }
                    /**
   * Used to query whether the state machine is currently running
   * @returns {Boolean} `true` if the state machine is processing events; false otherwise.
   */
                    isRunning() {
                        return this.impl.processingEvents;
                    }
                    /**
   * This is the main function to invoke an FSM with an event.
   * @param {FsmEvent} evt The event to be processed by the FSM.
   */
                    processEvent(evt) {
                        const {
                            impl
                        } = this;
                        if (!this.process(() => {
                            this.log(`Processing event ${evt}`);
                            let result;
                            if (impl.currentState) {
                                try {
                                    result = impl.currentState.handleEvent(evt);
                                    impl.currentState = impl.currentState.processReactionResult(result, evt);
                                } catch (exc) {
                                    this.log(`Caught exception ${exc}, continuing`);
                                    result = impl.handleUncaughtException.call(impl.currentState, evt, exc);
                                    impl.currentState = impl.currentState.processReactionResult(result, evt);
                                }
                            }
                        })) {
                            // Didn't run immediately
                            this.log(`Deferring event ${evt}`);
                        }
                    }
                    /**
   * Terminates the FSM by transitioning the FSM to its final state. After
   * this returns, the FSM may be started again with @link start.  This method
   * should only be called externally from the FSM, not from within a reaction.
   * To terminate the FSM within a reaction, use the
   * {@link StateContext.ReactionResult} returned by {@link State#terminate}.
   */
                    terminateFsm() {
                        const curState = this.getCurrentState();
                        if (!curState) {
                            return;
                        }
                        if (this.impl.processingEvents) {
                            throw new Error("Cannot terminate state machine while FSM is processing " + "events. To terminate the FSM from within a reaction, return " + "State~terminate() from a reaction.");
                        }
                        this.process(() => {
                            const result = curState.terminate();
                            this.impl.currentState = curState.processReactionResult(result);
                        });
                    }
                    /**
   * This should only be called from within the context of a reaction
   * function, which is to say a function called by the FSM infrastructure
   * that returns {@link StateContext~ReactionResult}.  The purpose of this
   * function is to set a function to be called after the currently
   * executing event is completely handled, which includes the execution of
   * any events that have been or will be queued as a result of processing
   * the current event.
   *
   * Typical uses of this would be to set a function that does one of:
   * 1. Throws an exception to the caller.
   * 2. Calls an application callback.
   * @param {Function} postEventAction function to call when the FSM has finished
   *  processing events.  The context (i.e. 'this') will be the FSM when it
   *  is called.
   */
                    setPostEventAction(postEventAction) {
                        if (!this.impl.processingEvents) {
                            throw new Error("Cannot set post event hook unless FSM is processing events.");
                        }
                        if (!postEventAction || typeof postEventAction !== "function") {
                            // TBD: Do we need to allow clearing of the hook?  Not that
                            // I'm aware of for the known use cases.  If we want to allow
                            // it, I propose adding a 'clearPostEventAction' rather than
                            // allowing null or undefined as the argument.
                            throw new Error(`postEventAction must be a function; got (${postEventAction})`);
                        }
                        this.impl.postEventAction = postEventAction.bind(this);
                    }
                    /**
   * Called by the FSM when it finishes processing events.  If a
   * postEventAction had been set, it will be called, then cleared.
   * @private
   */
                    _onEventCompletion() {
                        const action = this.impl.postEventAction;
                        if (action) {
                            this.impl.postEventAction = undefined;
                            this.log("Running post event action");
                            action.apply(this);
                        }
                    }
                    /**
   * Returns the innermost active state.
   *
   * If regions were implemented, this would return an iterator to innermost
   * active states.
   *
   * @returns {StateContext} The innermost active state.
   */
                    getCurrentState() {
                        return this.impl.currentState;
                    }
                    /**
   * Gets an active state by name.  Returns undefined if the named state is
   * not currently active.
   *
   * Note the returned state may not be the innermost state as returned by
   * {@link StateMachine#getCurrentState}.  If the innermost active state is not
   * returned, the returned state is guaranteed to contain the innermost active
   * state.
   *
   * @param {String} name The name of the state to be retrieved.
   * @returns {?StateContext} The state with the specified name, if the
   *      state is active; undefined otherwise.  Note the returned state may not
   *      be the innermost active state.
   */
                    getActiveState(name) {
                        const activeStates = this.impl.currentState.getAncestorList();
                        // Don't include the first ancestor in the loop since it is the state
                        // machine itself, not a state.
                        for (let i = 1; i < activeStates.length; ++i) {
                            if (activeStates[i].getName() === name) {
                                return activeStates[i];
                            }
                        }
                        return undefined;
                    }
                    /**
   * Checks if the named state is currently active.
   * @param {String} name The name of the state to be queried.
   * @returns {Boolean} Whether or not the named state is active.
   */
                    isStateActive(name) {
                        return this.getActiveState(name) !== undefined;
                    }
                    /**
   * Allows a reaction to be registered for unhandled events in the FSM.  The
   * default reaction is to log the unhandled event at debug and remain in the
   * current state with no other side effects.
   * @param {StateContext.reactionCallback} r The reaction to be invoked when an
   *      event is unhandled by the FSM.
   * @returns {StateMachine} This StateMachine object.
   */
                    unhandledEventReaction(r) {
                        if (typeof r !== "function") {
                            throw new Error(`In ${this}: unhandled event reaction must be a function; got ${r}`);
                        }
                        this.impl.handleUnhandledEvent = r.bind(this);
                        return this;
                    }
                    /**
   * This allows a reaction to be registered for uncaught exceptions while
   * processing events.  Generally, it is preferred to catch exceptions from
   * within reaction functions.  However, this is a good way to safeguard
   * against missed exceptions.  Usually an error should be logged here,
   * which is the default behaviour.
   *
   * Also note that this is only called for either:
   * - an exception thrown from an event reaction;
   * - an exception thrown from a transition action
   * If exceptions are thrown from within state entry, exit, initials, etc,
   * this function is not invoked.  These functions may end up getting
   * invoked from the transition taken as a result of the exception in the
   * first place.  The generate another exception would be difficult to
   * handle in a sensible way.  Users of this infrastructure must always
   * catch exceptions from these functions.
   *
   * @param {fsm.StateContext.reactionCallback} r The reaction to be
   *      invoked when an exception has not been caught by another of the
   *      FSM's reactionCallbacks.  When this function is invoked, 'this'
   *      will be the FSM's current state.
   * @returns {StateMachine} `this`, for method chaining.
   */
                    uncaughtExceptionReaction(r) {
                        if (typeof r !== "function") {
                            throw new Error(`In ${this}: Uncaught exception reaction must be a function; got ${r}`);
                        }
                        this.impl.handleUncaughtException = r;
                        return this;
                    }
                    /**
   * Used by the implementation to get the final state.  This should never be
   * used by applications.  Their only need to reference this state should be
   * indirectly via the {@link State#terminate} function.
   * @returns {State} The FSM's final state, which is a hidden implementation
   *      detail of the FSM.
   * @protected
   */
                    getFinalState() {
                        return this.impl.finalState;
                    }
                }
                module.exports.StateMachine = StateMachine;
                /***/
            },
            /***/ "./modules/solclient-fsm/lib/state.js": 
            /*!********************************************!*\
  !*** ./modules/solclient-fsm/lib/state.js ***!
  \********************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    EntryPoint
                } = __webpack_require__(/*! ./entry-point */ "./modules/solclient-fsm/lib/entry-point.js");
                const {
                    ExitPoint
                } = __webpack_require__(/*! ./exit-point */ "./modules/solclient-fsm/lib/exit-point.js");
                const {
                    StateContext
                } = __webpack_require__(/*! ./state-context */ "./modules/solclient-fsm/lib/state-context.js");
                /**
 * @classdesc
 * This class represents a state in a state machine.
 * @private
 */
                class State extends StateContext {
                    /**
   * @constructor
   * @param {Object} spec Object specifier used to implement the named parameter
   *  idiom.  In addition to the properties documented here, it is also expected
   *  to have properties required by the [StateContext base class]{@link StateContext}.
   * @param {String} spec.name The name of the state, used in debug logs.
   * @param {State|StateMachine} spec.parentContext One of:
   *  - The parent state object or;
   *  - The stateMachine object for top-level states.
   * @param {Object} [extensions] Additional methods to add to the state.
   */
                    constructor(spec, extensions = null) {
                        super(spec);
                        const parentContext = spec.parentContext;
                        Object.assign(this.impl, {
                            parentContext: parentContext,
                            reactions: {},
                            entryPoints: {},
                            exitPoints: {},
                            ancestorList: [ ...parentContext.getAncestorList(), this ],
                            handleUnhandledEvent: e => parentContext.handleEvent ? parentContext.handleEvent(e) : parentContext.impl.handleUnhandledEvent(e)
                        });
                        if (parentContext) this.log = parentContext.log.bind(this);
                        // Extend and bind functions
                        Object.keys(extensions || {}).forEach(k => {
                            const extension = extensions[k];
                            this[k] = typeof extension === "function" ? extension.bind(this) : extension;
                        });
                        this.setLogPadding(" ".repeat(this.impl.ancestorList.length));
                    }
                    /**
   * Register a reaction function for a particular event.
   * @param {String} eventName The name of the event func is to react to.
   * @param {StateContext.reactionCallback} func The function to call when
   *  the state processes an event with the name eventName.  The function is
   *  bound to this object so that this refers to this state object when it
   *  is invoked.
   * @returns {State} This state object.
   * @public
   */
                    reaction(eventName, func) {
                        if (!eventName) throw new Error("No event name for reaction");
                        if (!func) throw new Error(`No reaction function for reaction ${eventName}`);
                        this.log(`Adding reaction to ${this} for event ${eventName}`);
                        if (this.impl.reactions[eventName]) {
                            this.log(`Replacing reaction ${this.impl.reactions[eventName]} with ${func}`);
                        }
                        this.impl.reactions[eventName] = func.bind(this);
                        return this;
                    }
                    /**
   * Create an entryPoint for this state.
   * @param {String} entryPointName The name of the entryPoint being created.
   * @param {StateContext.reactionCallback} func The reaction to invoke after
   *  the state is entered via this entryPoint
   * @returns {State} This state object.
   * @public
   */
                    entryPoint(entryPointName, func) {
                        if (!entryPointName) throw new Error("No entry point name for entry point");
                        if (!func) throw new Error(`No reaction function for entry point ${entryPointName}`);
                        this.log(`Adding entryPoint ${entryPointName} to ${this}`);
                        if (this.impl.entryPoints[entryPointName]) {
                            this.log(`EntryPoint ${entryPointName} already exists in ${this}`);
                            return this;
                        }
                        this.impl.entryPoints[entryPointName] = new EntryPoint({
                            state: this,
                            entryPointName: entryPointName,
                            func: func
                        });
                        return this;
                    }
                    /**
   * Create an exitPoint for this state.
   * @param {String} exitPointName The name of the exitPoint being created.
   * @param {StateContext.reactionCallback} func The reaction to invoke after
   *  the state is exited via this exitPoint.
   * @returns {State} This state object.
   * @public
   */
                    exitPoint(exitPointName, func) {
                        if (!exitPointName) throw new Error("No exit point name for entry point");
                        if (!func) throw new Error(`No reaction function for exit point ${exitPointName}`);
                        this.log(`Adding exitPoint ${exitPointName} to ${this}`);
                        if (this.impl.exitPoints[exitPointName]) {
                            this.log(`ExitPoint ${exitPointName} already exists in  ${this}`);
                            return this;
                        }
                        this.impl.exitPoints[exitPointName] = new ExitPoint({
                            state: this,
                            exitPointName: exitPointName,
                            func: func
                        });
                        return this;
                    }
                    /**
   * @param {String} entryPointName The name of the entry point to be
   *      transitioned to.
   * @returns { StateContext } The state context to transition to when
   *      entering via the state's entryPoint named entryPointName.
   * @protected
   */
                    getEntryPointDestState(entryPointName) {
                        if (this.impl.entryPoints[entryPointName] === undefined) {
                            this.log(`${this}: EntryPoint ${entryPointName} does not exist.`);
                            return this;
                        }
                        return this.impl.entryPoints[entryPointName].getDestState();
                    }
                    /**
   * @param {String} exitPointName The name of the exit point to be
   *      transitioned to.
   * @returns {StateContext} The state context to transition to when
   *      exiting via the state's exitPoint named exitPointName.
   * @protected
   */
                    getExitPointDestState(exitPointName) {
                        if (this.impl.exitPoints[exitPointName] === undefined) {
                            this.log(`${this}: ExitPoint ${exitPointName} does not exist.`);
                            return this;
                        }
                        return this.impl.exitPoints[exitPointName].getDestState();
                    }
                    /**
   * Register a function to be called when the state is entered.
   * @param {function} func The function to call when the state is entered.
   *  The function is bound to this object so that this refers to this
   *  state object when it is invoked.
   * @returns {State} This state object.
   * @public
   */
                    entry(func) {
                        if (this.impl.appEntryFunc) {
                            this.log(`Replacing entry function ${this.impl.appEntryFunc} with ${func}`);
                        }
                        this.impl.appEntryFunc = func.bind(this);
                        return this;
                    }
                    /**
   * Register a function to be called when the state is exited.
   * @param {function} func The function to call when the state is exited.
   *  The function is bound to this object so that this refers to this
   *  state object when it is invoked.
   * @returns {State} This state object.
   * @public
   */
                    exit(func) {
                        if (this.impl.appExitFunc) {
                            this.log(`Replacing exit function ${this.impl.appExitFunc} with ${func}`);
                        }
                        this.impl.appExitFunc = func.bind(this);
                        return this;
                    }
                    /**
   * This is the same as [transitionTo]{@link StateContext#transitionTo},
   * except the outermost state is exited if the source state is within the
   * dest state or vice versa.  If one state is not within the other, this
   * is equivalent to [transitionTo]{@link StateContext#transitionTo}.
   * @param {State} state The state to transition to; if undefined, it is
   *      a self-transition.
   * @param {StateContext.actionCallback} [action] Optional The action to perform as part
   *      of the transition, if desired.
   * @returns {StateContext.ReactionResult} The result of the transition.
   */
                    externalTransitionTo(state, action) {
                        return new StateContext.ReactionResult({
                            caller: this,
                            destState: state,
                            action: action,
                            external: true
                        });
                    }
                    /**
   * This is similar to [transitionTo]{@link StateContext#transitionTo}, except
   * that this is a transition to a named entryPoint created on state.  If the
   * named entryPoint does not exist, this is a malformed FSM and the behaviour
   * is undefined.
   * @param {State} state The state that has the named entryPoint.
   * @param {String} entryPointName The name of the entryPoint of state.
   * @param {StateContext.actionCallback} action The action to perform as part of
   *      the transaction, if desired.
   * @returns {StateContext.ReactionResult} The result of the transition
   */
                    transitionToEntryPoint(state, entryPointName, action) {
                        return new StateContext.ReactionResult({
                            caller: this,
                            destState: state.getEntryPointDestState(entryPointName),
                            action: action
                        });
                    }
                    /**
   * This is similar to [transitionTo]{@link StateContext#transitionTo}, except
   * that this is a transition to a named exitPoint created on state.  If the
   * named exitPoint does not exist, this is a malformed FSM and the behaviour
   * is undefined.
   * @param {State} state The state that has the named exitPoint.
   * @param {String} exitPointName The name of the exitPoint of state.
   * @param {StateContext.actionCallback} [action] Optional The
   * action to perform as part of the transaction, if desired.
   * @returns {StateContext.ReactionResult} The result of the transition
   */
                    transitionToExitPoint(state, exitPointName, action) {
                        return new StateContext.ReactionResult({
                            caller: this,
                            destState: state.getExitPointDestState(exitPointName),
                            action: action
                        });
                    }
                    /**
   * If a reaction evaluates the guard conditions for the reaction and none
   * succeed, the eventUnhandled
   * [ReactionResult]{@link StateContext.ReactionResult} should be
   * returned.  This causes the FSM to continue looking for a reaction to
   * process the event.
   * @returns {StateContext.ReactionResult} The result of the transition
   */
                    eventUnhandled() {
                        return new StateContext.ReactionResult({
                            caller: this
                        });
                    }
                    /**
   * This [ReactionResult]{@link StateContext.ReactionResult} is used
   * when an event has been handled in a state and the transition is a local
   * transition back to itself.  Note that internal transitions never cause
   * state exits or entries -- if the internal transition is defined in an
   * outer state that contains the active state, then the behaviour is as if the
   * active state has inherited the internal transition from the outer state.
   * @param {?Function} action The action to perform in the transition.
   * @returns {StateContext.ReactionResult} The result of the transition
   */
                    internalTransition(action) {
                        return new StateContext.ReactionResult({
                            caller: this,
                            destState: this.getStateMachine().getCurrentState(),
                            action: action
                        });
                    }
                    /**
   * Used to terminate the FSM.
   * @param {StateContext.actionCallback} action An optional action to
   *      take within the FSM context after all states have been exited.
   * @returns {StateContext.ReactionResult} The result of the transition
   */
                    terminate(action) {
                        return new StateContext.ReactionResult({
                            caller: this,
                            destState: this.getStateMachine().getFinalState(),
                            action: action
                        });
                    }
                    /**
   * @returns {StateContext} The parent state context for this state, which
   *      could either be an outer state, or the state machine for top-level
   *      states.
   * @protected
   */
                    getParent() {
                        return this.impl.parentContext;
                    }
                    /**
   * Called when a state is being entered.  Calls the app's registered entry
   * function, if any.
   * @protected
   */
                    onEntry() {
                        this.log(`Entering: ${this}`);
                        if (this.impl.appEntryFunc) {
                            this.impl.appEntryFunc();
                        }
                    }
                    /**
   * Called when a state is being exited.  Calls the app's registered exit
   * function, if any.
   * @protected
   */
                    onExit() {
                        this.log(`Exiting: ${this}`);
                        if (this.impl.appExitFunc) {
                            this.impl.appExitFunc();
                        }
                    }
                    /**
   * Called when a state is to handle an event.
   * @param {FsmEvent} e The event to handle.
   * @returns {ReactionResult} The result of handling the event.
   * @protected
   */
                    handleEvent(e) {
                        this.log(`Process: ${e}`);
                        const reaction = this.impl.reactions[e.getName()];
                        if (reaction) {
                            const result = reaction(e);
                            // All ReactionResults in which an event is considered handled
                            // have a destState defined.
                            if (!result) {
                                this.log(`Reaction returned undefined: ${e} in ${this}`);
                            }
                            if (result.destState) {
                                this.log(`Handled: ${e}`);
                                return result;
                            }
                            this.log(`Unhandled: ${e} in ${this}`);
                        } else {
                            this.log(`No reaction: ${e} in ${this}`);
                        }
                        return this.impl.handleUnhandledEvent(e);
                    }
                }
                module.exports.State = State;
                /***/
            },
            /***/ "./modules/solclient-log/api.js": 
            /*!**************************************!*\
  !*** ./modules/solclient-log/api.js ***!
  \**************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ConsoleLogImpl
                } = __webpack_require__(/*! ./lib/console-log-impl */ "./modules/solclient-log/lib/console-log-impl.js");
                const {
                    GlobalBinding
                } = __webpack_require__(/*! ./lib/global-binding */ "./modules/solclient-log/lib/global-binding.js");
                const {
                    LogImpl
                } = __webpack_require__(/*! ./lib/log-impl */ "./modules/solclient-log/lib/log-impl.js");
                const {
                    LogLevel
                } = __webpack_require__(/*! ./lib/log-levels */ "./modules/solclient-log/lib/log-levels.js");
                const {
                    Parameter
                } = __webpack_require__(/*! solclient-validate */ "./modules/solclient-validate/api.js");
                const {
                    SolclientFactory
                } = __webpack_require__(/*! solclient-factory */ "./modules/solclient-factory/api.js");
                const {
                    isEnumMember,
                    isFunction
                } = Parameter;
                const {
                    getImpl,
                    getLogLevel,
                    setImpl,
                    setLogLevel
                } = GlobalBinding;
                const forwarder = {};
                function buildLogForwarder() {
                    Object.assign(forwarder, {
                        trace(...args) {
                            const impl = getImpl();
                            if (impl && impl.trace && getLogLevel() >= LogLevel.TRACE) {
                                impl.trace.apply(null, [ "solclientjs: ", ...args ]);
                            }
                        },
                        debug(...args) {
                            const impl = getImpl();
                            if (impl && impl.debug && getLogLevel() >= LogLevel.DEBUG) {
                                impl.debug.apply(null, [ "solclientjs: ", ...args ]);
                            }
                        },
                        info(...args) {
                            const impl = getImpl();
                            if (impl && impl.info && getLogLevel() >= LogLevel.INFO) {
                                impl.info.apply(null, [ "solclientjs: ", ...args ]);
                            }
                        },
                        warn(...args) {
                            const impl = getImpl();
                            if (impl && impl.warn && getLogLevel() >= LogLevel.WARN) {
                                impl.warn.apply(null, [ "solclientjs: ", ...args ]);
                            }
                        },
                        error(...args) {
                            const impl = getImpl();
                            if (impl && impl.error && getLogLevel() >= LogLevel.ERROR) {
                                impl.error.apply(null, [ "solclientjs: ", ...args ]);
                            }
                        },
                        fatal(...args) {
                            const impl = getImpl();
                            if (impl && impl.fatal) {
                                impl.fatal.apply(null, [ "solclientjs: ", ...args ]);
                            }
                        }
                    });
                }
                buildLogForwarder(); // stripped by production build
                function addGlobalFuncs(source, target) {
                    Object.keys(forwarder).forEach(k => {
                        target[`LOG_${k.toUpperCase()}`] = source[k];
                    });
                }
                class LogFormatter {
                    constructor(formatter) {
                        this._formatter = (() => {
                            if (typeof formatter === "function") return formatter;
                            if (typeof formatter === "string") return function prepend(...args) {
                                return [ formatter, ...args ];
                            };
                            if (!formatter) return function passthrough(...args) {
                                return [ ...args ];
                            };
                            return formatter;
                        })();
                        const self = this;
                        Object.keys(forwarder).forEach(key => {
                            this[key] = function forward(...args) {
                                return forwarder[key].apply(null, self._formatter(...args));
                            };
                        });
                        addGlobalFuncs(this, this);
                    }
                    get formatter() {
                        return this._formatter;
                    }
                    set formatter(func) {
                        this._formatter = func;
                    }
                    wrap(genericFunction, targetSelf) {
                        const self = this;
                        return function genericLogWrapper(...args) {
                            return genericFunction.apply(targetSelf, self._formatter(...args));
                        };
                    }
                }
                /**
 * Gets the current log level, which was set by {@link solace.SolclientFactory.init} or a
 * subsequent call to {@link solace.SolclientFactory.setLogLevel}.
 *
 * @returns {solace.LogLevel} The current log level.
 */
                SolclientFactory.getLogLevel = () => getLogLevel();
                /**
   * This method changes the current log level from the level set when
   * {@link solace.SolclientFactory.init} was called.
   *
   * @param {solace.LogLevel} newLevel The new log level to set.
   * @throws {solace.OperationError} Invalid log level
   */
                SolclientFactory.setLogLevel = newLevel => {
                    isEnumMember("logLevel", newLevel, LogLevel);
                    setLogLevel(newLevel);
                };
                SolclientFactory.addInitializer(props => {
                    setLogLevel(props.logLevel);
                    const logger = props.logger || getImpl() || new ConsoleLogImpl();
                    // Validate that the supplied log implementation is a superset of LogImpl
                    Object.keys(new LogImpl()).forEach(key => isFunction(`logger.${key}`, logger[key]));
                    setImpl(logger);
                });
                addGlobalFuncs(forwarder, module.exports);
                module.exports.LogImpl = LogImpl;
                module.exports.LogLevel = LogLevel;
                module.exports.Binding = GlobalBinding;
                module.exports.ConsoleLogImpl = ConsoleLogImpl;
                GlobalBinding.setImpl(new ConsoleLogImpl());
                module.exports.LogFormatter = LogFormatter;
                /***/
            },
            /***/ "./modules/solclient-log/lib/console-log-impl.js": 
            /*!*******************************************************!*\
  !*** ./modules/solclient-log/lib/console-log-impl.js ***!
  \*******************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    LogImpl
                } = __webpack_require__(/*! ./log-impl */ "./modules/solclient-log/lib/log-impl.js");
                const STUB = () => undefined;
                function generateLogHeader(levelStr) {
                    const date = new Date();
                    const levelStrPadding = " ".repeat(6 - levelStr.length);
                    let YY = String(date.getFullYear());
                    let MM = String(date.getMonth() + 1);
                    let DD = String(date.getDate());
                    let hh = String(date.getHours());
                    let mm = String(date.getMinutes());
                    let ss = String(date.getSeconds());
                    let ms = String(date.getMilliseconds());
                    YY = "0".repeat(4 - YY.length) + YY;
                    MM = MM.length < 2 ? `0${MM}` : MM;
                    DD = DD.length < 2 ? `0${DD}` : DD;
                    hh = hh.length < 2 ? `0${hh}` : hh;
                    mm = mm.length < 2 ? `0${mm}` : mm;
                    ss = ss.length < 2 ? `0${ss}` : ss;
                    ms = ms.length < 3 ? `0${ms}` : ms;
                    ms = ms.length < 3 ? `0${ms}` : ms; // twice: pad to 3
                    return [ `${YY}-${MM}-${DD} ${hh}:${mm}:${ss}.${ms}`, `${levelStr}${levelStrPadding}` ];
                }
                /**
 * @classdesc
 * A log implementation that uses the global or window console.
 *
 * This is the default log implementation used by the API if no logger was
 * supplied via {@link solace.SolclientFactoryProperties}.
 *
 * @memberof solace
 * @private
 */
                class ConsoleLogImpl extends LogImpl {
                    /**
   * @constructor
   * @param {Object} [consoleIn] The console to which to apply this implementation. If
   *  not specified, uses the global or window console.
   */
                    constructor(consoleIn) {
                        /**
     * Logs the given arguments at TRACE level. This is bound to the first valid method of the
     * following on the global or window console object, in priority order:
     *  * console.log
     *  * console.debug
     *
     * @name solace.ConsoleLogImpl#trace
     * @method
     * @param {...*} args Arguments to be logged
     */
                        let _trace = STUB;
                        /**
     * Logs the given arguments at DEBUG level. This is bound to the first valid method of the
     * following on the global or window console object, in priority order:
     *  * console.log
     *  * console.debug
     *
     * @name solace.ConsoleLogImpl#debug
     * @method
     * @param {...*} args Arguments to be logged
     */
                        let _debug = STUB;
                        /**
     * Logs the given arguments at INFO level. This is bound to the first valid method of the
     * following on the global or window console object, in priority order:
     *  * console.info
     *  * console.log
     *
     * @name solace.ConsoleLogImpl#info
     * @method
     * @param {...*} args Arguments to be logged
     */
                        let _info = STUB;
                        /**
     * Logs the given arguments at WARN level. This is bound to the first valid method of the
     * following on the global or window console object, in priority order:
     *  * console.warn
     *  * console.log
     *
     * @name solace.ConsoleLogImpl#warn
     * @method
     * @param {...*} args Arguments to be logged
     */
                        let _warn = STUB;
                        /**
     * Logs the given arguments at ERROR level. This is bound to the first valid method of the
     * following on the global or window console object, in priority order:
     *  * console.info
     *  * console.log
     *
     * @name solace.ConsoleLogImpl#error
     * @method
     * @param {...*} args Arguments to be logged
     */
                        let _error = STUB;
                        /**
     * Logs the given arguments at FATAL level. This is bound to the first valid method of the
     * following on the global or window console object, in priority order:
     *  * console.info
     *  * console.log
     *
     * @name solace.ConsoleLogImpl#fatal
     * @method
     * @param {...*} args Arguments to be logged
     */
                        let _fatal = STUB;
                        const console = consoleIn || (typeof window === "undefined"
                        /* eslint-env node */ ? __webpack_require__.g
                        /* eslint-env browser */ : window).console;
                        /* eslint-env shared-node-browser */
                        if (console && (console.log || console.warn)) {
                            /* eslint-disable no-console */
                            // Where console.log is supported, it is preferred over console.debug
                            // https://developer.mozilla.org/en-US/docs/DOM/console
                            // console methods in IE9 are object, not function, unfortunately
                            //
                            // Also, console.trace outputs a stack trace on some platforms.  So we
                            // use the same underlying logger as debug for trace to avoid the
                            // excessive verbosity that would result.
                            if (console.log && console.log !== undefined) {
                                _trace = Function.prototype.bind.call(console.log, console);
                                _debug = Function.prototype.bind.call(console.log, console);
                            } else if (console.debug && typeof console.debug === "function") {
                                _trace = Function.prototype.bind.call(console.debug, console);
                                _debug = Function.prototype.bind.call(console.debug, console);
                            }
                            // Where console.info exists, it is preferred. Otherwise, fall back to
                            // console.log.
                            if (console.info && console.info !== undefined) {
                                _info = Function.prototype.bind.call(console.info, console);
                            } else {
                                _info = Function.prototype.bind.call(console.log, console);
                            }
                            // Where console.warn exists, it is preferred. Otherwise, fall back to
                            // console.log.
                            if (console.warn && console.warn !== undefined) {
                                _warn = Function.prototype.bind.call(console.warn, console);
                            } else {
                                _warn = Function.prototype.bind.call(console.log, console);
                            }
                            // Where console.error exists, it is preferred. Otherwise, fall back to
                            // console.log.
                            //
                            // console.fatal is not present in any known console implementation. Use
                            // console.error or console.log.
                            if (console.error && console.error !== undefined) {
                                _error = Function.prototype.bind.call(console.error, console);
                                _fatal = Function.prototype.bind.call(console.error, console);
                            } else {
                                _error = Function.prototype.bind.call(console.log, console);
                                _fatal = Function.prototype.bind.call(console.log, console);
                            }
                            /* eslint-enable no-console */
                        } // else no console implementation was found, so the default (stub) is used for each level.
                        super((...args) => {
                            _trace(...generateLogHeader("TRACE"), ...args);
                        }, (...args) => {
                            _debug(...generateLogHeader("DEBUG"), ...args);
                        }, (...args) => {
                            _info(...generateLogHeader("INFO"), ...args);
                        }, (...args) => {
                            _warn(...generateLogHeader("WARN"), ...args);
                        }, (...args) => {
                            _error(...generateLogHeader("ERROR"), ...args);
                        }, (...args) => {
                            _fatal(...generateLogHeader("FATAL"), ...args);
                        });
                    }
                }
                module.exports.ConsoleLogImpl = ConsoleLogImpl;
                /***/
            },
            /***/ "./modules/solclient-log/lib/global-binding.js": 
            /*!*****************************************************!*\
  !*** ./modules/solclient-log/lib/global-binding.js ***!
  \*****************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    LogLevel
                } = __webpack_require__(/*! ./log-levels */ "./modules/solclient-log/lib/log-levels.js");
                const state = {
                    impl: null,
                    level: LogLevel.INFO
                };
                const LogBinding = {};
                LogBinding.getImpl = function getImpl() {
                    return state.impl;
                };
                LogBinding.setImpl = function setImpl(impl) {
                    state.impl = impl;
                };
                LogBinding.getLogLevel = function getLogLevel() {
                    return state.level;
                };
                LogBinding.setLogLevel = function setLogLevel(level) {
                    state.level = level;
                };
                module.exports.GlobalBinding = LogBinding;
                /***/
            },
            /***/ "./modules/solclient-log/lib/log-impl.js": 
            /*!***********************************************!*\
  !*** ./modules/solclient-log/lib/log-impl.js ***!
  \***********************************************/
            /***/ module => {
                /* eslint-disable class-methods-use-this */ // declare prototype stubs
                /**
 * A logging callback. It must accept any valid number of arguments of any type. It must not throw.
 *
 * @callback
 * @function
 * @name solace.LogImpl.loggingCallback
 * @param {...*} args The arguments to log. Typically this is a mixture of strings and
 *  objects to be inspected. A simple implementation might call .toString() on each
 *  argument.
 */
                /**
 * @classdesc
 * A class that provides a binding to a log implementation. Applications that need to
 * control API logging must construct a LogImpl
 * instance, a log implementation that can be set in
 * {@link solace.SolclientFactoryProperties#logger}.
 * The binding will call the supplied log methods with the
 * parameters supplied to each.
 * @memberof solace
 */
                class LogImpl {
                    /**
   * @param {solace.LogImpl.loggingCallback} trace Callback for {@link solace.LogLevel.TRACE} logs.
   * @param {solace.LogImpl.loggingCallback} debug Callback for {@link solace.LogLevel.DEBUG} logs.
   * @param {solace.LogImpl.loggingCallback} info Callback for {@link solace.LogLevel.INFO} logs.
   * @param {solace.LogImpl.loggingCallback} warn Callback for {@link solace.LogLevel.WARN} logs.
   * @param {solace.LogImpl.loggingCallback} error Callback for {@link solace.LogLevel.ERROR} logs.
   * @param {solace.LogImpl.loggingCallback} fatal Callback for {@link solace.LogLevel.FATAL} logs.
   *
   * @constructor
   */
                    constructor(trace, debug, info, warn, error, fatal) {
                        Object.assign(this, {
                            trace: trace,
                            debug: debug,
                            info: info,
                            warn: warn,
                            error: error,
                            fatal: fatal
                        });
                    }
                    trace() {}
                    debug() {}
                    info() {}
                    warn() {}
                    error() {}
                    fatal() {}
                }
                module.exports.LogImpl = LogImpl;
                /***/
            },
            /***/ "./modules/solclient-log/lib/log-levels.js": 
            /*!*************************************************!*\
  !*** ./modules/solclient-log/lib/log-levels.js ***!
  \*************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Represents a log level enumeration.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
                const LogLevel = {
                    /**
   * Fatal. Rserved for unrecoverable errors.
   * @type {Number}
   */
                    FATAL: 0,
                    /**
   * Error. An internal error to the API or Solace Message Router.
   * @type {Number}
   */
                    ERROR: 1,
                    /**
   * Warn. An external error which may be caused by the application passing invalid
   * arguments or objects to the API. Often accompanied by an thrown exception.
   * @type {Number}
   */
                    WARN: 2,
                    /**
   * Info. An unexpected event or occurrence that does not affect the sane
   * operation of the SDK or application.
   * @type {Number}
   */
                    INFO: 3,
                    /**
   * Debug. The highest (least) level of debug logs. Debug logs provide an overview of
   * the API operation.
   * @type {Number}
   */
                    DEBUG: 4,
                    /**
   * Trace. The loweest (most verbose) level of debug logs.
   * @type {Number}
   */
                    TRACE: 5
                };
                module.exports.LogLevel = Enum.new(LogLevel);
                /***/
            },
            /***/ "./modules/solclient-message-consumer/api.js": 
            /*!***************************************************!*\
  !*** ./modules/solclient-message-consumer/api.js ***!
  \***************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ConsumerFlows
                } = __webpack_require__(/*! ./lib/consumer-flows */ "./modules/solclient-message-consumer/lib/consumer-flows.js");
                const {
                    ConsumerFSMEvent
                } = __webpack_require__(/*! ./lib/consumer-fsm-event */ "./modules/solclient-message-consumer/lib/consumer-fsm-event.js");
                const {
                    ConsumerFSMEventNames
                } = __webpack_require__(/*! ./lib/consumer-fsm-event-names */ "./modules/solclient-message-consumer/lib/consumer-fsm-event-names.js");
                const {
                    MessageConsumer
                } = __webpack_require__(/*! ./lib/message-consumer */ "./modules/solclient-message-consumer/lib/message-consumer.js");
                const {
                    MessageConsumerAcknowledgeMode
                } = __webpack_require__(/*! ./lib/message-consumer-acknowledge-modes */ "./modules/solclient-message-consumer/lib/message-consumer-acknowledge-modes.js");
                const {
                    MessageConsumerEvent
                } = __webpack_require__(/*! ./lib/message-consumer-event */ "./modules/solclient-message-consumer/lib/message-consumer-event.js");
                const {
                    MessageConsumerEventName
                } = __webpack_require__(/*! ./lib/message-consumer-event-names */ "./modules/solclient-message-consumer/lib/message-consumer-event-names.js");
                const {
                    MessageConsumerProperties
                } = __webpack_require__(/*! ./lib/message-consumer-properties */ "./modules/solclient-message-consumer/lib/message-consumer-properties.js");
                const {
                    QueueBrowser
                } = __webpack_require__(/*! ./lib/queue-browser */ "./modules/solclient-message-consumer/lib/queue-browser.js");
                const {
                    QueueBrowserEventName
                } = __webpack_require__(/*! ./lib/queue-browser-event-names */ "./modules/solclient-message-consumer/lib/queue-browser-event-names.js");
                const {
                    QueueBrowserProperties
                } = __webpack_require__(/*! ./lib/queue-browser-properties */ "./modules/solclient-message-consumer/lib/queue-browser-properties.js");
                module.exports.ConsumerFlows = ConsumerFlows;
                module.exports.ConsumerFSMEvent = ConsumerFSMEvent;
                module.exports.ConsumerFSMEventNames = ConsumerFSMEventNames;
                module.exports.MessageConsumer = MessageConsumer;
                module.exports.MessageConsumerEvent = MessageConsumerEvent;
                module.exports.MessageConsumerAcknowledgeMode = MessageConsumerAcknowledgeMode;
                module.exports.MessageConsumerEventName = MessageConsumerEventName;
                module.exports.MessageConsumerProperties = MessageConsumerProperties;
                module.exports.QueueBrowser = QueueBrowser;
                module.exports.QueueBrowserEventName = QueueBrowserEventName;
                module.exports.QueueBrowserProperties = QueueBrowserProperties;
                /***/
            },
            /***/ "./modules/solclient-message-consumer/lib/application-acks.js": 
            /*!********************************************************************!*\
  !*** ./modules/solclient-message-consumer/lib/application-acks.js ***!
  \********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum,
                    assert
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                const {
                    LOG_DEBUG,
                    LOG_ERROR
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                /**
 * @private
 */
                const ApplicationAckState = Enum.new({
                    UNACKED: "UNACKED",
                    ACKED_NOT_SENT: "ACKED_NOT_SENT",
                    ACKED_SENT: "ACKED_SENT"
                });
                // For the ring buffer update index, we have two key-value options:
                //  Map() - generally faster where supported
                //  Object - seems to automatically coerce keys to string, which is what we want in this case
                // By using Map and explicly creating a .key attribute and using it whenever possible,
                // we should get performance that is no worse than Object, which may have to perform that
                // coercion more often.
                /**
 * @private
 */
                class ApplicationAck {
                    constructor(id, state) {
                        if (id) {
                            this.exists = true;
                            this.id = id;
                            this.key = id.toString();
                            this.state = state || ApplicationAckState.UNACKED;
                        } else {
                            this.exists = false;
                        }
                    }
                    set(id, state) {
                        this.exists = true;
                        this.id = id;
                        this.key = id.toString();
                        this.state = state || ApplicationAckState.UNACKED;
                    }
                    clear() {
                        this.exists = false;
                        this.id = null;
                        this.key = null;
                        this.state = null;
                    }
                }
                /**
 * @private
 */
                class ApplicationAckRingBuffer {
                    /**
   * Creates an instance of ApplicationAckRingBuffer. A standard ring buffer except that
   * it reserves an empty entry so that an operation can occur during insert that includes
   * both the new element and any element to be evicted. Also includes an ID-to-index map
   * to speed updates.
   *
   * @param {Number} size The number of entries in the ring. Effective size is (size - 1).
   * @memberof ApplicationAckRingBuffer
   */
                    constructor(size) {
                        LOG_DEBUG("Creating application ack ring buffer with size ", size, " retained size", size - 1);
                        assert(size >= 2); // one always free doesn't work with < 2 elements
                        this._size = size;
                        this._insertIndex = 0;
                        /**
     * @property {Array.<?ApplicationAck>}
     */
                        this._buffer = Array(size).fill(null).map(() => new ApplicationAck());
                        /**
     * @property {Map.<String, Number>}
     */
                        this._index = new Map();
                    }
                    reset() {
                        this._insertIndex = 0;
                        this._buffer.forEach(ack => {
                            ack.exists = false;
                        });
                        this._index.clear();
                    }
                    /**
   * @param {Long} id The id of the new entry
   * @param {function(ApplicationAck)} beforeEvictCallback Call this before operation completes
   * @returns {any} Return value of beforeEvictCallback
   * @private
   */
                    insert(id, beforeEvictCallback) {
                        assert(beforeEvictCallback);
                        assert(id);
                        const size = this._size;
                        const buffer = this._buffer;
                        const index = this._index;
                        const insertIndex = this._insertIndex;
                        /*
     * Because of the postprocessing step, we are not re-entrant safe. It is expected
     * that we are called from TCP -> Transport -> Session -> acceptMessage().
     * This assert verifies that the postprocess cleanup has happened.
     */
                        assert(!buffer[insertIndex].exists, "Invariant not enforced (before): insert index not empty");
                        // First, insert.
                        const inserting = buffer[insertIndex];
                        inserting.set(id, ApplicationAckState.UNACKED);
                        if (index.has(inserting.key)) {
                            LOG_ERROR(`Duplicate ID: ${index.get(inserting.key)} insertIndex: ${insertIndex}`);
                        }
                        index.set(inserting.key, insertIndex);
                        const evictingIndex = (insertIndex + 1) % size;
                        const evicting = buffer[evictingIndex];
                        let result;
                        try {
                            result = beforeEvictCallback(evicting.exists ? evicting : null);
                        } finally {
                            // Always clean up to keep the RB in a consistent state.
                            // If inProgressCallback threw, this runs before the exception propagates.
                            // Update insert index for next operation.
                            this._insertIndex = (insertIndex + 1) % size;
                            if (evicting.exists) {
                                index.delete(evicting.key);
                                evicting.clear();
                            }
                        }
                        assert(!buffer[this._insertIndex].exists, "Invariant not enforced (after): insert index not empty");
                        return result;
                    }
                    /**
   * Returns the number of elements in this ringbuffer. Will increase to
   * one less than the size provided to the constructor as the buffer is used.
   *
   * @readonly
   * @memberof ApplicationAckRingBuffer
   */
                    get length() {
                        return this._index.size;
                    }
                    /**
   * Returns the first element in the ring buffer.
   *
   * This could be called from the evict callback, so insert needs to be sure
   * that internal state is correct for that scenario.
   *
   * The expected case is that the first element is at insertIndex + 1, but if the
   * buffer has not been filled yet, we will iterate the buffer and skip nonexistent
   * elements to find it.
   *
   * This is a little inefficient until we have received this._size messages, but after
   * that it is more efficient than maintaining a read pointer.
   *
   * @returns {?ApplicationAck} The first ack in the buffer.
   */
                    front() {
                        if (this.length === 0) return null;
                        const buffer = this._buffer;
                        const insertIndex = this._insertIndex;
                        const size = this._size;
                        const firstIndex = (insertIndex + 1) % size;
                        // Cannot assert invariant here: insert is usually in progress.
                        // Buffer full case
                        if (buffer[firstIndex].exists) return buffer[firstIndex];
                        // Not yet filled case
                        // The last checked element for the iteration is the start point,
                        //  plus size, a full lap including the start index,
                        //  minus 1, to exclude the start
                        //  minus 1, to exclude the invariant null entry
                        for (let rawIndex = firstIndex, lastIndex = firstIndex + size - 1; rawIndex <= lastIndex; ++rawIndex) {
                            const readIndex = rawIndex % size;
                            const element = buffer[readIndex];
                            if (element.exists) {
                                return element;
                            }
                        }
                        // Buffer is completely empty
                        assert(this._index.size === 0, "#front() failed so buffer must be empty");
                        return null;
                    }
                    /**
   * Rather than implementing the iterator protocol, which requires Symbol support,
   * we'll implement a forEach that behaves as though this is an array.
   *
   * @param {function(ApplicationAppState, index, collection)} callback The iteration callback
   */
                    forEach(callback) {
                        if (this.length === 0) return;
                        const buffer = this._buffer;
                        const size = this._size;
                        let index = 0;
                        for (let rawIndex = this._insertIndex + 1, lastIndex = this._insertIndex + size; rawIndex <= lastIndex; ++rawIndex) {
                            const readIndex = rawIndex % size;
                            const element = buffer[readIndex];
                            if (element.exists) {
                                callback(element, index++, this);
                            }
                        }
                        assert(index > 0, "Not empty but did not dispatch");
                    }
                    /**
   * @param {Long} id The ID to update
   * @param {ApplicationAckState} state The new state for the ID
   * @private
   */
                    updateAckState(id, state) {
                        const key = id.toString();
                        assert(this._index.has(key), "Ack key not found");
                        const buffer = this._buffer;
                        const updateIndex = this._index.get(key);
                        const existing = buffer[updateIndex];
                        assert(existing, "Ack key has no entry");
                        existing.state = state;
                    }
                    /**
   * @param {Long} id The ID to look up
   * @returns {Boolean} `true` if this ID exists in the ringbuffer
   */
                    has(id) {
                        const key = id.toString();
                        return this._index.has(key);
                    }
                }
                Object.assign(module.exports, {
                    ApplicationAckState: ApplicationAckState,
                    ApplicationAck: ApplicationAck,
                    ApplicationAckRingBuffer: ApplicationAckRingBuffer
                });
                /***/
            },
            /***/ "./modules/solclient-message-consumer/lib/consumer-flows.js": 
            /*!******************************************************************!*\
  !*** ./modules/solclient-message-consumer/lib/consumer-flows.js ***!
  \******************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    assert
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                const {
                    MessageConsumer
                } = __webpack_require__(/*! ./message-consumer */ "./modules/solclient-message-consumer/lib/message-consumer.js");
                const {
                    MessageConsumerEventName
                } = __webpack_require__(/*! ./message-consumer-event-names */ "./modules/solclient-message-consumer/lib/message-consumer-event-names.js");
                class ConsumerFlows {
                    /**
   * Defines a set of Guaranteed Messaging Flows.  There are two sets allocated, one
   * for publishers (typically just one entry) and one for Subscribers.
   * There is a separate set for flows in RECONNECTING state.
   * These need special treatment during SESSION_DOWN:
   * they need to be notified, but not waited on by the session FSM.
   * Flows in _reconnectingFlows are not in _allFLows.
   * @param {any} options Construction options
   * @private
   */
                    constructor() {
                        this._allFlows = new Set();
                        this._reconnectingFlows = new Set();
                        // Flows by id (UP)
                        this._flowsById = {};
                    }
                    add(flow) {
                        assert(flow instanceof MessageConsumer, "Flow was not a consumer");
                        if (this._allFlows.has(flow)) {
                            return flow;
                        }
                        const flowUp = () => {
                            // Don't worry about flow collisions -- the router assigned the new flow to the same ID
                            // so it won't address the old flow. Retain the old flow in _allFlows and make sure we
                            // dispose the right flow.
                            this._flowsById[flow.flowId] = flow;
                        };
                        const flowDisposed = () => {
                            const flowId = flow.flowId;
                            this._allFlows.delete(flow);
                            this._reconnectingFlows.delete(flow);
                            const flowById = this._flowsById[flowId];
                            // If this test fails, the router reassigned the flow ID, and we were only keeping the
                            // _allFlows set reference for blanket cleanup.
                            if (flowById === flow) {
                                delete this._flowsById[flowId];
                            }
                            // Flow will be disposed and this will happen automatically
                        };
                        const flowReconnecting = () => {
                            flowDisposed();
                            this._reconnectingFlows.add(flow);
                        };
                        const flowReconnected = () => {
                            flowUp();
                            this._allFlows.add(flow);
                            this._reconnectingFlows.delete(flow);
                        };
                        const flowDown = () => {
                            this._reconnectingFlows.delete(flow);
                        };
                        flow._on(MessageConsumerEventName.UP, flowUp);
                        flow._on(MessageConsumerEventName.RECONNECTED, flowReconnected);
                        flow._on(MessageConsumerEventName.DISPOSED, flowDisposed);
                        flow._on(MessageConsumerEventName.RECONNECTING, flowReconnecting);
                        flow._on(MessageConsumerEventName.DOWN, flowDown);
                        flow._on(MessageConsumerEventName.DOWN_ERROR, flowDown);
                        this._allFlows.add(flow);
                        return flow;
                    }
                    get flows() {
                        return Array.from(this._allFlows);
                    }
                    get reconnectingFlows() {
                        return Array.from(this._reconnectingFlows);
                    }
                    getFlowById(flowId) {
                        return this._flowsById[flowId];
                    }
                    disposeAll() {
                        this._allFlows.forEach(flow => flow.dispose());
                    }
                }
                module.exports.ConsumerFlows = ConsumerFlows;
                /***/
            },
            /***/ "./modules/solclient-message-consumer/lib/consumer-fsm-event-names.js": 
            /*!****************************************************************************!*\
  !*** ./modules/solclient-message-consumer/lib/consumer-fsm-event-names.js ***!
  \****************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /**
 * Created by rpaulson on 06/02/2017.
 */
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /********************************************************************************
 * @private
 * Events on the Consumer FSM
 * @enum {string}
 ********************************************************************************/
                const ConsumerFSMEventNames = {
                    SESSION_UP: "SESSION_UP",
                    SESSION_UP_NO_AD: "SESSION_UP_NO_AD",
                    SESSION_DOWN: "SESSION_DOWN",
                    SESSION_DISCONNECT: "SESSION_DISCONNECT",
                    FLOW_FAILED: "FLOW_FAILED",
                    FLOW_UP: "FLOW_UP",
                    FLOW_ACTIVE_IND: "FLOW_ACTIVE_IND",
                    FLOW_CLOSE: "FLOW_CLOSE",
                    FLOW_OPEN: "FLOW_OPEN",
                    FLOW_UNBOUND: "FLOW_UNBOUND",
                    ACK: "ACK",
                    ACK_TIMEOUT: "ACK_TIMEOUT",
                    BIND_TIMEOUT: "BIND_TIMEOUT",
                    CREATE_TIMEOUT: "CREATE_TIMEOUT",
                    UNBIND_TIMEOUT: "UNBIND_TIMEOUT",
                    CAN_SEND: "CAN_SEND",
                    TRANSPORT_ERROR: "TRANSPORT_ERROR",
                    DISPOSE: "DISPOSE",
                    VIRTUALROUTER_NAME_CHANGED: "VIRTUALROUTER_NAME_CHANGED",
                    RECONNECT_INTERVAL_TIMEOUT: "RECONNECT_INTERVAL_TIMEOUT",
                    BIND_RESPONSE: "BIND_RESPONSE",
                    CREATE_FAILED: "CREATE_FAILED",
                    CREATE_SUCCESS: "CREATE_SUCCESS"
                };
                module.exports.ConsumerFSMEventNames = Enum.new(ConsumerFSMEventNames);
                /***/
            },
            /***/ "./modules/solclient-message-consumer/lib/consumer-fsm-event.js": 
            /*!**********************************************************************!*\
  !*** ./modules/solclient-message-consumer/lib/consumer-fsm-event.js ***!
  \**********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /**
 * Created by rpaulson on 06/02/2017.
 */
                const {
                    FsmEvent
                } = __webpack_require__(/*! solclient-fsm */ "./modules/solclient-fsm/api.js");
                /**
 *
 * ConsumerFSMEvent extends {@link FsmEvent}.  This object should be used for all events
 * passed to the Subscriber FSM.  This extension provides members to carry information specfic to
 * the Subscriber FSM transitions.
 *
 * @extends FsmEvent
 * @private
 */
                class ConsumerFSMEvent extends FsmEvent {
                    constructor(spec, details) {
                        super(spec);
                        this.details = details;
                    }
                }
                module.exports.ConsumerFSMEvent = ConsumerFSMEvent;
                /***/
            },
            /***/ "./modules/solclient-message-consumer/lib/consumer-fsm.js": 
            /*!****************************************************************!*\
  !*** ./modules/solclient-message-consumer/lib/consumer-fsm.js ***!
  \****************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const SMFLib = __webpack_require__(/*! solclient-smf */ "./modules/solclient-smf/api.js");
                const {
                    ApplicationAck,
                    ApplicationAckRingBuffer,
                    ApplicationAckState
                } = __webpack_require__(/*! ./application-acks */ "./modules/solclient-message-consumer/lib/application-acks.js");
                const {
                    assert
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                const {
                    CapabilityType
                } = __webpack_require__(/*! solclient-session */ "./modules/solclient-session/api.js");
                const {
                    ConsumerFSMEvent
                } = __webpack_require__(/*! ./consumer-fsm-event */ "./modules/solclient-message-consumer/lib/consumer-fsm-event.js");
                const {
                    ConsumerFSMEventNames
                } = __webpack_require__(/*! ./consumer-fsm-event-names */ "./modules/solclient-message-consumer/lib/consumer-fsm-event-names.js");
                const {
                    ConsumerStateNames
                } = __webpack_require__(/*! ./consumer-state-names */ "./modules/solclient-message-consumer/lib/consumer-state-names.js");
                const {
                    DestinationFromNetwork,
                    DestinationType,
                    Queue,
                    Topic
                } = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                const {
                    ErrorResponseSubcodeMapper,
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    LogFormatter
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    Long
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    MessageConsumerAcknowledgeMode
                } = __webpack_require__(/*! ./message-consumer-acknowledge-modes */ "./modules/solclient-message-consumer/lib/message-consumer-acknowledge-modes.js");
                const {
                    MessageConsumerEventName
                } = __webpack_require__(/*! ./message-consumer-event-names */ "./modules/solclient-message-consumer/lib/message-consumer-event-names.js");
                const {
                    MessageDispatcher
                } = __webpack_require__(/*! ./message-dispatcher */ "./modules/solclient-message-consumer/lib/message-dispatcher.js");
                const {
                    PrivateFlowEventName
                } = __webpack_require__(/*! solclient-flow */ "./modules/solclient-flow/api.js");
                const {
                    QueueAccessType,
                    QueueDescriptor,
                    QueuePermissions,
                    QueueProperties,
                    QueueType
                } = __webpack_require__(/*! solclient-queue */ "./modules/solclient-queue/api.js");
                const {
                    RgmidFactory
                } = __webpack_require__(/*! solclient-message */ "./modules/solclient-message/api.js");
                const {
                    State,
                    StateMachine
                } = __webpack_require__(/*! solclient-fsm */ "./modules/solclient-fsm/api.js");
                const {
                    Stats
                } = __webpack_require__(/*! solclient-stats */ "./modules/solclient-stats/api.js");
                const {
                    StatType
                } = __webpack_require__(/*! solclient-stats */ "./modules/solclient-stats/api.js");
                const {
                    Timer
                } = __webpack_require__(/*! solclient-events */ "./modules/solclient-events/api.js");
                const {
                    TransportAcks,
                    TransportAckResult
                } = __webpack_require__(/*! ./transport-acks */ "./modules/solclient-message-consumer/lib/transport-acks.js");
                const RING_BUFFER_SIZE = 512;
                const ZERO_APP_ACK = new ApplicationAck(Long.UZERO, ApplicationAckState.ACKED_SENT);
                class ConsumerFSM extends StateMachine {
                    constructor({
                        name,
                        consumer,
                        sessionInterface,
                        properties
                    } = {}) {
                        super({
                            name: name
                        });
                        const fsm = this;
                        const formatter = function formatter(...args) {
                            return [ `[session=${sessionInterface.sessionIdHex}]`, `[message-consumer-fsm=${consumer.flowIdDec}]`, ...args ];
                        };
                        const logger = this.logger = new LogFormatter(formatter);
                        const {
                            LOG_TRACE,
                            LOG_DEBUG,
                            LOG_INFO,
                            LOG_WARN,
                            LOG_ERROR
                        } = logger;
                        this.log = logger.wrap(this.log, this);
                        const autoAck = properties.acknowledgeMode === MessageConsumerAcknowledgeMode.AUTO;
                        this._consumer = consumer;
                        this._sessionInterface = sessionInterface;
                        // Save copies of properties accessed outside the constructor
                        this._acknowledgeTimeoutInMsecs = properties.acknowledgeTimeoutInMsecs;
                        this._acknowledgeThreshold = properties.acknowledgeThreshold;
                        this._localPreferredWindowSize = properties.windowSize;
                        this._localMaxWindowSize = properties.windowSize;
                        this._messageDispatch = new MessageDispatcher({
                            emitter: consumer,
                            autoAck: autoAck,
                            logger: logger
                        });
                        this._stats = new Stats();
                        this._resetRemoteConnectionState();
                        this._resetLocalConnectionState();
                        // Flag to delay flow dispose() for autoAck.
                        this._midDispatch = false;
                        // Save a copy to clear out on first successful bind
                        this._replayStartLocation = properties.replayStartLocation;
                        this._errorCausingReconnect = null;
                        //**********************************************************************************************
                        // A bit of infrastructure around post-event actions, which includes maintaining a queue of
                        // pending actions, and some logic to pre-process the actions before performing them.
                        // These should not be the same as any MessageConsumerEventName value or they will collide in
                        // the actionLocations object during event pre-processing.
                        const emitEventActionType = "EMIT";
                        const startDispatchActionType = "DISPATCH";
                        const stopDispatchActionType = "NO_DISPATCH";
                        let postEventActions = [];
                        function preprocessPostEventActions(startIndex) {
                            // first pre-process post event actions.  This isn't an exhaustive search of every possible
                            // combination of event sequences, as many are practically impossible, and therefore
                            // impossible to test.  We only handle sequences that are known to be possible.  If there
                            // are other sequences that need to be considered, we can add processing for them when we
                            // know they are possible.
                            LOG_TRACE(`Pre-processing post event action list @${startIndex}`, postEventActions);
                            const actionLocations = {};
                            postEventActions.forEach((action, i, arr) => {
                                function cancelAction(firstActionName, cancellingActionName) {
                                    if (actionLocations[firstActionName] === undefined) {
                                        return;
                                    }
                                    const firstLocation = actionLocations[firstActionName];
                                    LOG_TRACE(`Cancelling post event action ${firstActionName}@${firstLocation} with ${cancellingActionName}@${i}`);
                                    actionLocations[firstActionName] = undefined;
                                    arr[firstLocation] = null;
                                    arr[i] = null;
                                }
                                if (i < startIndex || !action) {
                                    LOG_TRACE(`Skip n/a action@${i}, start: ${startIndex}, action:`, action);
                                    return;
                                }
                                switch (action.type) {
                                  case emitEventActionType:
                                    switch (action.data) {
                                      case MessageConsumerEventName.UP:
                                      case MessageConsumerEventName.ACTIVE:
                                      case MessageConsumerEventName.RECONNECTED:
                                        actionLocations[action.data] = i;
                                        break;

                                      case MessageConsumerEventName.DOWN:
                                      case MessageConsumerEventName.DOWN_ERROR:
                                        //case MessageConsumerEventName.RECONNECTED: // I can't get this to work :-/
                                        cancelAction(MessageConsumerEventName.UP, action.data);
                                        break;

                                      case MessageConsumerEventName.INACTIVE:
                                        cancelAction(MessageConsumerEventName.ACTIVE, action.data);
                                        break;

                                      default:
                                        LOG_ERROR(`Unexpected event in post-event action: ${action.data}`);
                                        break;
                                    }
                                    break;

                                  case startDispatchActionType:
                                    actionLocations[action.type] = i;
                                    break;

                                  case stopDispatchActionType:
                                    cancelAction(startDispatchActionType, action.type);
                                    break;

                                  default:
                                    break;
                                }
                            });
                        }
                        function processPostEventActions() {
                            let preprocessedActions = 0;
                            let i;
                            // Now we've pre-processed the list, execute any remaining non-null entries.  We don't use a
                            // foreach loop since foreach won't include elements added after processing has started.  This
                            // can occur if a callback causes more postEventActions to be added.
                            LOG_TRACE("Executing post event action list", postEventActions);
                            for (i = 0; i < postEventActions.length; ++i) {
                                if (preprocessedActions < postEventActions.length) {
                                    preprocessPostEventActions(i);
                                    preprocessedActions = postEventActions.length;
                                }
                                const action = postEventActions[i];
                                LOG_TRACE(`Action ${i}:`, action);
                                if (!action) {
                                    continue;
                                }
                                switch (action.type) {
                                  case emitEventActionType:
                                    if (action.error !== undefined) {
                                        consumer._emit(action.data, action.error);
                                    } else {
                                        consumer._emit(action.data);
                                    }
                                    break;

                                  case stopDispatchActionType:
                                    // We don't actually do the stop here -- it is always done when this is enqueued.
                                    // The reason for enqueuing this event is to that it can cencel a startDispatch, if
                                    // present.
                                    break;

                                  case startDispatchActionType:
                                    this.requestStartDispatchFSM();
                                    break;

                                  default:
                                    LOG_ERROR(`Unhandled post event action type: ${action.type}`);
                                    break;
                                }
                            }
                            postEventActions = [];
                        }
                        function addPostEventAction(type, data, error) {
                            let newEvent;
                            if (data !== undefined) {
                                newEvent = {
                                    type: type,
                                    data: data,
                                    error: error
                                };
                            } else {
                                newEvent = {
                                    type: type
                                };
                            }
                            postEventActions.push(newEvent);
                            LOG_TRACE(`Added post event action ${postEventActions.length}:`, newEvent);
                            if (postEventActions.length === 1) {
                                fsm.setPostEventAction(processPostEventActions);
                            }
                        }
                        const addEventToEmit = (event, error) => {
                            if (!properties.activeIndicationEnabled) {
                                if (event === MessageConsumerEventName.INACTIVE || event === MessageConsumerEventName.ACTIVE) {
                                    LOG_TRACE(`Skip emitting ${event} due to disabled flow active indications`);
                                    return;
                                }
                            }
                            addPostEventAction(emitEventActionType, event, error);
                        };
                        const requestStartDispatch = () => {
                            addPostEventAction(startDispatchActionType);
                        };
                        const requestStopDispatch = () => {
                            // We do the stop inline, then add a post-event action so that it can have the effect of
                            // cancelling a previous start.  It will not execute the stop when processed however since we
                            // have already done it here.
                            this.requestStopDispatchFSM();
                            addPostEventAction(stopDispatchActionType);
                        };
                        this._addEventToEmit = addEventToEmit;
                        this._requestStartDispatch = requestStartDispatch;
                        this._requestStopDispatch = requestStopDispatch;
                        // End of post-event action infrastructure
                        // Utility functions
                        function emitBindFailed(error) {
                            assert(error instanceof OperationError);
                            consumer._emit(MessageConsumerEventName.CONNECT_FAILED_ERROR, error);
                        }
                        function emitRebindFailed(error) {
                            assert(error instanceof OperationError);
                            consumer._emit(MessageConsumerEventName.DOWN_ERROR, error);
                        }
                        function verifyEndpointSubscription(destination) {
                            let error = null;
                            if (destination) {
                                const subInfo = destination.getSubscriptionInfo();
                                if (subInfo && (subInfo.isShare || subInfo.isNoExport) && !fsm._sessionInterface.isCapable(CapabilityType.SHARED_SUBSCRIPTIONS)) {
                                    error = new OperationError("Shared Subscriptions not Supported", ErrorSubcode.SHARED_SUBSCRIPTIONS_NOT_SUPPORTED);
                                }
                            }
                            return error;
                        }
                        //**********************************************************************************************
                        // ChoicePoints on transitions.
                        // Not every transition is  unilateral. In some cases, particularly with session-up/flow-open
                        // we want to check the session capabilities, which will effect which transition is taken.
                        // The following choicePoints are NOT generic, they may only be used in the documented states
                        // to control the transition out of that state.
                        // ChoicePoints must return a new state (this.transitionTo())
                        //
                        // checkCapabiltiesChoicePoint - Check the session capabilities against the consumer properties.
                        // If all requested properties are supported by the session capabilties, transitionTo(BindSent).
                        // otherwise emitError and transitionTo unbound.
                        // Used in:  fsm.Unbound.AwaitFlowOpen
                        //           fsm.Unbound.AwaitSessionUp
                        //
                        function checkCapabilitiesChoicePoint(curState) {
                            let error = null;
                            if (fsm._replayStartLocation !== undefined && !fsm._sessionInterface.isCapable(CapabilityType.MESSAGE_REPLAY)) {
                                error = new OperationError("Message Replay Not Supported", ErrorSubcode.REPLAY_NOT_SUPPORTED);
                            } else if (properties.topicEndpointSubscription) {
                                error = verifyEndpointSubscription(properties.topicEndpointSubscription);
                            }
                            if (error) {
                                // Transition to Unbound means we wait for both SessionUp and flow open, which is rare.
                                // It makes sense here though, because the next session might be capable,
                                // but this one surely isn't.
                                // (and FLOW_DOWN is emitted, so we are waiting for both.)
                                return curState.transitionTo(fsm.Unbound, () => emitBindFailed(error));
                            }
                            // OK to bind
                            if (properties.createIfMissing && properties.queueDescriptor && properties.queueDescriptor.durable) {
                                return curState.transitionTo(fsm.CreateSent);
                            }
                            return curState.transitionTo(fsm.BindSent);
                        }
                        // End of ChoicePoints
                        //*********************************************************************************************
                        // FSM config
                        function handleAccidentalBind(msg) {
                            // Unbind with timout-recursion using flowid.
                            LOG_TRACE(`handleAccidentalBind mssg: ${msg}`);
                            const correlationTag = sessionInterface.getCorrelationTag();
                            const message = SMFLib.AdProtocolMessage.getCloseMessageConsumer(msg.flowId, correlationTag);
                            sessionInterface.sendControl(message);
                            sessionInterface.enqueueRequest(correlationTag, () => this.handleAccidentalBind(msg), properties.connectTimeoutInMsecs, null, null); //ignore response. Maybe log?
                        }
                        this.unhandledEventReaction(function onUnhandledEvent(event) {
                            switch (event.getName()) {
                              case ConsumerFSMEventNames.VIRTUALROUTER_NAME_CHANGED:
                                LOG_INFO("VirtualRouter name change: clearing all acknowledgement state");
                                fsm._resetRemoteConnectionState();
                                return this;

                              case ConsumerFSMEventNames.FLOW_UNBOUND:
                                LOG_INFO("Received unsolicited unbind. Flow may be manually reconnected.");
                                return this.transitionToUnbound(MessageConsumerEventName.DOWN_ERROR, event.details);

                              case ConsumerFSMEventNames.DISPOSE:
                                fsm._dispose();
                                return fsm.getCurrentState().terminate();

                              case ConsumerFSMEventNames.BIND_RESPONSE:
                                LOG_TRACE("Unhandled bind, assuming accidental BIND duplication");
                                handleAccidentalBind(event.details);
                                return this;

                              default:
                                LOG_TRACE(`Ignoring event ${event.getName()} in state ${this.getCurrentState().getName()}`);
                                return this;
                            }
                        });
                        this.initial(function onInitial() {
                            return this.transitionTo(fsm.Unbound, context => {
                                LOG_INFO(`Starting ${context.getStateMachine().getName()}`);
                            });
                        });
                        /*
      We don't transition directly from Unbound to BindSent.
      We need the following events:
       * FLOW_OPEN
       * SESSION_UP
      (The session ensures we get SESSION_UP or SESSION_UP_NO_AD if we are created
      and there is a session already up.)
      The Unbound base state implements transitions to its wait state children:
       * FLOW_OPEN -> AwaitSessionUp
       * SESSION_UP -> AwaitFlowOpen
      It also has the following transitions that pull the FSM out of its children
      and back to itself:
       * FLOW_CLOSE
       * SESSION_DOWN
      The child states can override these with internal transitions.
     */
                        this.Unbound = new State({
                            name: ConsumerStateNames.UNBOUND,
                            parentContext: fsm
                        }, {
                            emitDisabledEvent() {
                                consumer._emit(MessageConsumerEventName.GM_DISABLED);
                            }
                        }).reaction(ConsumerFSMEventNames.FLOW_CLOSE, function onFlowClose() {
                            return this.transitionTo(this);
                        }).reaction(ConsumerFSMEventNames.SESSION_DOWN, function onSessionDown() {
                            return this.transitionTo(this);
                        }).reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function onSesssionDisconnect() {
                            return this.transitionTo(this);
                        }).reaction(ConsumerFSMEventNames.FLOW_OPEN, function onFlowOpen() {
                            return this.transitionTo(fsm.Unbound.AwaitSessionUp); // Enter child state
                        }).reaction(ConsumerFSMEventNames.SESSION_UP, function onSessionUp() {
                            if (fsm._sessionInterface.isCapable(CapabilityType.GUARANTEED_MESSAGE_CONSUME)) {
                                return this.transitionTo(fsm.Unbound.AwaitFlowOpen); // Enter child state
                            }
                            LOG_WARN(`Consumer is not supported by router for this client on sessionId 0x${fsm._sessionInterface.sessionIdHex}`);
                            // Act as if the child state handled this
                            return this.internalTransition(() => this.emitDisabledEvent());
                        }).reaction(ConsumerFSMEventNames.SESSION_UP_NO_AD, function onSessionUpNoAD() {
                            // Act as if the child state handled this
                            return this.internalTransition(() => this.emitDisabledEvent());
                        }).exit(() => {
                            fsm._connectAttempts = properties.connectAttempts;
                        });
                        /*
      In this state, we have received FLOW_OPEN, but no SESSION_UP.
      SESSION_DOWN does not cancel this wait, so we must override the
      parent and explicitly do nothing.
    */
                        this.Unbound.AwaitSessionUp = new State({
                            name: ConsumerStateNames.UNBOUND_AWAIT_SESSION_UP,
                            parentContext: this.Unbound
                        }, {
                            emitBindWaiting() {
                                consumer._emit(PrivateFlowEventName.BIND_WAITING);
                            }
                        }).entry(function onEntry() {
                            this.emitBindWaiting();
                        }).reaction(ConsumerFSMEventNames.SESSION_DOWN, function onSessionDown() {
                            return this.internalTransition(); // Don't exit; continue waiting
                        }).reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function onSessionDown() {
                            return this.internalTransition(); // Don't exit; continue waiting
                        }).reaction(ConsumerFSMEventNames.SESSION_UP, function onSessionUp() {
                            return checkCapabilitiesChoicePoint(this);
                        });
                        /*
      In this state, we have received SESSION_UP but not FLOW_OPEN.
      If we get FLOW_OPEN, attempt to bind. Any other event is handled
      by the parent.
     */
                        this.Unbound.AwaitFlowOpen = new State({
                            name: ConsumerStateNames.UNBOUND_AWAIT_FLOWOPEN,
                            parentContext: this.Unbound
                        }).reaction(ConsumerFSMEventNames.FLOW_OPEN, function onFlowOpen() {
                            return checkCapabilitiesChoicePoint(this);
                        });
                        // Factored out the extension object from the State constructor for reuse in
                        // flow auto-reconnect sister-states.
                        this.BindSentExtensions = {
                            sendBindRequest() {
                                const correlationTag = sessionInterface.getCorrelationTag();
                                const transportAcks = fsm._transportAcks;
                                fsm._endpointEnsure();
                                const endpoint = fsm._endpoint;
                                const subscription = fsm._subscription;
                                const message = SMFLib.AdProtocolMessage.getOpenMessageConsumer(properties.queueDescriptor, properties.queueProperties, endpoint, subscription, correlationTag, properties.windowSize, properties.noLocal, properties.activeIndicationEnabled, transportAcks.lastAcked, transportAcks.lastReceived, properties.browser, fsm._replayStartLocation, consumer.endpointErrorId);
                                sessionInterface.sendControl(message);
                                sessionInterface.enqueueRequest(correlationTag, this.handleBindTimeout.bind(this), properties.connectTimeoutInMsecs, null, this.handleBindResponse.bind(this));
                                LOG_TRACE("Sent consumer bind request with arguments", [ properties.queueDescriptor, properties.queueProperties, endpoint, subscription, correlationTag, properties.windowSize, properties.noLocal, properties.activeIndicationEnabled, transportAcks.lastAcked, transportAcks.lastReceived, properties.browser, fsm._replayStartLocation, consumer.endpointErrorId ]);
                            },
                            cancelBindRequestTimer() {
                                LOG_TRACE("Cancelling bindRequestTimer.");
                                this.bindRequestTimer.cancel();
                            },
                            handleBindTimeout() {
                                LOG_INFO("Bind timeout");
                                fsm.processEvent(new ConsumerFSMEvent({
                                    name: ConsumerFSMEventNames.BIND_TIMEOUT
                                }));
                            },
                            handleExpectedBind(msg) {
                                const accessTypeOrDefault = x => x === undefined ? QueueAccessType.EXCLUSIVE : x;
                                const attrs = {
                                    lastMsgIdAcked: msg.getLastMsgIdAcked(),
                                    flowId: msg.getFlowId(),
                                    accessType: accessTypeOrDefault(msg.getAccessType()),
                                    topicEndpointBytes: msg.getTopicEndpointBytes(),
                                    grantedPermissions: msg.getGrantedPermissions(),
                                    allOthersPermissions: msg.getAllOthersPermissions(),
                                    respectsTTL: msg.getRespectsTTL(),
                                    activeFlow: msg.getActiveFlow(),
                                    wantFlowChangeNotify: msg.getWantFlowChangeNotify(),
                                    discardBehavior: msg.getQueueDiscardBehavior(),
                                    deliveryCountSent: msg.getEndpointDeliveryCountSent(),
                                    endpointId: msg.getEndpointId(),
                                    maxUnackedMessages: msg.getMaxUnackedMessages(),
                                    endpointErrorId: msg.getEndpointErrorId(),
                                    spoolerUniqueId: msg.getSpoolerUniqueId(),
                                    quota: msg.getQuota(),
                                    maxMsgSize: msg.getMaxMsgSize(),
                                    maxRedelivery: msg.getMaxRedelivery()
                                };
                                LOG_DEBUG("BIND response attributes:", attrs);
                                Object.assign(consumer, {
                                    accessType: attrs.accessType,
                                    queueDiscardBehavior: attrs.discardBehavior,
                                    deliveryCountSent: attrs.deliveryCountSent,
                                    endpointId: attrs.endpointId,
                                    respectsTTL: attrs.respectsTTL,
                                    flowId: attrs.flowId,
                                    permissions: attrs.grantedPermissions,
                                    wantFlowChangeNotify: attrs.wantFlowChangeNotify,
                                    endpointErrorId: attrs.endpointErrorId,
                                    spoolerUniqueId: attrs.spoolerUniqueId
                                });
                                if (fsm._sessionInterface.isCapable(CapabilityType.BR_REPLAY_ERRORID)) {
                                    consumer.endpointErrorId = attrs.endpointErrorId;
                                }
                                if (attrs.topicEndpointBytes && attrs.topicEndpointBytes.length) {
                                    attrs.endpoint = DestinationFromNetwork.createDestinationFromBytes(attrs.topicEndpointBytes);
                                    LOG_DEBUG("Overwriting local endpoint:", fsm._endpoint, "with remote:", attrs.endpoint);
                                    fsm._endpoint = attrs.endpoint;
                                    const consumerProperties = fsm._consumer._properties;
                                    consumerProperties.queueDescriptor = new QueueDescriptor({
                                        name: attrs.endpoint.name,
                                        type: consumerProperties.queueDescriptor.type,
                                        durable: consumerProperties.queueDescriptor.durable
                                    });
                                }
                                const consumerProperties = fsm._consumer._properties;
                                consumerProperties.queueProperties = new QueueProperties({
                                    respectsTTL: attrs.respectsTTL,
                                    permissions: attrs.allOthersPermissions,
                                    quotaMB: attrs.quota,
                                    maxMessageSize: attrs.maxMsgSize,
                                    discardBehavior: attrs.discardBehavior,
                                    maxMessageRedelivery: attrs.maxRedelivery,
                                    accessType: attrs.accessType
                                });
                                if (!consumerProperties.queueProperties.permissions) {
                                    consumerProperties.queueProperties.permissions = QueuePermissions.NONE;
                                }
                                Object.assign(fsm, {
                                    _active: attrs.activeFlow,
                                    _remoteWindowSize: attrs.maxUnackedMessages
                                });
                                if (Long.UZERO.eq(fsm._transportAcks.lastAcked)) {
                                    fsm._transportAcks.lastAcked = attrs.lastMsgIdAcked || Long.UZERO;
                                } else {
                                    LOG_DEBUG(`Retaining last acked/last received: ${fsm._transportAcks}`);
                                }
                                //return this.transitionTo(fsm.FlowUp);
                                //return fsm.processEvent(new ConsumerFSMEvent({ name: ConsumerFSMEventNames.FLOW_UP }));
                            },
                            handleBindResponse(msg) {
                                LOG_TRACE(`handleBindResponse called for message ${msg}`);
                                if (msg.msgType !== SMFLib.SMFAdProtocolMessageType.BIND) {
                                    LOG_INFO(`Unexpected message type in bind response: ${SMFLib.SMFAdProtocolMessageType.describe(msg.msgType)}`);
                                    return fsm.processEvent(new ConsumerFSMEvent({
                                        name: ConsumerFSMEventNames.FLOW_FAILED
                                    }, new OperationError(`Unexpected bind response: ${SMFLib.SMFAdProtocolMessageType.describe(msg.msgType)}`, ErrorSubcode.PROTOTOCOL_ERROR)));
                                }
                                const header = msg.smfHeader;
                                const responseCode = header.pm_respcode;
                                if (responseCode === null) {
                                    // Drop message and increment stats. Flow will time out
                                    this._consumer.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
                                    LOG_DEBUG(`Drop Open-Publisher-Flow Request message on sessionId 0x${this._sessionInterface.sessionIdHex}`);
                                    return undefined;
                                }
                                if (responseCode !== 200) {
                                    const description = header.pm_respstr;
                                    const errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode, description);
                                    LOG_INFO("Flow failed (bind):", responseCode, description, ErrorSubcode.describe(errorSubcode));
                                    LOG_DEBUG("subcode:", errorSubcode);
                                    return fsm.processEvent(new ConsumerFSMEvent({
                                        name: ConsumerFSMEventNames.FLOW_FAILED
                                    }, new OperationError(description, errorSubcode, {
                                        responseCode: responseCode
                                    })));
                                }
                                const respEvent = {
                                    name: ConsumerFSMEventNames.BIND_RESPONSE
                                };
                                return fsm.processEvent(new ConsumerFSMEvent(respEvent, msg));
                            }
                        };
                        this.BindSent = new State({
                            name: ConsumerStateNames.BIND_SENT,
                            parentContext: fsm
                        }, this.BindSentExtensions).entry(function onEntry() {
                            fsm._connectAttempts--;
                            this.sendBindRequest();
                            this.bindRequestTimer = Timer.newTimeout(properties.connectTimeoutInMsecs, this.handleBindTimeout);
                        }).reaction(ConsumerFSMEventNames.SESSION_DOWN, function onSessionDown() {
                            return this.transitionTo(fsm.Unbound.AwaitSessionUp);
                        }).reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function onSessionDown() {
                            return this.transitionTo(fsm.Unbound.AwaitSessionUp, () => fsm._addEventToEmit(MessageConsumerEventName.DOWN));
                        }).reaction(ConsumerFSMEventNames.FLOW_CLOSE, function onFlowClose() {
                            return this.transitionTo(fsm.UnbindSent);
                        }).reaction(ConsumerFSMEventNames.BIND_TIMEOUT, function onBindTimeout() {
                            LOG_TRACE(`Bind timeout, connectAttempts left: ${fsm._connectAttempts}`);
                            if (fsm._connectAttempts > 0) {
                                return this.externalTransitionTo(fsm.BindSent);
                            }
                            return this.transitionTo(fsm.Unbound.AwaitFlowOpen, () => emitBindFailed(new OperationError("Bind failed due to timeout", ErrorSubcode.TIMEOUT)));
                        }).reaction(ConsumerFSMEventNames.FLOW_FAILED, function onFlowFailed(evt) {
                            // Act like a newly created flow
                            return this.transitionTo(fsm.Unbound.AwaitFlowOpen, () => emitBindFailed(evt.details));
                        }).reaction(ConsumerFSMEventNames.BIND_RESPONSE, function onBindResponse(event) {
                            this.handleExpectedBind(event.details);
                            //return this;
                            return this.transitionTo(fsm.FlowUp);
                        }).reaction(ConsumerFSMEventNames.FLOW_UP, function onFlowUp() {
                            return this.transitionTo(fsm.FlowUp);
                        }).exit(function onExit() {
                            this.cancelBindRequestTimer();
                        });
                        this.Reconnecting = new State({
                            name: ConsumerStateNames.RECONNECTING,
                            parentContext: fsm
                        }).entry(function onEntry() {
                            LOG_TRACE("RECONNECTING onEntry: emitting RECONNECTING, resetting attempt counters");
                            LOG_TRACE(`this._errorCausingReconnect: ${this._errorCausingReconnect}`);
                            LOG_TRACE(`fsm._errorCausingReconnect: ${fsm._errorCausingReconnect}`);
                            consumer._emit(MessageConsumerEventName.RECONNECTING, fsm._errorCausingReconnect);
                            fsm._connectAttempts = properties.connectAttempts;
                            fsm.reconnectAttempts = properties.reconnectAttempts;
                        }).initial(function onInitial() {
                            return this.transitionTo(fsm.Reconnecting.RBindSent);
                        }).reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function onSessionDown() {
                            return this.transitionTo(fsm.Reconnecting.RAwaitSessionUp);
                        }).reaction(ConsumerFSMEventNames.SESSION_DOWN, function onSessionDown() {
                            return this.transitionTo(fsm.Reconnecting.RAwaitSessionUp);
                        });
                        this.Reconnecting.RAwaitSessionUp = new State({
                            name: ConsumerStateNames.RECONNECTING_AWAIT_SESSION_UP,
                            parentContext: this.Reconnecting
                        }).reaction(ConsumerFSMEventNames.SESSION_UP, function onSessionUp() {
                            fsm._connectAttempts = properties.connectAttempts;
                            return this.transitionTo(fsm.Reconnecting.RBindSent);
                        });
                        this.Reconnecting.RBindSent = new State({
                            name: ConsumerStateNames.RECONNECTING_BIND_SENT,
                            parentContext: this.Reconnecting
                        }, this.BindSentExtensions).entry(function onEntry() {
                            fsm._connectAttempts--;
                            this.sendBindRequest();
                            this.bindRequestTimer = Timer.newTimeout(properties.connectTimeoutInMsecs, this.handleBindTimeout);
                        }).reaction(ConsumerFSMEventNames.FLOW_CLOSE, function onFlowClose() {
                            // TODO: This is probably wrong in the original state machine too:
                            // flowid is either missing or stale. Keeping it the same as there for now.
                            return this.transitionTo(fsm.UnbindSent);
                        }).reaction(ConsumerFSMEventNames.BIND_TIMEOUT, function onBindTimeout() {
                            LOG_TRACE(`Bind timeout during reconnect, connectAttempts left: ${fsm._connectAttempts}`);
                            if (fsm._connectAttempts > 0) {
                                return this.externalTransitionTo(fsm.Reconnecting.RBindSent);
                            }
                            // Running out of rebinds is a non rebindable failure, so break the reconect loop.
                            LOG_TRACE("Running out of rebinds is a non rebindable failure, so break the reconect loop.");
                            return this.transitionTo(fsm.Unbound.AwaitFlowOpen, () => emitBindFailed(new OperationError("Rebind failed due to timeout", ErrorSubcode.TIMEOUT)));
                        }).reaction(ConsumerFSMEventNames.FLOW_FAILED, function onFlowFailed(evt) {
                            // These three reconnect-errors are "rebindable",
                            // anything else breaks the reconnect loop.
                            if (fsm.reconnectAttempts > 0 || fsm.reconnectAttempts === -1) {
                                if (evt && evt.details && evt.details.subcode) {
                                    if (evt.details.subcode === ErrorSubcode.QUEUE_SHUTDOWN || evt.details.subcode === ErrorSubcode.TOPIC_ENDPOINT_SHUTDOWN || evt.details.subcode === ErrorSubcode.GM_UNAVAILABLE) {
                                        LOG_TRACE(`ReconnectAttempts left: ${fsm.reconnectAttempts} subcode: ${evt.details.subcode}, giving it another shot.`);
                                        return this.transitionTo(fsm.Reconnecting.RAwaitTimer);
                                    }
                                } else {
                                    LOG_DEBUG(`Hmm, no subcode in FLOW_FAILED? ${evt}`);
                                }
                            } else {
                                LOG_TRACE(`Ran out of reconnectAttempts: ${fsm.reconnectAttempts}`);
                            }
                            return this.transitionTo(fsm.Unbound.AwaitFlowOpen, () => emitRebindFailed(evt.details));
                        }).reaction(ConsumerFSMEventNames.BIND_RESPONSE, function onBindResponse(event) {
                            this.handleExpectedBind(event.details);
                            //return this;
                            return this.transitionTo(fsm.FlowUp, () => fsm._addEventToEmit(MessageConsumerEventName.RECONNECTED));
                        }).reaction(ConsumerFSMEventNames.FLOW_UP, function onFlowUp() {
                            return this.transitionTo(fsm.FlowUp, () => fsm._addEventToEmit(MessageConsumerEventName.RECONNECTED));
                            //() => consumer._emit(MessageConsumerEventName.RECONNECTING));
                        }).exit(function onExit() {
                            this.cancelBindRequestTimer();
                        });
                        this.Reconnecting.RAwaitTimer = new State({
                            name: ConsumerStateNames.RECONNECTING_AWAIT_TIMER,
                            parentContext: this.Reconnecting
                        }, {
                            handleReconnectIntervalTimeout() {
                                LOG_DEBUG("Reconnect interval timeout (expected)");
                                fsm.processEvent(new ConsumerFSMEvent({
                                    name: ConsumerFSMEventNames.RECONNECT_INTERVAL_TIMEOUT
                                }));
                            },
                            cancelReconnectIntervalTimer() {
                                this.reconnectIntervalTimer.cancel();
                            }
                        }).entry(function onEntry() {
                            if (fsm.reconnectAttempts > 0) {
                                --fsm.reconnectAttempts;
                            }
                            LOG_TRACE(`Setting up timer for ${properties.reconnectIntervalInMsecs}. reconnectAttempts left: ${fsm.reconnectAttempts}`);
                            this.reconnectIntervalTimer = Timer.newTimeout(properties.reconnectIntervalInMsecs, this.handleReconnectIntervalTimeout);
                        }).exit(function onExit() {
                            this.cancelReconnectIntervalTimer();
                        }).reaction(ConsumerFSMEventNames.RECONNECT_INTERVAL_TIMEOUT, function onTimeout() {
                            fsm._connectAttempts = properties.connectAttempts;
                            return this.transitionTo(fsm.Reconnecting.RBindSent);
                        });
                        const flowUpFSM = this.FlowUp = new State({
                            name: ConsumerStateNames.FLOW_UP,
                            parentContext: fsm
                        }).initial(function onInitial() {
                            return this.transitionTo(fsm._active === 0 ? flowUpFSM.XferInactive : flowUpFSM.Xfer);
                        }).entry(() => {
                            fsm._replayStartLocation = undefined; //SOL-12945: only replay once.
                            // This is ugly, but I can't coerce the post event action queue to work with me:
                            // RECONNECTING should suppress UP.
                            if (!fsm._errorCausingReconnect) {
                                LOG_TRACE("Emittging UP, because there is no errorCausingReconnect");
                                fsm._addEventToEmit(MessageConsumerEventName.UP);
                            } else {
                                LOG_TRACE("Not emittging UP, because there is errorCausingReconnect");
                                fsm._errorCausingReconnect = null;
                            }
                        }).reaction(ConsumerFSMEventNames.SESSION_DOWN, function onSessionDown() {
                            return this.transitionTo(fsm.Unbound.AwaitSessionUp);
                        }).reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function onSessionDisconnect() {
                            return this.transitionTo(fsm.Unbound.AwaitSessionUp, () => fsm._addEventToEmit(MessageConsumerEventName.DOWN));
                        }).reaction(ConsumerFSMEventNames.FLOW_CLOSE, function onFlowClose() {
                            // Acks will be sent by UnbindSent
                            return this.transitionTo(fsm.UnbindSent);
                        }).reaction(ConsumerFSMEventNames.FLOW_UNBOUND, event => 
                        // Acks will be sent by UnbindSent
                        fsm.transitionToUnboundFromUp(properties, MessageConsumerEventName.DOWN_ERROR, event.details));
                        flowUpFSM.Xfer = new State({
                            name: ConsumerStateNames.FLOW_UP_XFER,
                            parentContext: flowUpFSM
                        }).entry(() => {
                            fsm._addEventToEmit(MessageConsumerEventName.ACTIVE);
                            fsm._sendAcks(true);
                            fsm._requestStartDispatch();
                        }).exit(() => {
                            fsm._addEventToEmit(MessageConsumerEventName.INACTIVE);
                            fsm._requestStopDispatch();
                        }).reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function onSessionDown() {
                            fsm._sendAcks(true); // send acks, then...
                            return this.eventUnhandled(); // let the parent state handle the remaining steps.
                        });
                        flowUpFSM.XferInactive = new State({
                            name: ConsumerStateNames.FLOW_UP_XFER_INACTIVE,
                            parentContext: flowUpFSM
                        }).reaction(ConsumerFSMEventNames.FLOW_ACTIVE_IND, function onFlowActiveIndication() {
                            return this.transitionTo(flowUpFSM.Xfer);
                        });
                        this.UnbindSent = new State({
                            name: ConsumerStateNames.UNBIND_SENT,
                            parentContext: fsm
                        }, {
                            sendUnbindRequest() {
                                // Don't do this on entry to UNBIND, do it when the user
                                // wants to unbind
                                fsm._endpointClear();
                                try {
                                    const correlationTag = sessionInterface.getCorrelationTag();
                                    const message = SMFLib.AdProtocolMessage.getCloseMessageConsumer(consumer.flowId, correlationTag);
                                    sessionInterface.sendControl(message);
                                    sessionInterface.enqueueRequest(correlationTag, () => this.handleUnbindTimeout(), properties.connectTimeoutInMsecs, null, response => this.handleUnbindResponse(response));
                                    LOG_INFO("Sent consumer unbind request with arguments", {
                                        flowId: consumer.flowId,
                                        correlationTag: correlationTag
                                    });
                                } catch (e) {
                                    LOG_INFO(`Exception in sendUnbindRequest while trying to send unbind request: ${e}`);
                                    LOG_DEBUG(`Session (${sessionInterface.getCurrentStateName()}) assumed lost before flow unbind could be sent. Considering this flow unbound.`);
                                    fsm.processEvent(new ConsumerFSMEvent({
                                        name: ConsumerFSMEventNames.FLOW_UNBOUND
                                    }));
                                }
                            },
                            handleUnbindTimeout() {
                                LOG_INFO("Unbind timeout");
                                return fsm.processEvent(new ConsumerFSMEvent({
                                    name: ConsumerFSMEventNames.UNBIND_TIMEOUT
                                }));
                            },
                            handleUnbindResponse(msg) {
                                if (msg.msgType !== SMFLib.SMFAdProtocolMessageType.UNBIND) {
                                    LOG_INFO(`Unexpected message type in bind response: ${SMFLib.SMFAdProtocolMessageType.describe(msg.msgType)}`);
                                }
                                const responseCode = msg.smfHeader.pm_respcode;
                                const description = msg.smfHeader.pm_respstr;
                                const errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode, description);
                                consumer.endpointErrorId = msg.getEndpointErrorId();
                                LOG_INFO("Flow failed (unbind):", responseCode, description, ErrorSubcode.describe(errorSubcode));
                                return fsm.processEvent(new ConsumerFSMEvent({
                                    name: ConsumerFSMEventNames.FLOW_UNBOUND
                                }, new OperationError(description, errorSubcode, responseCode)));
                            }
                        }).entry(function onEntry() {
                            this.sendUnbindRequest();
                        }).reaction(ConsumerFSMEventNames.UNBIND_TIMEOUT, function onUnbindTimeout() {
                            return this.externalTransitionTo(fsm.UnbindSent);
                        }).reaction(ConsumerFSMEventNames.FLOW_UNBOUND, () => fsm.transitionToUnbound(MessageConsumerEventName.DOWN));
                        this.CreateSent = new State({
                            name: ConsumerStateNames.CREATE_SENT,
                            parentContext: fsm
                        }, {
                            sendCreateRequest() {
                                const correlationTag = sessionInterface.getCorrelationTag();
                                const message = SMFLib.AdProtocolMessage.getCreate(properties.queueDescriptor, properties.queueProperties, correlationTag);
                                sessionInterface.sendControl(message);
                                sessionInterface.enqueueRequest(correlationTag, this.handleCreateTimeout.bind(this), properties.connectTimeoutInMsecs, null, this.handleCreateResponse.bind(this));
                            },
                            handleCreateTimeout() {
                                LOG_INFO("Create timeout");
                                fsm.processEvent(new ConsumerFSMEvent({
                                    name: ConsumerFSMEventNames.CREATE_TIMEOUT
                                }));
                            },
                            handleCreateResponse(msg) {
                                LOG_TRACE(`handleCreateResponse called for message ${msg}`);
                                if (msg.msgType !== SMFLib.SMFAdProtocolMessageType.CREATE) {
                                    LOG_INFO(`Unexpected message type in create response: ${SMFLib.SMFAdProtocolMessageType.describe(msg.msgType)}`);
                                    return fsm.processEvent(new ConsumerFSMEvent({
                                        name: ConsumerFSMEventNames.CREATE_FAILED
                                    }, new OperationError(`Unexpected create response: ${SMFLib.SMFAdProtocolMessageType.describe(msg.msgType)}`, ErrorSubcode.PROTOTOCOL_ERROR)));
                                }
                                const header = msg.smfHeader;
                                const responseCode = header.pm_respcode;
                                if (responseCode !== 200) {
                                    const description = header.pm_respstr;
                                    const errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode, description);
                                    LOG_INFO("Endpoint create failed:", responseCode, description, ErrorSubcode.describe(errorSubcode));
                                    LOG_DEBUG("subcode:", errorSubcode);
                                    if (errorSubcode === ErrorSubcode.ENDPOINT_ALREADY_EXISTS) {
                                        LOG_TRACE("subcode recognized as ALREADY EXISTS:", errorSubcode);
                                        const respEvent = {
                                            name: ConsumerFSMEventNames.CREATE_SUCCESS
                                        };
                                        return fsm.processEvent(new ConsumerFSMEvent(respEvent, msg));
                                    }
                                    LOG_TRACE("subcode not recognized as ALREADY EXISTS:", errorSubcode);
                                    return fsm.processEvent(new ConsumerFSMEvent({
                                        name: ConsumerFSMEventNames.CREATE_FAILED
                                    }, new OperationError(description, errorSubcode, {
                                        responseCode: responseCode
                                    })));
                                }
                                const respEvent = {
                                    name: ConsumerFSMEventNames.CREATE_SUCCESS
                                };
                                return fsm.processEvent(new ConsumerFSMEvent(respEvent, msg));
                            }
                        }).entry(function onEntry() {
                            //send create request
                            this.sendCreateRequest();
                        }).reaction(ConsumerFSMEventNames.CREATE_TIMEOUT, function onCreateTimeout() {
                            LOG_DEBUG("Create timeout, just moving on to bind and hoping for the best.");
                            return this.externalTransitionTo(fsm.BindSent);
                        }).reaction(ConsumerFSMEventNames.CREATE_SUCCESS, function onCreateSuccess() {
                            return this.externalTransitionTo(fsm.BindSent);
                        }).reaction(ConsumerFSMEventNames.CREATE_FAILED, function onCreateFailed(evt) {
                            // "queue exists" should be noticed in the response handler and emit CREATE_SUCCESS.:
                            return this.transitionTo(fsm.Unbound.AwaitFlowOpen, () => emitBindFailed(evt.details));
                        });
                    }
                    /**
   *
   * @param {solace.Message} message The message being accepted by the flow.
   * @returns {Boolean} True if the message was accepted.
   * @private
   */
                    acceptMessage(message) {
                        const {
                            LOG_TRACE,
                            LOG_DEBUG
                        } = this.logger;
                        const messageID = message.getGuaranteedMessageId();
                        const idstr = messageID.toString();
                        const consumer = this._consumer;
                        if (!this._fsmDispatch) {
                            // We're disconnecting. Drop the message.
                            LOG_TRACE("Dropping message because this flow cannot acknowledge it");
                            consumer.incStat(StatType.RX_DISCARD_NO_MATCHING_CONSUMER);
                            return false;
                        }
                        //Booby trap getDeliveryCount() on the message if the flow doesn't support it:
                        if (!consumer.deliveryCountSent) {
                            message.setDeliveryCount(-1);
                        }
                        // SMF flow suid can be updated via data message if there is a
                        // header parameter containing the suid. All subsequent data messages
                        // without suid must have the stored Flow suid set on data message.
                        //
                        // Update flow with message suid if and only if there was an initialized
                        // suid from the flow bind response.
                        // There is a legacy router case where suid are passed opaquely through the
                        // network of brokers on the message. In the case where a suid is present
                        // on a message without a suid on the bind response this indicates the suid
                        // is not an update to subsequent messages suid values. As the current broker
                        // connected does not support suid generation or assignment.
                        //
                        // Note a spooler unique id is only set if the message SMF
                        // contained the SpoolerUniqueId header parameter.
                        // See decode for details.
                        const messageSuid = message._getSpoolerUniqueId();
                        if (RgmidFactory.INVALID_SUID.eq(messageSuid)) {
                            // set the message suid value to stored consumer suid value
                            message._setSpoolerUniqueId(consumer.spoolerUniqueId);
                        } else if (consumer.spoolerUniqueId !== undefined && !RgmidFactory.INVALID_SUID.eq(consumer.spoolerUniqueId)) {
                            // otherwise update the consumer with new suid value if consumer suid was initialized
                            const consumerSuidStr = consumer.spoolerUniqueId.toString();
                            const msgSuidStr = messageSuid.toString();
                            LOG_DEBUG("Updating Consumer message spoolerUniqueId from ", consumerSuidStr, " to ", msgSuidStr);
                            consumer.spoolerUniqueId = messageSuid;
                        } else if ((consumer.spoolerUniqueId === undefined || RgmidFactory.INVALID_SUID.eq(consumer.spoolerUniqueId)) && !RgmidFactory.INVALID_SUID.eq(messageSuid)) {
                            // clear the message spooler unique id on flows without initial spooler
                            // unique id as rmid is not supported
                            message._setSpoolerUniqueId(RgmidFactory.INVALID_SUID);
                        }
                        const transportAcks = this._transportAcks;
                        const ackResult = transportAcks.tryReceive(messageID, message.getGuaranteedPreviousMessageId());
                        const transportAckRequired = transportAcks.acksPending > this.maxPendingAcks;
                        switch (ackResult) {
                          case TransportAckResult.OK:
                            break; // carry on

                          case TransportAckResult.DUPLICATE:
                            consumer.incStat(StatType.RX_DISCARD_DUPLICATE);
                            // Two options here: could check membership in the ringbuffer,
                            // or could check whether the ID is less than ringbuffer.front().
                            // Untested assumption: arithmetic comparison on boxed Long at front()
                            // is more computationally expensive than native Map() lookup.
                            if (!this._applicationAcks.has(messageID) && !this._oldUnacked.has(idstr)) {
                                LOG_TRACE("Will application ack unknown duplicate ID", idstr);
                                this._sendAck([ [ messageID, messageID ] ]);
                            } else if (transportAckRequired) {
                                this._sendAcks(transportAckRequired);
                            } else {
                                // if we are receiving dups we should make sure we send
                                // and ack in case we don't receive any non duplicates
                                // and we don't receive enough duplicates to exceed
                                // maxPendingAcks.  Eventually we would but only after
                                // the  router retransmitted many times.
                                this._setTransportAckTimer();
                            }
                            return false;

                          case TransportAckResult.OUT_OF_ORDER:
                            consumer.incStat(StatType.RX_DISCARD_OUT_OF_ORDER);
                            return false;

                          default:
                            assert(false, "Unhandled transport ack result", ackResult);
                            return false;
                        }
                        return this._applicationAcks.insert(messageID, evicting => {
                            let applicationAckRequired = false;
                            if (evicting) {
                                switch (evicting.state) {
                                  case ApplicationAckState.UNACKED:
                                    this._oldUnacked.add(evicting.key);
                                    break;

                                  case ApplicationAckState.ACKED_NOT_SENT:
                                    applicationAckRequired = true;
                                    break;

                                  case ApplicationAckState.ACKED_SENT:
                                    // OK to evict
                                    break;

                                  default:
                                    assert(false, "Unhandled application ack state", ApplicationAckState.describe(evicting.state));
                                }
                            }
                            this._midDispatch = true;
                            this._messageDispatch.push(message);
                            this._midDispatch = false;
                            if (transportAckRequired || applicationAckRequired) {
                                LOG_TRACE("Need to send acks:", "transport", transportAckRequired, "application", applicationAckRequired);
                                this._sendAcks(transportAckRequired);
                            } else {
                                this._setTransportAckTimer();
                            }
                            return true;
                        });
                    }
                    applicationAck(messageId) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        const idstr = messageId.toString();
                        this._consumer.incStat(StatType.RX_ACKED);
                        // Was the message old, and demoted to _oldUnacked?
                        if (this._oldUnacked.delete(idstr)) {
                            // True if idstr was member
                            // It was old. Ack immediatesly.
                            LOG_TRACE("Application acking old message immediately");
                            this._sendAck([ [ messageId, messageId ] ]);
                            return;
                        }
                        // We can't regress the ack_state this way; message.acknowledge() throws if called
                        // more than once.
                        this._applicationAcks.updateAckState(messageId, ApplicationAckState.ACKED_NOT_SENT);
                        this._setTransportAckTimer();
                    }
                    getDestination() {
                        this._endpointEnsure();
                        return this._destination;
                    }
                    isDisconnected() {
                        if (!this.getCurrentState()) return true;
                        return this.getActiveState(ConsumerStateNames.UNBOUND) || this.getActiveState(ConsumerStateNames.UNBOUND_AWAITING_FLOWOPEN);
                    }
                    requestStartDispatchUser() {
                        this._userDispatch = true;
                        this.applyStartDispatch();
                    }
                    requestStartDispatchFSM() {
                        this._fsmDispatch = true;
                        this.applyStartDispatch();
                    }
                    applyStartDispatch() {
                        if (this._userDispatch && this._fsmDispatch) {
                            this.log(`Starting message dispatch (fsm ${this._fsmDispatch}, user ${this._userDispatch})`);
                            this._messageDispatch.start();
                            this._localMaxWindowSize = this._localPreferredWindowSize;
                            this._sendAcks(true);
                        } else {
                            this.log(`Not starting message dispatch (fsm ${this._fsmDispatch}, user ${this._userDispatch})`);
                        }
                    }
                    transitionToUnbound(eventName, error) {
                        const consumer = this._consumer;
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Flow down, user disconnected?", consumer.userDisconnected);
                        return this.transitionTo(this.Unbound.AwaitFlowOpen, () => this._addEventToEmit(eventName, error));
                    }
                    transitionToUnboundFromUp(properties, eventName, error) {
                        const consumer = this._consumer;
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Choice point for FLOW_UNBOUND in FlowUp state.");
                        // Always clear duplicate filter state on "Replay started"
                        // (no way to maintain it and drop the replayed messages as duplicates)
                        if (error && error instanceof OperationError && error.subcode) {
                            if (error.subcode === ErrorSubcode.REPLAY_STARTED) {
                                // "this" is the fsm.
                                this._transportAcks.reset();
                                this._applicationAcks.reset();
                            }
                        }
                        if (consumer.endpointErrorId && this._sessionInterface.isCapable(CapabilityType.MESSAGE_REPLAY)) {
                            LOG_TRACE(`Acking unsolicited unbind with endpointErrorId ${consumer.endpointErrorId}`);
                            const unbindAck = SMFLib.AdProtocolMessage.getUnbindAck(consumer._flowId, consumer.endpointErrorId, this._transportAcks.lastAcked);
                            this._sessionInterface.sendControl(unbindAck); // Must succeed or throw
                        }
                        if (properties.reconnectAttempts === -1 || properties.reconnectAttempts > 0) {
                            if (error && error instanceof OperationError && error.subcode) {
                                if (error.subcode === ErrorSubcode.REPLAY_STARTED || error.subcode === ErrorSubcode.GM_UNAVAILABLE) {
                                    LOG_TRACE(`Saving errorCausingReconnect: ${error}`);
                                    this._errorCausingReconnect = error;
                                    // Reconnecting state emits the RECONNECTING event.
                                    return this.transitionTo(this.Reconnecting);
                                }
                            }
                        } //else: flow reconnect feature disabled, or not applicable.
                        return this.transitionTo(this.Unbound.AwaitFlowOpen, () => this._addEventToEmit(eventName, error));
                    }
                    requestStopDispatchUser() {
                        this._userDispatch = false;
                        this.log(`Stop dispatch user (fsm ${this._fsmDispatch}, user ${this._userDispatch})`);
                        this._messageDispatch.stop();
                    }
                    requestStopDispatchFSM() {
                        this._fsmDispatch = false;
                        this.log(`Stop dispatch FSM (fsm ${this._fsmDispatch}, user ${this._userDispatch})`);
                        this._sendAcks(true);
                    }
                    _clearTransportAckTimer() {
                        if (!this._transportAckTimer) return;
                        clearTimeout(this._transportAckTimer);
                        this._transportAckTimer = null;
                    }
                    _dispose() {
                        this._clearTransportAckTimer();
                        this._endpointClear();
                        this._destination = undefined;
                        this._unacked = null;
                        this._messageDispatch = null;
                        this._transportAcks = null;
                        this._consumer = null;
                        this._sessionInterface = null;
                    }
                    _endpointClear() {
                        this._endpoint = undefined;
                        this._subscription = undefined;
                    }
                    _endpointEnsure() {
                        if (this._endpoint) {
                            // The endpoint, destination and any possible topic subscription are generated
                            // at the same time. Use the presence of the endpoint to determine whether
                            // any of this has already been done.
                            return;
                        }
                        const sessionInterface = this._sessionInterface;
                        const properties = this._consumer._properties;
                        const {
                            queueDescriptor
                        } = properties;
                        let destination;
                        let endpoint;
                        let subscription;
                        if (queueDescriptor.type === QueueType.QUEUE) {
                            // The publish destination needs a prefix. Create a destination from
                            // the descriptor, then derive the endpoint name from that.
                            destination = sessionInterface.createDestinationFromDescriptor(queueDescriptor);
                            // The bind target is the queue name encoded as though a topic -- no prefix
                            // Use the offset information to build a bind target
                            endpoint = new Queue({
                                name: destination.name,
                                type: DestinationType.QUEUE,
                                offset: 0,
                                bytes: destination.bytes.substr(destination.offset)
                            });
                            subscription = undefined;
                        } else {
                            // QueueType.TOPIC_ENDPOINT
                            endpoint = queueDescriptor.name ? sessionInterface.createDestinationFromDescriptor(queueDescriptor) : new Topic({
                                name: "\0?",
                                offset: 0,
                                bytes: "\0"
                            });
                            subscription = properties.topicEndpointSubscription || sessionInterface.createTemporaryDestination(DestinationType.TOPIC);
                            destination = subscription;
                        }
                        // Using Object.assign to enforce the invariant that these three properties are set together
                        // or not at all.
                        Object.assign(this, {
                            _destination: destination,
                            _endpoint: endpoint,
                            _subscription: subscription
                        });
                        // Update the properties object (if TTMP, we may modify it again)
                        properties.queueDescriptor = new QueueDescriptor({
                            name: endpoint.name,
                            type: queueDescriptor.type,
                            durable: queueDescriptor.durable
                        });
                    }
                    _resetLocalConnectionState() {
                        Object.assign(this, {
                            _remoteWindowSize: 0,
                            _active: undefined,
                            _fsmDispatch: false,
                            _userDispatch: true
                        });
                    }
                    _resetRemoteConnectionState() {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Initializing transport acks");
                        this._transportAcks = new TransportAcks();
                        LOG_TRACE("Initializing application acks");
                        this._applicationAcks = new ApplicationAckRingBuffer(RING_BUFFER_SIZE);
                        this._oldUnacked = new Set();
                        LOG_TRACE("Initializing endpointErrorId");
                        this._consumer.endpointErrorId = undefined;
                    }
                    /**
   * Sends a single ack.
   *
   * @param {Array.<ackpair>} applicationAcks The application ack ranges to send
   * @memberof ConsumerFSM
   * @private
   */
                    _sendAck(applicationAcks) {
                        const transportAck = SMFLib.AdProtocolMessage.getAck(this._consumer.flowId, this._transportAcks.lastReceived, this.windowSize, applicationAcks);
                        this._sessionInterface.sendControl(transportAck); // Must succeed or throw
                    }
                    /**
   * Adds the current ack ranges to an accumulator. Call this for each applicationAck.
   * When a range ends (we receive an unacked), or we are explictly flushing
   * (applicationAck === null), we convert the accumulator to acks, send them, update state,
   * and reset accumulators.
   *
   * This should be called at least once with the last invocation having ackRange = null.
   * This invokes the flush path, which is necessary if any ranges were in progress,
   * and this is the only path that repects the forceTransportAck flag.
   *
   * @param {Object} acksPendingState State associated with this activity
   * @param {ApplicationAck} applicationAck The ack to process for ack ranges.
   *    If `null`, any pending acks are flushed and a transport ack is sent, if
   *    required.
   * @private
   */
                    _addAckToRanges(acksPendingState, applicationAck = null) {
                        const currentRange = acksPendingState.currentRange;
                        const ackRanges = acksPendingState.ackRanges;
                        if (applicationAck && applicationAck.state !== ApplicationAckState.UNACKED) {
                            currentRange.push(applicationAck);
                            return; // Wait for end of range or flush
                        }
                        // We received an UNACKED or a null ack (flush). Complete this range.
                        if (currentRange.length) {
                            ackRanges.push(currentRange);
                        }
                        // If we're flushing or we've hit the protocol limit for ranges in a single ack,
                        // we send ack messages, update ack states and clear the accumulator.
                        // This condition will be true at least once (must flush at the end).
                        if (applicationAck === null || ackRanges.length === SMFLib.AdProtocolMessage.MAX_CLIENT_ACK_RANGES) {
                            // Reduce each range to a first and last ID.
                            const bareRanges = ackRanges.map(range => [ range[0].id, range[range.length - 1].id ]);
                            if (bareRanges.length || acksPendingState.forceTransportAck) {
                                // We send the ranges. This could throw.
                                const {
                                    LOG_TRACE
                                } = this.logger;
                                this._sendAck(bareRanges);
                                // Warning: this log statement reduces debug performance by 25%!
                                LOG_TRACE("Sent ack: ", `Transport ack: ${this._transportAcks.lastReceived}`, `Application acks: ${bareRanges.length ? bareRanges.map(g => `[${g[0]}..${g[1]}]`) : "[]"}`);
                                // If the intent was to force a transport ack, that condition is fulfilled.
                                this._transportAcks.setAcked();
                                acksPendingState.forceTransportAck = false;
                            }
                            // Since the range send succeeded, update the ack states.
                            ackRanges.forEach(ackRange => {
                                ackRange.forEach(ack => {
                                    if (ack.state !== ApplicationAckState.ACKED_SENT) {
                                        try {
                                            this._applicationAcks.updateAckState(ack.id, ApplicationAckState.ACKED_SENT);
                                        } catch (e) {
                                            const {
                                                LOG_ERROR
                                            } = this.logger;
                                            LOG_ERROR(`Marking ack ${ack.id} as sent failed: ${e}`);
                                        }
                                    }
                                });
                            });
                            // Clear the main accumulator since it has hit the wire.
                            acksPendingState.ackRanges = [];
                        }
                        // Clear the accumulator for this range.
                        acksPendingState.currentRange = [];
                    }
                    /**
   * Sends acknowledgements, along with a window update for this flow.
   *
   * @param {Boolean} forceTransportAck `true` sends transport ack even if no acks pending
   * @private
   */
                    _sendAcks(forceTransportAck = false) {
                        this._clearTransportAckTimer();
                        const applicationAcks = this._applicationAcks;
                        const transportAcks = this._transportAcks;
                        // This state is temporary and shared with the ack generating function.
                        const acksPendingState = {
                            forceTransportAck: forceTransportAck || transportAcks.acksPending > 0,
                            ackRanges: [],
                            currentRange: []
                        };
                        // If the first ringbuffer ack state is acked and there are no unacked before this,
                        // we can create an ack range that includes zero.
                        // If the first ringbuffer ack state is unacked, we can say nothing about the
                        // range before the first acked ID in the ringbuffer.
                        const front = this._applicationAcks.front();
                        if (this._oldUnacked.size === 0 && front && front.state !== ApplicationAckState.UNACKED) {
                            // State is acked_sent so we don't try to update the ring buffer.
                            this._addAckToRanges(acksPendingState, ZERO_APP_ACK);
                            // We know that front will be added to this range by the iteration.
                        }
                        // Build ack ranges using the accumulator
                        applicationAcks.forEach(ack => this._addAckToRanges(acksPendingState, ack));
                        // Flush the last pending ack range.
                        this._addAckToRanges(acksPendingState);
                        // On successful exit, we've sent and cleared all accumulators, and we've sent
                        // a transport ack if we were supposed to do that.
                        assert(acksPendingState.forceTransportAck === false);
                        assert(acksPendingState.currentRange.length === 0);
                        assert(acksPendingState.ackRanges.length === 0);
                    }
                    _setTransportAckTimer() {
                        if (this._transportAckTimer) return;
                        if (this._consumer.disposed) return;
                        this._transportAckTimer = setTimeout(() => this._sendAcks(true), this._acknowledgeTimeoutInMsecs);
                    }
                    get maxWindowSize() {
                        return Math.min(this._localMaxWindowSize, this._remoteWindowSize || Number.POSITIVE_INFINITY);
                    }
                    get windowSize() {
                        return this.maxWindowSize - this._messageDispatch.length;
                    }
                    get maxPendingAcks() {
                        return this.windowSize * this._acknowledgeThreshold / 100;
                    }
                }
                module.exports.ConsumerFSM = ConsumerFSM;
                /***/
            },
            /***/ "./modules/solclient-message-consumer/lib/consumer-state-names.js": 
            /*!************************************************************************!*\
  !*** ./modules/solclient-message-consumer/lib/consumer-state-names.js ***!
  \************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                const ConsumerStateNames = {
                    UNBOUND: "UNBOUND",
                    UNBOUND_AWAIT_SESSION_UP: "UNBOUND_AWAIT_SESSION_UP",
                    UNBOUND_AWAIT_FLOWOPEN: "UNBOUND_AWAIT_FLOWOPEN",
                    UNBOUND_AWAIT_ANY: "UNBOUND_AWAIT_ANY",
                    BIND_SENT: "BIND_SENT",
                    FLOW_UP: "FLOW_UP",
                    FLOW_UP_XFER: "FLOW_UP_XFER",
                    FLOW_UP_XFER_INACTIVE: "FLOW_UP_XFER_INACTIVE",
                    UNBIND_SENT: "UNBIND_SENT",
                    RECONNECTING: "RECONNECTING",
                    RECONNECTING_BIND_SENT: "RECONNECTING_BIND_SENT",
                    RECONNECTING_AWAIT_SESSION_UP: "RECONNECTING_AWAIT_SESSION_UP",
                    RECONNECTING_AWAIT_TIMER: "RECONNECTING_AWAIT_TIMER",
                    CREATE_SENT: "CREATE_SENT"
                };
                module.exports.ConsumerStateNames = Enum.new(ConsumerStateNames);
                /***/
            },
            /***/ "./modules/solclient-message-consumer/lib/message-consumer-acknowledge-modes.js": 
            /*!**************************************************************************************!*\
  !*** ./modules/solclient-message-consumer/lib/message-consumer-acknowledge-modes.js ***!
  \**************************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * An enumeration of consumer acknowledgement modes. The corresponding
 * MessageConsumer property {@link solace.MessageConsumerProperties#acknowledgeMode}
 * configures how acknowledgments are generated for received Guaranteed messages.
 *
 * When received messages are acknowledged they are removed from the Guaranteed
 * Message storage on the Solace Message Router. Message Consumer acknowledgements,
 * <b>only</b> remove messages from the Solace Message Router.
 *
 * In particular, withholding Message Consumer Acknowledgemnts does not stop
 * message delivery. For Message Consumer flow control see
 * {@link solace.MessageConsumer.stop}/{@link solace.MessageConsumer.start}. Message Consumer
 * flow control may also be imlpemented by removing the
 * {@link solace.MessageConsumerEventName#event:MESSAGE} listener.
 *
 * @memberof solace
 * @enum {string}
 * @namespace
 */
                const MessageConsumerAcknowledgeMode = {
                    /**
   * The API automatically acknowledges any message that was delivered to all
   * {@link solace.MessageConsumerEventName#event:MESSAGE} listeners with no exception thrown
   * on any of them.
   */
                    AUTO: "AUTO",
                    /**
   * The API acknowledges a message only when the application calls
   * {@link solace.Message#acknowledge}.
   */
                    CLIENT: "CLIENT"
                };
                module.exports.MessageConsumerAcknowledgeMode = Enum.new(MessageConsumerAcknowledgeMode);
                /***/
            },
            /***/ "./modules/solclient-message-consumer/lib/message-consumer-event-names.js": 
            /*!********************************************************************************!*\
  !*** ./modules/solclient-message-consumer/lib/message-consumer-event-names.js ***!
  \********************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * An enumeration of message consumer event names. A {@link solace.MessageConsumer} will emit
 * these events as part of its lifecycle.  Applications, having created a MessageConsumer can
 * choose to listen to all of the events described here, or any subset of these events. For Example:
 * <pre>
 *   <code>
 *     mc = solace.Session.createMessageConsumer(...);
 *     mc.on(solace.MessageConsumerEventName.CONNECT_FAILED_ERROR,
 *           function connectFailedErrorEventCb(error) {
 *             // error can be used as an OperationError object
 *           });
 *   </code>
 * </pre>
 *
 * @memberof solace
 * @enum {string}
 * @namespace
 */
                const MessageConsumerEventName = {
                    /**
   * The message consumer is established.
   * @event solace.MessageConsumerEventName#UP
   */
                    UP: "MessageConsumerEventName_up",
                    /**
   * The message consumer is successfully disconnected.
   * The message consumer is disabled.
   *
   * @event solace.MessageConsumerEventName#DOWN
   */
                    DOWN: "MessageConsumerEventName_down",
                    /**
   * The message consumer has become active.
   *
   * @event solace.MessageConsumerEventName#ACTIVE
   */
                    ACTIVE: "MessageConsumerEventName_active",
                    /**
   * The message consumer has become inactive.
   *
   * @event solace.MessageConsumerEventName#INACTIVE
   */
                    INACTIVE: "MessageConsumerEventName_inactive",
                    /**
   * The message consumer was established and then disconnected by the router,
   * likely due to operator intervention. The message consumer is disabled.
   *
   * @event solace.MessageConsumerEventName#DOWN_ERROR
   * @param {solace.OperationError} error Details of the error.
   */
                    DOWN_ERROR: "MessageConsumerEventName_downError",
                    /**
   * The message consumer was established and then disconnected by the router,
   * likely due to operator intervention, but flow auto reconnect is active.
   * The message consumer is disabled, but actively reconnecting.
   * Expect a RECONNECTED or DOWN_ERROR on success of failure. respectively.
   * See also MessageConsumerProperties.reconnectAttempts and reconnectIntervalInMsecs.
   *
   * @event solace.MessageConsumerEventName#RECONNECTING
   * @param {solace.OperationError} error Details of the error that triggered the reconnect.
   */
                    RECONNECTING: "MessageConsumerEventName_reconnecting",
                    /**
   * The message consumer successfully auto-reconnected.
   *
   * @event solace.MessageConsumerEventName#RECONNECTED
   */
                    RECONNECTED: "MessageConsumerEventName_reconnected",
                    /**
   * The message consumer attempted to connect but was unsuccessful.
   * The message consumer is disabled.
   *
   * @event solace.MessageConsumerEventName#CONNECT_FAILED_ERROR
   * @param {solace.OperationError} error Details of the error.
   */
                    CONNECT_FAILED_ERROR: "MessageConsumerEventName_connectFailedError",
                    /**
   * The message consumer will not connect because the current session is incompatible
   * with Guaranteed Messaging. The message consumer is disabled until a compatible session
   * is available.
   *
   * @event solace.MessageConsumerEventName#GM_DISABLED
   */
                    GM_DISABLED: "MessageConsumerEventName_GMDisabled",
                    /**
   * The message consumer is being disposed. No further events will be emitted.
   *
   * @event solace.MessageConsumerEventName#DISPOSED
   */
                    DISPOSED: "MessageConsumerEventName_disposed",
                    /**
   * A message was received on the message consumer.
   *
   * If the application throws an exception in this listener, and the consumer was configured
   * to automatically acknowledge messages
   * (see {@link solace.MessageConsumerProperties#acknowledgeMode}),
   * the API will not acknowledge the message, since it
   * may not have been successfully processed by the application. Such a message must be
   * acknowledged manually. If the application did not retain a reference to the message, it
   * may be redelivered by calling {@link solace.MessageConsumer#disconnect} followed by
   * {@link solace.MessageConsumer#connect} depending on the configuration of the queue.
   *
   * When there is no listener for <i>MESSAGE</i> on a MessageConsumer, messages are queued
   * internally until a listener is added.
   *
   * @event solace.MessageConsumerEventName#MESSAGE
   * @param {solace.Message} message The received message being delivered in this event.
   */
                    MESSAGE: "MessageConsumerEventName_message",
                    /**
   * The subscribe or unsubscribe operation succeeded on the queue.
   * @event solace.MessageConsumerEventName#SUBSCRIPTION_OK
   * @param {solace.MessageConsumerEvent} event The details related
   * to the successful subscription update.
   */
                    SUBSCRIPTION_OK: "MessageConsumerEventName_ok",
                    /**
   * The Solace Message Router rejected a queue subscription (add or remove).
   * @event solace.MessageConsumerEventName#SUBSCRIPTION_ERROR
   * @param {solace.MessageConsumerEvent} error The details related
   * to the failed subscription update.
   */
                    SUBSCRIPTION_ERROR: "MessageConsumerEventName_error"
                };
                module.exports.MessageConsumerEventName = Enum.new(MessageConsumerEventName);
                /***/
            },
            /***/ "./modules/solclient-message-consumer/lib/message-consumer-event.js": 
            /*!**************************************************************************!*\
  !*** ./modules/solclient-message-consumer/lib/message-consumer-event.js ***!
  \**************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /* provided dependency */ var util_inspect = __webpack_require__(/*! browser-util-inspect */ "./node_modules/browser-util-inspect/index.js");
                const {
                    ErrorSubcode
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                /**
 * Message consumer event objects. A {@link solace.MessageConsumer} will emit
 * these events related to queue subscription management:
 * MessageConsumerEventName.SUBSCRIPTION_OK and
 * MessageConsumerEventName.SUBSCRIPTION_ERROR.
 *
 * Similar to SessionEvent.
 * Also compatible with RequestError.
 *
 * @memberof solace
 */
                class MessageConsumerEvent {
                    /**
   * @constructor
   * @param {String} messageConsumerEventName one of the MessageConsumerEventNames.
   * @param {String} infoStr Information string
   * @param {Number} [responseCode] Any associated router response code
   * @param {solace.ErrorSubcode} [errorSubcode] Any associated error subcode
   * @param {Object} [correlationKey] Any associated correlation key
   * @param {String} [reason] Any additional information
   * @private
   */
                    constructor(messageConsumerEventName, infoStr, responseCode = undefined, errorSubcode = 0, correlationKey = undefined, reason = undefined) {
                        this._messageConsumerEventName = messageConsumerEventName;
                        this._infoStr = infoStr;
                        this._responseCode = responseCode;
                        this._errorSubcode = errorSubcode;
                        this._correlationKey = correlationKey; // optional
                        this._reason = reason; // optional
                    }
                    /**
   * @type {String}
   * @description the appropriate MessageConsumerEventName
   *
   *   MessageConsumerEventName.SUBSCRIPTION_OK or
   *   MessageConsumerEventName.SUBSCRIPTION_ERROR.
   */
                    get messageConsumerEventName() {
                        return this._messageConsumerEventName;
                    }
                    /**
   * @type {String}
   * @description the appropriate MessageConsumerEventName
   *
   *   MessageConsumerEventName.SUBSCRIPTION_OK or
   *   MessageConsumerEventName.SUBSCRIPTION_ERROR.
   */
                    get name() {
                        return this._messageConsumerEventName;
                    }
                    /**
   * @type {String}
   * @description if applicable, an information string returned by the Solace Message Router.
   */
                    get infoStr() {
                        return this._infoStr;
                    }
                    /**
   * @type {?Number}
   * @description if applicable, a response code returned by the Solace Message Router.
   */
                    get responseCode() {
                        return this._responseCode;
                    }
                    /**
   * @type {?solace.ErrorSubcode}
   * @description if applicable, an error subcode. Defined in {@link solace.ErrorSubcode}
   * same as subcode.
   */
                    get errorSubcode() {
                        return this._errorSubcode;
                    }
                    /**
   * @type {?solace.ErrorSubcode}
   * @description if applicable, an error subcode. Defined in {@link solace.ErrorSubcode}
   * Same as errorSubcode.
   */
                    get subcode() {
                        return this._errorSubcode;
                    }
                    /**
   * @type {?Object}
   * @description A user-specified object
   * made available in the response or confirmation event by including it as a
   * parameter in the orignal API call.  If the user did not specify a
   * correlationKey, it will be <code>null</code>.
   */
                    get correlationKey() {
                        return this._correlationKey;
                    }
                    /**
   * @type {?String}
   * @description Additional information if it is applicable.
   *
   * In case of subscribe or publish events, it constains the topic.
   */
                    get reason() {
                        return this._reason;
                    }
                    /**
   * @param {Object} value The reason info object
   * @internal
   */
                    set reason(value) {
                        this._reason = value;
                    }
                    /**
   * @type {?solace.SessionEventCode}
   * @description Only here for compatibility with the RequestError exception class.
   * Always returns undefined for a MessageConsumerEvent.
   */
                    // eslint-disable-next-line class-methods-use-this
                    get requestEventCode() {
                        return undefined;
                    }
                    ["inspect"]() {
                        return {
                            messageConsumerEventName: this.messageConsumerEventName,
                            infoStr: this.infoStr,
                            responseCode: this.responseCode,
                            errorSubcode: ErrorSubcode.describe(this.errorSubcode),
                            correlationKey: this.correlationKey ? this.correlationKey.toString() : null,
                            reason: this.reason ? this.reason : null
                        };
                    }
                    toString() {
                        return util_inspect(this);
                    }
                }
                module.exports.MessageConsumerEvent = MessageConsumerEvent;
                /***/
            },
            /***/ "./modules/solclient-message-consumer/lib/message-consumer-properties-validator.js": 
            /*!*****************************************************************************************!*\
  !*** ./modules/solclient-message-consumer/lib/message-consumer-properties-validator.js ***!
  \*****************************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    AbstractQueueDescriptor,
                    QueueDescriptor,
                    QueueDescriptorValidator,
                    QueueProperties,
                    QueuePropertiesValidator,
                    QueueType
                } = __webpack_require__(/*! solclient-queue */ "./modules/solclient-queue/api.js");
                const {
                    APIPropertiesValidators
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const {
                    Check
                } = __webpack_require__(/*! solclient-validate */ "./modules/solclient-validate/api.js");
                const {
                    MessageConsumerAcknowledgeMode
                } = __webpack_require__(/*! ./message-consumer-acknowledge-modes */ "./modules/solclient-message-consumer/lib/message-consumer-acknowledge-modes.js");
                const {
                    OperationError,
                    ErrorSubcode
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    ReplayStartLocation
                } = __webpack_require__(/*! solclient-replaystart */ "./modules/solclient-replaystart/api.js");
                const {
                    validateInstance,
                    valBoolean,
                    valInstance,
                    valIsMember,
                    valNumber,
                    valRange,
                    valTopicStringOrEmpty
                } = APIPropertiesValidators;
                function valTopicEndpointSubscription(typeDesc, instance) {
                    if (instance.queueDescriptor.getType() === QueueType.TOPIC_ENDPOINT) {
                        if (instance.queueDescriptor.isDurable() && !instance.createIfMissing) {
                            if (!instance.topicEndpointSubscription) {
                                throw new OperationError("topicEndpointSubscription must be set when queueDescriptor " + "refers to a durable topic endpoint and not allowed to create.", ErrorSubcode.PARAMETER_CONFLICT);
                            }
                        }
                    } else if (instance.topicEndpointSubscription) {
                        // is QueueType.QUEUE
                        throw new OperationError("topicEndpointSubscription is set, but queueDescriptor " + "refers to a queue that is not of type QueueType.TOPIC_ENDPOINT", ErrorSubcode.PARAMETER_CONFLICT);
                    }
                }
                const MessageConsumerPropertiesValidator = {
                    validate(prefix, instance, rawProperties) {
                        if (Object.prototype.hasOwnProperty.call(rawProperties, "transportAcknowledgeTimeoutInMsecs") && Object.prototype.hasOwnProperty.call(rawProperties, "acknowledgeTimeoutInMsecs")) {
                            throw new OperationError(`${prefix} validation: transportAcknowledgeTimeoutInMsecs and acknowledgeTimeoutInMsecs are mutually exclusive`, ErrorSubcode.PARAMETER_CONFLICT);
                        }
                        if (Object.prototype.hasOwnProperty.call(rawProperties, "transportAcknowledgeThresholdPercentage") && Object.prototype.hasOwnProperty.call(rawProperties, "acknowledgeThreshold")) {
                            throw new OperationError(`${prefix} validation: transportAcknowledgeThresholdPercentage and acknowledgeThreshold are mutually exclusive`, ErrorSubcode.PARAMETER_CONFLICT);
                        }
                        const v = validateInstance.bind(null, prefix, instance);
                        if (!(instance.queueDescriptor instanceof AbstractQueueDescriptor || instance.queueDescriptor instanceof QueueDescriptor)) {
                            throw new OperationError(`${prefix} validation: queue descriptor must be ` + "an AbstractQueueDescriptor or a QueueDescriptor", ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                        QueueDescriptorValidator.validate(instance.queueDescriptor);
                        if (instance.queueProperties) {
                            if (instance.queueDescriptor.durable && !instance.createIfMissing) {
                                throw new OperationError(`${prefix} validation: queueProperties cannot be set unless ` + "queueDescriptor refers to a temporary queue, or createIfMissing is set.", ErrorSubcode.PARAMETER_CONFLICT);
                            }
                            v("queueProperties", [ valInstance, QueueProperties, "QueueProperties" ]);
                            QueuePropertiesValidator.validate(instance.queueProperties);
                            if (!instance.queueDescriptor.durable && Check.something(instance.queueProperties.accessType)) {
                                throw new OperationError(`${prefix} validation: queueProperties cannot specify accessType ` + "in creation of a temporary queue", ErrorSubcode.PARAMETER_CONFLICT);
                            }
                        }
                        // Validate TE subscription
                        if (instance.queueDescriptor.type === QueueType.TOPIC_ENDPOINT) {
                            // QueueType.TOPIC_ENDPOINT
                            if (instance.queueDescriptor.durable && !instance.createIfMissing && !instance.topicEndpointSubscription) {
                                throw new OperationError(`${prefix} validation: topicEndpointSubscription must be set for durable ` + "topic endpoints unless creation is allowed.", ErrorSubcode.PARAMETER_CONFLICT);
                            }
                        } else if (instance.topicEndpointSubscription) {
                            throw new OperationError(`${prefix} validation: topicEndpointSubscription cannot be set unless ` + "descriptor.type is TOPIC_ENDPOINT", ErrorSubcode.PARAMETER_CONFLICT);
                        }
                        v("connectTimeoutInMsecs", [ valNumber ], [ valRange, 50, Number.MAX_VALUE ]);
                        v("connectAttempts", [ valNumber ], [ valRange, 1, Number.MAX_VALUE ]);
                        v("topicEndpointSubscription", [ valTopicEndpointSubscription ], [ valTopicStringOrEmpty ]);
                        v("acknowledgeMode", [ valIsMember, MessageConsumerAcknowledgeMode, "MessageConsumerAcknowledgeMode" ]);
                        v("transportAcknowledgeTimeoutInMsecs", [ valNumber ], [ valRange, 20, 1500 ]);
                        v("transportAcknowledgeThresholdPercentage", [ valNumber ], [ valRange, 1, 75 ]);
                        v("activeIndicationEnabled", [ valBoolean ]);
                        v("noLocal", [ valBoolean ]);
                        v("windowSize", [ valNumber ], [ valRange, 1, 255 ]);
                        v("reconnectIntervalInMsecs", [ valNumber ], [ valRange, 50, Number.MAX_VALUE ]);
                        if (instance.activeIndicationEnabled && instance.queueDescriptor.type !== QueueType.QUEUE) {
                            throw new OperationError(`${prefix} validation: activeIndicationEnabled may only be true for ` + "QUEUE destinations", ErrorSubcode.PARAMETER_CONFLICT);
                        }
                        if (instance.replayStartLocation && !(instance.replayStartLocation instanceof ReplayStartLocation)) {
                            throw new OperationError(`${prefix} validation: replayStartLocation must be ` + "an instance of ReplayStartLocation", ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                    }
                };
                module.exports.MessageConsumerPropertiesValidator = MessageConsumerPropertiesValidator;
                /***/
            },
            /***/ "./modules/solclient-message-consumer/lib/message-consumer-properties.js": 
            /*!*******************************************************************************!*\
  !*** ./modules/solclient-message-consumer/lib/message-consumer-properties.js ***!
  \*******************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const QueueLib = __webpack_require__(/*! solclient-queue */ "./modules/solclient-queue/api.js");
                const {
                    APIProperties
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const {
                    Check
                } = __webpack_require__(/*! solclient-validate */ "./modules/solclient-validate/api.js");
                const {
                    MessageConsumerAcknowledgeMode
                } = __webpack_require__(/*! ./message-consumer-acknowledge-modes */ "./modules/solclient-message-consumer/lib/message-consumer-acknowledge-modes.js");
                const {
                    Topic
                } = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                const DEFAULTS = {
                    queueDescriptor: undefined,
                    queueProperties: undefined,
                    connectTimeoutInMsecs: 1e4,
                    connectAttempts: 3,
                    topicEndpointSubscription: undefined,
                    // selector: undefined,
                    acknowledgeMode: MessageConsumerAcknowledgeMode.AUTO,
                    transportAcknowledgeTimeoutInMsecs: 1e3,
                    transportAcknowledgeThresholdPercentage: 60,
                    activeIndicationEnabled: false,
                    noLocal: false,
                    windowSize: 255,
                    _browser: false,
                    replayStartLocation: undefined,
                    reconnectAttempts: -1,
                    reconnectIntervalInMsecs: 3e3,
                    createIfMissing: false
                };
                /**
 * @classdesc
 * Defines the properties for a {@link solace.MessageConsumer}.
 *
 * @memberof solace
 */
                class MessageConsumerProperties extends APIProperties {
                    constructor(options) {
                        super(DEFAULTS, options);
                    }
                    /**
   * Defines the queue from which to consume.
   *  * For durable queues and durable topic endpoints, this must be a
   *    {@link solace.QueueDescriptor} unless
   *    {@link solace.MessageConsumerProperties#createIfMissing} is set.
   *  * When an {@link solace.AbstractQueueDescriptor} is used, the name is generated when
   *    the {@link solace.MessageConsumer} is connected. The generated descriptor can be queried
   *    from the consumer after it has successfully connected by calling
   *    {@link solace.MessageConsumer#getProperties}.
   * @type {solace.QueueDescriptor|object}
   */
                    get queueDescriptor() {
                        return Check.something(this._queueDescriptor) ? this._queueDescriptor : DEFAULTS.queueDescriptor;
                    }
                    set queueDescriptor(value) {
                        if (value instanceof QueueLib.AbstractQueueDescriptor) {
                            this._queueDescriptor = value;
                        } else if (value) {
                            this._queueDescriptor = value.name ? new QueueLib.QueueDescriptor(value) : new QueueLib.AbstractQueueDescriptor(value);
                        } else {
                            this._queueDescriptor = value;
                        }
                    }
                    /**
   * Gets the properties of the remote queue.
   *  * For temporary queues and temporary topic endpoints,
   *    or if {@link solace.MessageConsumerProperties#createIfMissing} is true,
   *    these properties define the endpoint that is created.
   *  * For durable queues, these must be unset on consumer creation
   *    unless {@link solace.MessageConsumerProperties#createIfMissing} is set.
   *    The values will be populated
   *    after the queue is connected and can be retrieved by calling
   *    {@link solace.MessageConsumer#getProperties}.
   * @type {solace.QueueProperties|null|undefined}
   */
                    get queueProperties() {
                        return Check.something(this._queueProperties) ? this._queueProperties : DEFAULTS.queueProperties;
                    }
                    set queueProperties(value) {
                        if (value) {
                            this._queueProperties = new QueueLib.QueueProperties(value);
                        } else {
                            this._queueProperties = value;
                        }
                    }
                    // ------------ Properties controlling connection of the consumer ----------------
                    /**
   * The bind timeout in milliseconds when creating a connection to the Solace Message Router.
   *  * The valid range is >= 50.
   * @type {Number}
   * @default 10000
   */
                    get connectTimeoutInMsecs() {
                        return Check.something(this._bindTimeoutInMsecs) ? this._bindTimeoutInMsecs : DEFAULTS.connectTimeoutInMsecs;
                    }
                    set connectTimeoutInMsecs(value) {
                        this._bindTimeoutInMsecs = value;
                    }
                    /**
   * Gets and sets the maximum number of bind attempts when creating a connection to the
   * Solace Message Router.
   *  * The valid range is >= 1.
   * @type {Number}
   * @default 3
   */
                    get connectAttempts() {
                        return Check.something(this._connectAttempts) ? this._connectAttempts : DEFAULTS.connectAttempts;
                    }
                    set connectAttempts(val) {
                        this._connectAttempts = val;
                    }
                    // ------------ Properties applied to the queue when connecting ----------------
                    /**
   * This must be undefined if the type of the
   * {@link solace.MessageConsumerProperties#queueDescriptor} is not
   * {@link solace.QueueType.TOPIC_ENDPOINT}.
   *
   * If {@link solace.MessageConsumerProperties#queueDescriptor} is
   * not durable, or {@link solace.MessageConsumerProperties#createIfMissing} is true,
   * this may be left undefined to generate the topic endpoint's
   * destination. When generated, the destination can be obtained from
   * the {@link solace.MessageConsumer} after it is connected by calling
   * {@link solace.MessageConsumer#getDestination}.
   *
   * @type {solace.Destination}
   * @default undefined
   */
                    get topicEndpointSubscription() {
                        return this._topicEndpointSubscription;
                    }
                    set topicEndpointSubscription(val) {
                        // Avoid instanceof check failing on Node 4?
                        if (typeof val === "string") {
                            this._topicEndpointSubscription = Topic.createFromName(val);
                        } else {
                            this._topicEndpointSubscription = val;
                        }
                    }
                    // ----------- Properties controlling an established connection to a queue --------------
                    /**
   * The Application Acknowledgement mode for the Message Consumer.
   *
   * When the acknowledgement mode is {@link solace.MessageConsumerAcknowledgeMode.CLIENT},
   * a message is Application Acknowledged when the application calls
   * {@link solace.Message#acknowledge} on that message.
   *
   * When the acknowledge mode is {@link solace.MessageConsumerAcknowledgeMode.AUTO}, a message is
   * Application Acknowledged by the API after all
   * {@link solace.MessageConsumerEventName#event:MESSAGE}
   * listeners are called and none throw an exception. If a message handler throws, the message
   * can still be acknowledged by calling {@link solace.Message#acknowledge}, but this would not be
   * a recommended practice.
   *
   * When received messages are Application Acknowledged they are removed from the Guaranteed
   * Message storage on the Solace Message Router. Message Consumer Application Acknowledged,
   * <b>only</b> remove messages from the Solace Message Router.
   *
   * In particular, withholding Message Consumer Acknowledgemnts does not stop
   * message delivery. For Message Consumer flow control (aka transport acknowledgemeent) see
   * {@link solace.MessageConsumer#stop}/{@link solace.MessageConsumer#start}. Message Consumer
   * flow control may also be imlpemented by removing the
   * {@link solace.MessageConsumerEventName#event:MESSAGE} listener.
   *
   * Flow control and transport acknowledgements characteristics are defined by
   * {@link solace.MessageConsumerProperties#transportAcknowledgeThresholdPercentage} and
   * {@link solace.MessageConsumerProperties#transportAcknowledgeTimeoutInMsecs}
   *
   * @type {solace.MessageConsumerAcknowledgeMode}
   * @default solace.MessageConsumerAcknowledgeMode.AUTO
   */
                    get acknowledgeMode() {
                        return Check.something(this._acknowledgeMode) ? this._acknowledgeMode : DEFAULTS.acknowledgeMode;
                    }
                    set acknowledgeMode(value) {
                        this._acknowledgeMode = value;
                    }
                    /**
   * The transport acknowledgement timeout for guaranteed messaging.
   * When the {@link solace.MessageConsumerProperties#transportAcknowledgeTimeoutInMsecs}
   * is not exceeded, acknowledgements will be returned to the router at intervals not
   * less than this value.
   *   * The valid range is 20 <= transportAcknowledgeTimeoutInMsecs <= 1500.
   * @type {Number}
   * @default 1000
   * @deprecated
   */
                    get acknowledgeTimeoutInMsecs() {
                        return Check.something(this._transportAcknowledgeTimeoutInMsecs) ? this._transportAcknowledgeTimeoutInMsecs : DEFAULTS.transportAcknowledgeTimeoutInMsecs;
                    }
                    set acknowledgeTimeoutInMsecs(val) {
                        this._transportAcknowledgeTimeoutInMsecs = val;
                    }
                    /**
   * The threshold for sending an acknowledgement, as a percentage.
   * The API sends a transport acknowledgment every
   * N messages where N is calculated as this percentage of the transport
   * window size if the endpoint's max-delivered-unacked-msgs-per-flow
   * setting at bind time is greater than or equal to the transport
   * window size. Otherwise, N is calculated as this percentage of the
   * endpoint's max-delivered-unacked-msgs-per-flow setting at bind time.
   * * The valid range is 1 <= transportAcknowledgeThresholdPercentage <= 75.
   * @type {Number}
   * @default 60
   * @deprecated
   */
                    get acknowledgeThreshold() {
                        return Check.something(this._transportAcknowledgeThresholdPercentage) ? this._transportAcknowledgeThresholdPercentage : DEFAULTS.transportAcknowledgeThresholdPercentage;
                    }
                    set acknowledgeThreshold(value) {
                        this._transportAcknowledgeThresholdPercentage = value;
                    }
                    /**
   * The transport acknowledgement timeout for guaranteed messaging.
   * When the {@link solace.MessageConsumerProperties.transportAcknowledgeTimeoutInMsecs}
   * is not exceeded, acknowledgements will be returned to the router at intervals not less than
   * this value.
   *   * The valid range is 20 <= transportAcknowledgeTimeoutInMsecs <= 1500.
   * @type {Number}
   * @default 1000
   */
                    get transportAcknowledgeTimeoutInMsecs() {
                        return Check.something(this._transportAcknowledgeTimeoutInMsecs) ? this._transportAcknowledgeTimeoutInMsecs : DEFAULTS.transportAcknowledgeTimeoutInMsecs;
                    }
                    set transportAcknowledgeTimeoutInMsecs(val) {
                        this._transportAcknowledgeTimeoutInMsecs = val;
                    }
                    /**
   * The threshold for sending an acknowledgement, as a percentage.
   * The API sends a transport acknowledgment every
   * N messages where N is calculated as this percentage of the transport
   * window size if the endpoint's max-delivered-unacked-msgs-per-flow
   * setting at bind time is greater than or equal to the transport
   * window size. Otherwise, N is calculated as this percentage of the
   * endpoint's max-delivered-unacked-msgs-per-flow setting at bind time.
   * * The valid range is 1 <= transportAcknowledgeThresholdPercentage <= 75.
   * @type {Number}
   * @default 60
   */
                    get transportAcknowledgeThresholdPercentage() {
                        return Check.something(this._transportAcknowledgeThresholdPercentage) ? this._transportAcknowledgeThresholdPercentage : DEFAULTS.transportAcknowledgeThresholdPercentage;
                    }
                    set transportAcknowledgeThresholdPercentage(value) {
                        this._transportAcknowledgeThresholdPercentage = value;
                    }
                    /**
   * @description When enabled, a Guaranteed Messaging Consumer requests Active and Inactive
   * events from the router and emits them to interested listeners.
   * @type {Boolean}
   * @default false
   * @see {@link solace.MessageConsumerEventName.ACTIVE}
   * @see {@link solace.MessageConsumerEventName.INACTIVE}
   */
                    get activeIndicationEnabled() {
                        return Check.something(this._activeIndicationEnabled) ? this._activeIndicationEnabled : DEFAULTS.activeIndicationEnabled;
                    }
                    set activeIndicationEnabled(newValue) {
                        this._activeIndicationEnabled = newValue;
                    }
                    /**
   * When enabled, a Guaranteed Messaging Consumer does not receive messages published
   * in the same Session, even if the endpoint contains a subscription that matches the published
   * message.
   * @type {Boolean}
   * @default false
   */
                    get noLocal() {
                        return Check.something(this._noLocal) ? this._noLocal : DEFAULTS.noLocal;
                    }
                    set noLocal(newValue) {
                        this._noLocal = newValue;
                    }
                    /**
   * The window size for Guaranteed Message delivery.  This is the maximum number of messages that
   * will be prefetched from the Solace Messaging Router and queued internally by the API while
   * waiting for the application to accept delivery of the messages.
   *   * The valid range is 1 <= windowSize <= 255.
   * @type {Number}
   * @default 255
   */
                    get windowSize() {
                        return Check.something(this._windowSize) ? this._windowSize : DEFAULTS.windowSize;
                    }
                    set windowSize(val) {
                        this._windowSize = val;
                    }
                    /**
   * When enabled, a Guaranteed Messaging Consumer will connect as a queue browser
   * @type {Boolean}
   * @default false
   * @private
   * @internal
   */
                    get browser() {
                        return Check.something(this._browser) ? this._browser : DEFAULTS._browser;
                    }
                    set browser(newValue) {
                        this._browser = newValue;
                    }
                    /**
   * When a Flow is created, the application may request replay of messages from the replay log,
   * even messages that have been previously delivered and removed the from topic endpoint or queue.
   * The default is undefined, and indicates that no replay is requested.
   *
   * When defined the replay start location must be a {@link solace.ReplayStartLocation} object
   * as returned by
   * {@link solace.SolClientFactory.createReplayStartLocationBeginning} or
   * {@link solace.SolClientFactory.createReplayStartLocationDate}.
   *
   * The {@link solace.ReplayStartLocation} returned by
   * {@link solace.SolClientFactory.createReplayStartLocationBeginning}
   * indicate that all messages available should be replayed.
   *
   * The replay start location returned by
   * {@link solace.SolClientFactory.createReplayStartLocationDate}
   * indicates that all messages logged since a given date must be retrieved.
   * @type {solace.ReplayStartLocation}
   * @default undefined.
   */
                    get replayStartLocation() {
                        return Check.something(this._replayStartLocation) ? this._replayStartLocation : DEFAULTS.replayStartLocation;
                    }
                    set replayStartLocation(newValue) {
                        this._replayStartLocation = newValue;
                    }
                    /**
   * When a connected flow receives an unsolicited unbind event with subcode
   * REPLAY_STARTED or GM_UNAVAILABLE, the SDK can reconnect the flow automatically.
   * This property controls the flow auto reconnect feature:
   * 0: Disable flow auto reconnect for this consumer flow.
   * -1: Enable flow auto reconnect for this consumer flow, infiinite retries (default)
   * <n, positive number>: Enable flow auto reconnect for this consumer flow, n retries.
   *
   * When the flow auto rebind is enabled, DOWN_ERRORs with REPLAY_STARTED and GM_UNAVAILABLE
   * are handled internally, and not (immediately) emitted to the application.
   * A RECONNECTING event (with the same subcode) is emitted instead,
   * ideally followed by a RECONNECTED event when the reconnect succeedes.
   * In case of REPLAY_STARTED, the window of message IDs and acknowledgements are reset
   * to allow replay packets to be passed to the application without marking them as duplicates.
   * In case of GM_UNAVAILABLE, flow state is preserved.
   *
   * If reconnecting fails after exhausting the number of retries, a DOWN_ERROR is emitted
   * with the details of the last retry.
   *
   *
   * @type {Number}
   * @default -1
   */
                    get reconnectAttempts() {
                        return Check.something(this._reconnectAttempts) ? this._reconnectAttempts : DEFAULTS.reconnectAttempts;
                    }
                    set reconnectAttempts(newValue) {
                        this._reconnectAttempts = newValue;
                    }
                    /**
   * Time to wait between flow auto reconnect attempts, in milliseconds.
   * See {@link solace.MessageConsumerProperties.reconnectAttempts}
   * Defaults to 3 seconds (3000)
   *  * The valid range is >= 50.
   *
   * @type {Number}
   * @default 3000
   */
                    get reconnectIntervalInMsecs() {
                        return Check.something(this._reconnectIntervalInMsecs) ? this._reconnectIntervalInMsecs : DEFAULTS.reconnectIntervalInMsecs;
                    }
                    set reconnectIntervalInMsecs(newValue) {
                        this._reconnectIntervalInMsecs = newValue;
                    }
                    /**
   * If the endpoint is durable, it won't be auto-created unless this flag is set.
   * This flag has no effect for temporary endpoints, those are always created if missing.
   * This flag has no effect for existing endpoints.
   *
   * Off by default for backwards compatibility.
   *
   * @type {Boolean}
   * @default false
   *
   */
                    get createIfMissing() {
                        return Check.something(this._createIfMissing) ? this._createIfMissing : DEFAULTS.createIfMissing;
                    }
                    set createIfMissing(newValue) {
                        this._createIfMissing = newValue;
                    }
                }
                module.exports.MessageConsumerProperties = MessageConsumerProperties;
                /***/
            },
            /***/ "./modules/solclient-message-consumer/lib/message-consumer.js": 
            /*!********************************************************************!*\
  !*** ./modules/solclient-message-consumer/lib/message-consumer.js ***!
  \********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /* provided dependency */ var util_inspect = __webpack_require__(/*! browser-util-inspect */ "./node_modules/browser-util-inspect/index.js");
                const SMFLib = __webpack_require__(/*! solclient-smf */ "./modules/solclient-smf/api.js");
                const {
                    CapabilityType
                } = __webpack_require__(/*! solclient-session */ "./modules/solclient-session/api.js");
                const {
                    ConsumerFSM
                } = __webpack_require__(/*! ./consumer-fsm */ "./modules/solclient-message-consumer/lib/consumer-fsm.js");
                const {
                    ConsumerFSMEvent
                } = __webpack_require__(/*! ./consumer-fsm-event */ "./modules/solclient-message-consumer/lib/consumer-fsm-event.js");
                const {
                    ConsumerFSMEventNames
                } = __webpack_require__(/*! ./consumer-fsm-event-names */ "./modules/solclient-message-consumer/lib/consumer-fsm-event-names.js");
                const {
                    ErrorResponseSubcodeMapper,
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    Flow,
                    FlowOperation
                } = __webpack_require__(/*! solclient-flow */ "./modules/solclient-flow/api.js");
                const {
                    MessageConsumerEvent
                } = __webpack_require__(/*! ./message-consumer-event */ "./modules/solclient-message-consumer/lib/message-consumer-event.js");
                const {
                    MessageConsumerEventName
                } = __webpack_require__(/*! ./message-consumer-event-names */ "./modules/solclient-message-consumer/lib/message-consumer-event-names.js");
                const {
                    MessageConsumerProperties
                } = __webpack_require__(/*! ./message-consumer-properties */ "./modules/solclient-message-consumer/lib/message-consumer-properties.js");
                const {
                    MessageConsumerPropertiesValidator
                } = __webpack_require__(/*! ./message-consumer-properties-validator */ "./modules/solclient-message-consumer/lib/message-consumer-properties-validator.js");
                const {
                    Queue,
                    Topic
                } = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                const {
                    QueueAccessType,
                    QueuePermissions,
                    QueueDiscardBehavior
                } = __webpack_require__(/*! solclient-queue */ "./modules/solclient-queue/api.js");
                function formatEventName(eventName) {
                    return `MessageConsumerEventName.${MessageConsumerEventName.describe(eventName)}`;
                }
                let localCounter = 0;
                function getConsumerLocalName() {
                    return `ConsumerFSM ${localCounter++}`;
                }
                /**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 * A Message Consumer is created by calling {@link solace.Session#createMessageConsumer}.
 *
 * A MessageConsumer controls Guaranteed Message delivery to this client.
 *
 * Consumer characteristics and behavior are defined by {@link solace.MessageConsumerProperties}.
 * The properties can also be supplied as a simple key-value {Object}. The queue descriptor,
 * {@link solace.MessageConsumerProperties#queueDescriptor} must be specified to identify the
 * Guaranteed Message Queue or Guaranteed Message Topic Endpoint on the Solace Message Router.
 *
 * The MessageConsumer object is an EventEmitter, and will emit events to which the
 * application may choose to subscribe, such as the connection to the Solace Message Router
 * going up or down.
 *
 * If a registered listener for an emitted event throws an exception, this is caught and emitted as
 * an 'error'.
 *
 * @fires solace.MessageConsumerEventName#ACTIVE
 * @fires solace.MessageConsumerEventName#CONNECT_FAILED_ERROR
 * @fires solace.MessageConsumerEventName#DISPOSED
 * @fires solace.MessageConsumerEventName#DOWN
 * @fires solace.MessageConsumerEventName#DOWN_ERROR
 * @fires solace.MessageConsumerEventName#GM_DISABLED
 * @fires solace.MessageConsumerEventName#INACTIVE
 * @fires solace.MessageConsumerEventName#MESSAGE
 * @fires solace.MessageConsumerEventName#UP
 * @fires solace.MessageConsumerEventName#SUBSCRIPTION_OK
 * @fires solace.MessageConsumerEventName#SUBSCRIPTION_ERROR
 *
 *
 * @hideconstructor
 * @extends solace.Flow
 * @memberof solace
 */
                class MessageConsumer extends Flow {
                    constructor({
                        properties,
                        sessionInterfaceFactory
                    } = {}) {
                        const applyProperties = new MessageConsumerProperties(properties);
                        MessageConsumerPropertiesValidator.validate(applyProperties.browser ? "QueueBrowserProperties" : "MessageConsumerProperties", applyProperties, properties);
                        super(applyProperties, sessionInterfaceFactory, {
                            direct: MessageConsumerEventName.MESSAGE,
                            emits: MessageConsumerEventName.values,
                            formatEventName: formatEventName
                        });
                        const superFormatter = this.logger.formatter;
                        this.logger.formatter = (...args) => superFormatter("[message-consumer]", ...args);
                        this._active = undefined;
                        this._fsm = this._makeFSM();
                        this.endpointErrorId = undefined;
                        this._on(MessageConsumerEventName.ACTIVE, () => this._onFlowActive(true));
                        this._on(MessageConsumerEventName.INACTIVE, () => this._onFlowActive(false));
                        this._on(MessageConsumerEventName.DOWN_ERROR, this._onFlowDisconnected.bind(this));
                        this._on(MessageConsumerEventName.UP, this._onFlowUp.bind(this));
                        this._fsm.start(); // Subscriber flows self-manage, so they start immediately
                    }
                    _makeFSM() {
                        const properties = this._properties;
                        const name = `${getConsumerLocalName()}`;
                        return new ConsumerFSM({
                            name: name,
                            consumer: this,
                            sessionInterface: this._sessionInterface,
                            properties: properties
                        });
                    }
                    /**
   * Begins delivery of messages to this consumer. This method opens the protocol window
   * to the Solace Message Router so further messages can be received.
   *
   * A newly created consumer is in started state.
   *
   * If the consumer was already started, this method has no effect.
   *
   * A consumer is stopped by calling {@link solace.MessageConsumer.stop}
   *
   * @throws {solace.OperationError}
   * * if the Message Consumer is disposed.
   *   subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   * * if the Message Consumer is disconnected.
   *   subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   */
                    start() {
                        this._operationCheck(FlowOperation.START);
                        this._fsm.requestStartDispatchUser();
                    }
                    /**
   * Stops messages from being delivered to this consumer from the Solace Message Router.
   * Messages may continue to be prefetched by the API and queued internally
   * until {@link solace.MessageConsumer#start} is called.
   *
   * If the consumer was already stopped, this method has no effect.
   *
   * @throws {solace.OperationError}
   * * if the Message Consumer is disconnected.
   *   subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   */
                    stop() {
                        this._operationCheck(FlowOperation.STOP);
                        this._fsm.requestStopDispatchUser();
                    }
                    /**
   * Connects the consumer immediately. The application should add event listeners (see
   * {@link solace.MessageConsumerEventName}). If there is no listener added for
   * {@link solace.MessageConsumerEventName#event:MESSAGE} then up to a window
   * {@link solace.MessageConsumerProperties.windowSize} of messages can be queued internally.
   * to the {@link solace.MessageConsumer} before calling this method.
   *
   * @throws {solace.OperationError}
   *  * if consumer is not supported by router for this client.
   *  subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   *
   */
                    connect() {
                        if (this._sessionInterface.getCapability(CapabilityType.GUARANTEED_MESSAGE_CONSUME) !== null && !this._sessionInterface.isCapable(CapabilityType.GUARANTEED_MESSAGE_CONSUME)) {
                            throw new OperationError("Consumer is not supported by router for this client", ErrorSubcode.INVALID_OPERATION, null);
                        }
                        super.connect();
                        this.processFSMEvent(new ConsumerFSMEvent({
                            name: ConsumerFSMEventNames.FLOW_OPEN
                        }));
                    }
                    /**
   * Initiates an orderly disconnection of the Message Consumer. The API will send any pending
   * client acknowledgements on the Message Consumer, then send an unbind request.
   * Any messages subsequently
   * received are discarded silently. When the unbind message is acknowledged, the application
   * receives a {@link solace.MessageConsumerEventName#event:DOWN} event if it has set a listener
   * for that event.
   *
   * @throws {solace.OperationError}
   * * if the Message Consumer is disconnected.
   *   subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   */
                    disconnect() {
                        super.disconnect();
                        this.processFSMEvent(new ConsumerFSMEvent({
                            name: ConsumerFSMEventNames.FLOW_CLOSE
                        }));
                    }
                    /**
   * Returns the destination that should be used to publish messages that this consumer
   * will receive.
   * * For topic endpoints, this is the topic to which the topic endpoint is subscribed.
   * * For queues, this is the associated queue destination.
   *
   * The destination returned can
   * be used to set the ReplyTo field in a message, or otherwise communicated
   * to partners that need to send messages to this Message Consumer. This is especially useful
   * for temporary endpoints (Queues and Topic Endpoints), as the destination
   * is unknown before the endpoint is created.
   *
   * This method will succeed after {@link solace.MessageConsumerEventName#event:UP} for temporaries
   * with generated destinations.
   *
   * @throws {solace.OperationError}
   * * if the {@link solace.MessageConsumer} is disconnected and the destination is temporary.
   *
   * @returns {solace.Destination} The publishing destination that delivers to this consumer.
   */
                    getDestination() {
                        const destination = this._fsm.getDestination();
                        if (destination instanceof Queue) {
                            return new Queue(destination);
                        }
                        return new Topic(destination);
                    }
                    // Application has disconnected the session, we must continue to orderly shut down
                    // unbinding Message Consumers,
                    // but Message Consumers that are up merely treat this as a 'down' event and
                    // transition to awaitingSessionUp
                    _disconnectSession() {
                        super._disconnectSession();
                        this.processFSMEvent(new ConsumerFSMEvent({
                            name: ConsumerFSMEventNames.SESSION_DISCONNECT
                        }));
                    }
                    _operationCheck(operation) {
                        super._operationCheck(operation);
                        switch (operation) {
                          case FlowOperation.GET_DESTINATION:
                            if (this._isDisconnected()) {
                                throw new OperationError("Cannot get destination of a disconnected flow", ErrorSubcode.INVALID_OPERATION);
                            }
                            break;

                          default:
                        }
                    }
                    // ----
                    /**
   * @param {any} messageId The message ID to ack
   * @internal
   */
                    applicationAck(messageId) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE(`Adding application ack for ${messageId}`);
                        this._fsm.applicationAck(messageId);
                    }
                    getDisposedEvent() {
                        // eslint-disable-line class-methods-use-this
                        return MessageConsumerEventName.DISPOSED;
                    }
                    /**
   * @param {solace.Message} message The data message to handle
   * @internal
   */
                    handleDataMessage(message) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Handling data message");
                        message.setMessageConsumer(this);
                        this._fsm.acceptMessage(message);
                    }
                    /**
   * @override
   * @param {solace.AdProtocolMessage} message The control message to handle
   * @internal
   */
                    handleUncorrelatedControlMessage(message) {
                        const {
                            LOG_INFO,
                            LOG_DEBUG,
                            LOG_TRACE
                        } = this.logger;
                        LOG_INFO("Handling uncorrelated control message");
                        const msgType = message.msgType;
                        const {
                            SMFAdProtocolMessageType
                        } = SMFLib;
                        switch (msgType) {
                          case SMFAdProtocolMessageType.UNBIND:
                            {
                                const responseCode = message.smfHeader.pm_respcode;
                                const description = message.smfHeader.pm_respstr;
                                const errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode, description);
                                LOG_TRACE(`Handling uncorrelated UNBIND. endpointErrorId: ${message.getEndpointErrorId()}`);
                                if (message.getEndpointErrorId() !== undefined) {
                                    this.endpointErrorId = message.getEndpointErrorId();
                                }
                                this.processFSMEvent(new ConsumerFSMEvent({
                                    name: ConsumerFSMEventNames.FLOW_UNBOUND
                                }, new OperationError(description, errorSubcode, responseCode)));
                            }
                            break;

                          case SMFAdProtocolMessageType.FLOWCHANGEUPDATE:
                            this.processFSMEvent(new ConsumerFSMEvent({
                                name: ConsumerFSMEventNames.FLOW_ACTIVE_IND
                            }, {
                                active: message.getActiveFlow()
                            }));
                            break;

                          default:
                            LOG_DEBUG("Dropping unhandled AD control message: ", SMFAdProtocolMessageType.describe(msgType));
                        }
                    }
                    /**
   * Creates and returns copy of the properties for this MessageConsumer.
   *
   * If the object was constructed using an {@link solace.AbstractQueueDescriptor},
   * and the queue descriptor was subsequently connected to an endpoint, the
   * `MessageConsumerProperties` returned will include a {@link solace.QueueDescriptor}
   * that contains the resolved name.
   *
   * A new copy of the properties object is returned each time this property is accessed.
   * The returned object cannot be polled for mutations such as the one described above.
   *
   * @returns {solace.MessageConsumerProperties} The properties associated with this object.
   */
                    getProperties() {
                        return super.getProperties();
                    }
                    /**
   * Resets the router state contained in the consumer, e.g. on VRN change
   *
   * @memberof MessageConsumer
   * @internal
   */
                    onVRNChanged() {
                        this.processFSMEvent(new ConsumerFSMEvent({
                            name: ConsumerFSMEventNames.VIRTUALROUTER_NAME_CHANGED
                        }));
                    }
                    /**
   * After the MessageConsumer has connected to an endpoint
   * ({@link solace.MessageConsumerEventName#UP}), accesstype represents
   *  the access type for the endpoint to which this Message Consumer is bound.
   * @name solace.MessageConsumer.accessType
   * @type {solace.QueueAccessType}
   */
                    get accessType() {
                        return this._accessType;
                    }
                    /**
   * @param {solace.QueueAccessType} value The value to set
   * @internal
   */
                    set accessType(value) {
                        this._accessType = value;
                    }
                    /**
   * Whether the consumer is active. If active indications for the consumer are not
   * enabled, this will return undefined.
   * @type {?Boolean}
   * @internal
   */
                    get active() {
                        return this._active;
                    }
                    /**
   * @param {Boolean} value The value to set
   * @internal
   */
                    set active(value) {
                        if (value !== this._active) {
                            this._emit(value ? MessageConsumerEventName.ACTIVE : MessageConsumerEventName.INACTIVE);
                        }
                        this._active = value;
                    }
                    /**
   * After the MessageConsumer has connected as indicated by the event
   * {@link solace.MessageConsumerEventName#event:UP}, queueDiscardBehavior represents
   * the discard behavior flags for the endpoint to which this Message Consumer is bound.
   * @name solace.MessageConsumer.queueDiscardBehaviour
   * @type {solace.QueueDiscardBehavior}
   */
                    get queueDiscardBehavior() {
                        return this._queueDiscardBehavior;
                    }
                    /**
   * @param {solace.QueueDiscardBehavior} value The value to set
   * @internal
   */
                    set queueDiscardBehavior(value) {
                        this._queueDiscardBehavior = value;
                    }
                    /**
   * After the MessageConsumer has connected as indicated by the event
   * {@link solace.MessageConsumerEventName#event:UP}
   * respectsTTL is `true` when the endpoint respects Time To Live on messages
   * and 'false' otherwise.
   * @name solace.MessageConsumer.respectsTTL
   * @type {Boolean}
   */
                    get respectsTTL() {
                        return this._respectsTTL;
                    }
                    /**
   * @param {Boolean} value The value to set
   * @internal
   */
                    set respectsTTL(value) {
                        this._respectsTTL = value;
                    }
                    /**
   * Gets the flow ID for this consumer. This number will change between reconnects
   * and is purely informational.
   * @type {Long}
   * @internal
   */
                    get flowId() {
                        return this._flowId;
                    }
                    /**
   * @param {Long} value The value to set
   * @internal
   */
                    set flowId(value) {
                        this._flowId = value;
                    }
                    /**
   * After the MessageConsumer has connected as indicated by the event
   * {@link solace.MessageConsumerEventName#event:UP}, this property represents
   * permissions granted by the router to this user on this Message Consumer
   * @name solace.MessageConsumer.permissions
   * @type {solace.QueuePermissions}
   */
                    get permissions() {
                        return this._permissions || 0;
                    }
                    /**
   * @param {Number} value The value to set
   * @internal
   */
                    set permissions(value) {
                        this._permissions = value;
                    }
                    _onFlowActive(isActive) {
                        const {
                            LOG_DEBUG
                        } = this.logger;
                        LOG_DEBUG(`Flow (flowId = ${this._flowId}) became ${isActive ? "active" : "inactive"}`);
                        this._active = isActive;
                    }
                    _onFlowDisconnected(error) {
                        const {
                            LOG_INFO
                        } = this.logger;
                        LOG_INFO(`${this} disconnected: ${error}.message`);
                    }
                    _disposeFSM() {
                        const {
                            LOG_INFO
                        } = this.logger;
                        LOG_INFO("Disposing FSM");
                        this.processFSMEvent(new ConsumerFSMEvent({
                            name: ConsumerFSMEventNames.DISPOSE
                        }));
                    }
                    _onFlowUp() {
                        const {
                            LOG_INFO
                        } = this.logger;
                        LOG_INFO(`Flow is up: flowId = ${this._flowId}`);
                    }
                    ["inspect"]() {
                        return Object.assign(super["inspect"](), {
                            destination: this._destination,
                            accessType: QueueAccessType.describe(this.accessType),
                            permissions: QueuePermissions.describe(this.permissions),
                            respectsTTL: this.respectsTTL,
                            active: this.wantFlowChangeNotify ? this.active : "(indications disabled)",
                            wantFlowChangeNotify: this.wantFlowChangeNotify,
                            queueDiscardBehavior: QueueDiscardBehavior.describe(this.queueDiscardBehavior),
                            maxWindowSize: this._fsm.maxWindowSize
                        });
                    }
                    toString() {
                        return util_inspect(this);
                    }
                    _isDisconnected() {
                        return this._fsm.isDisconnected();
                    }
                    /**
   * Subscribe the queue to a topic, always requesting confirmation from the router.
   *
   * {@link solace.MessageConsumerEventName.SUBSCRIPTION_OK} is generated when subscription is
   * added successfully; otherwise, session event
   * {@link solace.MessageConsumerEventName.SUBSCRIPTION_ERROR} is generated.
   *
   * When the application receives the event
   * {@link solace.MessageConsumerEventName.SUBSCRIPTION_ERROR}, it
   * can obtain the failed topic subscription by calling
   * {@link solace.MessageConsumerEvent#reason}.
   * The returned string is in the format of "Topic: <failed topic subscription>".
   *
   * @param {solace.Destination} topic The topic destination subscription to add.
   * @param {Object} correlationKey If specified, this value is
   *                                echoed in the messageConsumer event within
   *                                {@link MessageConsumerEvent}.
   * @param {Number} requestTimeout The request timeout period (in milliseconds). If specified, this
   *                                value overwrites readTimeoutInMsecs property in
   *                                {@link SessionProperties}.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected,
   *   or the consumer is inactive, down, disconnected, or disposed.
   *   Or if the consumer is bound to a topic endpoint instead of a queue.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the parameters have an invalid value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   * * if the topic has invalid syntax.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_TOPIC_SYNTAX}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   * * if the topic is a shared subscription and the peer router does not support Shared
   *   Subscriptions.
   *   Subcode: {@link solace.ErrorSubcode.SHARED_SUBSCRIPTIONS_NOT_SUPPORTED}.
   * * if the topic is a shared subscription and the client does not allowed Shared
   *   Subscriptions.
   *   Subcode: {@link solace.ErrorSubcode.SHARED_SUBSCRIPTIONS_NOT_ALLOWED}.
   */
                    addSubscription(topic, correlationKey, requestTimeout) {
                        const callback = (success, subCode, respCode, respText) => {
                            if (success) {
                                const event = new MessageConsumerEvent(MessageConsumerEventName.SUBSCRIPTION_OK, respText, respCode, subCode, correlationKey, `Topic: ${topic.getName()}`);
                                this._emit(MessageConsumerEventName.SUBSCRIPTION_OK, event);
                            } else {
                                const error = new MessageConsumerEvent(MessageConsumerEventName.SUBSCRIPTION_ERROR, respText, respCode, subCode, correlationKey, `Topic: ${topic.getName()}`);
                                this._emit(MessageConsumerEventName.SUBSCRIPTION_ERROR, error);
                            }
                        };
                        this._sessionInterface.updateQueueSubscription(topic, this._fsm.getDestination(), true, this, callback, requestTimeout);
                    }
                    /**
   * Unsubscribe the queue from a topic, requesting confirmation from the router.
   *
   * {@link solace.MessageConsumerEventName.SUBSCRIPTION_OK} is generated when subscription is
   * removed successfully; otherwise, session event
   * {@link solace.MessageConsumerEventName.SUBSCRIPTION_ERROR} is generated.
   *
   * When the application receives the message consumer event
   * {@link solace.MessageConsumerEventName.SUBSCRIPTION_ERROR}, it
   * can obtain the failed topic subscription by calling
   * {@link solace.MessageConsumerEvent#reason}. The returned
   * string is in the format "Topic: <failed topic subscription>".
   *
   * @param {solace.Destination} topic The topic destination subscription to remove.
   * @param {Object} correlationKey If <code>null</code> or undefined, a Correlation Key is not set
   *                                in the confirmation session event.
   * @param {Number} requestTimeout The request timeout period (in milliseconds). If specified, this
   *                                value overwrites readTimeoutInMsecs property in
   *                                {@link SessionProperties}.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected,
   *   or the consumer is inactive, down, disconnected, or disposed.
   *   Or if the consumer is bound to a topic endpoint instead of a queue.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the parameters have an invalid value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   * * if the topic has invalid syntax.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_TOPIC_SYNTAX}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   * * if the topic is a shared subscription and the peer router does not support Shared
   *   Subscriptions.
   *   Subcode: {@link solace.ErrorSubcode.SHARED_SUBSCRIPTIONS_NOT_SUPPORTED}.
   * * if the topic is a shared subscription and the client does not allowed Shared
   *   Subscriptions.
   *   Subcode: {@link solace.ErrorSubcode.SHARED_SUBSCRIPTIONS_NOT_ALLOWED}.
   */
                    removeSubscription(topic, correlationKey, requestTimeout) {
                        const callback = (success, subCode, respCode, respText) => {
                            if (success) {
                                const event = new MessageConsumerEvent(MessageConsumerEventName.SUBSCRIPTION_OK, respText, respCode, subCode, correlationKey, `Topic: ${topic.getName()}`);
                                this._emit(MessageConsumerEventName.SUBSCRIPTION_OK, event);
                            } else {
                                const error = new MessageConsumerEvent(MessageConsumerEventName.SUBSCRIPTION_ERROR, respText, respCode, subCode, correlationKey, `Topic: ${topic.getName()}`);
                                this._emit(MessageConsumerEventName.SUBSCRIPTION_ERROR, error);
                            }
                        };
                        this._sessionInterface.updateQueueSubscription(topic, this._fsm.getDestination(), false, this, callback, requestTimeout);
                    }
                }
                module.exports.MessageConsumer = MessageConsumer;
                /***/
            },
            /***/ "./modules/solclient-message-consumer/lib/message-dispatcher.js": 
            /*!**********************************************************************!*\
  !*** ./modules/solclient-message-consumer/lib/message-dispatcher.js ***!
  \**********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    MessageConsumerEventName
                } = __webpack_require__(/*! ./message-consumer-event-names */ "./modules/solclient-message-consumer/lib/message-consumer-event-names.js");
                function formatEventName(x) {
                    return `MessageConsumerEventName.${MessageConsumerEventName.describe(x)}`;
                }
                class MessageDispatcher {
                    constructor({
                        emitter,
                        autoAck,
                        logger
                    } = {}) {
                        Object.assign(this, {
                            emitter: emitter,
                            queue: [],
                            dispatch: true,
                            formatEventName: formatEventName,
                            logger: logger
                        });
                        this._dispatchOne = autoAck ? this._dispatchOneAutoAck : this._dispatchOneBare;
                        this.emitter.setOnFirstDirectListener(this._onFirstMessageListener.bind(this));
                        // Although a listener may not be available, we set it to true so that we detect a transition to
                        // false when we attempt to dispatch the first message, which will generate a log that
                        // dispatching is stopped due to a missing listener.
                        this._availableListener = true;
                    }
                    start() {
                        this.dispatch = true;
                        this._flush();
                    }
                    stop() {
                        this.dispatch = false;
                    }
                    get length() {
                        return this.queue.length;
                    }
                    push(message) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        this.queue.push(message);
                        if (this.dispatch) {
                            this._flush();
                        } else {
                            LOG_TRACE(`Dispatch disabled, message ${message.getGuaranteedMessageId()} queued locally`);
                        }
                    }
                    _onFirstMessageListener() {
                        const {
                            LOG_DEBUG
                        } = this.logger;
                        if (!this._availableListener) {
                            LOG_DEBUG(`Message listener available for dispatcher, ${this.queue.length} messages queued`);
                            LOG_DEBUG(`Dispatcher started and connected: ${this.dispatch ? "true" : "false"}`);
                            this._availableListener = true;
                        }
                        this._flush();
                    }
                    _flush() {
                        const {
                            LOG_DEBUG
                        } = this.logger;
                        // Check whether dispatch enabled for every element,
                        // to handle when #stop is called from a message handler
                        while (this.queue.length && this.dispatch && this.emitter.directListenerCount() > 0) {
                            this._dispatchOne(this.queue.shift());
                        }
                        if (this.queue.length && this.dispatch && this.emitter.directListenerCount() === 0 && this._availableListener) {
                            LOG_DEBUG("Message dispatching stopped: No message listener registered");
                            this._availableListener = false;
                        }
                    }
                    _dispatchOneAutoAck(message) {
                        const {
                            LOG_WARN
                        } = this.logger;
                        // Set the current outbound message, dispatch it, and clear the current outbound message
                        let caught = null;
                        // Auto-ack unless the receiver throws.
                        caught = this._dispatchOneBare(message);
                        // Outside of exception block because we want to throw normally from message.acknowledge()
                        if (caught) {
                            LOG_WARN(`Suppressing message acknowledgement for message ${message.getGuaranteedMessageId()} because client threw exception from listener`, caught);
                        } else {
                            // Did the user manually ack for some reason?
                            if (message.isAcknowledged) {
                                LOG_WARN(`Consumer configured to auto-acknowledge messages, but message ${message.getGuaranteedMessageId()} was application acknowledged`);
                                return;
                            }
                            message.acknowledge(); // No, so ack the message
                        }
                    }
                    _dispatchOneBare(message) {
                        const {
                            LOG_WARN
                        } = this.logger;
                        let caught;
                        // Requires the emitter's direct option to be MessageConsumerEventName.MESSAGE
                        if (this.listenerCount === 0) {
                            LOG_WARN(`No listeners to dispatch message ${message.getGuaranteedMessageId()}`);
                        }
                        // Since _dispatchOneBare uses emitDirect, this behaviour is not affected by the presence
                        // of an 'error' handler.
                        try {
                            this.emitter.emitDirect(message);
                        } catch (ex) {
                            // User code threw an exception
                            caught = this.emitter.formatErrorEvent(ex, MessageConsumerEventName.MESSAGE, message);
                            // Also propagating to the common error handler
                            this.emitter.emit("error", caught);
                        }
                        return caught;
                    }
                }
                module.exports = {
                    MessageDispatcher: MessageDispatcher
                };
                /***/
            },
            /***/ "./modules/solclient-message-consumer/lib/queue-browser-event-names.js": 
            /*!*****************************************************************************!*\
  !*** ./modules/solclient-message-consumer/lib/queue-browser-event-names.js ***!
  \*****************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * An enumeration of queue browser event names. A {@link solace.QueueBrowser} will emit
 * these events as part of its lifecycle.  Applications, having created a QueueBrowser can
 * choose to listen to all of the events described here, or any subset of these events. For Example:
 * <pre>
 *   <code>
 *     qb = solace.Session.createQueueBrowser(...);
 *     qb.on(solace.QueueBrowserEventName.CONNECT_FAILED_ERROR,
 *           function connectFailedErrorEventCb(error) {
 *             // details is an OperationError object
 *           });
 *   </code>
 * </pre>
 *
 * @memberof solace
 * @enum {string}
 * @namespace
 */
                const QueueBrowserEventName = {
                    /**
   * The queue browser is established.
   * @event solace.QueueBrowserEventName#UP
   */
                    UP: "QueueBrowserEventName_up",
                    /**
   * The queue browser is successfully disconnected.
   * The queue browser is disabled.
   *
   * @event solace.QueueBrowserEventName#DOWN
   */
                    DOWN: "QueueBrowserEventName_down",
                    /**
   * The queue browser was established and then disconnected by the router,
   * likely due to operator intervention. The queue browser is disabled.
   *
   * @event solace.QueueBrowserEventName#DOWN_ERROR
   * @param {solace.OperationError} error Details of the error.
   */
                    DOWN_ERROR: "QueueBrowserEventName_downError",
                    /**
   * The queue browser attempted to connect but was unsuccessful.
   * The queue browser is disabled.
   *
   * @event solace.QueueBrowserEventName#CONNECT_FAILED_ERROR
   * @param {solace.OperationError} error Details of the error.
   */
                    CONNECT_FAILED_ERROR: "QueueBrowserEventName_connectFailedError",
                    /**
   * The queue browser will not connect because the current session is incompatible
   * with Guaranteed Messaging. The queue browser is disabled until a compatible session
   * is available.
   *
   * @event solace.QueueBrowserEventName#GM_DISABLED
   */
                    GM_DISABLED: "QueueBrowserEventName_GMDisabled",
                    /**
   * The queue browser is being disposed. No further events will be emitted.
   *
   * @event solace.QueueBrowserEventName#DISPOSED
   */
                    DISPOSED: "QueueBrowserEventName_disposed",
                    /**
   * A message was received on the queue browser.
   *
   * If the application did not retain a reference to the message, it
   * may be redelivered by calling {@link solace.QueueBrowser#disconnect} followed by
   * {@link solace.QueueBrowser#connect} depending on the configuration of the queue.
   *
   * When there is no listener for <i>MESSAGE</i> on a QueueBrowser, messages are queued
   * internally until a listener is added.
   *
   * @event solace.QueueBrowserEventName#MESSAGE
   * @param {solace.Message} message The received message being delivered in this event.
   */
                    MESSAGE: "QueueBrowserEventName_message"
                };
                module.exports.QueueBrowserEventName = Enum.new(QueueBrowserEventName);
                /***/
            },
            /***/ "./modules/solclient-message-consumer/lib/queue-browser-properties.js": 
            /*!****************************************************************************!*\
  !*** ./modules/solclient-message-consumer/lib/queue-browser-properties.js ***!
  \****************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const QueueLib = __webpack_require__(/*! solclient-queue */ "./modules/solclient-queue/api.js");
                const {
                    APIProperties
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const {
                    Check
                } = __webpack_require__(/*! solclient-validate */ "./modules/solclient-validate/api.js");
                const DEFAULTS = {
                    queueDescriptor: undefined,
                    connectTimeoutInMsecs: 1e4,
                    connectAttempts: 3,
                    windowSize: 255,
                    transportAcknowledgeTimeoutInMsecs: 1e3,
                    transportAcknowledgeThresholdPercentage: 60
                };
                /**
 * @classdesc
 * Defines the properties for a {@link solace.QueueBrowser}.
 *
 * @memberof solace
 */
                class QueueBrowserProperties extends APIProperties {
                    constructor(options) {
                        super(DEFAULTS, options);
                    }
                    /**
   * Defines the queue from which to consume.
   *  * For durable queues and durable topic endpoints, this must be a
   *    {@link solace.QueueDescriptor}.
   * @type {solace.QueueDescriptor}
   */
                    get queueDescriptor() {
                        return Check.something(this._queueDescriptor) ? this._queueDescriptor : DEFAULTS.queueDescriptor;
                    }
                    set queueDescriptor(value) {
                        if (value) {
                            this._queueDescriptor = new QueueLib.QueueDescriptor(value);
                        } else {
                            this._queueDescriptor = value;
                        }
                    }
                    // ------------ Properties controlling connection of the consumer ----------------
                    /**
   * The bind timeout in milliseconds when creating a connection to the Solace Message Router.
   *  * The valid range is >= 50.
   * @type {Number}
   * @default 10000
   */
                    get connectTimeoutInMsecs() {
                        return Check.something(this._bindTimeoutInMsecs) ? this._bindTimeoutInMsecs : DEFAULTS.connectTimeoutInMsecs;
                    }
                    set connectTimeoutInMsecs(value) {
                        this._bindTimeoutInMsecs = value;
                    }
                    /**
   * Gets and sets the maximum number of bind attempts when creating a connection to the
   * Solace Message Router.
   *  * The valid range is >= 1.
   * @type {Number}
   * @default 3
   */
                    get connectAttempts() {
                        return Check.something(this._connectAttempts) ? this._connectAttempts : DEFAULTS.connectAttempts;
                    }
                    set connectAttempts(val) {
                        this._connectAttempts = val;
                    }
                    // ----------- Properties controlling an established connection to a queue --------------
                    /**
   * The window size for Guaranteed Message delivery.  This is the maximum number of messages that
   * will be prefetched from the Solace Messaging Router and queued internally by the API while
   * waiting for the application to accept delivery of the messages.
   *   * The valid range is 1 <= windowSize <= 255.
   * @type {Number}
   * @default 255
   */
                    get windowSize() {
                        return Check.something(this._windowSize) ? this._windowSize : DEFAULTS.windowSize;
                    }
                    set windowSize(val) {
                        this._windowSize = val;
                    }
                    /**
   * The transport acknowledgement timeout for guaranteed messaging in milliseconds.
   * When the {@link solace.QueueBrowserProperties.transportAcknowledgeTimeoutInMsecs} is not
   * exceeded, acknowledgements will be returned to the router at intervals not less than
   * this value.
   *   * The valid range is 20 <= transportAcknowledgeTimeoutInMsecs <= 1500.
   * @type {Number}
   * @default 1000
   */
                    get transportAcknowledgeTimeoutInMsecs() {
                        return Check.something(this._transportAcknowledgeTimeoutInMsecs) ? this._transportAcknowledgeTimeoutInMsecs : DEFAULTS.transportAcknowledgeTimeoutInMsecs;
                    }
                    set transportAcknowledgeTimeoutInMsecs(val) {
                        this._transportAcknowledgeTimeoutInMsecs = val;
                    }
                    /**
   * The threshold for sending an acknowledgement, as a percentage.
   * The API sends a transport acknowledgment every
   * N messages where N is calculated as this percentage of the transport
   * window size if the endpoint's max-delivered-unacked-msgs-per-flow
   * setting at bind time is greater than or equal to the transport
   * window size. Otherwise, N is calculated as this percentage of the
   * endpoint's max-delivered-unacked-msgs-per-flow setting at bind time.
   * * The valid range is 1 <= transportAcknowledgeThresholdPercentage <= 75.
   * @type {Number}
   * @default 60
   */
                    get transportAcknowledgeThresholdPercentage() {
                        return Check.something(this._transportAcknowledgeThresholdPercentage) ? this._transportAcknowledgeThresholdPercentage : DEFAULTS.transportAcknowledgeThresholdPercentage;
                    }
                    set transportAcknowledgeThresholdPercentage(value) {
                        this._transportAcknowledgeThresholdPercentage = value;
                    }
                }
                module.exports.QueueBrowserProperties = QueueBrowserProperties;
                /***/
            },
            /***/ "./modules/solclient-message-consumer/lib/queue-browser.js": 
            /*!*****************************************************************!*\
  !*** ./modules/solclient-message-consumer/lib/queue-browser.js ***!
  \*****************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    EventEmitter
                } = __webpack_require__(/*! solclient-events */ "./modules/solclient-events/api.js");
                const {
                    LogFormatter
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    MessageConsumerEventName
                } = __webpack_require__(/*! ./message-consumer-event-names */ "./modules/solclient-message-consumer/lib/message-consumer-event-names.js");
                const {
                    QueueBrowserEventName
                } = __webpack_require__(/*! ./queue-browser-event-names */ "./modules/solclient-message-consumer/lib/queue-browser-event-names.js");
                function formatEventName(eventName) {
                    return `QueueBrowserEventName.${QueueBrowserEventName.describe(eventName)}`;
                }
                /**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 * A Queue Browser is created by calling {@link solace.Session#createQueueBrowser}.
 *
 * A Queue Browser allows client applications to look at messages spooled on Endpoints
 * without removing them. Messages are browsed from oldest to newest.
 * After being browsed, messages are still available for consumption over normal flows.
 * However, it is possible to selectively remove messages from the persistent store of an Endpoint.
 * In this case, these removed messages will no longer be available for consumption.

 * Note: If browsing a queue with an active consumer, no guarantee is made that the browser will
 * receive all messages published to the queue. The consumer can receive and acknowledge messages
 * before they are delivered to the browser.
 *
 * One typical application is to use Browsers to allow message bus administrators to remove stuck
 * Guaranteed messages from an Endpoint without having to modify or disrupt existing applications.
 * A message can get stuck if:
 *
 *  1) It has been received by an application, but for some reason, that application has failed to
 *     acknowledge it.
 *  2) All active message selectors have failed to match this particular message and therefore the
 *     message bus has not delivered it to any client yet. The current release only supports
 *     browsing Endpoints of type Queue.
 *
 * Note that the delivery restrictions imposed by the queues Access type
 * (exclusive or non-exclusive), do not apply when browsing messages with a Browser.
 *
 * Browser characteristics and behavior are defined by {@link solace.QueueBrowserProperties}.
 * The properties can also be supplied as a simple key-value {Object}. The queue descriptor,
 * {@link solace.QueueBrowserProperties#queueDescriptor} must be specified to identify the
 * Guaranteed Message Queue on the Solace Message Router.
 *
 * The Browser is an EventEmitter, and will emit events to which the application may choose to
 * subscribe, such as the connection to the Solace Message Router going up or down.
 *
 * If a registered listener for an emitted event throws an exception, this is caught and emitted as
 * an 'error'.
 *
 * @fires solace.QueueBrowserEventName#CONNECT_FAILED_ERROR
 * @fires solace.QueueBrowserEventName#DISPOSED
 * @fires solace.QueueBrowserEventName#DOWN
 * @fires solace.QueueBrowserEventName#DOWN_ERROR
 * @fires solace.QueueBrowserEventName#GM_DISABLED
 * @fires solace.QueueBrowserEventName#MESSAGE
 * @fires solace.QueueBrowserEventName#UP
 *
 * @hideconstructor
 * @memberof solace
 */
                class QueueBrowser extends EventEmitter {
                    constructor(messageConsumer) {
                        super({
                            direct: QueueBrowserEventName.MESSAGE,
                            emits: QueueBrowserEventName.values,
                            formatEventName: formatEventName
                        });
                        this._messageConsumer = messageConsumer;
                        this.logger = new LogFormatter((...args) => [ "[queue-browser]", ...args ]);
                        this._setupEventListers();
                    }
                    _setupEventListers() {
                        // Listen to message consumer events, redispatch as queue browser events
                        this._messageConsumer.on(MessageConsumerEventName.UP, this._onConsumerUp.bind(this));
                        this._messageConsumer.on(MessageConsumerEventName.CONNECT_FAILED_ERROR, this._onConsumerConnectFailed.bind(this));
                        this._messageConsumer.on(MessageConsumerEventName.DOWN, this._onConsumerDown.bind(this));
                        this._messageConsumer.on(MessageConsumerEventName.DOWN_ERROR, this._onConsumerDownError.bind(this));
                        this._messageConsumer.on(MessageConsumerEventName.MESSAGE, this._onConsumerMessage.bind(this));
                        this._messageConsumer.on(MessageConsumerEventName.DISPOSED, this._onConsumerDisposed.bind(this));
                        this._messageConsumer.on(MessageConsumerEventName.GM_DISABLED, this._onConsumerGMDisabled.bind(this));
                    }
                    _onConsumerMessage(event) {
                        this.emit(QueueBrowserEventName.MESSAGE, event);
                    }
                    _onConsumerUp(event) {
                        this.emit(QueueBrowserEventName.UP, event);
                    }
                    _onConsumerConnectFailed(event) {
                        this.emit(QueueBrowserEventName.CONNECT_FAILED_ERROR, event);
                    }
                    _onConsumerDown(event) {
                        this.emit(QueueBrowserEventName.DOWN, event);
                    }
                    _onConsumerDownError(event) {
                        this.emit(QueueBrowserEventName.DOWN_ERROR, event);
                    }
                    _onConsumerDisposed(event) {
                        this.emit(QueueBrowserEventName.DISPOSED, event);
                    }
                    _onConsumerGMDisabled(event) {
                        this.emit(QueueBrowserEventName.GM_DISABLED, event);
                    }
                    /**
   * Connects the queue browser immediately. The application should add event listeners (see
   * {@link solace.QueueBrowserEventName}). If there is no listener added for
   * {@link solace.QueueBrowserEventName#event:MESSAGE} then up to a window
   * {@link solace.QueueBrowserProperties.windowSize} of messages can be queued internally.
   * before calling this method.
   *
   * @throws {solace.OperationError}
   *  * if consumer is not supported by router for this client.
   *  subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   *
   */
                    connect() {
                        const {
                            LOG_DEBUG,
                            LOG_ERROR
                        } = this.logger;
                        try {
                            LOG_DEBUG("Connecting the queue browser's message consumer");
                            this._messageConsumer.connect();
                        } catch (error) {
                            LOG_ERROR(error.toString());
                            throw error;
                        }
                    }
                    /**
   * Initiates an orderly disconnection of the queue browser. The API will send an unbind request.
   * Any messages subsequently received are discarded silently.
   * When the unbind message is acknowledged, the application
   * receives a {@link solace.QueueBrowserEventName#event:DOWN} event if it has set a listener
   * for that event.
   *
   * @throws {solace.OperationError}
   * * if the Message Consumer is disconnected.
   *   subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   */
                    disconnect() {
                        const {
                            LOG_DEBUG,
                            LOG_ERROR
                        } = this.logger;
                        try {
                            LOG_DEBUG("Disconnecting the queue browser's message consumer");
                            this._messageConsumer.disconnect();
                        } catch (error) {
                            LOG_ERROR(error.toString());
                            throw error;
                        }
                    }
                    /**
   * Begins delivery of messages to this queue browser. This method opens the protocol window
   * to the Solace Message Router so further messages can be received.
   *
   * A newly created queue browser is in started state.
   *
   * If the queue browser was already started, this method has no effect.
   *
   * A consumer is stopped by calling {@link solace.QueueBrowser.stop}
   *
   * @throws {solace.OperationError}
   * * if the Queue BrowserMessage Consumer is disposed.
   *   subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   * * if the Message Consumer is disconnected.
   *   subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   */
                    start() {
                        const {
                            LOG_DEBUG,
                            LOG_ERROR
                        } = this.logger;
                        try {
                            LOG_DEBUG("Starting the queue browser's message consumer");
                            this._messageConsumer.start();
                        } catch (error) {
                            LOG_ERROR(error.toString());
                            throw error;
                        }
                    }
                    /**
   * Stops messages from being delivered to this queue browser from the Solace Message Router.
   * Messages may continue to be prefetched by the API and queued internally
   * until {@link solace.QueueBrowser#start} is called.
   *
   * If the queue browser was already stopped, this method has no effect.
   *
   * @throws {solace.OperationError}
   * * if the Queue Browser is disconnected.
   *   subcode = {@link solace.ErrorSubcode.INVALID_OPERATION}
   */
                    stop() {
                        const {
                            LOG_DEBUG,
                            LOG_ERROR
                        } = this.logger;
                        try {
                            LOG_DEBUG("Stopping the queue browser's message consumer");
                            this._messageConsumer.stop();
                        } catch (error) {
                            LOG_ERROR(error.toString());
                            throw error;
                        }
                    }
                    /**
   * Removes a message from the queue by acknowledging it.
   *
   * The {@link solace.QueueBrowser} does not automatically acknowledge messages.
   * once they have been received.
   *
   * The API does not send acknowledgments immediately. It stores the state for
   * acknowledged messages internally and acknowledges messages, in bulk, when a
   * threshold or timer is reached.
   *
   * @param {Message} message The message to remove
   */
                    removeMessageFromQueue(message) {
                        // ack the message to delete it
                        this._messageConsumer.applicationAck(message._guaranteedMsgId);
                        message._acked = true;
                    }
                }
                module.exports.QueueBrowser = QueueBrowser;
                /***/
            },
            /***/ "./modules/solclient-message-consumer/lib/transport-acks.js": 
            /*!******************************************************************!*\
  !*** ./modules/solclient-message-consumer/lib/transport-acks.js ***!
  \******************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /* provided dependency */ var util_inspect = __webpack_require__(/*! browser-util-inspect */ "./node_modules/browser-util-inspect/index.js");
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                const {
                    LOG_TRACE,
                    LOG_DEBUG
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    Long
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const TransportAckResult = Enum.new({
                    OK: 0,
                    DUPLICATE: 1,
                    OUT_OF_ORDER: 2
                });
                class TransportAcks {
                    constructor(id = 0) {
                        const base = typeof id === "number" ? Long.fromNumber(id, true) : Long.fromValue(id);
                        this.lastAcked = base;
                        this._acksPending = 0;
                    }
                    reset() {
                        this._acksPending = 0;
                        this.lastAcked = Long.ZERO;
                    }
                    tryReceive(messageID, prevMessageID) {
                        if (this._lastReceived.lt(prevMessageID)) {
                            LOG_DEBUG(`Rejecting out of order message: ${prevMessageID} (last received: ${this._lastReceived})`);
                            return TransportAckResult.OUT_OF_ORDER;
                        }
                        if (this._lastReceived.gte(messageID)) {
                            LOG_DEBUG(`Rejecting duplicate message: ${messageID} (last received: ${this._lastReceived})`);
                            // duplicate messages indicate the router is retransmitting because it expects a transport ack
                            this._acksPending++;
                            return TransportAckResult.DUPLICATE;
                        }
                        LOG_TRACE(`Accepting message: ${messageID}`);
                        this._lastReceived = messageID;
                        this._acksPending++;
                        return TransportAckResult.OK;
                    }
                    setAcked() {
                        this._lastAcked = Long.fromValue(this._lastReceived);
                        this._acksPending = 0;
                    }
                    get acksPending() {
                        return this._acksPending;
                    }
                    get lastAcked() {
                        return this._lastAcked;
                    }
                    /**
   * Resets the beginning of the ack sequence to the given value.
   * @param {Long} value The value to set as last acknowledged ID.
   */
                    set lastAcked(value) {
                        LOG_TRACE("Setting last acked:", value.toString());
                        Object.assign(this, {
                            _lastAcked: Long.fromValue(value),
                            _lastReceived: Long.fromValue(value)
                        });
                    }
                    get lastReceived() {
                        return this._lastReceived;
                    }
                    toString() {
                        return util_inspect(this);
                    }
                }
                module.exports = {
                    TransportAcks: TransportAcks,
                    TransportAckResult: TransportAckResult
                };
                /***/
            },
            /***/ "./modules/solclient-message-publisher/api.js": 
            /*!****************************************************!*\
  !*** ./modules/solclient-message-publisher/api.js ***!
  \****************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    MessagePublisher
                } = __webpack_require__(/*! ./lib/message-publisher */ "./modules/solclient-message-publisher/lib/message-publisher.js");
                const {
                    MessagePublisherAcknowledgeMode
                } = __webpack_require__(/*! ./lib/message-publisher-acknowledge-modes */ "./modules/solclient-message-publisher/lib/message-publisher-acknowledge-modes.js");
                const {
                    MessagePublisherEventName
                } = __webpack_require__(/*! ./lib/message-publisher-event-names */ "./modules/solclient-message-publisher/lib/message-publisher-event-names.js");
                const {
                    MessagePublisherProperties
                } = __webpack_require__(/*! ./lib/message-publisher-properties */ "./modules/solclient-message-publisher/lib/message-publisher-properties.js");
                const {
                    MessagePublisherPropertiesValidator
                } = __webpack_require__(/*! ./lib/message-publisher-properties-validator */ "./modules/solclient-message-publisher/lib/message-publisher-properties-validator.js");
                const {
                    PublisherFSMEvent
                } = __webpack_require__(/*! ./lib/publisher-fsm-event */ "./modules/solclient-message-publisher/lib/publisher-fsm-event.js");
                const {
                    PublisherFSMEventNames
                } = __webpack_require__(/*! ./lib/publisher-fsm-event-names */ "./modules/solclient-message-publisher/lib/publisher-fsm-event-names.js");
                module.exports.MessagePublisherAcknowledgeMode = MessagePublisherAcknowledgeMode;
                module.exports.MessagePublisher = MessagePublisher;
                module.exports.MessagePublisherProperties = MessagePublisherProperties;
                module.exports.PublisherFSMEvent = PublisherFSMEvent;
                module.exports.PublisherFSMEventNames = PublisherFSMEventNames;
                module.exports.MessagePublisherPropertiesValidator = MessagePublisherPropertiesValidator;
                module.exports.MessagePublisherEventName = MessagePublisherEventName;
                /***/
            },
            /***/ "./modules/solclient-message-publisher/lib/message-ids.js": 
            /*!****************************************************************!*\
  !*** ./modules/solclient-message-publisher/lib/message-ids.js ***!
  \****************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /* provided dependency */ var util_inspect = __webpack_require__(/*! browser-util-inspect */ "./node_modules/browser-util-inspect/index.js");
                const {
                    Long
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const DEFAULTS = {
                    _lastAcked: Long.fromNumber(0, true),
                    _lastSent: Long.fromNumber(0, true),
                    _next: Long.fromNumber(1, true)
                };
                const longToString = v => v.toString(10);
                class MessageIds {
                    constructor(attrs) {
                        Object.assign(this, DEFAULTS, attrs);
                    }
                    get lastAcked() {
                        return this._lastAcked;
                    }
                    set lastAcked(value) {
                        this._lastAcked = Long.fromValue(value);
                    }
                    get lastSent() {
                        return this._lastSent;
                    }
                    setLastSent(id) {
                        this._lastSent = Long.fromValue(id);
                        this._next = this._lastSent.add(1);
                    }
                    get next() {
                        return this._next;
                    }
                    ["inspect"]() {
                        return {
                            lastAcked: longToString(this.lastAcked),
                            lastSent: longToString(this.lastSent),
                            next: longToString(this.next)
                        };
                    }
                    toString() {
                        return util_inspect(this);
                    }
                }
                module.exports.MessageIds = MessageIds;
                /***/
            },
            /***/ "./modules/solclient-message-publisher/lib/message-publisher-acknowledge-modes.js": 
            /*!****************************************************************************************!*\
  !*** ./modules/solclient-message-publisher/lib/message-publisher-acknowledge-modes.js ***!
  \****************************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Represents authentication scheme enumeration.
 * @enum {string}
 * @namespace
 * @memberof solace
 */
                const MessagePublisherAcknowledgeMode = {
                    /**
   * @description Applications receive an acknowledgement for every
   * message.
   * @type {String}
   */
                    PER_MESSAGE: "PER_MESSAGE",
                    /**
   * @description Applications receive a windowed acknowledgement that
   * acknowledges the returned correlation identifier and every message sent prior.
   * @type {String}
   */
                    WINDOWED: "WINDOWED"
                };
                module.exports.MessagePublisherAcknowledgeMode = Enum.new(MessagePublisherAcknowledgeMode);
                /***/
            },
            /***/ "./modules/solclient-message-publisher/lib/message-publisher-event-names.js": 
            /*!**********************************************************************************!*\
  !*** ./modules/solclient-message-publisher/lib/message-publisher-event-names.js ***!
  \**********************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * The publisher currently isn't exposed, and its events are dispatched
 * via the Session. These events are therefore private. They should
 * be moved to MessageConsumerEventName when they are made public.
 * @private
 */
                const MessagePublisherEventName = Enum.new({
                    ACKNOWLEDGED_MESSAGE: "MessagePublisherEventName_acknowledgedMessage",
                    CONNECT_FAILED_ERROR: "MessagePublisherEventName_connectFailedError",
                    CAN_SEND: "MessagePublisherEventName_canSend",
                    DISPOSED: "MessagePublisherEventName_disposed",
                    DOWN: "MessagePublisherEventName_down",
                    FLOW_NAME_CHANGED: "MessagePublisherEventName_flowNameChanged",
                    GUARANTEED_MESSAGING_DOWN: "MessagePublisherEventName_guaranteedMessagingDown",
                    REJECTED_MESSAGE: "MessagePublisherEventName_rejectedMessage",
                    DISCONNECT_FAILED_ERROR: "MessagePublisherEventName_disconnectFailedError",
                    UP: "MessagePublisherEventName_up",
                    TRANSPORT_FULL: "MessagePublisherEventName_transportFull"
                });
                module.exports.MessagePublisherEventName = MessagePublisherEventName;
                /***/
            },
            /***/ "./modules/solclient-message-publisher/lib/message-publisher-properties-validator.js": 
            /*!*******************************************************************************************!*\
  !*** ./modules/solclient-message-publisher/lib/message-publisher-properties-validator.js ***!
  \*******************************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    APIPropertiesValidators
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const {
                    MessagePublisherAcknowledgeMode
                } = __webpack_require__(/*! ./message-publisher-acknowledge-modes */ "./modules/solclient-message-publisher/lib/message-publisher-acknowledge-modes.js");
                const {
                    validateInstance,
                    valBoolean,
                    valIsMember,
                    valNumber,
                    valRange
                } = APIPropertiesValidators;
                const MessagePublisherPropertiesValidator = {
                    validate(instance) {
                        const v = validateInstance.bind(null, "MessagePublisherProperties", instance);
                        v("enabled", [ valBoolean ]);
                        v("windowSize", [ valNumber ], [ valRange, 1, 255 ]);
                        v("acknowledgeTimeoutInMsecs", [ valNumber ], [ valRange, 20, 6e4 ]);
                        v("acknowledgeMode", [ valIsMember, MessagePublisherAcknowledgeMode, "MessagePublisherAcknowledgeMode" ]);
                        v("connectRetryCount", [ valNumber ], [ valRange, 0, Number.MAX_VALUE ]);
                        v("connectTimeoutInMsecs", [ valNumber ], [ valRange, 50, Number.MAX_VALUE ]);
                    }
                };
                module.exports.MessagePublisherPropertiesValidator = MessagePublisherPropertiesValidator;
                /***/
            },
            /***/ "./modules/solclient-message-publisher/lib/message-publisher-properties.js": 
            /*!*********************************************************************************!*\
  !*** ./modules/solclient-message-publisher/lib/message-publisher-properties.js ***!
  \*********************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const SolclientFactoryLib = __webpack_require__(/*! solclient-factory */ "./modules/solclient-factory/api.js");
                const {
                    APIProperties
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const {
                    Check
                } = __webpack_require__(/*! solclient-validate */ "./modules/solclient-validate/api.js");
                const {
                    MessagePublisherAcknowledgeMode
                } = __webpack_require__(/*! ./message-publisher-acknowledge-modes */ "./modules/solclient-message-publisher/lib/message-publisher-acknowledge-modes.js");
                const {
                    TransportCapabilities
                } = __webpack_require__(/*! solclient-transport */ "./modules/solclient-transport/api.js");
                function defaultEnablePublisher() {
                    const {
                        ProfileBinding
                    } = SolclientFactoryLib;
                    const binding = ProfileBinding.value;
                    const globallyEnabled = binding.guaranteedMessagingEnabled;
                    const webSocketAvailable = TransportCapabilities.web.webSocket();
                    return globallyEnabled && webSocketAvailable;
                }
                function getDefaults() {
                    return {
                        enabled: defaultEnablePublisher(),
                        windowSize: 50,
                        acknowledgeTimeoutInMsecs: 2e3,
                        acknowledgeMode: MessagePublisherAcknowledgeMode.PER_MESSAGE,
                        connectRetryCount: 3,
                        connectTimeoutInMsecs: 5e3
                    };
                }
                /**
 * @classdesc
 * Properties that define the configuration for a guaranteed message publisher.
 *
 * @memberof solace
 */
                class MessagePublisherProperties extends APIProperties {
                    /**
   * @constructor
   * @param {Object} options Properties to apply to the newly constructed object.
   */
                    constructor(options) {
                        super(getDefaults(), options || {});
                    }
                    /**
   * @name solace.MessagePublisherProperties#enabled
   * @type {Boolean}
   * @description When enabled, a Guaranteed Messaging Publisher
   * is automatically created when a session is connected.
   *
   * The default value is the same as the value provided to
   * {@link solace.SolclientFactory.init},
   * in the profile, {@link solace.SolclientFactoryProperties#profile},
   * in the field {@link solace.FactoryProfile#guaranteedMessagingEnabled}.
   */
                    get enabled() {
                        return this._enabled;
                    }
                    set enabled(newValue) {
                        this._enabled = newValue;
                    }
                    /**
   * @name solace.MessagePublisherProperties#windowSize
   * @default 50
   * @type {Number}
   * @description  Maximum number of messages that can be published
   * without acknowledgment.
   *  * The valid range is 1 <= value <= 255
   */
                    get windowSize() {
                        return Check.defined(this._windowSize) ? this._windowSize : getDefaults().windowSize;
                    }
                    set windowSize(newValue) {
                        this._windowSize = newValue;
                    }
                    /**
   * @name solace.MessagePublisherProperties#acknowledgeTimeoutInMsecs
   * @type {Number}
   * @default 2000
   * @description  The time to wait for an acknowledgement,
   * in milliseconds, before retransmitting unacknowledged
   * messages.
   *  * The valid range is 20 <= value <= 60000.
   */
                    get acknowledgeTimeoutInMsecs() {
                        return Check.defined(this._acknowledgeTimeoutInMsecs) ? this._acknowledgeTimeoutInMsecs : getDefaults().acknowledgeTimeoutInMsecs;
                    }
                    set acknowledgeTimeoutInMsecs(newValue) {
                        this._acknowledgeTimeoutInMsecs = newValue;
                    }
                    /**
   * @name solace.MessagePublisherProperties#acknowledgeMode
   * @type {solace.MessagePublisherAcknowledgeMode}
   * @default {@link solace.MessagePublisherAcknowledgeMode.PER_MESSAGE}
   * @description  The message-router sends windowed acknowledgements
   * which the API converts to per-message acknowledgement by default. If
   * acknowledgeMode is Windowed, then the API will simply pass through
   * the message-router acknowledgements.
   */
                    get acknowledgeMode() {
                        return this._acknowledgeMode || MessagePublisherAcknowledgeMode.PER_MESSAGE;
                    }
                    set acknowledgeMode(newValue) {
                        this._acknowledgeMode = newValue;
                    }
                    /**
   * @name solace.MessagePublisherProperties#connectRetryCount
   * @type {Number}
   * @default 3
   * @description The number of times to retry a bind (aka open-flow) request
   * before deciding the the Guaranteed Message Publisher cannot be started.
   *  * The valid range 0 <= value.
   * @private
   */
                    get connectRetryCount() {
                        return Check.defined(this._connectRetryCount) ? this._connectRetryCount : getDefaults().connectRetryCount;
                    }
                    set connectRetryCount(newValue) {
                        this._connectRetryCount = newValue;
                    }
                    /**
   * @name solace.MessagePublisherProperties#connectTimeoutInMsecs
   * @type {Number}
   * @default 5000
   * @description  The time to wait for an bind response,
   * in milliseconds, before retransmitting the bind request.
   *  * The valid range is 50 <= value</li>
   * @private
   */
                    get connectTimeoutInMsecs() {
                        return Check.defined(this._connectTimeoutInMsecs) ? this._connectTimeoutInMsecs : getDefaults().connectTimeoutInMsecs;
                    }
                    set connectTimeoutInMsecs(newValue) {
                        this._connectTimeoutInMsecs = newValue;
                    }
                    ["inspect"]() {
                        return {
                            enabled: this.enabled,
                            windowSize: this.windowSize,
                            acknowledgeTimeoutInMsecs: this.acknowledgeTimeoutInMsecs,
                            acknowledgeMode: MessagePublisherAcknowledgeMode.describe(this.acknowledgeMode),
                            connectRetryCount: this.connectRetryCount,
                            connectTimeoutInMsecs: this.connectTimeoutInMsecs
                        };
                    }
                }
                module.exports.MessagePublisherProperties = MessagePublisherProperties;
                /***/
            },
            /***/ "./modules/solclient-message-publisher/lib/message-publisher.js": 
            /*!**********************************************************************!*\
  !*** ./modules/solclient-message-publisher/lib/message-publisher.js ***!
  \**********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /* provided dependency */ var util_inspect = __webpack_require__(/*! browser-util-inspect */ "./node_modules/browser-util-inspect/index.js");
                const SMFLib = __webpack_require__(/*! solclient-smf */ "./modules/solclient-smf/api.js");
                const {
                    Flow,
                    PrivateFlowEventName
                } = __webpack_require__(/*! solclient-flow */ "./modules/solclient-flow/api.js");
                const {
                    LogFormatter
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    MessagePublisherEventName
                } = __webpack_require__(/*! ./message-publisher-event-names */ "./modules/solclient-message-publisher/lib/message-publisher-event-names.js");
                const {
                    MessagePublisherProperties
                } = __webpack_require__(/*! ./message-publisher-properties */ "./modules/solclient-message-publisher/lib/message-publisher-properties.js");
                const {
                    PublisherFSM
                } = __webpack_require__(/*! ./publisher-fsm */ "./modules/solclient-message-publisher/lib/publisher-fsm.js");
                const {
                    PublisherFSMEvent
                } = __webpack_require__(/*! ./publisher-fsm-event */ "./modules/solclient-message-publisher/lib/publisher-fsm-event.js");
                const {
                    PublisherFSMEventNames
                } = __webpack_require__(/*! ./publisher-fsm-event-names */ "./modules/solclient-message-publisher/lib/publisher-fsm-event-names.js");
                const {
                    LOG_WARN
                } = new LogFormatter();
                class MessagePublisher extends Flow {
                    /**
   * Represents a Guaranteed Message Publisher.  This object must be used to publish
   * Guaranteed Messages on a session.
   *
   * Publishers are created on sessions.  In this implementation the session functions are provided
   * by the sessionFSM.  Publishers require the session to provide
   * basic communications functions:
   *  * send - send a message to the transport
   *  * getCorrelationTag - return a unique transport correlation tag
   *  * enqueueOutstandingCorrelatedReq - enqueue a callback for a received message
   *    on a correlation tag
   *
   * @constructor
   * @param {Object} properties Expected schema is
   *  {@link solace.MessagePublisherProperties}
   * @param {Object} sessionInterfaceFactory The session for the Guaranteed Message Publisher
   * @private
   */
                    constructor({
                        properties,
                        sessionInterfaceFactory
                    } = {}) {
                        const applyProperties = new MessagePublisherProperties(properties);
                        super(applyProperties, sessionInterfaceFactory, {
                            direct: MessagePublisherEventName.ACKNOWLEDGED_MESSAGE,
                            emits: MessagePublisherEventName.values
                        });
                        this._fsm = this._makeFSM();
                        const logger = new LogFormatter();
                        logger.formatter = function formatter(...args) {
                            return [ "[message-publisher]", ...args ];
                        };
                        this.log = logger.wrap(this.log, this);
                        // Doesn't emit anything unless started; won't start unless bindWaiting
                        this._bindWaiting = true;
                        this.on(PrivateFlowEventName.BIND_WAITING, this._onBindWaiting.bind(this));
                        this.on(MessagePublisherEventName.CONNECT_FAILED_ERROR, this._onBindFailed.bind(this));
                        this.on(MessagePublisherEventName.DOWN, this._onDown.bind(this));
                        this.on(MessagePublisherEventName.UP, this._onUp.bind(this));
                    }
                    _onBindFailed() {
                        this._bindWaiting = false;
                    }
                    _onBindWaiting() {
                        this._bindWaiting = true;
                    }
                    _onDown() {
                        this._bindWaiting = false;
                    }
                    _onUp() {
                        this._bindWaiting = false;
                    }
                    /**
   * @override
   * @private
   */
                    _makeFSM() {
                        return new PublisherFSM({
                            publisher: this,
                            name: "PublisherFSM",
                            sessionInterface: this._sessionInterface,
                            properties: this._properties
                        });
                    }
                    /**
   * @returns {Long} The flow ID of this flow
   */
                    get flowId() {
                        return this._flowId;
                    }
                    /**
   * @param {Long} value The flow ID for this flow
   * @private
   */
                    set flowId(value) {
                        this._flowId = value;
                    }
                    /**
   * @returns {String} The publisher name set for this flow
   */
                    get name() {
                        return this._flowName;
                    }
                    /**
   * @param {String} value The name to set on this flow
   * @private
   */
                    set name(value) {
                        this._flowName = value;
                    }
                    /**
   * @returns {Number} The publisher ID set on this flow
   */
                    get publisherId() {
                        return this._publisherId;
                    }
                    /**
   * @param {Number} value The publisher ID to set on this flow
   */
                    set publisherId(value) {
                        this._publisherId = value;
                    }
                    /**
   * @readonly
   * @returns {solace.MessagePublisherProperties} A clone of the publisher's properties.
   */
                    get properties() {
                        return this._properties.clone();
                    }
                    /**
   *
   * @override
   * @memberof MessagePublisher
   */
                    connect() {
                        super.connect();
                        if (!this._fsm.getCurrentState()) {
                            this._fsm.start();
                        }
                    }
                    /**
   * Application has disconnected the session, so
   * disconnects the Guaranteed Message Publisher.
   * @private
   */
                    _disconnectSession() {
                        super._disconnectSession();
                        this.processFSMEvent(new PublisherFSMEvent({
                            name: PublisherFSMEventNames.FLOW_CLOSE
                        }));
                    }
                    /**
   * @returns {solace.MessagePublisherEventName} The name of the disposed event for this flow
   * @private
   */
                    getDisposedEvent() {
                        // eslint-disable-line class-methods-use-this
                        return MessagePublisherEventName.DISPOSED;
                    }
                    /**
   * Handles an incoming ACK for the given message ID.
   * @param {Long} id The message id for acknowledgement.
   * @private
   */
                    handleAck(id) {
                        this.processFSMEvent(new PublisherFSMEvent({
                            name: PublisherFSMEventNames.ACK
                        }, {
                            ack: id
                        }));
                    }
                    /**
   * Handles an incoming NACK for the given message ID.
   * @param {Long} id The message id for acknowledgement.
   * @param {AdCtrlMessage} ctrlMessage The NACK message
   * @private
   */
                    handleNack(id, ctrlMessage) {
                        this.processFSMEvent(new PublisherFSMEvent({
                            name: PublisherFSMEventNames.ACK
                        }, {
                            nack: id,
                            ctrlMessage: ctrlMessage
                        }));
                    }
                    /**
   * @override
   */
                    handleUncorrelatedControlMessage(message) {
                        const msgType = message.msgType;
                        const {
                            SMFAdProtocolMessageType
                        } = SMFLib;
                        switch (msgType) {
                          case SMFAdProtocolMessageType.CLIENTACK:
                            {
                                const id = message.getLastMsgIdAcked();
                                if (message.smfHeader.pm_respcode > 299) {
                                    this.handleNack(id, message);
                                } else {
                                    this.handleAck(id);
                                }
                                break;
                            }

                          case SMFAdProtocolMessageType.CLIENTNACK:
                            {
                                const id = message.getLastMsgIdAcked();
                                this.handleNack(id, message);
                                break;
                            }

                          case SMFAdProtocolMessageType.CLOSEPUBFLOW:
                            this.processFSMEvent(new PublisherFSMEvent({
                                name: PublisherFSMEventNames.FLOW_UNBOUND
                            }));
                            break;

                          default:
                            LOG_WARN(`Dropping unhandled AD control message for ${this}`, SMFAdProtocolMessageType.describe(msgType));
                        }
                    }
                    /**
   * Prepares an AD message for publishing on this flow.
   * @param {Message} dataMsg The message to be prepared for publishing.
   * @returns {TransportReturnCode} transport level returnCode
   * @private
   */
                    prepareAdMessageAndSend(dataMsg) {
                        return this._fsm.prepareAdMessageAndSend(dataMsg);
                    }
                    isBindWaiting() {
                        return this._bindWaiting;
                    }
                    /**
   * @returns {String} Formatted inspector output
   * @private
   */
                    ["inspect"]() {
                        return Object.assign(super["inspect"](), {
                            name: this.name,
                            publisherId: this.publisherId
                        });
                    }
                    /**
   * @override
   */
                    toString() {
                        return util_inspect(this);
                    }
                    /**
   * Disposes the FSM associated with this flow.
   *
   * @private
   */
                    _disposeFSM() {
                        this.processFSMEvent(new PublisherFSMEvent({
                            name: PublisherFSMEventNames.DISPOSE
                        }));
                    }
                    _isDisconnected() {
                        return this._fsm.isDisconnected();
                    }
                }
                module.exports.MessagePublisher = MessagePublisher;
                /***/
            },
            /***/ "./modules/solclient-message-publisher/lib/publisher-fsm-event-names.js": 
            /*!******************************************************************************!*\
  !*** ./modules/solclient-message-publisher/lib/publisher-fsm-event-names.js ***!
  \******************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /********************************************************************************
 * @private
 * Events on the Publisher FSM
 * @enum {string}
 ********************************************************************************/
                const PublisherFSMEventNames = {
                    SESSION_UP: "PublisherSessionUp",
                    SESSION_UP_NO_AD: "PublisherSessionUpNoAD",
                    SESSION_DOWN: "PublisherSessionDown",
                    FLOW_FAILED: "MessagePublisherFailed",
                    FLOW_UP: "MessagePublisherUp",
                    FLOW_CLOSE: "MessagePublisherClose",
                    FLOW_UNBOUND: "MessagePublisherUnbound",
                    TRANSPORT_FULL: "PublisherTransportFull",
                    ACK: "PublisherAck",
                    ACK_TIMEOUT: "PublisherAckTimeout",
                    BIND_TIMEOUT: "PublisherBindTimeout",
                    UNBIND_TIMEOUT: "PublisherUnbindTimeout",
                    CAN_SEND: "PublisherCanSend",
                    TRANSPORT_ERROR: "PublisherTransportError",
                    RESEND_COMPLETE: "PublisherResendComplete",
                    DISPOSE: "PublisherDispose"
                };
                module.exports.PublisherFSMEventNames = Enum.new(PublisherFSMEventNames);
                /***/
            },
            /***/ "./modules/solclient-message-publisher/lib/publisher-fsm-event.js": 
            /*!************************************************************************!*\
  !*** ./modules/solclient-message-publisher/lib/publisher-fsm-event.js ***!
  \************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    FsmEvent
                } = __webpack_require__(/*! solclient-fsm */ "./modules/solclient-fsm/api.js");
                /**
 *
 * PublisherFSMEvent extends {@link FsmEvent}.  This object should be used for all events
 * passed to the SessionFSM.  This extension provides members to carry information specfic to
 * the SessionFSM transitions.
 * @extends {FsmEvent}
 * @private
 */
                class PublisherFSMEvent extends FsmEvent {
                    /**
   * @constructor
   * @param {Object} spec The specification for this event
   * @param {?Object} details The details to assign to this event object
   * @param {Message|BaseMessage} smfmessage The message associated with this event
   */
                    constructor(spec, details, smfmessage) {
                        super(spec);
                        Object.assign(this, details);
                        Object.assign(this, smfmessage);
                    }
                    getEventText() {
                        return this._eventText;
                    }
                }
                module.exports.PublisherFSMEvent = PublisherFSMEvent;
                /***/
            },
            /***/ "./modules/solclient-message-publisher/lib/publisher-fsm.js": 
            /*!******************************************************************!*\
  !*** ./modules/solclient-message-publisher/lib/publisher-fsm.js ***!
  \******************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const SMFLib = __webpack_require__(/*! solclient-smf */ "./modules/solclient-smf/api.js");
                // No idea why the usual import idiom does not work.
                //const { CapabilityType } = require('solclient-session');
                const SolclientSession = __webpack_require__(/*! solclient-session */ "./modules/solclient-session/api.js");
                const {
                    ErrorResponseSubcodeMapper,
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    LogFormatter
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    Long
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    MessageIds
                } = __webpack_require__(/*! ./message-ids */ "./modules/solclient-message-publisher/lib/message-ids.js");
                const {
                    MessagePublisherAcknowledgeMode
                } = __webpack_require__(/*! ./message-publisher-acknowledge-modes */ "./modules/solclient-message-publisher/lib/message-publisher-acknowledge-modes.js");
                const {
                    MessagePublisherEventName
                } = __webpack_require__(/*! ./message-publisher-event-names */ "./modules/solclient-message-publisher/lib/message-publisher-event-names.js");
                const {
                    PrivateFlowEventName
                } = __webpack_require__(/*! solclient-flow */ "./modules/solclient-flow/api.js");
                const {
                    PublisherFSMEvent
                } = __webpack_require__(/*! ./publisher-fsm-event */ "./modules/solclient-message-publisher/lib/publisher-fsm-event.js");
                const {
                    PublisherFSMEventNames
                } = __webpack_require__(/*! ./publisher-fsm-event-names */ "./modules/solclient-message-publisher/lib/publisher-fsm-event-names.js");
                const {
                    PublisherStateNames
                } = __webpack_require__(/*! ./publisher-state-names */ "./modules/solclient-message-publisher/lib/publisher-state-names.js");
                const {
                    State,
                    StateMachine
                } = __webpack_require__(/*! solclient-fsm */ "./modules/solclient-fsm/api.js");
                const {
                    StatType
                } = __webpack_require__(/*! solclient-stats */ "./modules/solclient-stats/api.js");
                const {
                    TransportReturnCode
                } = __webpack_require__(/*! solclient-transport */ "./modules/solclient-transport/api.js");
                const ConnectReason = {
                    INIT: 0,
                    // never connected: message renumbering required
                    RESUME: 1,
                    // connected before
                    FAILOVER: 2
                };
                class PublisherFSM extends StateMachine {
                    constructor({
                        publisher,
                        name,
                        sessionInterface,
                        properties
                    } = {}) {
                        super({
                            name: name
                        });
                        /** @type {MessagePublisher} */
                        const fsm = this;
                        const currentState = () => {
                            const state = fsm.getCurrentState();
                            return state ? state.getName() : "<not running>";
                        };
                        this.logger = new LogFormatter((...args) => [ `[session=${sessionInterface.sessionIdHex}]`, `[message-publisher-fsm=${publisher.flowIdDec}]`, `[${currentState()}]`, ...args ]);
                        this.log = this.logger.wrap(this.log, this);
                        const {
                            LOG_TRACE,
                            LOG_DEBUG,
                            LOG_INFO,
                            LOG_WARN
                        } = this.logger;
                        Object.assign(this, {
                            _publisher: publisher,
                            _acknowledgeMode: properties.acknowledgeMode,
                            _acknowledgeTimeoutInMsecs: properties.acknowledgeTimeoutInMsecs,
                            _sessionInterface: sessionInterface,
                            _windowSize: properties.windowSize,
                            _stateEvents: []
                        });
                        // The publisher is not even constructed when publisherProperties.enabled is false
                        // so we could just set _guaranteedEnabled to true, but lets be thorough as at
                        // some point we may want to have sendADMessage() be responsible for throwing all
                        // errors. As it is, when publisher properties enabled is false, the session-fsm
                        // throws an error and when the message-spool is shutdown (close-flow received) the
                        // publisher-fsm thtows and error.
                        this._guaranteedEnabled = properties.enabled;
                        this._sendWindow = properties.windowSize;
                        this._resetConnectedInfo();
                        this._notifiedWindowClosed = false;
                        // We need a boolean to track the transport flow
                        // controlled state. prepareAdMessageAndSend is called by the
                        // session to prepare a message for publish and we
                        // need to return whether or not we are flow controlled
                        // without invoking the FSM or calling methods on the
                        // FSM.
                        // We consider all down states and all resending states equal
                        // to flow-controlled as in all states me must queue the message
                        // to the unacked list and not attempt to send directly.
                        // This is strictly a performance issue.
                        this._transportFlowControlled = true;
                        this.initial(function onInitial() {
                            return this.transitionTo(fsm.PublisherUnbound, context => {
                                LOG_TRACE(`Starting ${context.getStateMachine().getName()}`);
                            });
                        });
                        fsm.unhandledEventReaction(function onUnhandledEvent(event) {
                            switch (event.getName()) {
                              case PublisherFSMEventNames.FLOW_UNBOUND:
                                // the router has closed the flow, likely due to operator
                                // shutdown on the message spool. Throw on any attempt
                                // to publish
                                this._guaranteedEnabled = false;
                                this._publisher.emit(MessagePublisherEventName.GUARANTEED_MESSAGING_DOWN);
                                return this.transitionTo(fsm.PublisherUnbound, context => {
                                    LOG_TRACE(`Received close publisher for ${context.getStateMachine().getName()}`);
                                });

                              case PublisherFSMEventNames.DISPOSE:
                                LOG_TRACE("Received dispose request");
                                break;

                              case PublisherFSMEventNames.TRANSPORT_FULL:
                                LOG_TRACE("Received TRANSPORT_FULL");
                                break;

                              case PublisherFSMEventNames.CAN_SEND:
                                // This is ok because the session just sends the publisher CAN_SEND whenever received
                                // from transport, even if the publisher is not in use, or hasn't caused the flow control
                                LOG_TRACE("Received CAN_SEND when not flow controlled");
                                break;

                              default:
                                LOG_TRACE(`Ignoring event ${event.getName()}`);
                            }
                            return this;
                        });
                        fsm.PublisherUnbound = new State({
                            name: PublisherStateNames.UNBOUND,
                            parentContext: fsm
                        }, {
                            emitDownAndBindWaiting() {
                                LOG_TRACE("Emit down and bind waiting");
                                publisher.emit(MessagePublisherEventName.DOWN);
                                publisher.emit(PrivateFlowEventName.BIND_WAITING);
                            }
                        }).entry(function onEntry() {
                            this.emitDownAndBindWaiting();
                            fsm._connectRetryCount = properties.connectRetryCount;
                        }).reaction(PublisherFSMEventNames.FLOW_UNBOUND, function onFlowUnbind() {
                            return this.internalTransition();
                        }).reaction(PublisherFSMEventNames.SESSION_UP, function onSessionUp() {
                            return this.transitionTo(fsm.PublisherOpenFlowSent);
                        });
                        fsm.PublisherOpenFlowSent = new State({
                            name: PublisherStateNames.OPENFLOWSENT,
                            parentContext: fsm
                        }, {
                            emitOpenFlowFailedError(details) {
                                publisher.emit(MessagePublisherEventName.CONNECT_FAILED_ERROR, details);
                            },
                            /**
       * @param {AdProtocolMessage} adpMsg An OPENFLOW response.
       * @description Handle an incoming Guaranteed Messaging Protocol Message.
       * @returns {?} The result of processing an event, or null if no event was dispatched.
       * @private
       */
                            handleOpenFlowResponse(adpMsg) {
                                const smfRespHeader = adpMsg.smfHeader;
                                const respCode = smfRespHeader.pm_respcode;
                                /*
         * Assured Control Protocol messages are received on publisher and consumer flows. The
         * message types for each are unique, so we can determine whether it is a publisher or
         * consumer by message type.  A specific publisher or consumer is found by the flowId, or
         * by the correlation tag in the case of OPEN-FLOW (publisher) or BIND (consumer) responses.
         */
                                if (adpMsg.msgType !== SMFLib.SMFAdProtocolMessageType.OPENPUBFLOW) {
                                    return fsm.processEvent(new PublisherFSMEvent({
                                        name: PublisherFSMEventNames.FLOW_FAILED
                                    }, {
                                        returnCode: respCode,
                                        description: `Unexpected response: ${SMFLib.SMFAdProtocolMessageType.describe(adpMsg.msgType)}`
                                    }));
                                }
                                /*
         * The response code will indicate whether we create a PUB_FLOW_UP (200 OK) event
         * or a PUB_FLOW_FAIL (any other response) event, or treat this as an invalid
         * message (received a OPEN-PUB-FLOW request).
         */
                                if (respCode === null) {
                                    // Drop message and increment stats
                                    publisher.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
                                    LOG_DEBUG(`Drop Open-Publisher-Flow Request message on sessionId 0x${sessionInterface.sessionIdHex}`);
                                    return null;
                                }
                                if (respCode !== 200) {
                                    const respStr = smfRespHeader.pm_respstr;
                                    const mappedSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(respCode, respStr);
                                    return fsm.processEvent(new PublisherFSMEvent({
                                        name: PublisherFSMEventNames.FLOW_FAILED
                                    }, {
                                        subcode: mappedSubcode,
                                        returnCode: respCode,
                                        description: respStr
                                    }));
                                }
                                LOG_TRACE("Handling OPENPUBFLOW message");
                                // typical response: { lastmsgidacked window flowid flowname publisher_id }
                                const lastMsgIDAcked = adpMsg.getLastMsgIdAcked();
                                const window = adpMsg.getWindow();
                                const flowId = adpMsg.getFlowId();
                                const flowName = adpMsg.getFlowName();
                                const publisherId = adpMsg.getPublisherId();
                                LOG_DEBUG(`OPENPUBFLOW response attributes: lastMsgIDAcked=${lastMsgIDAcked} window=${window} flowId=${flowId} flowName=${flowName} publisherId=${publisherId}`);
                                LOG_TRACE(`Local before handling response: ${fsm._messageIds}`);
                                if (window === undefined) {
                                    return fsm.processEvent(new PublisherFSMEvent({
                                        name: PublisherFSMEventNames.FLOW_FAILED
                                    }, {
                                        description: "Window parameter not found"
                                    }));
                                }
                                if (window > this._windowSize) {
                                    return fsm.processEvent(new PublisherFSMEvent({
                                        name: PublisherFSMEventNames.FLOW_FAILED
                                    }, {
                                        description: "Invalid window negotiation"
                                    }));
                                }
                                // reduce sendWindow by the size of unAckedList but do not reduce below zero
                                fsm._sendWindow = window - fsm._unackedList.length;
                                if (fsm._sendWindow < 0) fsm._sendWindow = 0;
                                // update publisher info before renumbering
                                Object.assign(fsm._publisher, {
                                    name: flowName,
                                    flowId: flowId,
                                    publisherId: publisherId
                                });
                                // we may have been disabled by a previous closeFlow messsage, now that
                                // we know hte message spool is enabled again, set _guaranteedEnabled back
                                // to true
                                fsm._guaranteedEnabled = true;
                                if (fsm._connectReason === ConnectReason.INIT || fsm._connectReason === ConnectReason.FAILOVER) {
                                    // reset 'lastSent' before renumbering
                                    fsm._messageIds.setLastSent(lastMsgIDAcked);
                                    LOG_DEBUG(`Renumbering unacked/unsent messages: fsm._messageIds=${fsm._messageIds}, lastMsgIDAcked=${lastMsgIDAcked}, type=${fsm._connectReason}`);
                                    if (fsm._connectReason === ConnectReason.FAILOVER) {
                                        publisher.emit(MessagePublisherEventName.FLOW_NAME_CHANGED, {
                                            messages: [ ...fsm._unackedList ],
                                            count: fsm._unackedList.length
                                        });
                                    }
                                    fsm._connectReason = ConnectReason.RESUME;
                                    fsm._unackedList.forEach(message => {
                                        const oldId = message.getGuaranteedMessageId();
                                        fsm._renumber(message);
                                        LOG_TRACE(`Renumbering message ID: from ${oldId} to ${message.getGuaranteedMessageId()}`);
                                        fsm._messageIds.setLastSent(message.getGuaranteedMessageId());
                                    });
                                } else {
                                    fsm._unackedList.forEach(message => {
                                        message.setFlowId(flowId);
                                        message.setPublisherId(publisher.publisherId);
                                        LOG_TRACE(`Set FlowId to ${flowId} in msg# ${message.getGuaranteedMessageId()}`);
                                    });
                                }
                                // Either way, make sure none of the messages is above the size limit:
                                const payloadSizeLimit = fsm._sessionInterface.getCapability(SolclientSession.CapabilityType.MAX_GUARANTEED_MSG_SIZE).getValue();
                                fsm._unackedList.forEach(message => {
                                    if (payloadSizeLimit < message._memoized_payload.length) {
                                        LOG_WARN(`Message size ${message._memoized_payload.length} above broker limit ${payloadSizeLimit}`);
                                    }
                                });
                                if (fsm._unackedList.length) {
                                    fsm._handleAck(lastMsgIDAcked, false, adpMsg, true);
                                    // the starting point for retransmitting.  If lastMsgIdAcked doesn't
                                    // ack anything this does not get updates, causing us to possible send
                                    // messages out of order, or not start sending at all
                                    fsm._firstUnackedToSend = fsm._unackedList[0];
                                } else {
                                    fsm._messageIds.lastAcked = Long.fromValue(lastMsgIDAcked);
                                }
                                LOG_TRACE(`Local after applying lastMsgIDAcked: ${fsm._messageIds}`);
                                return fsm.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.FLOW_UP
                                }));
                            },
                            /**
       * @returns {?} The result of processing an BIND_TIMEOUT event
       * @private
       */
                            handleOpenFlowTimeout() {
                                LOG_INFO("Open publisher connection timeout");
                                return fsm.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.BIND_TIMEOUT
                                }));
                            },
                            handleUnknownFlowName() {
                                LOG_INFO("Flow name unknown, republish required");
                                // Don't send the FLOW_NAME_CHANGED message yet -- it specifically indicates
                                // that duplicate messages should be expected. Wait until the flow is successfully
                                // connected and messages are being renumbered.
                                fsm._resetConnectedInfo(true);
                                return this.externalTransitionTo(fsm.PublisherOpenFlowSent);
                            },
                            /**
       * Send a Publisher Open Flow Request.
       * @private
       */
                            sendOpenFlow() {
                                const correlationTag = sessionInterface.getCorrelationTag();
                                LOG_TRACE(`sendOpenFlow correlationTag: ${correlationTag}`);
                                const openPubFlowMsg = SMFLib.AdProtocolMessage.getOpenMessagePublisher(fsm._messageIds.lastAcked, fsm._messageIds.lastSent, properties.windowSize, fsm._publisher._flowName, correlationTag);
                                LOG_TRACE("sendOpenFlow openPubFlowMsg constituents:");
                                LOG_TRACE(`fsm._messageIds.lastAcked:${fsm._messageIds.lastAcked} fsm._messageIds.lastSent:${fsm._messageIds.lastSent} properties.windowSize:${properties.windowSize} fsm._publisher._flowName:${fsm._publisher._flowName} `);
                                sessionInterface.sendControl(openPubFlowMsg);
                                sessionInterface.enqueueRequest(correlationTag, () => this.handleOpenFlowTimeout(), properties.connectTimeoutInMsecs, null, rxMsgObj => this.handleOpenFlowResponse(rxMsgObj));
                                LOG_TRACE("Sent open publisher connection");
                            }
                        }).entry(function onEntry() {
                            try {
                                this.sendOpenFlow();
                            } catch (e) {
                                LOG_WARN(`Exception during bind attempt: ${e}`);
                                fsm.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.SESSION_DOWN
                                }));
                            }
                        }).reaction(PublisherFSMEventNames.FLOW_CLOSE, function onFlowClose() {
                            return this.transitionTo(fsm.PublisherCloseFlowSent);
                        }).reaction(PublisherFSMEventNames.FLOW_UP, function onFlowUp() {
                            return this.transitionTo(fsm.PublisherUp);
                        }).reaction(PublisherFSMEventNames.SESSION_DOWN, function onSessionDown() {
                            return this.transitionTo(fsm.PublisherUnbound);
                        }).reaction(PublisherFSMEventNames.BIND_TIMEOUT, function onOpenFlowTimeout() {
                            if (fsm._connectRetryCount > 0) {
                                fsm._connectRetryCount--;
                                return this.externalTransitionTo(fsm.PublisherOpenFlowSent);
                            }
                            this.emitOpenFlowFailedError({
                                subcode: ErrorSubcode.TIMEOUT,
                                description: "Open publisher connection failed due to timeout"
                            });
                            return this.transitionTo(fsm.PublisherUnbound);
                        }).reaction(PublisherFSMEventNames.FLOW_FAILED, function onFlowFailed(pEvent) {
                            const {
                                subcode,
                                returnCode,
                                description
                            } = pEvent;
                            LOG_TRACE(`FLOW_FAILED in PublisherOpenFlowSent state: subcode: ${subcode}, returnCode: ${returnCode}, description: ${description}`);
                            switch (pEvent.subcode) {
                              case ErrorSubcode.UNKNOWN_FLOW_NAME:
                                // DR or long HA failover
                                return this.handleUnknownFlowName();
                                // case ErrorSubcode.GM_NOT_READY: Fail the session

                              default:
                                this.emitOpenFlowFailedError({
                                    event: pEvent,
                                    subcode: subcode,
                                    returnCode: returnCode,
                                    description: description
                                });
                                // Otherwise, the flow is invalid
                                fsm._resetConnectedInfo();
                            }
                            return this.transitionTo(fsm.PublisherUnbound);
                        });
                        fsm.PublisherCloseFlowSent = new State({
                            name: PublisherStateNames.CLOSEFLOWSENT,
                            parentContext: fsm
                        }, {
                            handleCloseFlowResponse(response) {
                                const smfRespHeader = response.smfHeader;
                                const respCode = smfRespHeader.pm_respcode;
                                if (response.msgType !== SMFLib.SMFAdProtocolMessageType.CLOSEPUBFLOW) {
                                    return fsm.processEvent(new PublisherFSMEvent({
                                        name: PublisherFSMEventNames.FLOW_FAILED
                                    }, {
                                        returnCode: respCode,
                                        description: `Unexpected response: ${SMFLib.SMFAdProtocolMessageType.describe(response.msgType)}`
                                    }));
                                }
                                if (respCode === null) {
                                    // Drop message  and increment stats
                                    publisher.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
                                    LOG_DEBUG(`Drop Close-Publisher-Flow Request message on sessionId 0x${sessionInterface.sessionIdHex}`);
                                    return null;
                                }
                                if (respCode !== 200) {
                                    fsm.processEvent(new PublisherFSMEvent({
                                        name: PublisherFSMEventNames.FLOW_FAILED
                                    }, {
                                        returnCode: respCode,
                                        description: smfRespHeader.pm_respstr
                                    }));
                                }
                                return fsm.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.FLOW_UNBOUND
                                }));
                            },
                            handleCloseFlowTimeout() {
                                LOG_INFO("Close publisher connection timeout.");
                                return fsm.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.UNBIND_TIMEOUT
                                }));
                            },
                            sendCloseFlow() {
                                const correlationTag = sessionInterface.getCorrelationTag();
                                const closePubFlowMsg = SMFLib.AdProtocolMessage.getCloseMessagePublisher(fsm._publisher.flowId, correlationTag);
                                sessionInterface.sendControl(closePubFlowMsg);
                                sessionInterface.enqueueRequest(correlationTag, () => this.handleCloseFlowTimeout(), properties.connectTimeoutInMsecs, null, rxMsgObj => this.handleCloseFlowResponse(rxMsgObj));
                                LOG_TRACE("Sent close publisher connection");
                            }
                        }).entry(function onEntry() {
                            this.sendCloseFlow();
                            return this;
                        }).reaction(PublisherFSMEventNames.ACK, function onAck(event) {
                            fsm._handleAckEvent(event);
                            return this.internalTransition();
                        }).reaction(PublisherFSMEventNames.FLOW_UNBOUND, function onFlowUnbound() {
                            return this.transitionTo(fsm.PublisherUnbound);
                        }).reaction(PublisherFSMEventNames.FLOW_FAILED, function onCloseFlowFailed() {
                            this.transitionTo(fsm.PublisherUnbound);
                        }).reaction(PublisherFSMEventNames.UNBIND_TIMEOUT, function onCloseFlowTimeout() {
                            return this.transitionTo(fsm.PublisherCloseFlowSent);
                        });
                        fsm.PublisherUp = new State({
                            name: PublisherStateNames.UP,
                            parentContext: fsm
                        }, {
                            emitFlowUp() {
                                publisher.emit(MessagePublisherEventName.UP);
                            }
                        }).initial(function initial() {
                            return this.transitionTo(fsm._unackedList.length ? fsm.PublisherRetransmitting : fsm.PublisherDataXfer);
                        }).entry(function onEntry() {
                            // The state isn't changed on entry, so don't emit yet.
                            LOG_DEBUG("Flow is UP");
                            fsm._scheduleStateEvents(fsm.PublisherUp, () => this.emitFlowUp());
                            return this;
                        }).reaction(PublisherFSMEventNames.ACK, function onAck(event) {
                            LOG_DEBUG("Ack received");
                            fsm._handleAckEvent(event);
                            return this.internalTransition();
                        }).reaction(PublisherFSMEventNames.ACK_TIMEOUT, function onAckTimeout() {
                            // the starting point when we get the CAN_SEND
                            fsm._firstUnackedToSend = fsm._unackedList[0];
                            return this.transitionTo(fsm.PublisherRetransmitting);
                        }).reaction(PublisherFSMEventNames.FLOW_CLOSE, function onFlowClose() {
                            return this.transitionTo(fsm.PublisherCloseFlowSent);
                        }).reaction(PublisherFSMEventNames.SESSION_DOWN, function onSessionDown() {
                            return this.transitionTo(fsm.PublisherUnbound);
                        }).reaction(PublisherFSMEventNames.TRANSPORT_FULL, function onWindowClosed() {
                            return this.internalTransition();
                        });
                        fsm.PublisherDataXfer = new State({
                            name: PublisherStateNames.DATA_XFER,
                            parentContext: fsm.PublisherUp
                        }).entry(() => {
                            // publisher is up and capable of sending GM messages directly from the application
                            fsm._transportFlowControlled = false;
                            fsm._scheduleStateEvents(fsm.PublisherDataXfer, () => fsm._maybeEmitCanSend());
                        }).reaction(PublisherFSMEventNames.TRANSPORT_FULL, function onTransportFull() {
                            return this.transitionTo(fsm.PublisherFlowControlled);
                        }).exit(() => {
                            // publisher cannot send messages to transport and must queue in unAckedList until
                            // re-entering PublisherDataXfer
                            // set a FSM boolean that is checked in prepareADMessageAndSend() we
                            // need to avoid FSM interactions on the fast path so resort to
                            // this boolean.
                            fsm._transportFlowControlled = true;
                        });
                        fsm.PublisherFlowControlled = new State({
                            name: PublisherStateNames.FLOW_CONTROLLED,
                            parentContext: fsm.PublisherUp
                        }).reaction(PublisherFSMEventNames.TRANSPORT_FULL, function onTransportFull() {
                            // Unusual event, as only the FSM can send messages when we're in flow-controlled state
                            LOG_INFO("Attempt to send while flow controlled");
                            // Fall out and do the action for PublisherUp
                            return this.internalTransition();
                        }).reaction(PublisherFSMEventNames.CAN_SEND, function onCanSend() {
                            //
                            // start sending from tune unAcked list.
                            return this.transitionTo(fsm.PublisherRetransmitting);
                        });
                        fsm.PublisherRetransmitting = new State({
                            name: PublisherStateNames.RETRANSMITTING,
                            parentContext: fsm.PublisherUp
                        }, {
                            retransmit() {
                                try {
                                    fsm._resendFromUnacked();
                                } catch (ex) {
                                    // Resend failed:
                                    if (ex instanceof OperationError && ex.subcode === ErrorSubcode.INSUFFICIENT_SPACE) {
                                        LOG_DEBUG("Publisher resendFromUnacked blocked due to insufficient space, wait for CAN_SEND");
                                        fsm.processEvent(new PublisherFSMEvent({
                                            name: PublisherFSMEventNames.TRANSPORT_FULL
                                        }));
                                    } else {
                                        // send failed.  Fail the publisher
                                        LOG_INFO(`Publisher resendFromUnacked failed: ${ex}`);
                                        fsm.processEvent(new PublisherFSMEvent({
                                            name: PublisherFSMEventNames.FLOW_FAILED
                                        }));
                                    }
                                }
                            }
                        }).entry(function onEntry() {
                            this.retransmit();
                        }).reaction(PublisherFSMEventNames.RESEND_COMPLETE, function onResendComplete() {
                            return this.transitionTo(fsm.PublisherDataXfer);
                        }).reaction(PublisherFSMEventNames.TRANSPORT_FULL, function onTransportFull() {
                            // Transport flow controlled while resending/recovering from flow control. Go
                            // to flow controlled state and wait for CAN_SEND
                            LOG_DEBUG(`Transport full while retransmitting, unacked remaining: ${fsm._unackedList.length}`);
                            // Fall out and do the action for PublisherUp
                            return this.transitionTo(fsm.PublisherFlowControlled);
                        });
                    }
                    isDisconnected() {
                        if (!this.getCurrentState()) return true;
                        return !!this.getActiveState(PublisherStateNames.UNBOUND);
                    }
                    /**

   * Prepare and send a Guaranteed Message. This method updates FSM variables including
   * lastSendMessage.
   *
   * @private
   * @param {Message} dataMsg The message to prepare
   * @returns {TransportReturnCode} return the status from the transport send
   */
                    prepareAdMessageAndSend(dataMsg) {
                        if (!this._guaranteedEnabled) {
                            throw new OperationError("Session does not provide Guaranteed Message Publish capability", ErrorSubcode.GM_UNAVAILABLE, "close flow received from message-router");
                        }
                        if (this._sendWindow <= 0) {
                            this._publisher.incStat(StatType.TX_WINDOW_CLOSED);
                            this._notifiedWindowClosed = true;
                            throw new OperationError("Guaranteed Message Window Closed", ErrorSubcode.INSUFFICIENT_SPACE);
                        }
                        const unackedList = this._unackedList;
                        const {
                            LOG_TRACE,
                            LOG_DEBUG,
                            LOG_INFO,
                            LOG_WARN
                        } = this.logger;
                        if (dataMsg._payload_is_memoized) {
                            dataMsg._payload_is_memoized = false;
                            dataMsg._memoized_csumm = undefined;
                            dataMsg._memoized_payload = undefined;
                        }
                        const dupMsg = dataMsg.clone();
                        const payloadSize = SMFLib.Codec.Encode.adaptMessageToSmf_payloadMemoize(dupMsg);
                        var payloadSizeLimit = 0;
                        try {
                            payloadSizeLimit = this._sessionInterface.getCapability(SolclientSession.CapabilityType.MAX_GUARANTEED_MSG_SIZE).getValue();
                            LOG_TRACE(`Payload size limit: ${payloadSizeLimit}`);
                        } catch (e) {
                            LOG_INFO("Can't pre-check payload size, broker not connected yet?");
                            LOG_TRACE(e.stack);
                        }
                        if (0 < payloadSizeLimit && payloadSize > payloadSizeLimit) {
                            throw new OperationError(`Encoded payload size (${payloadSize}) exceeds broker size limit (MAX_GUARANTEED_MSG_SIZE, ${payloadSizeLimit})`, ErrorSubcode.MESSAGE_TOO_LARGE);
                        }
                        --this._sendWindow;
                        this._renumber(dupMsg);
                        this._cloneNumbers(dupMsg, dataMsg);
                        unackedList.push(dupMsg);
                        // Update the messgeIds, lastSend/next values only on a successful send or enqueue,
                        // from this point on we will return OK from this send method.
                        const msgId = dupMsg.getGuaranteedMessageId();
                        this._messageIds.setLastSent(msgId);
                        LOG_TRACE(`Prepare and send AD message ID = ${msgId}, 
      unackedListSize = ${unackedList.length}, sendWindow = ${this._sendWindow}`);
                        // Note that the transport sender can be flow controlled at the transport
                        // level, which means the message should not be sent. So simply return
                        // We also consider set-up/down-states as _transportFlowControlled. We must be up
                        // and not retransmitting to
                        // send directly from application space.
                        if (this._transportFlowControlled) {
                            // we may receive acknowledgements while transport flow controlled which can
                            // cause our firstUnAckedToSend to become undefined, if this is the first message
                            // queued in that case, set firstUnAckedToSend
                            if (this._firstUnackedToSend === undefined) {
                                this._firstUnackedToSend = dupMsg;
                            }
                            return TransportReturnCode.OK;
                        }
                        // We use the session sendToTransport directly which may throw or  otherwise
                        // return an error. If so, catch the eror and remove the message from the unackedlist
                        // before rethrowing the error.
                        let returnCode;
                        try {
                            returnCode = this._sessionInterface.sendToTransport(dupMsg);
                            if (returnCode !== TransportReturnCode.OK) {
                                if (returnCode === TransportReturnCode.NO_SPACE) {
                                    returnCode = TransportReturnCode.OK;
                                    this._firstUnackedToSend = dupMsg; // the starting point when we get the CAN_SEND
                                    this.processEvent(new PublisherFSMEvent({
                                        name: PublisherFSMEventNames.TRANSPORT_FULL
                                    }));
                                } else {
                                    //
                                    LOG_DEBUG(`prepareAdMessageAndSend: saw returnCode = ${returnCode}`);
                                }
                            } else {
                                // The message has successfully been sent once. Set the redelivered flag in case we need to
                                // resend it later.
                                dupMsg.setRedelivered(true);
                            }
                            // TBD: Should we start AckTimer when flow controlled?
                            this._startAckTimer();
                        } catch (ex) {
                            if (ex instanceof OperationError) {
                                LOG_DEBUG(`prepareAdMessageAndSend: caught OperationError: ${ErrorSubcode.describe(ex.subcode)} - ${ex.message}`);
                                // OperationErrors are encoding or other errors caused by the field contents the
                                // application has set on the message.  So we throw the error back at the
                                // application after undoing the queueing operations.
                                unackedList.pop();
                                this._messageIds.setLastSent(dupMsg.getGuaranteedPreviousMessageId());
                                ++this._sendWindow;
                                throw ex;
                            } else {
                                LOG_DEBUG(`prepareAdMessageAndSend: caught ${ex.message}`);
                                throw ex;
                            }
                        }
                        return TransportReturnCode.OK;
                    }
                    _handleAckEvent(event) {
                        this._publisher.incStat(StatType.TX_ACKS_RXED);
                        this._handleAck(event.ack || event.nack, !!event.nack, event.ctrlMessage);
                    }
                    _handleAck(id, nack, ctrlMessage = undefined, openFlow = false) {
                        const {
                            _messageIds: messageIds,
                            _unackedList: unackedList
                        } = this;
                        const {
                            LOG_DEBUG,
                            LOG_INFO
                        } = this.logger;
                        if (messageIds.lastAcked.gte(id)) {
                            if (openFlow) {
                                LOG_DEBUG(`Implicit acks up to date: remote ack for ${id}, local ids ${this._messageIds}`);
                            } else {
                                LOG_INFO(`Dropping ack: remote ack for ${id}, local ids ${this._messageIds}`);
                            }
                            return;
                        }
                        const reportAcked = [];
                        // Assumption: the unacked message list is in increasing order of message ID.
                        // The assured message ID should be automatically generated, immutable and
                        // monotonically increasing.
                        // While the acked ID is greater than an element at the beginning of the unacked list...
                        while (unackedList.length && id.gte(unackedList[0].getGuaranteedMessageId())) {
                            // That unacked message is now acked. Shift it off and append to list of acked.
                            reportAcked.push(unackedList.shift());
                        }
                        // if we have removed the firstUnacked, reset it to the beginning of the list
                        if (unackedList.indexOf(this._firstUnackedToSend) === -1) {
                            this._firstUnackedToSend = unackedList[0];
                        }
                        // Recover some window space from the acked IDs.
                        this._sendWindow += reportAcked.length;
                        LOG_DEBUG("Send window size is now", this._sendWindow);
                        // The last acked ID is now the one we received.
                        // Don't let an exception in event dispatching prevent this from being set -- do it now.
                        messageIds.lastAcked = id;
                        // If we're NACKing, it's only the last message.
                        const reportNacked = nack ? reportAcked.pop() : null;
                        // Any ACKs?
                        // reportAcked is constant from here on
                        const numAcked = reportAcked.length;
                        if (numAcked) {
                            if (this._acknowledgeMode === MessagePublisherAcknowledgeMode.PER_MESSAGE) {
                                LOG_DEBUG(`Ack received: lastAckedMsgId=${id}, numAckedMsgs=${numAcked}, numUnackedMsgs=${unackedList.length}`);
                                for (let i = 0; i < numAcked; ++i) {
                                    this._publisher.emit(MessagePublisherEventName.ACKNOWLEDGED_MESSAGE, reportAcked[i]);
                                }
                            } else {
                                const lastAckedMessage = reportAcked[numAcked - 1];
                                LOG_DEBUG(`Acking single message with ID ${lastAckedMessage.getGuaranteedMessageId()} from router ack on ${id}`);
                                this._publisher.emit(MessagePublisherEventName.ACKNOWLEDGED_MESSAGE, lastAckedMessage);
                            }
                        }
                        // Terminating NACK?
                        if (reportNacked) {
                            LOG_DEBUG(`Nacking single message with ID ${reportNacked.getGuaranteedMessageId()} from router ack on ${id}`);
                            this._publisher.emit(MessagePublisherEventName.REJECTED_MESSAGE, reportNacked, ctrlMessage);
                        }
                        LOG_DEBUG("Unacked messages remaining: ", unackedList.length);
                        if (unackedList.length) {
                            // There are more messages to be acked. Reset the ack timer.
                            this._resetAckTimer();
                        } else {
                            this._clearAckTimer();
                        }
                        //
                        // send can-send to applicatino if necessary.
                        this._maybeEmitCanSend();
                    }
                    _maybeEmitCanSend() {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        if (!this._notifiedWindowClosed) return;
                        if (this._sendWindow === 0) {
                            // Should log this since it is called AFTER the state change
                            LOG_TRACE("Suppressing CAN_SEND with zero window available");
                            return;
                        }
                        this._notifiedWindowClosed = false; // Set before emitting in case we re-enter
                        this._publisher.emit(MessagePublisherEventName.CAN_SEND);
                    }
                    _resendFromUnacked() {
                        const {
                            LOG_ERROR,
                            LOG_INFO,
                            LOG_DEBUG
                        } = this.logger;
                        // We choose to start the ack timer after the message resend. The resend could
                        // take longer than the ack timeout in poor conditions.
                        //
                        // If any message is successfully resent, we need to restart the ack timer,
                        // even if we are throwing.
                        const list = this._unackedList;
                        let resendIndex = list.indexOf(this._firstUnackedToSend);
                        if (resendIndex === -1) {
                            // first Unacked may be null if all have been resent alreadygrunt -
                            // in which case the list  should be empty
                            if (this._firstUnackedToSend) {
                                LOG_ERROR(`Could not find first Unacked Messages in unacked message list: msgId = ${this._firstUnackedToSend.getGuaranteedMessageId}`);
                            }
                            if (list.length === 0) {
                                // Nothing to resend: return to DataXfer
                                LOG_DEBUG(`Nothing to resend: ${this._messageIds.toString()}`);
                                this.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.RESEND_COMPLETE
                                }));
                            }
                            return;
                        }
                        LOG_DEBUG(`Resending unacked messages from ${resendIndex} to ${list.length - 1}: `, list.map(m => m.getGuaranteedMessageId().toString()));
                        while (resendIndex < list.length) {
                            if (list[resendIndex].getPublisherId() !== this._publisher.publisherId) {
                                LOG_ERROR(`Resending on invalid publisherId '${list[resendIndex].getPublisherId()}'when it should be '${this._publisher.publisherId}'`);
                            }
                            const returnCode = this._sessionInterface.sendData(list[resendIndex]);
                            if (returnCode === TransportReturnCode.NO_SPACE) {
                                // the starting point when we get the CAN_SEND from the transport
                                this._firstUnackedToSend = list[resendIndex];
                                LOG_INFO("Publisher sendMessage blocked due to insufficient space, wait for CAN_SEND");
                                this.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.TRANSPORT_FULL
                                }));
                                return;
                            }
                            if (returnCode !== TransportReturnCode.OK) {
                                // session-FSM is already processing the error
                                return;
                            }
                            // The message has successfullly been sent once. Set the redelivered flag in case we need to
                            // resend it later
                            list[resendIndex].setRedelivered(true);
                            resendIndex++;
                            this._startAckTimer();
                        }
                        // Resend successful: return to DataXfer
                        LOG_DEBUG(`Resend complete: ${this._messageIds.toString()}`);
                        this.processEvent(new PublisherFSMEvent({
                            name: PublisherFSMEventNames.RESEND_COMPLETE
                        }));
                    }
                    _resetConnectedInfo(failover = false) {
                        const {
                            LOG_DEBUG
                        } = this.logger;
                        LOG_DEBUG("Resetting connected flow info");
                        if (this._ackTimer) this._clearAckTimer();
                        Object.assign(this, {
                            _messageIds: new MessageIds()
                        });
                        Object.assign(this._publisher, {
                            publisherId: undefined,
                            flowId: undefined,
                            flowName: null
                        });
                        if (failover) {
                            this._connectReason = ConnectReason.FAILOVER;
                        } else {
                            // Full reset
                            this._unackedList = [];
                            this._connectReason = ConnectReason.INIT;
                        }
                    }
                    _clearAckTimer() {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE(`Clear ack timer ${this._ackTimer ? this._ackTimer : "undefined or null or zero"}`);
                        if (!this._ackTimer) return;
                        clearTimeout(this._ackTimer);
                        this._ackTimer = null;
                    }
                    _emitStateEvents() {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Emitting deferred state events");
                        while (this._stateEvents.length) {
                            const pair = this._stateEvents.shift();
                            const state = pair[0];
                            const event = pair[1];
                            // If the state requesting this event is still active...
                            if (this.getActiveState(state.getName())) {
                                // then do its action
                                event.apply(state);
                            }
                        }
                    }
                    /**
   * @private
   */
                    _handleAckTimeout() {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Ack Timeout");
                        this._ackTimer = null;
                        this._publisher.incStat(StatType.TX_ACK_TIMEOUT);
                        this.processEvent(new PublisherFSMEvent({
                            name: PublisherFSMEventNames.ACK_TIMEOUT
                        }));
                    }
                    /**
   * If the remote flow changes, any remote state applied to the unacked messages needs to
   * be reapplied.
   *
   * @param {solace.Message} message The message to renumber.
   * @private
   */
                    _renumber(message) {
                        const messageIds = this._messageIds;
                        const current = messageIds.next;
                        message.setGuaranteedPreviousMessageId(messageIds.lastSent);
                        message.setGuaranteedMessageId(current);
                        const publisher = this._publisher;
                        message.setFlowId(publisher.flowId);
                        message.setPublisherId(publisher.publisherId);
                    }
                    _cloneNumbers(fromMsg, toMsg) {
                        toMsg.setGuaranteedPreviousMessageId(fromMsg.getGuaranteedPreviousMessageId());
                        toMsg.setGuaranteedMessageId(fromMsg.getGuaranteedMessageId());
                        toMsg.setFlowId(fromMsg.getFlowId());
                        toMsg.setPublisherId(fromMsg.getPublisherId());
                    }
                    _resetAckTimer() {
                        this._clearAckTimer();
                        this._startAckTimer();
                    }
                    _scheduleStateEvents(state, event) {
                        this._stateEvents.push([ state, event ]);
                        this._setPostEventAction(() => this._emitStateEvents(), "Emit state events");
                    }
                    _setPostEventAction(action, desc = "No action") {
                        const {
                            LOG_DEBUG,
                            LOG_WARN
                        } = this.logger;
                        if (this._postEventAction && this._postEventAction.desc === desc) {
                            LOG_DEBUG("Keeping same post event action");
                            return;
                        }
                        if (this._postEventAction && this._postEventAction.desc) {
                            LOG_WARN(`Replacing post event action ${this._postEventAction.desc} with ${desc}`);
                        }
                        this._postEventAction = {
                            action: action || (() => {}),
                            desc: desc
                        };
                        this.setPostEventAction(() => {
                            this._postEventAction.action();
                            this._postEventAction = null;
                        });
                    }
                    /**
   * @private
   */
                    _startAckTimer() {
                        // const { LOG_TRACE } = this.logger;
                        // LOG_TRACE(`Start ack timer ${this._ackTimer ? this._ackTimer : 'undefined or null or zero'
                        //           }: ${this._acknowledgeTimeoutInMsecs} ms`);
                        if (this._ackTimer) return;
                        this._ackTimer = setTimeout(() => this._handleAckTimeout(), this._acknowledgeTimeoutInMsecs);
                    }
                }
                module.exports.PublisherFSM = PublisherFSM;
                /***/
            },
            /***/ "./modules/solclient-message-publisher/lib/publisher-state-names.js": 
            /*!**************************************************************************!*\
  !*** ./modules/solclient-message-publisher/lib/publisher-state-names.js ***!
  \**************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /********************************************************************************
 * @private
 * @enum {string}
 * State names on the Publisher FSM
 ********************************************************************************/
                const PublisherStateNames = {
                    UNBOUND: "PublisherUnbound",
                    OPENFLOWSENT: "PublisherOpenFlowSent",
                    UP: "PublisherUp",
                    FAILED: "PublisherFailed",
                    CLOSEFLOWSENT: "PublisherCloseFlowSent",
                    DATA_XFER: "PublisherDataXfer",
                    FLOW_CONTROLLED: "MessagePublisherFlowControlled",
                    RETRANSMITTING: "PublisherRetransmitting"
                };
                module.exports.PublisherStateNames = Enum.new(PublisherStateNames);
                /***/
            },
            /***/ "./modules/solclient-message/api.js": 
            /*!******************************************!*\
  !*** ./modules/solclient-message/api.js ***!
  \******************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ReplicationGroupMessageId,
                    RgmidFactory
                } = __webpack_require__(/*! ./lib/replication-group-message-id */ "./modules/solclient-message/lib/replication-group-message-id.js");
                const {
                    Message
                } = __webpack_require__(/*! ./lib/message */ "./modules/solclient-message/lib/message.js");
                const {
                    MessageCacheStatus
                } = __webpack_require__(/*! ./lib/message-cache-status */ "./modules/solclient-message/lib/message-cache-status.js");
                const {
                    MessageDeliveryModeType
                } = __webpack_require__(/*! ./lib/message-delivery-mode-types */ "./modules/solclient-message/lib/message-delivery-mode-types.js");
                const {
                    MessageDumpFlag
                } = __webpack_require__(/*! ./lib/message-dump-flags */ "./modules/solclient-message/lib/message-dump-flags.js");
                const {
                    MessageDumpStandardProvider
                } = __webpack_require__(/*! ./lib/message-dump-standard-provider */ "./modules/solclient-message/lib/message-dump-standard-provider.js");
                const {
                    MessageDumpUtil
                } = __webpack_require__(/*! ./lib/message-dump-util */ "./modules/solclient-message/lib/message-dump-util.js");
                const {
                    MessageType
                } = __webpack_require__(/*! ./lib/message-types */ "./modules/solclient-message/lib/message-types.js");
                const {
                    MessageUserCosType
                } = __webpack_require__(/*! ./lib/message-user-cos-types */ "./modules/solclient-message/lib/message-user-cos-types.js");
                const {
                    SolclientFactory
                } = __webpack_require__(/*! solclient-factory */ "./modules/solclient-factory/api.js");
                /**
 * Creates a {@link solace.Message} instance.
 * @returns {solace.Message} a new message instance.
 * @method
 * @name solace.SolclientFactory.createMessage
 */
                SolclientFactory.createMessage = SolclientFactory.createFactory(() => new Message());
                /**
 * Creates a {@link solace.ReplicationGroupMessageId} instance from string.
 * A ReplicationGroupMessageId is also a {@link solace.ReplayStartLocation} instance that
 * when set in MessageConsumerProperties indicates that only messages spooled
 * in the replay log since the message after the given ReplicationGroupMesageId
 * should be replayed.
 * @param {string} id a serialized ReplicationGroupMessageId had previously been returned
 *   from {@link solace.ReplicationGroupMessageId.toString}.
 * @returns {solace.ReplicationGroupMessageId} a new ReplicationGroupMessageId instance
 * @method
 * @name solace.SolclientFactory.createReplicationGroupMessageId
 * @throws {solace.OperationError}
 * * if parameter is not a string.
 *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
 * * if incorrect format is detected.
 *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
 */
                SolclientFactory.createReplicationGroupMessageId = SolclientFactory.createFactory(id => RgmidFactory.fromString(id));
                module.exports.Message = Message;
                module.exports.MessageCacheStatus = MessageCacheStatus;
                module.exports.MessageDeliveryModeType = MessageDeliveryModeType;
                module.exports.MessageDumpFlag = MessageDumpFlag;
                module.exports.MessageDumpStandardProvider = MessageDumpStandardProvider;
                module.exports.MessageDumpUtil = MessageDumpUtil;
                module.exports.MessageType = MessageType;
                module.exports.MessageUserCosType = MessageUserCosType;
                module.exports.ReplicationGroupMessageId = ReplicationGroupMessageId;
                module.exports.RgmidFactory = RgmidFactory;
                /***/
            },
            /***/ "./modules/solclient-message/lib/message-cache-status.js": 
            /*!***************************************************************!*\
  !*** ./modules/solclient-message/lib/message-cache-status.js ***!
  \***************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * An attribue of a {@link solace.Message}. Applications receive messages due to subscriptions on
 * topics, or consumers connected to durable objects.  The MessageCacheStatus of such messages is:
 * {@link solace.MessageCacheStatus.LIVE}.
 *
 * Message are also delivered to an application
 * as a result of a cache request (see {@link solace.CacheSession#sendCacheRequest}) which
 * have a MessageCacheStatus that is {@link solace.MessageCacheStatus.CACHED} or
 * {@link solace.MessageCacheStatus.SUSPECT}.
 *
 * The MessageCacheStatus is retrieved with {@link solace.Message#getCacheStatus}.
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
                const MessageCacheStatus = {
                    /**
   * The message is live.
   * @type {Number}
   */
                    LIVE: 0,
                    /**
   * The message was retrieveed from a solCache Instance.
   * @type {Number}
   */
                    CACHED: 1,
                    /**
   * The message was retrieved from a suspect solCache Instance.
   * @type {Number}
   */
                    SUSPECT: 2
                };
                module.exports.MessageCacheStatus = Enum.new(MessageCacheStatus);
                /***/
            },
            /***/ "./modules/solclient-message/lib/message-delivery-mode-types.js": 
            /*!**********************************************************************!*\
  !*** ./modules/solclient-message/lib/message-delivery-mode-types.js ***!
  \**********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Represents an enumeration of message delivery modes.
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
                const MessageDeliveryModeType = {
                    /**
   * This mode provides at-most-once message delivery. Direct messages have
   * the following characteristics:
   *   * They are not retained for clients that are not connected to a Solace Message Router.
   *   * They can be discarded when congestion or system failures are encountered.
   *   * They can be reordered in the event of network topology changes.
   *
   * Direct messages are most appropriate for messaging applications that require very
   * high-rate or very low-latency message transmission. Direct Messaging enables
   * applications to efficiently publish messages to a large number of clients
   * with matching subscriptions.
   */
                    DIRECT: 0,
                    /**
   * A Persistent delivery mode is used for Guaranteed Messaging, and this delivery mode
   * is most appropriate for applications that require persistent storage of the messages
   * they send or intend to receive. Persistent messages have the following characteristics:
   *
   *  * They cannot be discarded or lost (once they are acknowledged by the Solace Message Router).
   *  * They cannot be reordered in the event of network topology changes.
   *  * They cannot be delivered more than once to a single client (unless the redelivered
   *    message flag is applied).
   *  * When they match subscriptions on durable endpoints, they are retained for a client
   *    when that client is not connected.
   *
   * Persistent messages are most appropriate for applications that require persistent storage
   * of the messages they send or intend to receive.
   */
                    PERSISTENT: 1,
                    /**
   * This mode is functionally the same as Persistent. It exists to facilitate interaction
   * with JMS applications. In most situations where you want to use Guaranteed Messaging,
   * it is recommended that you use {@link solace.MessageDeliveryModeType.PERSISTENT}.
   */
                    NON_PERSISTENT: 2
                };
                module.exports.MessageDeliveryModeType = Enum.new(MessageDeliveryModeType);
                /***/
            },
            /***/ "./modules/solclient-message/lib/message-dump-flags.js": 
            /*!*************************************************************!*\
  !*** ./modules/solclient-message/lib/message-dump-flags.js ***!
  \*************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Represents an enumeration of message dump formats. It controls
 * the output of {@link solace.Message#dump}.
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
                const MessageDumpFlag = {
                    /**
   * Display only the length of the binary attachment, XML content and user property maps.
   */
                    MSGDUMP_BRIEF: 0,
                    /**
   * Display the entire message contents.
   */
                    MSGDUMP_FULL: 1
                };
                module.exports.MessageDumpFlag = Enum.new(MessageDumpFlag);
                /***/
            },
            /***/ "./modules/solclient-message/lib/message-dump-standard-provider.js": 
            /*!*************************************************************************!*\
  !*** ./modules/solclient-message/lib/message-dump-standard-provider.js ***!
  \*************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const DebugLib = __webpack_require__(/*! solclient-debug */ "./modules/solclient-debug/api.js");
                const MessageDumpUtilLib = __webpack_require__(/*! ./message-dump-util */ "./modules/solclient-message/lib/message-dump-util.js");
                const {
                    Destination
                } = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                const {
                    LOG_ERROR
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    Long
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    MessageCacheStatus
                } = __webpack_require__(/*! ./message-cache-status */ "./modules/solclient-message/lib/message-cache-status.js");
                const {
                    MessageDeliveryModeType
                } = __webpack_require__(/*! ./message-delivery-mode-types */ "./modules/solclient-message/lib/message-delivery-mode-types.js");
                const {
                    MessageDumpFlag
                } = __webpack_require__(/*! ./message-dump-flags */ "./modules/solclient-message/lib/message-dump-flags.js");
                const {
                    MessageUserCosType
                } = __webpack_require__(/*! ./message-user-cos-types */ "./modules/solclient-message/lib/message-user-cos-types.js");
                const {
                    SDTMapContainer,
                    SDTFieldType
                } = __webpack_require__(/*! solclient-sdt */ "./modules/solclient-sdt/api.js");
                const {
                    StringUtils
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const MessageDumpStandardProvider = {
                    fpDestination(message /* , flags*/) {
                        const dest = message.getDestination();
                        if (dest !== null && dest instanceof Destination) {
                            return [ "Destination", true, dest.toString(), null ];
                        }
                        return [ "Destination", false, "", null ];
                    },
                    fpSenderId(message /* , flags*/) {
                        return [ "SenderId", message.getSenderId() !== undefined && message.getSenderId() !== null, message.getSenderId(), null ];
                    },
                    fpAppmsgType(message /* , flags*/) {
                        return [ "AppMessageType", message.getApplicationMessageType() !== undefined && message.getApplicationMessageType() !== null, message.getApplicationMessageType(), null ];
                    },
                    fpAppMsgId(message /* , flags*/) {
                        return [ "AppMessageID", message.getApplicationMessageId() !== undefined && message.getApplicationMessageId() !== null, message.getApplicationMessageId(), null ];
                    },
                    fpSequenceNumber(message /* , flags*/) {
                        const sequenceNum = message.getSequenceNumber();
                        if (typeof sequenceNum === "number") {
                            return [ "SequenceNumber", true, sequenceNum, null ];
                        }
                        return [ "SequenceNumber", false, "", null ];
                    },
                    fpTopicSequenceNumber(message /*, flags */) {
                        const topicSeqNo = message.getTopicSequenceNumber();
                        if (Long.isLong(topicSeqNo)) {
                            return [ "TopicSequenceNumber", true, topicSeqNo.toString(), null ];
                        }
                        return [ "TopicequenceNumber", false, "", null ];
                    },
                    fpCorrelationId(message /* , flags*/) {
                        return [ "CorrelationId", message.getCorrelationId() !== undefined && message.getCorrelationId() !== null, message.getCorrelationId(), null ];
                    },
                    fpHttpContentType() {
                        return [ "HTTP Content Type", false, undefined, null ];
                    },
                    fpHttpContentEncoding() {
                        return [ "HTTP Content Encoding", false, undefined, null ];
                    },
                    fpSendTimestamp(message /* , flags*/) {
                        const timestamp = message.getSenderTimestamp();
                        if (typeof timestamp === "number") {
                            const mdu = MessageDumpUtilLib.MessageDumpUtil;
                            return [ "SendTimestamp", true, `${timestamp} (${mdu.formatDate(timestamp)})`, null ];
                        }
                        return [ "SendTimestamp", false, "", null ];
                    },
                    fpRcvTimestamp(message /* , flags*/) {
                        const timestamp = message.getReceiverTimestamp();
                        if (typeof timestamp === "number") {
                            const mdu = MessageDumpUtilLib.MessageDumpUtil;
                            return [ "RcvTimestamp", true, `${timestamp} (${mdu.formatDate(timestamp)})`, null ];
                        }
                        return [ "RcvTimestamp", false, "", null ];
                    },
                    fpClassOfService(message /* , flags*/) {
                        const cos = message.getUserCos();
                        if (typeof cos === "number") {
                            return [ "Class Of Service", true, MessageUserCosType.nameOf(message.getUserCos()), null ];
                        }
                        return [ "Class Of Service", false, "", null ];
                    },
                    //  fpPriority(message/* , flags*/) {
                    //    const prio = message.getPriority() !== undefined ? message.getPriority() : 'undefined';
                    //    return ['Message Priority', true, prio, null];
                    //  },
                    fpDeliveryMode(message /* , flags*/) {
                        const mode = message.getDeliveryMode();
                        if (typeof mode === "number") {
                            return [ "DeliveryMode", true, MessageDeliveryModeType.nameOf(message.getDeliveryMode()), null ];
                        }
                        return [ "DeliveryMode", false, "", null ];
                    },
                    fpGuaranteedMsgId(message /*, flags*/) {
                        const msgId = message.getGuaranteedMessageId();
                        if (Long.isLong(msgId)) {
                            return [ "Message Id", true, msgId.toString(10), null ];
                        }
                        return [ "Message Id", false, "", null ];
                    },
                    fpReplicationGroupMessageId(message /* , flags*/) {
                        const rgmid = message.getReplicationGroupMessageId();
                        if (rgmid === undefined) {
                            return [ "Replication Group Message Id", false, "", null ];
                        }
                        return [ "Replication Group Message Id", true, rgmid.toString(), null ];
                    },
                    fpTimeToLive(message /* , flags */) {
                        const timeToLive = message.getTimeToLive();
                        if (typeof timeToLive === "number") {
                            const mdu = MessageDumpUtilLib.MessageDumpUtil;
                            const d = new Date();
                            return [ "TimeToLive", true, `${timeToLive} (${mdu.formatDate(d.getTime() + timeToLive)})`, null ];
                        }
                        return [ "TimeToLive", false, "", null ];
                    },
                    fpExpiration(message /*, flags*/) {
                        const timestamp = message.getGMExpiration();
                        if (typeof timestamp === "number") {
                            const mdu = MessageDumpUtilLib.MessageDumpUtil;
                            return [ "Expiration", true, `${timestamp} (${mdu.formatDate(timestamp)})`, null ];
                        }
                        return [ "Expiration", false, "", null ];
                    },
                    fpMessageDMQEligible(message /* , flags*/) {
                        return [ "DMQ Eligible", message.isDMQEligible(), "", null ];
                    },
                    fpMessageRedelivered(message /* , flags*/) {
                        return [ "Message Re-delivered", message.isRedelivered(), "", null ];
                    },
                    fpMessageDeliveryCount(message /* , flags*/) {
                        //TODO: exception handling!
                        try {
                            return [ "Message Delivery Count", true, message.getDeliveryCount(), null ];
                        } catch (e) {
                            return [ "Message Delivery Count", false, "", null ];
                        }
                    },
                    fpDiscardIndication(message /* , flags*/) {
                        return [ "Discard Indication", message.isDiscardIndication(), "", null ];
                    },
                    fpAckImmediately(message /* , flags*/) {
                        return [ "ACK Immediately", message.isAcknowledgeImmediately(), "", null ];
                    },
                    fpElidingEligible(message /* , flags*/) {
                        return [ "Eliding Eligible", message.isElidingEligible(), "", null ];
                    },
                    fpReplyMessage(message /* , flags*/) {
                        return [ "Reply Message", message.isReplyMessage(), "", null ];
                    },
                    fpReplyTo(message /* , flags*/) {
                        const replyTo = message.getReplyTo();
                        if (replyTo !== null && replyTo instanceof Destination) {
                            return [ "ReplyTo", true, replyTo.toString(), null ];
                        }
                        return [ "ReplyTo", false, "", null ];
                    },
                    fpDeliverToOne(message /* , flags*/) {
                        return [ "Deliver To One", message.isDeliverToOne(), "", null ];
                    },
                    fpCacheMessage(message /* , flags*/) {
                        return [ "Message from cache", message.getCacheStatus() !== MessageCacheStatus.LIVE, "", null ];
                    },
                    fpCacheRequestId(message /*, flags */) {
                        const cacheRequestId = message.getCacheRequestId();
                        if (Long.isLong(cacheRequestId)) {
                            return [ "Cache Request Id", true, cacheRequestId.toString, null ];
                        }
                        return [ "Cache Request Id", false, "", null ];
                    },
                    fpUserPropertyMap(message, flags) {
                        const propMap = message.getUserPropertyMap();
                        if (propMap !== null && propMap instanceof SDTMapContainer) {
                            const value = `${propMap.getKeys().length} entries`;
                            let detailValue = null;
                            if (flags === MessageDumpFlag.MSGDUMP_FULL) {
                                try {
                                    const mdu = MessageDumpUtilLib.MessageDumpUtil;
                                    detailValue = mdu.printMap(propMap, 2);
                                } catch (e) {
                                    LOG_ERROR(e.message, e.stack);
                                    detailValue = "Error";
                                }
                            }
                            return [ "User Property Map", true, value, detailValue ];
                        }
                        return [ "User Property Map", false, "", null ];
                    },
                    fpCorrelationTag(message /*, flags*/) {
                        const strValue = message.getCorrelationKey();
                        return [ "Correlation Tag Pointer", strValue !== undefined && strValue !== null, strValue, null ];
                    },
                    fpUserData(message /* , flags*/) {
                        if (StringUtils.notEmpty(message.getUserData())) {
                            return [ "User Data", true, `len=${message.getUserData().length}`, DebugLib.Debug.formatDumpBytes(message.getUserData(), true, 2) ];
                        }
                        return [ "User Data", false, "", null ];
                    },
                    fpSdtStream(message, flags) {
                        const sdtFieldValue = message.getSdtContainer();
                        if (sdtFieldValue !== null && sdtFieldValue.getType() === SDTFieldType.STREAM) {
                            const mdu = MessageDumpUtilLib.MessageDumpUtil;
                            const value = `${mdu.countItems(sdtFieldValue.getValue())} entries`;
                            let detailValue = null;
                            if (flags === MessageDumpFlag.MSGDUMP_FULL) {
                                try {
                                    detailValue = mdu.printStream(sdtFieldValue.getValue(), 2);
                                } catch (e) {
                                    LOG_ERROR(e.message, e.stack);
                                    detailValue = "Error";
                                }
                            }
                            return [ "SDT Stream", true, value, detailValue ];
                        }
                        return [ "SDT Stream", false, "", null ];
                    },
                    fpSdtMap(message, flags) {
                        const sdtFieldValue = message.getSdtContainer();
                        if (sdtFieldValue !== null && sdtFieldValue.getType() === SDTFieldType.MAP) {
                            const value = `${sdtFieldValue.getValue().getKeys().length} entries`;
                            let detailValue = null;
                            if (flags === MessageDumpFlag.MSGDUMP_FULL) {
                                try {
                                    const mdu = MessageDumpUtilLib.MessageDumpUtil;
                                    detailValue = mdu.printMap(sdtFieldValue.getValue(), 2);
                                } catch (e) {
                                    LOG_ERROR(e.message, e.stack);
                                    detailValue = "Error";
                                }
                            }
                            return [ "SDT Map", true, value, detailValue ];
                        }
                        return [ "SDT Map", false, "", null ];
                    },
                    fpBinaryAttachment(message, flags) {
                        if (!message._binaryAttachment || message._binaryAttachment.length < 1) {
                            return [ "Binary Attachment", false, "", null ];
                        }
                        const att = message._binaryAttachment.toString("latin1");
                        const value = `len=${att.length}`;
                        let detailValue = null;
                        if (flags === MessageDumpFlag.MSGDUMP_FULL) {
                            detailValue = DebugLib.Debug.formatDumpBytes(att, true, 2);
                        }
                        return [ "Binary Attachment", true, value, detailValue ];
                    },
                    fpXmlContent(message, flags) {
                        const xml = message.getXmlContent();
                        if (StringUtils.notEmpty(xml)) {
                            const value = `len=${xml.length}`;
                            let detailValue = null;
                            if (flags === MessageDumpFlag.MSGDUMP_FULL) {
                                detailValue = DebugLib.Debug.formatDumpBytes(xml, true, 2);
                            }
                            return [ "XML", true, value, detailValue ];
                        }
                        return [ "XML", false, "", null ];
                    },
                    fpXmlMetadata(message, flags) {
                        const xmlMetadata = message.getXmlMetadata();
                        if (StringUtils.notEmpty(xmlMetadata)) {
                            const value = `len=${xmlMetadata.length}`;
                            let detailValue = null;
                            if (flags === MessageDumpFlag.MSGDUMP_FULL) {
                                detailValue = DebugLib.Debug.formatDumpBytes(xmlMetadata, true, 2);
                            }
                            return [ "XML Metadata", true, value, detailValue ];
                        }
                        return [ "XML Metadata", false, "", null ];
                    }
                };
                module.exports.MessageDumpStandardProvider = MessageDumpStandardProvider;
                /***/
            },
            /***/ "./modules/solclient-message/lib/message-dump-util.js": 
            /*!************************************************************!*\
  !*** ./modules/solclient-message/lib/message-dump-util.js ***!
  \************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const DebugLib = __webpack_require__(/*! solclient-debug */ "./modules/solclient-debug/api.js");
                const MessageDumpStandardProviderLib = __webpack_require__(/*! ./message-dump-standard-provider */ "./modules/solclient-message/lib/message-dump-standard-provider.js");
                const {
                    SDTFieldType,
                    SDTMapContainer,
                    SDTStreamContainer,
                    SDTUnsupportedValueError,
                    SDTValueErrorSubcode
                } = __webpack_require__(/*! solclient-sdt */ "./modules/solclient-sdt/api.js");
                const {
                    Check
                } = __webpack_require__(/*! solclient-validate */ "./modules/solclient-validate/api.js");
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    MessageDumpFlag
                } = __webpack_require__(/*! ./message-dump-flags */ "./modules/solclient-message/lib/message-dump-flags.js");
                const {
                    StringBuffer,
                    StringUtils
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const MessageDumpState = {
                    get dumpProviders() {
                        const providers = MessageDumpStandardProviderLib.MessageDumpStandardProvider;
                        return Object.keys(providers).map(k => providers[k]);
                    }
                };
                const MessageDumpUtil = {
                    getOutOfRangeValue(rawData) {
                        if (typeof rawData === "string") {
                            return `<out of range>\n${DebugLib.Debug.formatDumpBytes(rawData)}`;
                        }
                        return `<out of range>\n${DebugLib.Debug.formatDumpBytes(rawData.toString("latin1"))}`;
                    },
                    getValue(sdtField) {
                        let value = null;
                        try {
                            value = sdtField.getValue();
                            return value;
                        } catch (e) {
                            if (e instanceof SDTUnsupportedValueError) {
                                if (e.getSubcode() === SDTValueErrorSubcode.VALUE_OUTSIDE_SUPPORTED_RANGE) {
                                    return this.getOutOfRangeValue(e.getSourceData());
                                }
                            } else if (e instanceof OperationError && e.subcode === ErrorSubcode.PARAMETER_INVALID_TYPE) {
                                return "<invalid type>";
                            }
                            throw e;
                        }
                    },
                    printMap(sdtMap, indent) {
                        if (Check.nothing(sdtMap) || !(sdtMap instanceof SDTMapContainer)) {
                            return null;
                        }
                        const lines = [];
                        const strIndent = StringUtils.padRight("", indent, " ");
                        const keys = sdtMap.getKeys().sort();
                        keys.forEach(key => {
                            const sdtFieldValue = sdtMap.getField(key);
                            const type = sdtFieldValue.getType();
                            const value = this.getValue(sdtFieldValue);
                            let strValue;
                            switch (type) {
                              case SDTFieldType.MAP:
                                strValue = `\n${this.printMap(value, indent + 2)}`;
                                break;

                              case SDTFieldType.STREAM:
                                strValue = `\n${this.printStream(value, indent + 2)}`;
                                break;

                              case SDTFieldType.BYTEARRAY:
                                strValue = DebugLib.Debug.formatDumpBytes(value.toString("latin1"), false, 0);
                                if (strValue !== null && strValue.substr(-1) === "\n") {
                                    strValue = strValue.substring(0, strValue.length - 1);
                                }
                                break;

                              default:
                                strValue = value !== null ? value.toString() : null;
                            }
                            lines.push(`${strIndent}Key '${key}' (${SDTFieldType.nameOf(type)}): ${strValue}`);
                        });
                        return lines.join("\n");
                    },
                    printStream(sdtStream, indent) {
                        if (Check.nothing(sdtStream) || !(sdtStream instanceof SDTStreamContainer)) {
                            return null;
                        }
                        sdtStream.rewind();
                        const lines = [];
                        const strIndent = StringUtils.padRight("", indent, " ");
                        while (sdtStream.hasNext()) {
                            const sdtFieldValue = sdtStream.getNext();
                            const type = sdtFieldValue.getType();
                            const value = this.getValue(sdtFieldValue);
                            let strValue;
                            switch (type) {
                              case SDTFieldType.MAP:
                                strValue = `\n${this.printMap(value, indent + 2)}`;
                                break;

                              case SDTFieldType.STREAM:
                                strValue = `\n${this.printStream(value, indent + 2)}`;
                                break;

                              case SDTFieldType.BYTEARRAY:
                                strValue = DebugLib.Debug.formatDumpBytes(value.toString("latin1"), false, 0);
                                if (strValue !== null && strValue.substr(-1) === "\n") {
                                    strValue = strValue.substring(0, strValue.length - 1);
                                }
                                break;

                              case SDTFieldType.DESTINATION:
                                strValue = value.toString();
                                break;

                              default:
                                strValue = value !== null ? value.toString() : null;
                            }
                            lines.push(`${strIndent}(${SDTFieldType.nameOf(type)}): ${strValue}`);
                        }
                        sdtStream.rewind();
                        return lines.join("\n");
                    },
                    countItems(sdtStream) {
                        if (Check.nothing(sdtStream) || !(sdtStream instanceof SDTStreamContainer)) {
                            return 0;
                        }
                        sdtStream.rewind();
                        let count = 0;
                        while (sdtStream.hasNext()) {
                            sdtStream.getNext();
                            count++;
                        }
                        sdtStream.rewind();
                        return count;
                    },
                    formatDate(timeStamp) {
                        return new Date(timeStamp).toString();
                    },
                    dump(message, flags, separator, colPadding) {
                        const sb = new StringBuffer();
                        let theSeparator = "\n";
                        let needSeparator = false;
                        let theColPadding = 40;
                        if (separator !== undefined && separator !== null && typeof separator === "string") {
                            theSeparator = separator;
                        }
                        if (colPadding !== undefined && colPadding !== null && typeof colPadding === "number") {
                            theColPadding = colPadding;
                        }
                        MessageDumpState.dumpProviders.forEach((provider, index) => {
                            const [ key, isPresent, value, detailValue ] = provider(message, flags);
                            if (!isPresent) {
                                return;
                            }
                            if (needSeparator) {
                                sb.append(theSeparator);
                            }
                            if (value === null || value.length === 0) {
                                // If we have no VALUE field, this is probably a boolean flag
                                // and we just end up displaying the key and a newline.
                                sb.append(key);
                            } else {
                                sb.append(StringUtils.padRight(`${key}:`, theColPadding, " "));
                                sb.append(value);
                            }
                            if (detailValue !== null && flags & MessageDumpFlag.MSGDUMP_FULL) {
                                sb.append("\n");
                                if (detailValue.indexOf("  ") !== 0) {
                                    sb.append("  ");
                                }
                                sb.append(detailValue);
                                if (detailValue.substr(-1) !== "\n" && index < MessageDumpState.dumpProviders.length - 1) {
                                    sb.append("\n");
                                }
                            }
                            needSeparator = true;
                        });
                        return sb.toString();
                    }
                };
                module.exports.MessageDumpUtil = MessageDumpUtil;
                /***/
            },
            /***/ "./modules/solclient-message/lib/message-types.js": 
            /*!********************************************************!*\
  !*** ./modules/solclient-message/lib/message-types.js ***!
  \********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Represents an enumeration of message payload types
 * (see {@link solace.Message#getBinaryAttachment})
 *
 * A message may contain unstructured byte data, or a structured container.
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
                const MessageType = {
                    /**
   * Binary message (unstructured bytes stored in the binary attachment message part).
   * @type {Number}
   */
                    BINARY: 0,
                    /**
   * Structured map message.
   * @type {Number}
   */
                    MAP: 1,
                    /**
   * Structured stream message.
   * @type {Number}
   */
                    STREAM: 2,
                    /**
   * Structured text message.
   * @type {Number}
   */
                    TEXT: 3
                };
                module.exports.MessageType = Enum.new(MessageType);
                /***/
            },
            /***/ "./modules/solclient-message/lib/message-user-cos-types.js": 
            /*!*****************************************************************!*\
  !*** ./modules/solclient-message/lib/message-user-cos-types.js ***!
  \*****************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Represents an enumeration of user Class of Service (COS) levels. The COS is set
 * on a Message with {@link solace.Message#setUserCos}
 * The Class of Service has different semantics for direct and guaranteed messages.
 *
 * For messages published with {@link solace.MessageDeliveryModeType.DIRECT}, the
 * class of service selects the weighted round-robin delivery queue when the
 * message is forwarded to a consumer.  {@link solace.MessageUserCosType.COS1} are the
 * lowest priority messages and will use the Solace Message Router D-1 delivery queues.
 *
 * For messages published as guaranteed messages
 * ({@link solace.MessageDeliveryModeType.PERSISTENT} or
 * {@link solace.MessageDeliveryModeType.NON_PERSISTENT}), messages published
 * with {@link solace.MessageUserCosType.COS1} can be rejected by the Solace Message Router if
 * that message would cause any queue or topic-endpoint to exceed its configured
 * low-priority-max-msg-count.
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
                const MessageUserCosType = {
                    /**
   * Direct Messages: Lowest priority, use Solace Message Router client D-1 queues for delivery.
   *
   * Guaranteed Messages: Messages can be rejected if the message would cause any
   * queue or topic-endpoint to exceed its configured <i>low-priority-max-msg-count</i>.
   * @type {Number}
   */
                    COS1: 0,
                    /**
   * Direct Messages: Medium priority, use Solace Message Router client D-2 queues for delivery.
   *
   * Guaranteed Messages: N/A (same as COS3)
   * @type {Number}
   */
                    COS2: 1,
                    /**
   * Direct Messages: Highest priority, use Solace Message Router client D-3 queues for delivery.
   *
   * Guaranteed Messages: Messages are not rejected for exceeding <i>low-priority-max-msg-count</i>.
   * Messages may still be rejected for other reasons such as Queue 'Spool Over Quota'.
   * @type {Number}
   */
                    COS3: 2
                };
                module.exports.MessageUserCosType = Enum.new(MessageUserCosType);
                /***/
            },
            /***/ "./modules/solclient-message/lib/message.js": 
            /*!**************************************************!*\
  !*** ./modules/solclient-message/lib/message.js ***!
  \**************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const clone = __webpack_require__(/*! clone */ "./node_modules/clone/clone.js");
                const SolclientFactoryLib = __webpack_require__(/*! solclient-factory */ "./modules/solclient-factory/api.js");
                const {
                    Codec: SDTCodec
                } = __webpack_require__(/*! solclient-sdt */ "./modules/solclient-sdt/api.js");
                const {
                    Convert
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    Destination
                } = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    LOG_DEBUG
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    MessageCacheStatus
                } = __webpack_require__(/*! ./message-cache-status */ "./modules/solclient-message/lib/message-cache-status.js");
                const {
                    MessageDeliveryModeType
                } = __webpack_require__(/*! ./message-delivery-mode-types */ "./modules/solclient-message/lib/message-delivery-mode-types.js");
                const {
                    MessageDumpFlag
                } = __webpack_require__(/*! ./message-dump-flags */ "./modules/solclient-message/lib/message-dump-flags.js");
                const {
                    MessageDumpUtil
                } = __webpack_require__(/*! ./message-dump-util */ "./modules/solclient-message/lib/message-dump-util.js");
                const {
                    MessageType
                } = __webpack_require__(/*! ./message-types */ "./modules/solclient-message/lib/message-types.js");
                const {
                    MessageUserCosType
                } = __webpack_require__(/*! ./message-user-cos-types */ "./modules/solclient-message/lib/message-user-cos-types.js");
                const {
                    Parameter
                } = __webpack_require__(/*! solclient-validate */ "./modules/solclient-validate/api.js");
                const {
                    RgmidFactory
                } = __webpack_require__(/*! ./replication-group-message-id */ "./modules/solclient-message/lib/replication-group-message-id.js");
                const {
                    SDTField,
                    SDTFieldType,
                    SDTMapContainer,
                    SDTUnsupportedValueError
                } = __webpack_require__(/*! solclient-sdt */ "./modules/solclient-sdt/api.js");
                const {
                    ProfileBinding
                } = SolclientFactoryLib;
                const {
                    utf8ToUcs2,
                    anythingToBuffer
                } = Convert;
                const {
                    isBoolean,
                    isEnumMember,
                    isInstanceOf,
                    isInstanceOfOrNothing,
                    isNumberOrNothing,
                    isStringOrNothing
                } = Parameter;
                // When a message is cloned for sending,
                // * We assume that it may NOT include circular references.
                //   These are also unsupported in the encoder.
                // * We assume that all properties to be cloned are enumerable.
                //   This has significant (~10% AD send rate) performance impact.
                const MESSAGE_CLONE_OPTIONS = {
                    circular: false,
                    includeNonEnumerable: false
                };
                /**
 * Function called on construct/reset. Sets the initial values for fields that have them.
 * @param {Message} message The message to initialize
 * @internal
 */
                function initMessage(message) {
                    message._deliveryMode = MessageDeliveryModeType.DIRECT;
                    message._userCos = MessageUserCosType.COS1;
                    message._cacheStatus = MessageCacheStatus.LIVE;
                    message._spoolerUniqueId = undefined;
                    /* message._spoolerMessageId does not to be set to undefined
   * message._spoolerMessageId should only be set when
   * message._spoolerUniqueId is set to a value
   * other than undefined or RgmidFactory.INVALID_SUID
   */
                    message._priority = undefined;
                    message._deliveryCount = -1; //Makes the accessor throw, never returned to user.
                }
                /**
 * Function called on reset only. Clears every field in the message. Call #initMessage
 * to set initial values.
 * @param {Message} message The message to clear
 * @internal
 */
                function clearMessage(message) {
                    const fields = Object.keys(message);
                    fields.forEach(f => delete message[f]);
                }
                /**
 * @classdesc
 * <b>This class is not exposed for construction by API users. Users should obtain an instance from
 * {@link solace.SolclientFactory.createMessage}</b>
 * <p>
 * A message is a container that can be used to store and send messages to and from the
 * Solace Message Router.
 *
 * Applications manage the lifecycle of a message; a message is created by calling
 * {@link solace.SolclientFactory.createMessage} and is freed by dereferencing it.
 *
 * API operations that cache or mutate messages always take a copy. A message may
 * be created, mutated by the API user, and sent multiple times.
 *
 * The Message Object provides methods to manipulate the common Solace
 * message header fields that are optionally sent in the binary metadata
 * portion of the Solace message.
 *
 * Applications can also use the structured data API {@link solace.Message#setSdtContainer}
 * to add containers (maps or streams) and their fields to the binary payload or
 * to the User Property map contained within the binary metadata.
 *
 * This does not prevent applications from ignoring these
 * methods and sending payload in the binary payload as an opaque binary field for
 * end-to-end communications
 *
 * @memberof solace
 */
                class Message {
                    /**
   * @constructor
   * @hideconstructor
   **/
                    constructor() {
                        initMessage(this);
                    }
                    /**
   * Gets the payload type ({@link solace.MessageType}) of the message. A message has a
   * structured payload if one was attached via {@link solace.Message#setSdtContainer} otherwise
   * if the payload is attached via {@link Message@setBinaryAttachment} then it
   * is unstructured ({@link solace.MessageType#BINARY})
   *
   * @returns {solace.MessageType} The structured payload type.
   * @default {solace.MessageType.BINARY}
   */
                    getType() {
                        return this._messageType || MessageType.BINARY; // This is OK; BINARY === 0.
                    }
                    /**
   * Sets the application-provided message ID.
   * @param {?String} value The new value for the application-provided message ID.
   */
                    setApplicationMessageId(value) {
                        this._applicationMessageId = isStringOrNothing("applicationMessageId", value);
                    }
                    /**
   * Gets the application-provided message ID.
   * @returns {?String} The application provided message ID.
   */
                    getApplicationMessageId() {
                        return this._applicationMessageId;
                    }
                    /**
   * Sets the application message type. This value is used by applications
   * only, and is passed through the API and Solace Message Router untouched.
   * @param {?String} value The application message type.
   */
                    setApplicationMessageType(value) {
                        this._applicationMessageType = isStringOrNothing("applicationMessageType", value);
                    }
                    /**
   * Gets the application message type. This value is used by applications
   * only, and is passed through the API and Solace Message Router untouched.
   * @returns {?String} The application message type.
   */
                    getApplicationMessageType() {
                        return this._applicationMessageType;
                    }
                    /**
   * Gets the binary attachment part of the message.
   *
   * Backward compatibility note: Using the version10 factory profile or older,
   * the binary attachment is returned as a 'latin1' String:
   * Each character has a code in the range * 0-255
   * representing the value of a single received byte at that position.
   *
   * @returns {Uint8Array|String|null} A TypedArray view of the binary attachment.
   */
                    getBinaryAttachment() {
                        if (this._binaryAttachment && ProfileBinding.value.byteArrayAsString) {
                            return this._binaryAttachment.toString("latin1");
                        }
                        return this._binaryAttachment;
                    }
                    /**
   * Sets the binary attachment part of the message.
   *
   * The binary attachment is conceptually an array of bytes.
   * When this method is used, the message payload type is {@link solace.MessageType#BINARY}
   * See {@link solace.Message#getType}.
   *
   * Applications may set the binary attachment to NULL or undefined to
   * remove the binary attachment and create a message with no payload.
   *
   * The following types are accepted:
   *   Buffer (the nodeJS native type or equivalent)
   *   ArrayBuffer,
   *   Any DataView or TypedArray,
   *   'latin1' String for backwards compatibility:
   *     each character has a code in the range 0-255
   *     representing exactly one byte in the attachment.
   *
   * @param {Uint8Array|ArrayBufferLike|DataView|String|null|undefined} value Sets the binary attachment part of the message.
   */
                    setBinaryAttachment(value) {
                        if (value) {
                            this._messageType = MessageType.BINARY;
                        }
                        this._setBinaryAttachment(anythingToBuffer(value));
                    }
                    _setBinaryAttachment(value) {
                        this._binaryAttachment = value;
                    }
                    /**
   * Given a Message containing a cached message, return the cache Request Id that
   * the application set in the call to {@link solace.CacheSession#sendCacheRequest}.
   *
   * @returns {?Number} The request ID of the cache request associated with this message.
   */
                    getCacheRequestId() {
                        return this._cacheRequestId;
                    }
                    /**
   * @private
   * @param {Number} cacheRequestID The cache request ID associated with this message
   */
                    _setCacheRequestID(cacheRequestID) {
                        this._cacheRequestId = cacheRequestID;
                    }
                    /**
   * Gets the correlation ID.  The message Correlation Id
   * is carried in the Solace message headers unmodified by the API and
   * the Solace Message Router. This field may be used for peer-to-peer
   * message synchronization and is commonly used for correlating
   * a request to a reply. See {@link solace.Session#sendRequest}.
   * @returns {?String} The correlation ID associated with the message.
   */
                    getCorrelationId() {
                        return this._correlationId;
                    }
                    /**
   * Sets the correlation ID. The message Correlation Id
   * is carried in the Solace message headers unmodified by the API and
   * the Solace Message Router. This field may be used for peer-to-peer
   * message synchronization and is commonly used for correlating
   * a request to a reply. See {@link solace.Session#sendRequest}.
   * @param {String|null|undefined} value The correlation ID to associate with the message.
   */
                    setCorrelationId(value) {
                        this._correlationId = isStringOrNothing("correlationId", value);
                    }
                    /**
   * Gets the correlation Key. A correlation key is used to correlate
   * a message with its acknowledgement or rejection. The correlation key is an object that is
   * passed back to the client during the router acknowledgement or rejection.
   *
   * The correlation key is a local reference
   * used by applications generating Guaranteed messages. Messages that are
   * sent in either {@link solace.MessageDeliveryModeType.PERSISTENT} or
   * {@link solace.MessageDeliveryModeType.NON_PERSISTENT} mode may set the correlation key.
   * @returns {?Object} The correlation Key associated with the message,
   * or <code>null</code>, if unset.
   */
                    getCorrelationKey() {
                        return this._correlationKey || null;
                    }
                    /**
   * Sets the correlation Key. A correlation key is used to correlate
   * a message with its acknowledgement or rejection. The correlation key is an object that is
   * passed back to the client during the router acknowledgement or rejection.
   *
   * The correlation key is a local reference
   * used by applications generating Guaranteed Messages. Messages that are
   * sent in either {@link solace.MessageDeliveryModeType.PERSISTENT} or
   * {@link solace.MessageDeliveryModeType.NON_PERSISTENT} mode may set the correlation key. If this
   * method is used, the correlation information is returned
   * when the {@link solace.SessionEventCode#event:ACKNOWLEDGED_MESSAGE} event
   * is later received for an acknowledged message or when the
   * {@link solace.SessionEventCode#event:REJECTED_MESSAGE_ERROR} is received for a rejected
   * message.
   *
   * The API only maintains a reference to the passed object.  If the application requires the
   * contents are unmodified for proper correlation, then it is the application's responsibility
   * to ensure the contents of the object are not modified.
   *
   * Important: <b>The Correlation Key is not included in the
   * transmitted message and is only used with the local API</b>
   * @param {Object|String|null|undefined} value The correlation Key to associate with the message.
   */
                    setCorrelationKey(value) {
                        this._correlationKey = value;
                    }
                    /**
   * Gets whether the message is configured for delivering to one client only.
   * @returns {Boolean} indicates whether the message is configured for
   * delivering to one client only.
   * @deprecated use Shared Subscriptions instead.
   */
                    isDeliverToOne() {
                        return this._deliverToOne || false;
                    }
                    /**
   * Sets whether the message is configured for delivering to one client only.
   * @param {Boolean} value whether the message is configured for delivering to one client only.
   * @deprecated use Shared Subscriptions instead.
   */
                    setDeliverToOne(value) {
                        this._setDeliverToOne(this._deliverToOne = isBoolean("deliverToOne", value));
                    }
                    _setDeliverToOne(value) {
                        this._deliverToOne = value;
                    }
                    /**
   * Gets the delivery mode of the message.
   * @returns {solace.MessageDeliveryModeType} representing the delivery mode of the message.
   */
                    getDeliveryMode() {
                        return this._deliveryMode;
                    }
                    /**
   * Sets the delivery mode of the message.
   * @param {solace.MessageDeliveryModeType} value The message delivery mode.
   */
                    setDeliveryMode(value) {
                        this._setDeliveryMode(isEnumMember("deliveryMode", value, MessageDeliveryModeType));
                    }
                    _setDeliveryMode(value) {
                        this._deliveryMode = value;
                    }
                    /**
   * Gets the destination to which the message was published.
   * @returns {?Destination} The destination to which a message was published.
   */
                    getDestination() {
                        return this._destination;
                    }
                    /**
   * Sets the destination ({@link solace.DestinationType#Topic} or
   * {@link solace.DestinationType#Queue}) to publish the message to.
   * @param {Destination} value The destination to publish the message to.
   */
                    setDestination(value) {
                        this._setDestination(isInstanceOf("destination", value, Destination));
                    }
                    _setDestination(value) {
                        this._destination = value;
                    }
                    /**
   * Indicates whether one or more messages have been discarded prior
   * to the current message. This indicates congestion discards only and
   * is not affected by message eliding.
   * @returns {Boolean} Returns true if one or more messages have been
   * discarded prior to the current message; otherwise, it returns false.
   */
                    isDiscardIndication() {
                        return this._discardIndication || false;
                    }
                    /**
   * @private
   * @param {Boolean} value The new value for discard indication
   */
                    setDiscardIndication(value) {
                        this._setDiscardIndication(isBoolean("discardIndication", value));
                    }
                    _setDiscardIndication(value) {
                        this._discardIndication = value;
                    }
                    /**
   * Returns whether the message is eligible for eliding.
   * <p>
   * Message eliding enables filtering of data to avoid transmitting
   * every single update to a subscribing client.
   * <p>
   * This property does not indicate whether the message was elided.
   *
   * @returns {Boolean} indicates whether the message is eligible for eliding.
   */
                    isElidingEligible() {
                        return this._elidingEligible || false;
                    }
                    /**
   * Sets whether the message is eligible for eliding.
   * <p>
   * Message eliding enables filtering of data to avoid transmitting
   * every single update to a subscribing client.
   * <p>
   * This property does not indicate whether the message was elided.
   *
   * @param {Boolean} value sets whether the message is eligible for eliding.
   */
                    setElidingEligible(value) {
                        this._setElidingEligible(isBoolean("setElidingEligible", value));
                    }
                    _setElidingEligible(value) {
                        this._elidingEligible = value;
                    }
                    /// ---------------------------------------------------------
                    // * Internal use only methods on the message, for fields set by the internal
                    // * publisher
                    /// ---------------------------------------------------------
                    /**
   * @returns {Number} The publisher ID
   * @private
   */
                    getPublisherId() {
                        return this._publisherId;
                    }
                    /**
   * @param {Number} value  The publisher ID to set
   * @private
   */
                    setPublisherId(value) {
                        this._publisherId = value;
                    }
                    /**
   * @returns {Number} The publisher message ID
   * @private
   */
                    getPublisherMessageId() {
                        return this._publisherMsgId;
                    }
                    /**
   * @param {Number} value The publisher message ID to set
   * @private
   */
                    setPublisherMessageId(value) {
                        this._publisherMsgId = value;
                    }
                    /// -------------------------------------------------------------
                    // * User-settable properties for publishing
                    /// -------------------------------------------------------------
                    /**
   * @returns {Number} The Guaranteed Message TTL, in milliseconds.
   */
                    getTimeToLive() {
                        return this._timeToLive;
                    }
                    /**
   * @param {Number} value The Guaranteed Message TTL to set, in milliseconds.
   *
   * The time to live is the number of milliseconds the message may be stored on the
   * Solace Message Router before the message is discarded or moved to a Dead Message
   * Queue. See {@link solace.Message.setDMQEligible}.
   *
   * Setting the Time To Live to zero disables TTL for the message.
   *
   * This property is only valid for Guaranteed messages (Persistent and Non-Persistent).
   * It has no effect when used in conjunction with other message types unless the message
   * is promoted by the appliance to a Guaranteed message.
   *
   * The maxium allowed time to live is 3.1536E11 (315360000000) which is
   * approximately 10 years.
   */
                    setTimeToLive(value) {
                        const MAX_MESSAGE_TTL_MS = 10 * 365 * 24 * 60 * 60 * 1e3; // approximately 10 years
                        // Allow parser and initializer to set timeToLive to undefined
                        if (value === null || value === undefined) {
                            this._timeToLive = value;
                            return;
                        }
                        if (typeof value !== "number" || isNaN(value)) {
                            throw new OperationError("Invalid type for time to live", ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                        if (value < 0 || value > MAX_MESSAGE_TTL_MS) {
                            throw new OperationError("Invalid time to live value", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                        this._timeToLive = value;
                    }
                    /**
   * @returns {?Number} The Guaranteed Message expiration value.
   * The expiration time is the UTC time
   * (that is, the number of milliseconds from midnight January 1, 1970 UTC) when the
   * message is to expire.
   */
                    getGMExpiration() {
                        return this._expiration;
                    }
                    /**
   * Set the expiration time field. The expiration time is the UTC time
   * (that is, the number of milliseconds from midnight January 1, 1970 UTC) when the
   * message is to expire. The expiration time is carried in the message when set to
   * a non-zero value. Expiration time is not included when this value is set to zero or
   * undefined
   *
   * The message expiration time is carried to clients that receive the message
   * unmodified and does not effect the life cycle of the message. Use
   * {@link solace.Message#setTimeToLive} to enforce message expiry in the network.
   *
   * @param {?Number} value The new Guaranteed Message expiration value
   */
                    setGMExpiration(value) {
                        this._expiration = isNumberOrNothing("GMExpiration", value);
                    }
                    /**
   * @returns {Boolean} Whether this message is Guaranteed Message DMQ eligible
   */
                    isDMQEligible() {
                        return this._dmqEligible || false;
                    }
                    /**
   * @param {Boolean} value The new value for Guaranteed Message DMQ (Dead Message Queue) Eligible.
   * When this property is set, when the message expires in the network
   * the message is saved on a appliance dead message queue. Otherwise the expired message is
   * discarded. See {@link solace.Message#setTimeToLive}.
   * @default false
   */
                    setDMQEligible(value) {
                        this._setDMQEligible(isBoolean("DMQEligible", value));
                    }
                    _setDMQEligible(value) {
                        this._dmqEligible = value;
                    }
                    /// ---------------------------------------------------------
                    // * Internal use only methods on the message, for fields set by the consumer flow
                    /// ---------------------------------------------------------
                    /**
   * @returns {Long} The ID of the flow that received this message
   * @private
   */
                    getFlowId() {
                        return this._flowId;
                    }
                    /**
   * @param {Long} value The flow ID that received this message
   * @private
   */
                    setFlowId(value) {
                        this._flowId = value;
                    }
                    /**
   * @returns {Long} The Guaranteed Message prevMsgId
   * @private
   */
                    getGuaranteedPreviousMessageId() {
                        return this._guaranteedPrevMsgId;
                    }
                    /**
   * @param {Long} value The Guaranteed Message prevMsgId to set
   * @private
   */
                    setGuaranteedPreviousMessageId(value) {
                        this._guaranteedPrevMsgId = value;
                    }
                    /**
   * @param {Long} value Spooler unique id value
   * @private
   */
                    _setSpoolerUniqueId(value) {
                        this._spoolerUniqueId = value;
                    }
                    /**
   * @returns {?Long} value of Spooler unique id
   * @private
   */
                    _getSpoolerUniqueId() {
                        // This can be set via the smf header or by the message consumer
                        // using _setSpoolerUniqueId.
                        // The message consumer check if a data message has a suid set
                        // the updates the consumer stored value for suid from the message value.
                        // If the message does not have a suid the message consumer sets the suid
                        // of the message using _setSpoolerUniqueId.
                        // See consumer-fsm.acceptMessage for details.
                        if (this._spoolerUniqueId === undefined) {
                            return RgmidFactory.INVALID_SUID;
                        }
                        return this._spoolerUniqueId;
                    }
                    /// ---------------------------------------------------------
                    // * Properties set by the Message Consumer
                    /// ---------------------------------------------------------
                    /**
   * @returns {?solace.MessageConsumer} The associated Message Consumer, if received by a consumer
   */
                    getMessageConsumer() {
                        return this._consumer;
                    }
                    /**
   * @param {solace.MessageConsumer} value The Message Consumer to associate with this message
   * @private
   */
                    setMessageConsumer(value) {
                        this._consumer = value;
                    }
                    /**
   * This message ID is NOT a universal unique identifier for the message.
   * There is no use for this message ID in an application.
   * Internally this message ID is used when a message is acknowledged
   * calling Message.acknowledge().
   * No other meaning should be inferred from the value of this message ID.
   * @returns {?Long} A field in the message structure intended for internal use.
   * @deprecated There is no useful purpose for this method. Do not use it.
   */
                    getGuaranteedMessageId() {
                        return this._guaranteedMsgId;
                    }
                    /**
   * @param {Long} value The Guaranteed Message msgId to set
   * @private
   */
                    setGuaranteedMessageId(value) {
                        this._guaranteedMsgId = value;
                    }
                    /**
   * @param {Long} value Spooler message id value, this can be the mateAckId or the AckId
   * @private
   */
                    _setSpoolerMessageId(value) {
                        this._spoolerMessageId = value;
                    }
                    /**
   * Returns the Replication Group Message Id
   * @returns {?solace.ReplicationGroupMessageId} The replication group message id
   *  assigned by the router.
   */
                    getReplicationGroupMessageId() {
                        if (this._spoolerUniqueId === undefined || RgmidFactory.INVALID_SUID.eq(this._spoolerUniqueId)) {
                            return undefined;
                        }
                        /* use this._spoolerMessageId if possible otherwise use this._guaranteedMsgId */
                        const smid = this._spoolerMessageId || this._guaranteedMsgId;
                        /* Note smid as this._guaranteedMsgId must have a value
     * if this._spoolerUniqueId is not RgmidFactory.INVALID_SUID */
                        return RgmidFactory.from({
                            suid: this._spoolerUniqueId,
                            msgid: smid
                        });
                    }
                    /**
   * Returns the Topic Sequence Number.  If there is no topic sequence number
   * undefined is returned.
   * @returns {?Long} The Topic Sequence number assigned to this message by the Message Router.
   */
                    getTopicSequenceNumber() {
                        return this._topicSequenceNumber;
                    }
                    /**
   * @param {Long} topicSeqNo The Topic Sequence Number to set
   * @private
   */
                    setTopicSequenceNumber(topicSeqNo) {
                        this._topicSequenceNumber = topicSeqNo;
                    }
                    /**
   * Returns the delivery count.
   * @returns {?Number} The delivery count reported by the broker.
   */
                    getDeliveryCount() {
                        if (this._deliveryCount === -1) {
                            throw new OperationError("Endpoint does not report delivery count.", ErrorSubcode.INVALID_OPERATION);
                        } // else
                        return this._deliveryCount;
                    }
                    /**
   * @param {Number} deliveryCount on this message.
   * @private
   */
                    setDeliveryCount(deliveryCount) {
                        this._deliveryCount = deliveryCount;
                    }
                    /**
   * Acknowledges this message.
   *
   * If the {@link solace.MessageConsumer} on which this message was received is configured to use
   * {@link solace.MessageConsumerAckMode.CLIENT}, then when a message is received by an
   * application, the application must call this method to explicitly acknowledge reception of the
   * message. This frees local and router resources associated with an unacknowledged message.
   *
   * The API does not send acknowledgments immediately. It stores the state for
   * acknowledged messages internally and acknowledges messages, in bulk, when a
   * threshold or timer is reached.
   *
   * @throws {@link solace.OperationError}
   *  * if this message was not received via Guaranteed Message;
   *    subcode: {@link solace.ErrorSubcode.MESSAGE_DELIVERY_MODE_MISMATCH}
   *  * if the associated {@link solace.Session} is not connected;
   *    subcode: {@link solace.ErrorSubcode.SESSION_NOT_CONNECTED}
   *  * if the associated {@link solace.MessageConsumer} is not connectedl
   *    subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}
   */
                    acknowledge() {
                        if (this._consumer.getProperties().browser) {
                            throw new OperationError("Messages delivered to a Queue Browser can only be deleted by calling QueueBrowser.removeMessageFromQueue()", ErrorSubcode.INVALID_OPERATION);
                        }
                        if (this._acked) {
                            throw new OperationError("Message can only be acknowledged once", ErrorSubcode.MESSAGE_ALREADY_ACKNOWLEDGED);
                        }
                        if (this._deliveryMode === MessageDeliveryModeType.DIRECT) {
                            throw new OperationError("Cannot acknowledge a DIRECT message", ErrorSubcode.MESSAGE_DELIVERY_MODE_MISMATCH);
                        }
                        if (!this._consumer) {
                            throw new OperationError("Cannot acknowledge a locally-created message", ErrorSubcode.MESSAGE_DELIVERY_MODE_MISMATCH);
                        }
                        if (!this._consumer._sessionInterface.canAck) {
                            throw new OperationError("Cannot acknowledge using associated session", ErrorSubcode.SESSION_NOT_CONNECTED);
                        }
                        if (!this._consumer.canAck) {
                            throw new OperationError("Cannot acknowledge using associated Message Consumer", ErrorSubcode.INVALID_OPERATION);
                        }
                        this._consumer.applicationAck(this._guaranteedMsgId);
                        this._acked = true;
                    }
                    /**
   * Returns whether acknowledge() has been called on this message.
   *
   * @readonly
   * @type {Boolean}
   */
                    get isAcknowledged() {
                        return this._acked || false;
                    }
                    /**
   * Test if the Acknowledge Immediately message property is set or not.
   * When the Acknowledge Immediately property is set to true on an outgoing
   * Guaranteed Message,
   * it indicates that the Solace Message Router should Acknowledge this message
   * immediately upon receipt.
   *
   * This property, when set by a publisher, may or may not be removed by the
   * Solace Message Router prior to delivery to a consumer, so message consumers
   * must not expect the property value indicates how the message was
   * originally published
   * @returns {Boolean} Whether this message was set to acknowledge immediately.
   */
                    isAcknowledgeImmediately() {
                        return this._ackImmediately || false;
                    }
                    /**
   * Set the optional Acknoweledge Immediately message property.
   * When the Acknowledge Immediately property is set to true on an outgoing Guaranteed Message,
   * it indicates that the Solace Message Router should acknoweledge this message
   * immediately upon receipt. By default the property is set to false on newly created messages.
   *
   * This property, when set by a publisher, may or may not be removed by the appliance
   * prior to delivery to a consumer, so message consumers must not expect the property value
   * indicates how the message was originally published. Therefore if a received message
   * is forwarded by the application, the Acknowledge Immediately property should be
   * explicitly set to the desired value (true or false).
   *
   * Setting this property on an outgoing direct message has no effect.
   *
   * @param {Boolean} value Whether to acknowledge this message immediately.
   */
                    setAcknowledgeImmediately(value) {
                        this._setAcknowledgeImmediately(isBoolean("acknowledgeImmediately", value));
                    }
                    _setAcknowledgeImmediately(value) {
                        this._ackImmediately = value;
                    }
                    /**
   * Gets the cache status of this message.
   *
   * @returns {?solace.MessageCacheStatus} The cache status of this message. The status
   * will be MessageCacheStatus.LIVE unless the message was returned in a
   * reply to a cache request.
   */
                    getCacheStatus() {
                        return this._cacheStatus;
                    }
                    /**
   * @param {solace.MessageCacheStatus} cacheStatus The new cache status for this message
   * @private
   */
                    _setCacheStatus(cacheStatus) {
                        this._cacheStatus = cacheStatus;
                    }
                    /**
   * Returns whether the message's reply field is set, indicating
   * that this message is a reply to a previous request. See {@link solace.Session#sendRequest}.
   * @returns {Boolean} Indicates the state of the reply field.
   */
                    isReplyMessage() {
                        return this._replyMessage || false;
                    }
                    /**
   * Indicates whether the message has been marked as redelivered by the Solace Message Router.
   * @returns {Boolean} Indicates whether the redelivered flag is set.
   */
                    isRedelivered() {
                        return this._redelivered || false;
                    }
                    /**
   * @param {Boolean} value The redelivered flag
   * @private
   */
                    setRedelivered(value) {
                        this._redelivered = value;
                    }
                    /**
   * Sets the <i>reply</i> field of the message.
   * @param {Boolean} value Sets whether to flag the message as a reply.
   */
                    setAsReplyMessage(value) {
                        this._replyMessage = isBoolean("asReplyMessage", value);
                    }
                    /**
   * Gets the receive timestamp (in milliseconds, from midnight, January 1, 1970 UTC).
   * @returns {?Number} The receive timestamp, if set.
   */
                    getReceiverTimestamp() {
                        return this._receiverTimestamp;
                    }
                    /**
   * Gets the replyTo destination
   * @returns {?solace.Destination} The value of the replyTo destination, if set.
   */
                    getReplyTo() {
                        return this._replyTo;
                    }
                    /**
   * Sets the replyTo destination
   * @param {solace.Destination} value The replyTo destination.
   */
                    setReplyTo(value) {
                        this._replyTo = isInstanceOfOrNothing("replyTo", value, Destination);
                    }
                    /**
   * Returns the Sender's ID.
   * @returns {?String} The Sender's ID, if set.
   */
                    getSenderId() {
                        return this._senderId;
                    }
                    /**
   * Sets the Sender ID for the message
   * @param {String} value The Sender ID for the message.
   */
                    setSenderId(value) {
                        this._senderId = isStringOrNothing("senderId", value);
                    }
                    /**
   * Gets the send timestamp (in milliseconds, from midnight, January 1,
   * 1970 UTC).
   * @returns {?Number} The send timestamp, if set.
   */
                    getSenderTimestamp() {
                        return this._senderTimestamp;
                    }
                    /**
   * Sets the send timestamp (in milliseconds, from midnight, January 1,
   * 1970 UTC). This field can be generated automatically during message
   * publishing, but it will not be generated if previously set to a non-null value by this method.
   * See {@link solace.SessionProperties#generateSendTimestamps}.
   *
   * An application that publishes the same {@link solace.Messsage} multiple times and
   * also wants generted timestamps on each messages, should set the sender timestamp
   * to undefined after each call to {@link solace.Session#send}.
   * @param {?Number} value The value to set as the send timestamp.
   */
                    setSenderTimestamp(value) {
                        this._senderTimestamp = isNumberOrNothing("senderTimestamp", value);
                    }
                    /**
   * Gets the sequence number.
   * <p>
   * This is an application-defined field,
   * see <code>{@link solace.Message#setSequenceNumber}()</code>.
   * @returns {?Number} The sequence number, if set
   * @throws {@link solace.SDTUnsupportedValueError} in case the sequence number is out of range.
   */
                    getSequenceNumber() {
                        if (this._sequenceNumberError) {
                            throw this._sequenceNumberError;
                        }
                        return this._sequenceNumber;
                    }
                    /**
   * Sets the application-defined sequence number. If the sequence number
   * is not set, or set to undefined, and {@link solace.SessionProperties#generateSequenceNumber}
   * is true, then a sequence number is automatically generated for each sent message.
   * @param {?Number} value The sequence number.
   */
                    setSequenceNumber(value) {
                        if (value instanceof SDTUnsupportedValueError) {
                            this._sequenceNumberError = value;
                        } else {
                            this._sequenceNumber = isNumberOrNothing("sequenceNumber", value);
                            this._sequenceNumberError = undefined;
                            //TODO: this is probably wrong. Shouldn't it be cleared if value === undefined?
                            this._autoSequenceNumber = false;
                        }
                    }
                    /**
   * Gets the Class of Service (CoS) value for the message.
   * The Class of Service has different semantics for direct and guaranteed messages.
   *
   * For messages published with {@link solace.MessageDeliveryModeType.DIRECT}, the
   * class of service selects the weighted round-robin delivery queue when the
   * message is forwarded to a consumer.  {@link solace.MessageUserCosType.COS1} are the
   * lowest priority messages and will use the Solace Message Router D-1 delivery queues.
   *
   * For messages published as guaranteed messages
   * ({@link solace.MessageDeliveryModeType.PERSISTENT} or
   * {@link solace.solace.MessageDeliveryModeType.NON_PERSISTENT}), messages published
   * with {@link solace.MessageUserCosType.COS1} can be rejected by the Solace Message Router if
   * that message would cause any queue or topic-endpoint to exceed its configured
   * low-priority-max-msg-count.
   *
   * @returns {solace.MessageUserCosType} The COS value.
   */
                    getUserCos() {
                        return this._userCos;
                    }
                    /**
   * Gets the Message Priority Parameter (JMS Priority) value for the message.
   * Numerical values between 0 and 255 are valid return values,
   * undefined means the parameter is not present.
   *
   * If destination queues and topic endpoints for this message
   * are configured to respect message priority,
   * the values 0 through 9 can be used to affect the priority
   * of delivery to consumers of those queues or topic endpoints.
   * For the purposes of prioritized message delivery,
   * values larger than 9 are treated the same as 9.
   *
   * @returns {Number} The Message Priority Parameter value.
   */
                    getPriority() {
                        return this._priority;
                    }
                    /**
   * Sets the Class of Service (CoS) value for the message.
   *
   * The Class of Service has different semantics for direct and guaranteed messages.
   *
   * For messages published with {@link solace.MessageDeliveryModeType.DIRECT}, the
   * class of service selects the weighted round-robin delivery queue when the
   * message is forwarded to a consumer.  {@link solace.MessageUserCosType#COS1} are the
   * lowest priority messages and will use the Solace Message Router D-1 delivery queues.
   *
   * For messages published as guaranteed messages
   * ({@link solace.MessageDeliveryModeType.PERSISTENT} or
   * {@link solace.solace.MessageDeliveryModeType.NON_PERSISTENT}), messages published
   * with {@link solace.MessageUserCosType#COS1} can be rejected by the Solace Message Router if
   * that message would cause any queue or topic-endpoint to exceed its configured
   * low-priority-max-msg-count.
   *
   * @param {solace.MessageUserCosType} value The COS value.
   * @default {solace.MessageUserCosType#COS1}
   */
                    setUserCos(value) {
                        this._setUserCos(isEnumMember("userCos", value, MessageUserCosType));
                    }
                    _setUserCos(value) {
                        this._userCos = value;
                    }
                    /**
   * Sets the Message Priority Parameter (JMS Priority) value for the message.
   * Numerical values between 0 and 255 are accepted,
   * use undefined to unset.
   *
   * If destination queues and topic endpoints for this message
   * are configured to respect message priority,
   * the values 0 through 9 can be used to affect the priority
   * of delivery to consumers of those queues or topic endpoints.
   * For the purposes of prioritized message delivery, values larger than 9
   * are treated the same as 9.
   *
   * @param {?Number} value The priority value.
   */
                    setPriority(value) {
                        if (value === undefined || value === null) {
                            this._setPriority(undefined);
                            return;
                        }
                        if (typeof value !== "number" || isNaN(value)) {
                            throw new OperationError("Invalid type for message priority", ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                        if (value < 0 || value > 255) {
                            throw new OperationError("Invalid priority value", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                        this._setPriority(value);
                    }
                    _setPriority(value) {
                        this._priority = value;
                    }
                    /**
   * Gets the user data part of the message.
   * @returns {String} The user data part of the message, if set.
   */
                    getUserData() {
                        return this._userData;
                    }
                    /**
   * Sets the user data part of the message.
   * @param {String} value The user data part of the message.
   */
                    setUserData(value) {
                        this._setUserData(isStringOrNothing("userData", value));
                    }
                    _setUserData(value) {
                        this._userData = value;
                    }
                    /**
   * Gets the XML content part of the message.
   * Notice that the content is encoded as UTF-8 characters,
   * it needs to be decoded as JavaScript surrogate pair: decodeURIComponent(escape(value))
   * @returns {?String} The XML content part of the message, if set.
   */
                    getXmlContent() {
                        return this._xmlContent;
                    }
                    /**
   * Gets the XML content part of the message decoded from UTF-8 encoding of the characters.
   * @returns {?String} The XML content part of the message. Returns <code>null</code> if not
   * present.
   */
                    getXmlContentDecoded() {
                        return this._xmlContent ? utf8ToUcs2(this._xmlContent) : this._xmlContent;
                    }
                    /**
   * Sets the XML content part of the message.
   * The content is encoded by replacing each instance of certain characters
   * by one, two, three, or four escape sequences representing the
   * UTF-8 encoding of the character.
   * @param {String} value The XML content part of the message.
   */
                    setXmlContent(value) {
                        const setValue = isStringOrNothing("xmlContent", value);
                        this._xmlContent = setValue ? unescape(encodeURIComponent(setValue)) : setValue;
                    }
                    /**
   * Internal set for the XML content part of the message.
   * @param {String} value The XML content part of the message.
   * @private
   */
                    _setXmlContentInternal(value) {
                        this._xmlContent = isStringOrNothing("xmlContentInternal", value);
                    }
                    /**
   * Sets the message's XML metadata section.
   * @param {String} value The XML metadata.
   */
                    setXmlMetadata(value) {
                        this._setXmlMetadata(isStringOrNothing("xmlMetadata", value));
                    }
                    _setXmlMetadata(value) {
                        this._xmlMetadata = value;
                    }
                    /**
   * Gets the message's XML metadata section.
   * @returns {?String} The XML metadata, if set.
   */
                    getXmlMetadata() {
                        return this._xmlMetadata;
                    }
                    /**
   * @private
   */
                    get binaryMetadataChunk() {
                        return this._binaryMetaChunk || null;
                    }
                    /**
   * @param {?String} meta The meta chunk to set
   * @private
   */
                    set binaryMetadataChunk(meta) {
                        this._binaryMetaChunk = meta;
                    }
                    /**
   * @private
   */
                    get smfHeader() {
                        return this._smfHeader;
                    }
                    /**
   * @param {SMFHeader} val The SMF header to set
   * @private
   */
                    set smfHeader(val) {
                        this._smfHeader = val;
                    }
                    /**
   * @private
   */
                    get hasAutoSequenceNumber() {
                        return this._autoSequenceNumber || false;
                    }
                    /**
   * @param {Boolean} value Value to set
   * @private
   */
                    set hasAutoSequenceNumber(value) {
                        this._autoSequenceNumber = value;
                    }
                    /**
   * @private
   */
                    get hasAutoSenderTimestamp() {
                        return this._autoSenderTimestamp || false;
                    }
                    /**
   * @param {Number} value Value to set
   * @private
   */
                    set hasAutoSenderTimestamp(value) {
                        this._autoSenderTimestamp = value;
                    }
                    /**
   * Gets the user property map carried in the message binary metadata.
   *
   * @returns {?solace.SDTMapContainer} The user properties map, if set.
   */
                    getUserPropertyMap() {
                        return this._userPropertyMap;
                    }
                    /**
   * Allows users to specify their own user properties to be carried
   * in the message binary metadata separate from the payload.
   * @param {?SDTMapContainer} value The user property map.
   */
                    setUserPropertyMap(value) {
                        this._userPropertyMap = isInstanceOfOrNothing("userPropertyMap", value, SDTMapContainer);
                    }
                    /**
   * Makes this message a strutured data message by assigning it a
   * structured data type (SDT) container payload (such as a
   * {@link solace.SDTMapContainer}, {@link solace.SDTStreamContainer}
   * or a {@link solace.SDTFieldType.String}, which is transported in the binary attachment field.
   *
   * Assigning a SDT container updates the message's Type property to
   * the appropriate value.
   *
   * The container argument must be a {@link solace.SDTField} with a type
   * of {@link solace.SDTFieldType.MAP}, {@link solace.SDTFieldType.STREAM},
   * or {@link solace.SDTFieldType.STRING}.
   *
   * @param {?solace.SDTField} container The SDTField container to send in this message.
   */
                    setSdtContainer(container) {
                        const structuredContainer = isInstanceOfOrNothing("sdtContainer", container, SDTField);
                        if (structuredContainer === null || structuredContainer === undefined) {
                            // clear
                            this._structuredContainer = null;
                            this.setBinaryAttachment(null);
                            return;
                        }
                        this._setBinaryAttachment(null);
                        const sdtType = structuredContainer.getType();
                        switch (sdtType) {
                          case SDTFieldType.MAP:
                            this._messageType = MessageType.MAP;
                            break;

                          case SDTFieldType.STREAM:
                            this._messageType = MessageType.STREAM;
                            break;

                          case SDTFieldType.STRING:
                            this._messageType = MessageType.TEXT;
                            break;

                          default:
                            throw new OperationError("Invalid parameter: expected SDTField Type of " + "MAP, STREAM, or STRING.", ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                        this._structuredContainer = structuredContainer;
                    }
                    /**
   * Gets the message's structured data container, if this is a structured data message.
   *
   * @returns {SDTField|null} A field with a payload of {String}, {@link SDTMapContainer},
   * or {@link SDTStreamContainer} if one was set in the message; otherwise, null.
   */
                    getSdtContainer() {
                        const msgType = this.getType();
                        const binaryAttachment = this._binaryAttachment;
                        const binaryAttachmentLength = binaryAttachment ? binaryAttachment.length : 0;
                        if (msgType === MessageType.BINARY) {
                            LOG_DEBUG(`getSdtContainer returned null, reason: msgType=${msgType}`);
                            return null;
                        }
                        // MAP, STREAM or TEXT
                        // Use cached structured container if available
                        if (typeof this._structuredContainer !== "undefined") {
                            return this._structuredContainer;
                        }
                        if (binaryAttachmentLength === 0) {
                            LOG_DEBUG(`getSdtContainer returned null, reason: len=${binaryAttachmentLength}`);
                            this._structuredContainer = null;
                        } else {
                            // Last resort: Decode binary attachment.
                            // Cache structured container for later access
                            this._structuredContainer = SDTCodec.parseSingleElement(binaryAttachment, 0);
                        }
                        return this._structuredContainer;
                    }
                    /**
   * Produces a human-readable dump of the message's properties and
   * contents. Applications must not parse the output, as its format is
   * not a defined part of the API and subject to change.
   *
   * <p>
   * Output can be controlled by the <code>flags</code> parameter. The values are:
   * <ul>
   * <li>{@link MessageDumpFlag.MSGDUMP_BRIEF} Display only the length of the
   *                          binary attachment, xml attachment, and user property map
   * <li>{@link MessageDumpFlag.MSGDUMP_FULL} Display the entire message.
   * </ul>
   * </p>
   *
   * @param {Number} [flags]  Optional flags controlling the output, such as whether
   *                          to include verbose (binary dump) information
   * @returns {String} A string representation of the message.
   */
                    dump(flags = MessageDumpFlag.MSGDUMP_FULL) {
                        const validFlags = isEnumMember("flags", flags, MessageDumpFlag);
                        return MessageDumpUtil.dump(this, validFlags);
                    }
                    /**
   * Clones the message
   * @returns {Message} A clone of this message
   * @private
   */
                    clone() {
                        return clone(this, MESSAGE_CLONE_OPTIONS);
                    }
                    /**
   * Releases all memory associated with this message. All values are reinitialized
   * to defaults. The message is no longer associated with any session or consumer.
   */
                    reset() {
                        clearMessage(this);
                        initMessage(this);
                    }
                }
                module.exports.Message = Message;
                /***/
            },
            /***/ "./modules/solclient-message/lib/replication-group-message-id.js": 
            /*!***********************************************************************!*\
  !*** ./modules/solclient-message/lib/replication-group-message-id.js ***!
  \***********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    Long
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    Parameter
                } = __webpack_require__(/*! solclient-validate */ "./modules/solclient-validate/api.js");
                const {
                    ReplayStartLocation,
                    ReplayStartType
                } = __webpack_require__(/*! solclient-replaystart */ "./modules/solclient-replaystart/api.js");
                // eslint-disable-next-line global-require
                const BufferImpl = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;
                const RMID_VERSION_1_PREFIX = "rmid1:";
                /* prefix length + 3 '-' + 16 bytes of hex (32) */
                const RMID_LEN = RMID_VERSION_1_PREFIX.length + 3 + 16 * 2; // 41
                /* regex for testing if data component of the rmid string parsing is valid */
                const validRmidHexRegex = /^[0-9a-fA-F]{32}$/g;
                const INVALID_SUID = Long.UZERO;
                const {
                    isString,
                    isValue,
                    isInstanceOf
                } = Parameter;
                /**
 * @classdesc
 * <b>This class is not exposed for construction by API users. Users should obtain an instance from
 *  {@link solace.SolclientFactory.createReplicationGroupMessageId} or from
 *  {@link solace.Message.getReplicationGroupMessageId}</b>
 * <p>
 * ReplicationGroupMessageId specifies a Replication Group Message ID.
 * Can be used to specify a {@link solace.ReplayStartLocation} for the message after this id.
 * The ReplayStartLocation is set in the corresponding
 * MessageConsumer property {@link solace.MessageConsumerProperties#replayStartLocation}.
 *
 * @extends solace.ReplayStartLocation
 * @memberof solace
 * @hideconstructor
 */
                class ReplicationGroupMessageId extends ReplayStartLocation {
                    /**
   *@param {Long} spoolerUniqueId spooler id component of rgmid
   *@param {Long} effectiveMessageId message id component of rgmid
   *@private
   */
                    constructor(spoolerUniqueId, effectiveMessageId) {
                        super({
                            _replayStartValue: {
                                suid: spoolerUniqueId,
                                messageId: effectiveMessageId
                            },
                            _type: ReplayStartType.RGMID
                        });
                        /**
     * _suid {Long} spoolerUniqueId component of the replication group message id
     *              this should be unique to the replaication group
     * @private
     */
                        this._suid = spoolerUniqueId;
                        /**
     * _messageId {Long} effectiveMessageId component of the replication group message id
     *              this should be unique to the message in the replication group
     * @private
     */
                        this._messageId = effectiveMessageId;
                    }
                    /**
   * Compares with other ReplicationGroupMessageId
   * @param {ReplicationGroupMessageId} otherReplicationGroupMessageId the other id to compare
   * @returns {Number} 0 if the ReplicationGroupMessageId is equal to the other
   *   ReplicationGroupMessageId.
   *   < 0 if the ReplicationGroupMessageId is less than the other ReplicationGroupMessageId.
   *   \> 0 if the ReplicationGroupMessageId is greater than the other ReplicationGroupMessageId.
   * @throws {solace.OperationError}
   * * if the otherReplicationGroupMessageId is not a ReplicationGroupMessageId type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the otherReplicationGroupMessageId is not comparable as it is from different origins
   *   and can not be compared.
   *   Subcode: {@link solace.ErrorSubcode.MESSAGE_ID_NOT_COMPARABLE}.
   */
                    compare(otherReplicationGroupMessageId) {
                        isInstanceOf("otherReplicationGroupMessageId", otherReplicationGroupMessageId, ReplicationGroupMessageId);
                        const oId = otherReplicationGroupMessageId;
                        if (!this._suid.equals(oId._suid)) {
                            const message = "Unable to compare Replication Group Message ID from different origins";
                            throw new OperationError(`Parameter otherReplicationGroupMessageId[${oId.toString()}] failed validation`, ErrorSubcode.MESSAGE_ID_NOT_COMPARABLE, message);
                        }
                        if (this._messageId.gt(oId._messageId)) {
                            return 1;
                        } else if (this._messageId.lt(oId._messageId)) {
                            return -1;
                        }
                        return 0;
                    }
                    ["inspect"]() {
                        return `[Replication Group Message Id: ${this.toString()}]`;
                    }
                    /**
   * @override
   * @description
   * The ReplicationGroupMessageId toString() method returns a string that can later be passed to
   * {@link solace.SolclientFactory.createReplicationGroupMessageId} to create a
   * ReplicationGroupMessageId object.
   * @returns {String} serialized string of the ReplicationGroupMessageId
   */
                    toString() {
                        const idBuffer = BufferImpl.from(this._suid.toBytesBE().concat(this._messageId.toBytesBE()));
                        const hexString = idBuffer.toString("hex");
                        const sep = "-";
                        return `${RMID_VERSION_1_PREFIX}${hexString.substring(0, 5)}${sep}${hexString.substring(5, 16)}${sep}${hexString.substring(16, 24)}${sep}${hexString.substring(24, 32)}`;
                    }
                }
                /**
 * factory method for creating Replication Group Message Ids
 * @param {Object} spec object specification for building
 * @returns {ReplicationGroupMessageId} id instance for spec.
 * @private
 */
                function createReplicationGroupMessageId(spec) {
                    /* later this can be enhanced for other implementations of rgmids */
                    return new ReplicationGroupMessageId(spec.suid, spec.msgid);
                }
                function fromString(rgmidStr) {
                    /* check parameter type */
                    isString("id", rgmidStr);
                    /* validate rmid string to represent 128 bits of id data
   * must be of format:
   * rmid1:ttttt-rrrrrrrrrrr-mmmmmmmm-llllllll
   *
   * Where:
   *
   * * rmid1: This indicates it is a Replication Group Message ID (allows for some sanity
   *    checking that the bytes to follow are in fact a Replication Group Message ID).
   *    The '1' is a version to differentiate from a new type of Replication Group Message ID
   *    that may be introduced later.
   * * ttttt: Timestamp portion of SUID, 20 bits.
   * * rrrrrrrrrrr: Random portion of SUID, 44 bits.
   * * mmmmmmmm: Most significant 32-bits of ack message ID.
   * * llllllll: Least significant 32-bits of ack message ID.
   */
                    isValue("id", rgmidStr.length, RMID_LEN, ErrorSubcode.PARAMETER_OUT_OF_RANGE, `length expected: ${RMID_LEN} but is ${rgmidStr.length}`);
                    if (!rgmidStr.startsWith(RMID_VERSION_1_PREFIX)) {
                        /* raise invalid format error */
                        throw new OperationError("Parameter id has invalid Replication Group Message ID format", ErrorSubcode.PARAMETER_OUT_OF_RANGE, `id: ${rgmidStr}, does not start with ${RMID_VERSION_1_PREFIX}`);
                    }
                    const rmidBufs = rgmidStr.substring(RMID_VERSION_1_PREFIX.length).split("-");
                    if (rmidBufs.length !== 4 || rmidBufs[0].length !== 5 || rmidBufs[1].length !== 11 || rmidBufs[2].length !== 8 || rmidBufs[3].length !== 8) {
                        /* raise invalid format error */
                        throw new OperationError("Parameter id has invalid Replication Group Message ID format", ErrorSubcode.PARAMETER_OUT_OF_RANGE, `id: ${rgmidStr}, does not have valid separation of components`);
                    }
                    /* convert rmid data string (hex) to bytes
   * note use Buffer to read hex string to bytes as Long.from(str, 16) uses inaccurate
   *  calculation and loses precision, while Buffer.from(str, 'hex') does not.
   * Browser BufferImpl is dependent on parseInt reading the string text 2 characters
   *  at a time letting a hex string chuck of [0-9][notHex], eg '9G', is parsed as a
   *  value 9 not NaN leading to a "valid" read. This means data integrity is lost
   *  on browser buffer parsing of hex. An independent string check is required to avoid this.
   */
                    /* valid rmid component concatenated are hex only string with 32 character length */
                    const rmidHex = rmidBufs.join("").trim();
                    /* validRmidHexRegex uses the global flag and must be reset to advance the global regex
   * lastIndex.
   * reset regex
   */
                    validRmidHexRegex.test("");
                    if (!validRmidHexRegex.test(rmidHex)) {
                        throw new OperationError("Parameter id has invalid Replication Group Message ID format", ErrorSubcode.PARAMETER_OUT_OF_RANGE, `id: ${rgmidStr}, invalid data string value`);
                    }
                    /* convert hex string to bytes */
                    let rmidBuffer;
                    try {
                        rmidBuffer = BufferImpl.from(rmidHex, "hex");
                    } catch (ex) {
                        /* error parsing hex string into buffer */
                        throw new OperationError("Parameter id has invalid Replication Group Message ID format", ErrorSubcode.PARAMETER_OUT_OF_RANGE, `id: ${rgmidStr}, failed to read data, cause: ${ex.message}`);
                    }
                    /* validate read data len is expected for 128 bits of data */
                    const buflen = rmidBuffer ? rmidBuffer.length : 0;
                    if (buflen !== 16) {
                        /* error occured during read */
                        throw new OperationError("Parameter id has invalid Replication Group Message ID format", ErrorSubcode.PARAMETER_OUT_OF_RANGE, `id: ${rgmidStr}, failed to read data from id expected length of 16 got ${buflen}`);
                    }
                    /* extract components into long storage */
                    const suid = Long.fromBits(rmidBuffer.readUInt32BE(4), rmidBuffer.readUInt32BE(0), true);
                    if (suid.eq(INVALID_SUID)) {
                        /* invalid suid detected raise out of range parameter OperationError */
                        throw new OperationError("Parameter id has invalid Replication Group Message ID format", ErrorSubcode.PARAMETER_OUT_OF_RANGE, `id: ${rgmidStr}, has invalid origin`);
                    }
                    const msgid = Long.fromBits(rmidBuffer.readUInt32BE(12), rmidBuffer.readUInt32BE(8), true);
                    /* return created id object with Long values */
                    return createReplicationGroupMessageId({
                        suid: suid,
                        msgid: msgid
                    });
                }
                const RgmidFactory = {};
                RgmidFactory.fromString = fromString;
                RgmidFactory.from = createReplicationGroupMessageId;
                RgmidFactory.INVALID_SUID = INVALID_SUID;
                module.exports.ReplicationGroupMessageId = ReplicationGroupMessageId;
                module.exports.RgmidFactory = RgmidFactory;
                /***/
            },
            /***/ "./modules/solclient-queue/api.js": 
            /*!****************************************!*\
  !*** ./modules/solclient-queue/api.js ***!
  \****************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    AbstractQueueDescriptor
                } = __webpack_require__(/*! ./lib/abstract-queue-descriptor */ "./modules/solclient-queue/lib/abstract-queue-descriptor.js");
                const {
                    QueueAccessType
                } = __webpack_require__(/*! ./lib/queue-access-types */ "./modules/solclient-queue/lib/queue-access-types.js");
                const {
                    QueueDescriptor
                } = __webpack_require__(/*! ./lib/queue-descriptor */ "./modules/solclient-queue/lib/queue-descriptor.js");
                const {
                    QueueDescriptorValidator
                } = __webpack_require__(/*! ./lib/queue-descriptor-validator */ "./modules/solclient-queue/lib/queue-descriptor-validator.js");
                const {
                    QueueDiscardBehavior
                } = __webpack_require__(/*! ./lib/queue-discard-behaviors */ "./modules/solclient-queue/lib/queue-discard-behaviors.js");
                const {
                    QueuePermissions
                } = __webpack_require__(/*! ./lib/queue-permissions */ "./modules/solclient-queue/lib/queue-permissions.js");
                const {
                    QueueProperties
                } = __webpack_require__(/*! ./lib/queue-properties */ "./modules/solclient-queue/lib/queue-properties.js");
                const {
                    QueuePropertiesValidator
                } = __webpack_require__(/*! ./lib/queue-properties-validator */ "./modules/solclient-queue/lib/queue-properties-validator.js");
                const {
                    QueueType
                } = __webpack_require__(/*! ./lib/queue-types */ "./modules/solclient-queue/lib/queue-types.js");
                module.exports.AbstractQueueDescriptor = AbstractQueueDescriptor;
                module.exports.QueueAccessType = QueueAccessType;
                module.exports.QueueDescriptor = QueueDescriptor;
                module.exports.QueueDescriptorValidator = QueueDescriptorValidator;
                module.exports.QueueDiscardBehavior = QueueDiscardBehavior;
                module.exports.QueuePermissions = QueuePermissions;
                module.exports.QueueProperties = QueueProperties;
                module.exports.QueuePropertiesValidator = QueuePropertiesValidator;
                module.exports.QueueType = QueueType;
                /***/
            },
            /***/ "./modules/solclient-queue/lib/abstract-queue-descriptor.js": 
            /*!******************************************************************!*\
  !*** ./modules/solclient-queue/lib/abstract-queue-descriptor.js ***!
  \******************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    APIProperties
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const {
                    DestinationType
                } = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                const {
                    OperationError,
                    ErrorSubcode
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    QueueType
                } = __webpack_require__(/*! ./queue-types */ "./modules/solclient-queue/lib/queue-types.js");
                const DEFAULTS = {
                    durable: true,
                    type: undefined
                };
                const TYPE_DESCRIPTION = {
                    [QueueType.QUEUE]: "queue",
                    [QueueType.TOPIC_ENDPOINT]: "topic endpoint"
                };
                const DESINATION_TYPE_TO_DESCRIPTOR_TYPE = {
                    [DestinationType.TOPIC]: null,
                    [DestinationType.QUEUE]: QueueType.QUEUE,
                    [DestinationType.TEMPORARY_QUEUE]: QueueType.QUEUE
                };
                function maybeAdaptFromDestination(spec) {
                    if (spec && spec.name && spec.type && DestinationType.values.includes(spec.type)) {
                        const targetType = DESINATION_TYPE_TO_DESCRIPTOR_TYPE[spec.type];
                        if (!targetType) {
                            throw new OperationError(`Cannot create a descriptor from a ${DestinationType.describe(spec.type)} destination`, ErrorSubcode.PARAMETER_CONFLICT);
                        }
                        return {
                            name: spec.name,
                            type: QueueType.QUEUE,
                            durable: spec.type !== DestinationType.TEMPORARY_QUEUE
                        };
                    }
                    return spec;
                }
                /**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 * <p>
 * This is a base class for {@link solace.QueueDescriptor}. API users should access the
 * methods described here through a {@link solace.QueueDescriptor}.
 * @memberof solace
 * @hideconstructor
 */
                class AbstractQueueDescriptor extends APIProperties {
                    /*
   * @param {Object|solace.AbstractQueueDescriptor} queueSpec A specification for this descriptor.
   * @param {solace.QueueType} queueSpec.type The type of queue for this specification.
   * @param {Boolean} [queueSpec.durable=true] Whether this spec refers to a durable queue.
   * @constructor
   */
                    constructor(queueSpec) {
                        // eslint-disable-line no-useless-constructor
                        super(DEFAULTS, maybeAdaptFromDestination(queueSpec));
                    }
                    /**
   * Gets the queue type to which this descriptor refers.
   * @returns {solace.QueueType} The queue type that this object describes
   */
                    getType() {
                        return this._type;
                    }
                    /**
   * @type {solace.QueueType}
   * @description The Queue Type.
   */
                    get type() {
                        return this.getType();
                    }
                    set type(value) {
                        this._type = value;
                    }
                    /**
   * Gets whether this descriptor refers to a durable queue.
   *
   * @returns {Boolean} `true` if this describes a durable queue
   */
                    isDurable() {
                        // eslint-disable-line class-methods-use-this
                        return this._durable;
                    }
                    /**
   * @type {Boolean}
   * @description True if this descriptor refers to a durable queue.
   */
                    get durable() {
                        return this.isDurable();
                    }
                    set durable(value) {
                        this._durable = value;
                    }
                    ["inspect"]() {
                        return {
                            type: this.type,
                            durable: this.durable
                        };
                    }
                    /**
   * An informational summary of this object, subject to change.
   * @returns {String} A summary of this object.
   */
                    toString() {
                        return `${!this.isDurable() ? "non" : ""}-durable ` + `${TYPE_DESCRIPTION[this.getType()]}`;
                    }
                }
                module.exports.AbstractQueueDescriptor = AbstractQueueDescriptor;
                /***/
            },
            /***/ "./modules/solclient-queue/lib/queue-access-types.js": 
            /*!***********************************************************!*\
  !*** ./modules/solclient-queue/lib/queue-access-types.js ***!
  \***********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Represents the possible endpoint access types. The corresponding endpoint property is
 * {@link solace.QueueProperties#accessType}.
 *
 * @enum {string}
 * @namespace
 * @memberof solace
 */
                const QueueAccessType = {
                    /**
   * @description An exclusive endpoint. The first client to bind
   * receives the stored messages on the Endpoint.
   * @type {String}
   */
                    EXCLUSIVE: "EXCLUSIVE",
                    /**
   * @description A non-exclusive (shared) Queue. Each client to bind
   * receives messages in a round robin fashion.
   * @type {String}
   */
                    NONEXCLUSIVE: "NONEXCLUSIVE"
                };
                module.exports.QueueAccessType = Enum.new(QueueAccessType);
                /***/
            },
            /***/ "./modules/solclient-queue/lib/queue-descriptor-validator.js": 
            /*!*******************************************************************!*\
  !*** ./modules/solclient-queue/lib/queue-descriptor-validator.js ***!
  \*******************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    APIPropertiesValidators
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const {
                    QueueDescriptor
                } = __webpack_require__(/*! ./queue-descriptor */ "./modules/solclient-queue/lib/queue-descriptor.js");
                const {
                    QueueType
                } = __webpack_require__(/*! ./queue-types */ "./modules/solclient-queue/lib/queue-types.js");
                const {
                    validateInstance,
                    valBoolean,
                    valIsMember,
                    valTopicString
                } = APIPropertiesValidators;
                const QueueDescriptorValidator = {
                    validate(instance) {
                        const v = validateInstance.bind(null, "QueueDescriptor", instance);
                        if (instance instanceof QueueDescriptor) {
                            v("name", [ valTopicString ]);
                        } // else is abstract; don't check name
                        v("type", [ valIsMember, QueueType, "QueueType" ]);
                        v("durable", [ valBoolean ]);
                    }
                };
                module.exports.QueueDescriptorValidator = QueueDescriptorValidator;
                /***/
            },
            /***/ "./modules/solclient-queue/lib/queue-descriptor.js": 
            /*!*********************************************************!*\
  !*** ./modules/solclient-queue/lib/queue-descriptor.js ***!
  \*********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    AbstractQueueDescriptor
                } = __webpack_require__(/*! ./abstract-queue-descriptor */ "./modules/solclient-queue/lib/abstract-queue-descriptor.js");
                const {
                    Destination
                } = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                const DEFAULTS = {
                    name: undefined,
                    durable: true
                };
                /**
 * This class identifies a queue or topic endpoint on the message router.
 *
 * Operations that make use of queue descriptors include
 *  * {@link solace.Session#createMessageConsumer}
 *  * {@link solace.Session#dteUnsubscribe}
 *
 * @classdesc QueueDescriptor
 * @extends {AbstractQueueDescriptor}
 * @memberof solace
 */
                class QueueDescriptor extends AbstractQueueDescriptor {
                    /**
   * Creates an instance of {@link solace.QueueDescriptor}.
   *
   * @param {Object|solace.QueueDescriptor} queueSpec A specification for this descriptor.
   * @param {String} queueSpec.name The remote name to which this specification refers.
   * @param {solace.QueueType} queueSpec.type The type of queue for this specification.
   * @param {Boolean} [queueSpec.durable=true] `true` if this refers to a durable queue.
   */
                    constructor(queueSpec) {
                        super(queueSpec instanceof Destination ? {
                            name: queueSpec.name,
                            type: queueSpec.type
                        } : Object.assign({}, DEFAULTS, queueSpec));
                    }
                    /**
   * Gets/sets the remote name to which this descriptor refers.
   * @returns {String} The name of the queue.
   */
                    getName() {
                        return this._name;
                    }
                    get name() {
                        return this.getName();
                    }
                    set name(value) {
                        this._name = value;
                    }
                    ["inspect"]() {
                        return {
                            name: this.name,
                            type: this.type,
                            durable: this.durable
                        };
                    }
                    /**
   * An informational summary of this object, subject to change.
   * @returns {String} A summary of this object.
   */
                    toString() {
                        return `${super.toString()} '${this.getName()}'`;
                    }
                    /**
   * @static
   * @param {any} spec The descriptor spec
   * @returns {QueueDescriptor|AbstractQueueDescriptor} A new descriptor for the spec
   * @private
   */
                    static createFromSpec(spec) {
                        if (spec.name) return new QueueDescriptor(spec);
                        return AbstractQueueDescriptor(spec);
                    }
                }
                module.exports.QueueDescriptor = QueueDescriptor;
                /***/
            },
            /***/ "./modules/solclient-queue/lib/queue-discard-behaviors.js": 
            /*!****************************************************************!*\
  !*** ./modules/solclient-queue/lib/queue-discard-behaviors.js ***!
  \****************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Enumerates the behavior options when a message cannot be added to an endpoint
 * (for example, the maximum quota {@link solace.QueueProperties#quotaMB} was exceeded).
 *
 * @enum {string}
 * @namespace
 * @memberof solace
 */
                const QueueDiscardBehavior = {
                    /**
   * @description Send the publisher a message reject notification.
   * @type {String}
   */
                    NOTIFY_SENDER_ON: "NOTIFY_SENDER_ON",
                    /**
   * @description Discard the message and acknowledge it.
   * @type {String}
   */
                    NOTIFY_SENDER_OFF: "NOTIFY_SENDER_OFF"
                };
                module.exports.QueueDiscardBehavior = Enum.new(QueueDiscardBehavior);
                /***/
            },
            /***/ "./modules/solclient-queue/lib/queue-permissions.js": 
            /*!**********************************************************!*\
  !*** ./modules/solclient-queue/lib/queue-permissions.js ***!
  \**********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Represents the permissions applicable to a queue.
 *
 * The corresponding endpoint property is
 * {@link solace.QueueProperties#permissions}.
 *
 * The access controls:
 *  * the permissions for all other users of the queue, this only applies to
 *  non-durable queues {@link solace.QueueProperties#permissions};
 *  * for the current Message Consumer  on a queue or endpoint,
 *    {@link solace.MessageConsumer.permissions}
 *
 * For example, creating a temporary topic endpoint with MODIFY_TOPIC will allow
 * other users to modify the topic subscribed to that endpoint.
 *
 * @enum {string}
 * @namespace
 * @memberof solace
 */
                const QueuePermissions = {
                    /**
   * @description No client other than the queue's owner may access the endpoint.
   */
                    NONE: "NONE",
                    /**
   * @description Client may read messages but not consume them.
   * @type {String}
   */
                    READ_ONLY: "READ_ONLY",
                    /**
   * @description  Client may read and consume messages.
   * @type {String}
   */
                    CONSUME: "CONSUME",
                    /**
   * @description Client may read and consume messages, and modify topic(s) associated with the
   * queue.
   * @type {String}
   */
                    MODIFY_TOPIC: "MODIFY_TOPIC",
                    /**
   * @description Client may read and consume messages, modify topic(s) associated with the
   * queue, and delete the queue.
   * @type {String}
   */
                    DELETE: "DELETE"
                };
                module.exports.QueuePermissions = Enum.new(QueuePermissions);
                /***/
            },
            /***/ "./modules/solclient-queue/lib/queue-properties-validator.js": 
            /*!*******************************************************************!*\
  !*** ./modules/solclient-queue/lib/queue-properties-validator.js ***!
  \*******************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    APIPropertiesValidators
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const {
                    QueueAccessType
                } = __webpack_require__(/*! ./queue-access-types */ "./modules/solclient-queue/lib/queue-access-types.js");
                const {
                    QueueDiscardBehavior
                } = __webpack_require__(/*! ./queue-discard-behaviors */ "./modules/solclient-queue/lib/queue-discard-behaviors.js");
                const {
                    QueuePermissions
                } = __webpack_require__(/*! ./queue-permissions */ "./modules/solclient-queue/lib/queue-permissions.js");
                const {
                    validateInstance,
                    valBoolean,
                    valIsMember,
                    valNumber,
                    valRange
                } = APIPropertiesValidators;
                const QueuePropertiesValidator = {
                    validate(instance) {
                        const v = validateInstance.bind(null, "QueueProperties", instance);
                        if (instance.permissions !== undefined && instance.permissions !== null) {
                            v("permissions", [ valIsMember, QueuePermissions, "QueuePermissions" ]);
                        }
                        if (instance.accessType !== undefined && instance.accessType !== null) {
                            v("accessType", [ valIsMember, QueueAccessType, "QueueAccessType" ]);
                        }
                        if (instance.quotaMB !== undefined && instance.quotaMB !== null) {
                            v("quotaMB", [ valNumber ], [ valRange, 0, Number.POSITIVE_INFINITY ]);
                        }
                        if (instance.maxMessageSize !== undefined && instance.maxMessageSize !== null) {
                            v("maxMessageSize", [ valNumber ], [ valRange, 0, Number.POSITIVE_INFINITY ]);
                        }
                        if (instance.respectsTTL !== undefined && instance.respectsTTL !== null) {
                            v("respectsTTL", [ valBoolean ]);
                        }
                        if (instance.discardBehavior !== undefined && instance.discardBehavior !== null) {
                            v("discardBehavior", [ valIsMember, QueueDiscardBehavior, "QueueDiscardBehavior" ]);
                        }
                        if (instance.maxMessageRedelivery !== undefined && instance.maxMessageRedelivery !== null) {
                            v("maxMessageRedelivery", [ valNumber ], [ valRange, 0, 255 ]);
                        }
                    }
                };
                module.exports.QueuePropertiesValidator = QueuePropertiesValidator;
                /***/
            },
            /***/ "./modules/solclient-queue/lib/queue-properties.js": 
            /*!*********************************************************!*\
  !*** ./modules/solclient-queue/lib/queue-properties.js ***!
  \*********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /* provided dependency */ var util_inspect = __webpack_require__(/*! browser-util-inspect */ "./node_modules/browser-util-inspect/index.js");
                const {
                    APIProperties
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const {
                    QueueAccessType
                } = __webpack_require__(/*! ./queue-access-types */ "./modules/solclient-queue/lib/queue-access-types.js");
                const {
                    QueueDiscardBehavior
                } = __webpack_require__(/*! ./queue-discard-behaviors */ "./modules/solclient-queue/lib/queue-discard-behaviors.js");
                const {
                    QueuePermissions
                } = __webpack_require__(/*! ./queue-permissions */ "./modules/solclient-queue/lib/queue-permissions.js");
                const DEFAULTS = {
                    permissions: undefined,
                    accessType: undefined,
                    quotaMB: undefined,
                    maxMessageSize: undefined,
                    respectsTTL: undefined,
                    discardBehavior: undefined,
                    maxMessageRedelivery: undefined
                };
                /**
 * @classdesc
 * Represents a queue properties object. May be passed in to
 * {@link solace.Session#createMessageConsumer} when creating a
 * {@link solace.MessageConsumer} object.  Upon creation of a queue, undefined queue
 * properties are set to default values chosen by the router.
 *
 * @memberof solace
 */
                class QueueProperties extends APIProperties {
                    constructor(options) {
                        super(DEFAULTS, options);
                    }
                    /**
   * Gets/sets permissions for this queue.
   *
   * When creating a temporary queue, these are the permissions that apply
   * to all other users; the user creating the temporary queue is always
   * granted DELETE permissions.
   *
   * @type {solace.QueuePermissions}
   * @default undefined
   */
                    get permissions() {
                        return this._permissions;
                    }
                    set permissions(newValue) {
                        this._permissions = newValue;
                    }
                    /**
   * Gets/sets the access type for this queue.
   *
   * This parameter must NOT be set when creating a temporary queue via
   * {@link solace.Session#createMessageConsumer}. Such a queue has its
   * access type determined by the remote message router.
   *
   * @type {solace.QueueAccessType}
   * @default undefined
   */
                    get accessType() {
                        return this._accessType || DEFAULTS.accessType;
                    }
                    set accessType(newValue) {
                        this._accessType = newValue;
                    }
                    /**
   * Gets/sets the quota, in megabytes, for this queue.
   *  * The allowed values are (0 <= quotaMB) || undefined.
   *  * A value of 0 configures the queue to act as a Last-Value-Queue (LVQ), where the router
   *    enforces a Queue depth of one, and only the most current message is spooled by the
   *    queue. When a new message is received, the current queued message is first
   *    automatically deleted from the queue, then the new message is spooled.
   * @type {?Number}
   * @default undefined
   */
                    get quotaMB() {
                        return this._quotaMB;
                    }
                    set quotaMB(newValue) {
                        this._quotaMB = newValue;
                    }
                    /**
   * Gets/sets the maximum message size, in bytes, for any single message spooled on this queue.
   * @type {Number}
   * @default undefined
   */
                    get maxMessageSize() {
                        return this._maxMessageSize;
                    }
                    set maxMessageSize(newValue) {
                        this._maxMessageSize = newValue;
                    }
                    /**
   * Gets/sets whether this queue respects Time To Live on messages.
   * @type {Boolean}
   * @default false
   */
                    get respectsTTL() {
                        return this._respectsTTL;
                    }
                    set respectsTTL(newValue) {
                        this._respectsTTL = newValue;
                    }
                    /**
   * Gets/sets the discard behavior for this queue.
   * @type {solace.QueueDiscardBehavior}
   * @default {solace.QueueDiscardBehavior.NOTIFY_SENDER_OFF}
   */
                    get discardBehavior() {
                        return this._discardBehavior;
                    }
                    set discardBehavior(newValue) {
                        this._discardBehavior = newValue;
                    }
                    /**
   * Gets/sets the maximum number of times to attempt message redelivery for this queue.
   *  * The valid range is 0 <= maxMessageRedelivery <= 255
   *  * A value of 0 means retry forever.
   * @type {Number}
   * @default undefined
   */
                    get maxMessageRedelivery() {
                        return this._maxMessageRedelivery;
                    }
                    set maxMessageRedelivery(newValue) {
                        this._maxMessageRedelivery = newValue;
                    }
                    ["inspect"]() {
                        return {
                            permissions: QueuePermissions.describe(this.permissions),
                            accessType: QueueAccessType.describe(this.accessType),
                            quotaMB: this.quotaMB,
                            maxMessageSize: this.maxMessageSize,
                            respectsTTL: this.respectsTTL,
                            discardBehavior: this.discardBehavior ? QueueDiscardBehavior.describe(this.discardBehavior) : "undefined",
                            maxMessageRedelivery: this.maxMessageRedelivery
                        };
                    }
                    toString() {
                        return util_inspect(this);
                    }
                }
                module.exports.QueueProperties = QueueProperties;
                /***/
            },
            /***/ "./modules/solclient-queue/lib/queue-types.js": 
            /*!****************************************************!*\
  !*** ./modules/solclient-queue/lib/queue-types.js ***!
  \****************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Specifies the type of remote resource to which an
 * {@link solace.AbstractQueueDescriptor} refers.
 *
 * @enum {string}
 * @namespace
 * @memberof solace
 */
                const QueueType = {
                    /**
   * @description The queue descriptor refers to a queue endpoint.
   * @type {String}
   */
                    QUEUE: "QUEUE",
                    /**
   * @description The queue descriptor refers to a topic endpoint.
   * @type {String}
   */
                    TOPIC_ENDPOINT: "TOPIC_ENDPOINT"
                };
                module.exports.QueueType = Enum.new(QueueType);
                /***/
            },
            /***/ "./modules/solclient-replaystart/api.js": 
            /*!**********************************************!*\
  !*** ./modules/solclient-replaystart/api.js ***!
  \**********************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Parameter
                } = __webpack_require__(/*! solclient-validate */ "./modules/solclient-validate/api.js");
                const {
                    ReplayStartLocation,
                    ReplayStartType
                } = __webpack_require__(/*! ./lib/replayStartLocation */ "./modules/solclient-replaystart/lib/replayStartLocation.js");
                const {
                    ReplayStartLocationBeginning
                } = __webpack_require__(/*! ./lib/replayStartLocationBeginning */ "./modules/solclient-replaystart/lib/replayStartLocationBeginning.js");
                const {
                    ReplayStartLocationDate
                } = __webpack_require__(/*! ./lib/replayStartLocationDate */ "./modules/solclient-replaystart/lib/replayStartLocationDate.js");
                const {
                    SolclientFactory
                } = __webpack_require__(/*! solclient-factory */ "./modules/solclient-factory/api.js");
                module.exports.ReplayStartLocation = ReplayStartLocation;
                module.exports.ReplayStartLocationBeginning = ReplayStartLocationBeginning;
                module.exports.ReplayStartLocationDate = ReplayStartLocationDate;
                module.exports.ReplayStartType = ReplayStartType;
                /**
 * Creates a ReplayStartLocation {@link solace.ReplayStartLocation} instance that
 * when set in MessageConsumerProperties indicates that all messages available
 * in the replay log should be retrieved.
 *
 *
 * @returns {solace.ReplayStartLocation} The newly created ReplayStartLocation
 * @method
 * @name solace.SolclientFactory.createReplayStartLocationBeginning
 */
                SolclientFactory.createReplayStartLocationBeginning = SolclientFactory.createFactory(() => new ReplayStartLocationBeginning());
                /**
 * Creates a ReplayStartLocation {@link solace.ReplayStartLocation} instance that
 * when set in MessageConsumerProperties indicates that only messages spooled
 * in the replay log since the given Date should be retrieved.
 *
 * @param {Date} dateTime The Date object the represents the date and time of the replay
 * start location.  dateTime is always converted to UTC time if not already a UTC time.
 * @returns {solace.ReplayStartLocation} The newly created ReplayStartLocation
 * @method
 * @name solace.SolclientFactory.createReplayStartLocationDate
 */
                SolclientFactory.createReplayStartLocationDate = SolclientFactory.createFactory(dateTime => ReplayStartLocationDate.createReplayStartLocationDate(Parameter.isInstanceOf("date", dateTime, Date)));
                /***/
            },
            /***/ "./modules/solclient-replaystart/lib/replayStartLocation.js": 
            /*!******************************************************************!*\
  !*** ./modules/solclient-replaystart/lib/replayStartLocation.js ***!
  \******************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /* provided dependency */ var util_inspect = __webpack_require__(/*! browser-util-inspect */ "./node_modules/browser-util-inspect/index.js");
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Enumeration for smf replay start location value type
 *@private
 */
                const ReplayStartType = Enum.new({
                    // the value of the Enum is the value of the smf type
                    BEGINNING: 0,
                    DATE: 1,
                    RGMID: 2
                });
                /**
 * @classdesc
 *  * <b>This class is not exposed for construction by API users.
 *  Users should obtain an instances from one of the following:</b>
 * * {@link solace.SolclientFactory.createReplayStartLocationBeginning}
 * * {@link solace.SolclientFactory.createReplayStartLocationDate}
 *
 * Defines the ReplayStartLocation class.
 * The ReplayStartLocation is set in the corresponding
 * MessageConsumer property {@link solace.MessageConsumerProperties#replayStartLocation}
 * The single member variable, _replayStartTime is undefined in ReplayStartLocationBeginning and
 * contains the elapsed time in milliseconds since the epoch in ReplayStartLocationDate
 *
 * @hideconstructor
 * @memberof solace
 */
                class ReplayStartLocation {
                    /**
   * @constructor
   * @param {SObject} spec The ReplayStartLocation spec
   * Use the factory methods on {@link solace.SolclientFactory}.
   * @private
   */
                    constructor(spec) {
                        Object.assign(this, spec);
                        if (this._type === undefined) {
                            // use default replay start location type when not specified
                            this._type = ReplayStartType.BEGINNING;
                        }
                    }
                    /**
   * @returns {String} A generic description of the Destination.
   */
                    toString() {
                        return util_inspect(this);
                    }
                }
                module.exports.ReplayStartLocation = ReplayStartLocation;
                module.exports.ReplayStartType = ReplayStartType;
                /***/
            },
            /***/ "./modules/solclient-replaystart/lib/replayStartLocationBeginning.js": 
            /*!***************************************************************************!*\
  !*** ./modules/solclient-replaystart/lib/replayStartLocationBeginning.js ***!
  \***************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ReplayStartLocation,
                    ReplayStartType
                } = __webpack_require__(/*! ./replayStartLocation */ "./modules/solclient-replaystart/lib/replayStartLocation.js");
                /**
 * @classdesc
 *  * <b>This class is not exposed for construction by API users.
 *  Users should obtain an instances from the following:</b>
 *  * {@link solace.SolclientFactory.createReplayStartLocationBeginning}
 *
 * Defines the ReplayStartLocation class.
 * The ReplayStartLocation is set in the corresponding
 * MessageConsumer property {@link solace.MessageConsumerProperties#replayStartLocation}
 *
 * @extends {ReplayStartLocation}
 * @hideconstructor
 * @memberof solace
 */
                class ReplayStartLocationBeginning extends ReplayStartLocation {
                    /**
   * @private
   */
                    constructor() {
                        super({
                            _type: ReplayStartType.BEGINNING
                        });
                    }
                    static ["inspect"]() {
                        return "BEGINNING";
                    }
                }
                module.exports.ReplayStartLocationBeginning = ReplayStartLocationBeginning;
                /***/
            },
            /***/ "./modules/solclient-replaystart/lib/replayStartLocationDate.js": 
            /*!**********************************************************************!*\
  !*** ./modules/solclient-replaystart/lib/replayStartLocationDate.js ***!
  \**********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ReplayStartLocation,
                    ReplayStartType
                } = __webpack_require__(/*! ./replayStartLocation */ "./modules/solclient-replaystart/lib/replayStartLocation.js");
                /**
 * @classdesc
 *  * <b>This class is not exposed for construction by API users.
 *  Users should obtain an instances from the following:</b>
 *  * {@link solace.SolclientFactory.createReplayStartLocationDate}
 *
 * Defines the ReplayStartLocation class.
 * The ReplayStartLocation is set in the corresponding
 * MessageConsumer property {@link solace.MessageConsumerProperties#replayStartLocation}
 *
 * @extends ReplayStartLocation
 * @hideconstructor
 * @memberof solace
 */
                class ReplayStartLocationDate extends ReplayStartLocation {
                    /**
   * @param {Object} spec The topic spec
   * @private
   */
                    constructor(spec) {
                        super({
                            _replayStartValue: spec.getTime(),
                            _type: ReplayStartType.DATE
                        });
                    }
                    ["inspect"]() {
                        return `[Epoch Time: ${this._replayStartValue}]`;
                    }
                    /**
   * @static
   * @param {Date} dateTime The Date for the replay start location
   * @returns {ReplayStartLocation} the ReplayStartLocation
   * @private
   */
                    static createReplayStartLocationDate(dateTime) {
                        return new ReplayStartLocationDate(dateTime);
                    }
                }
                module.exports.ReplayStartLocationDate = ReplayStartLocationDate;
                /***/
            },
            /***/ "./modules/solclient-sdt/api.js": 
            /*!**************************************!*\
  !*** ./modules/solclient-sdt/api.js ***!
  \**************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Codec
                } = __webpack_require__(/*! ./lib/codec */ "./modules/solclient-sdt/lib/codec/api.js");
                const {
                    SDTDestType
                } = __webpack_require__(/*! ./lib/sdt-destination-types */ "./modules/solclient-sdt/lib/sdt-destination-types.js");
                const {
                    SDTField
                } = __webpack_require__(/*! ./lib/sdt-field */ "./modules/solclient-sdt/lib/sdt-field.js");
                const {
                    SDTFieldType
                } = __webpack_require__(/*! ./lib/sdt-field-types */ "./modules/solclient-sdt/lib/sdt-field-types.js");
                const {
                    SDTMapContainer
                } = __webpack_require__(/*! ./lib/sdt-map-container */ "./modules/solclient-sdt/lib/sdt-map-container.js");
                const {
                    SDTStreamContainer
                } = __webpack_require__(/*! ./lib/sdt-stream-container */ "./modules/solclient-sdt/lib/sdt-stream-container.js");
                const {
                    SDTUnsupportedValueError
                } = __webpack_require__(/*! ./lib/sdt-unsupported-value-error */ "./modules/solclient-sdt/lib/sdt-unsupported-value-error.js");
                const {
                    SDTValueErrorSubcode
                } = __webpack_require__(/*! ./lib/sdt-value-error-subcodes */ "./modules/solclient-sdt/lib/sdt-value-error-subcodes.js");
                module.exports.Codec = Codec;
                module.exports.SDTDestType = SDTDestType;
                module.exports.SDTField = SDTField;
                module.exports.SDTFieldType = SDTFieldType;
                module.exports.SDTMapContainer = SDTMapContainer;
                module.exports.SDTStreamContainer = SDTStreamContainer;
                module.exports.SDTUnsupportedValueError = SDTUnsupportedValueError;
                module.exports.SDTValueErrorSubcode = SDTValueErrorSubcode;
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/codec/api.js": 
            /*!************************************************!*\
  !*** ./modules/solclient-sdt/lib/codec/api.js ***!
  \************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    EncodeSingleElement
                } = __webpack_require__(/*! ./encode-single-element */ "./modules/solclient-sdt/lib/codec/encode-single-element.js");
                const {
                    IEEE754LIB
                } = __webpack_require__(/*! ./ieee754lib */ "./modules/solclient-sdt/lib/codec/ieee754lib.js");
                const {
                    ParseSingleElement,
                    StringToBuffer
                } = __webpack_require__(/*! ./parse-single-element */ "./modules/solclient-sdt/lib/codec/parse-single-element.js");
                const {
                    encodeSingleElement
                } = EncodeSingleElement;
                const {
                    parseSingleElement
                } = ParseSingleElement;
                const {
                    stringToBuffer
                } = StringToBuffer;
                const Codec = {
                    encodeSingleElement: encodeSingleElement,
                    parseSingleElement: parseSingleElement,
                    stringToBuffer: stringToBuffer,
                    IEEE754LIB: IEEE754LIB
                };
                module.exports.Codec = Codec;
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/codec/encode-header.js": 
            /*!**********************************************************!*\
  !*** ./modules/solclient-sdt/lib/codec/encode-header.js ***!
  \**********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Convert
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    SDTDataTypes
                } = __webpack_require__(/*! ../sdt-data-types */ "./modules/solclient-sdt/lib/sdt-data-types.js");
                const EncodeHeader = {};
                EncodeHeader.encodeHeader = function encodeHeader(tag, valueLen) {
                    // Tag in first 6 bits, then (lenbytes-1) in 2 bits
                    let byte0 = tag << 2 & 255;
                    let strSdtLen = null;
                    if (tag === SDTDataTypes.Map || tag === SDTDataTypes.Stream) {
                        // force 4 bytes
                        strSdtLen = Convert.int32ToStr(valueLen + 5);
                        byte0 |= 3; // 4 length bytes
                    } else if (valueLen + 2 <= 255) {
                        strSdtLen = Convert.int8ToStr(valueLen + 2);
                        byte0 |= 0; // 1 length byte
                    } else if (valueLen + 3 <= 65535) {
                        strSdtLen = Convert.int16ToStr(valueLen + 3);
                        byte0 |= 1; // 2 length bytes
                    } else {
                        strSdtLen = Convert.int32ToStr(valueLen + 5);
                        byte0 |= 3; // 4 length bytes
                    }
                    const ret = Convert.int8ToStr(byte0) + strSdtLen;
                    return ret;
                };
                module.exports.EncodeHeader = EncodeHeader;
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/codec/encode-integer.js": 
            /*!***********************************************************!*\
  !*** ./modules/solclient-sdt/lib/codec/encode-integer.js ***!
  \***********************************************************/
            /***/ module => {
                const EncodeInteger = {};
                EncodeInteger.int48ToStr = function int48ToStr(vIn) {
                    let v = vIn;
                    const bytes = [];
                    for (let i = 0; i < 6; i++) {
                        const byteI = v % 256;
                        v = Math.floor(v / 256);
                        bytes.push(String.fromCharCode(byteI));
                    }
                    bytes.reverse();
                    return bytes.join("");
                };
                module.exports.EncodeInteger = EncodeInteger;
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/codec/encode-map.js": 
            /*!*******************************************************!*\
  !*** ./modules/solclient-sdt/lib/codec/encode-map.js ***!
  \*******************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const EncodeSingleElementLib = __webpack_require__(/*! ./encode-single-element */ "./modules/solclient-sdt/lib/codec/encode-single-element.js");
                const UtilLib = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const {
                    EncodeHeader
                } = __webpack_require__(/*! ./encode-header */ "./modules/solclient-sdt/lib/codec/encode-header.js");
                const {
                    SDTDataTypes
                } = __webpack_require__(/*! ../sdt-data-types */ "./modules/solclient-sdt/lib/sdt-data-types.js");
                const {
                    SDTMapContainer
                } = __webpack_require__(/*! ../sdt-map-container */ "./modules/solclient-sdt/lib/sdt-map-container.js");
                const {
                    encodeHeader
                } = EncodeHeader;
                const EncodeMap = {
                    /**
   * Encodes an SDT map.
   * @param  {Object} sdtmap The map to parse
   * @returns {String}        The map in binary string format
   */
                    encodeMap(sdtmap) {
                        const buf = [];
                        if (!(sdtmap instanceof SDTMapContainer)) {
                            return null; // skip!
                        }
                        const keys = sdtmap.getKeys();
                        let sdtfield = null;
                        let strKeyField = null;
                        let strKeyName = null;
                        let i;
                        for (i = 0; i < keys.length; i++) {
                            sdtfield = sdtmap.getField(keys[i]);
                            if (sdtfield) {
                                // === KEY ===
                                strKeyName = UtilLib.StringUtils.nullTerminate(keys[i]);
                                strKeyField = encodeHeader(SDTDataTypes.String, strKeyName.length);
                                strKeyField += strKeyName;
                                buf.push(strKeyField);
                                // === VALUE ===
                                EncodeSingleElementLib.EncodeSingleElement.encodeSingleElementToBuf(sdtfield, buf);
                            }
                        } // end iter over keys
                        return buf.join("");
                    }
                };
                module.exports.EncodeMap = EncodeMap;
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/codec/encode-single-element.js": 
            /*!******************************************************************!*\
  !*** ./modules/solclient-sdt/lib/codec/encode-single-element.js ***!
  \******************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const DestinationLib = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                const {
                    Convert
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    EncodeHeader
                } = __webpack_require__(/*! ./encode-header */ "./modules/solclient-sdt/lib/codec/encode-header.js");
                const {
                    EncodeInteger
                } = __webpack_require__(/*! ./encode-integer */ "./modules/solclient-sdt/lib/codec/encode-integer.js");
                const {
                    EncodeMap
                } = __webpack_require__(/*! ./encode-map */ "./modules/solclient-sdt/lib/codec/encode-map.js");
                const {
                    EncodeStream
                } = __webpack_require__(/*! ./encode-stream */ "./modules/solclient-sdt/lib/codec/encode-stream.js");
                const {
                    IEEE754LIB
                } = __webpack_require__(/*! ./ieee754lib */ "./modules/solclient-sdt/lib/codec/ieee754lib.js");
                const {
                    SDTDataTypes
                } = __webpack_require__(/*! ../sdt-data-types */ "./modules/solclient-sdt/lib/sdt-data-types.js");
                const {
                    SDTDestType
                } = __webpack_require__(/*! ../sdt-destination-types */ "./modules/solclient-sdt/lib/sdt-destination-types.js");
                const {
                    SDTField
                } = __webpack_require__(/*! ../sdt-field */ "./modules/solclient-sdt/lib/sdt-field.js");
                const {
                    SDTFieldType
                } = __webpack_require__(/*! ../sdt-field-types */ "./modules/solclient-sdt/lib/sdt-field-types.js");
                const {
                    StringUtils
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const {
                    encodeHeader
                } = EncodeHeader;
                const {
                    int48ToStr
                } = EncodeInteger;
                const {
                    encodeMap
                } = EncodeMap;
                const {
                    encodeStream
                } = EncodeStream;
                const {
                    nullTerminate
                } = StringUtils;
                const C_2_48 = Math.pow(2, 48);
                // UCS-2 --> UTF-8 conversion
                function strencode(data) {
                    return unescape(encodeURIComponent(data));
                }
                // Encode an SDTField into provided buffer buf
                function encodeSingleElementToBuf(sdtfield, buf) {
                    if (!(sdtfield instanceof SDTField)) {
                        return false;
                    }
                    // we write the header at the end, once we know the size
                    const value = sdtfield.getValue();
                    let fieldVal = null;
                    let tag = 0; // SMF TAG
                    switch (sdtfield.getType()) {
                      case SDTFieldType.BOOL:
                        tag = SDTDataTypes.Boolean;
                        fieldVal = Convert.int8ToStr(value ? 1 : 0);
                        break;

                      case SDTFieldType.UINT8:
                        tag = SDTDataTypes.UnsignedInteger;
                        fieldVal = Convert.int8ToStr(value);
                        break;

                      case SDTFieldType.INT8:
                        tag = SDTDataTypes.Integer;
                        fieldVal = Convert.int8ToStr(value);
                        break;

                      case SDTFieldType.UINT16:
                        tag = SDTDataTypes.UnsignedInteger;
                        fieldVal = Convert.int16ToStr(value);
                        break;

                      case SDTFieldType.INT16:
                        tag = SDTDataTypes.Integer;
                        fieldVal = Convert.int16ToStr(value);
                        break;

                      case SDTFieldType.UINT32:
                        tag = SDTDataTypes.UnsignedInteger;
                        fieldVal = Convert.int32ToStr(value);
                        break;

                      case SDTFieldType.INT32:
                        tag = SDTDataTypes.Integer;
                        fieldVal = Convert.int32ToStr(value);
                        break;

                      case SDTFieldType.UINT64:
                        tag = SDTDataTypes.UnsignedInteger;
                        fieldVal = String.fromCharCode(0) + String.fromCharCode(0) + int48ToStr(value);
                        break;

                      case SDTFieldType.INT64:
                        tag = SDTDataTypes.Integer;
                        if (value >= 0) {
                            fieldVal = String.fromCharCode(0) + String.fromCharCode(0) + int48ToStr(value);
                        } else {
                            fieldVal = String.fromCharCode(255) + String.fromCharCode(255) + int48ToStr(C_2_48 + value);
                        }
                        break;

                      case SDTFieldType.WCHAR:
                        tag = SDTDataTypes.Char;
                        fieldVal = Convert.int16ToStr(value.charCodeAt(0));
                        break;

                      case SDTFieldType.STRING:
                        tag = SDTDataTypes.String;
                        fieldVal = nullTerminate(strencode(value));
                        break;

                      case SDTFieldType.BYTEARRAY:
                        tag = SDTDataTypes.ByteArray;
                        fieldVal = value.toString("latin1");
                        break;

                      case SDTFieldType.FLOATTYPE:
                        tag = SDTDataTypes.Float;
                        fieldVal = IEEE754LIB.toIEEE754Single(value);
                        break;

                      case SDTFieldType.DOUBLETYPE:
                        tag = SDTDataTypes.Float;
                        fieldVal = IEEE754LIB.toIEEE754Double(value);
                        break;

                      case SDTFieldType.MAP:
                        tag = SDTDataTypes.Map;
                        fieldVal = encodeMap(value);
                        break;

                      case SDTFieldType.STREAM:
                        tag = SDTDataTypes.Stream;
                        fieldVal = encodeStream(value);
                        break;

                      case SDTFieldType.DESTINATION:
                        tag = SDTDataTypes.Destination;
                        if (value instanceof DestinationLib.Destination) {
                            fieldVal = Convert.int8ToStr(SDTDestType[value.getType()]) + value.getBytes();
                        }
                        break;

                      case SDTFieldType.NULLTYPE:
                        tag = SDTDataTypes.Null;
                        fieldVal = "";
                        break;

                      case SDTFieldType.UNKNOWN:
                        fieldVal = null;
                        break;

                      default:
                    }
                    if (fieldVal !== null) {
                        const hdr = encodeHeader(tag, fieldVal.length);
                        buf.push(hdr);
                        buf.push(fieldVal);
                        return true;
                    }
                    return false;
                }
                function encodeSingleElement(sdtfield) {
                    const buf = [];
                    encodeSingleElementToBuf(sdtfield, buf);
                    return buf.join("");
                }
                const EncodeSingleElement = {
                    encodeSingleElement: encodeSingleElement,
                    encodeSingleElementToBuf: encodeSingleElementToBuf
                };
                module.exports.EncodeSingleElement = EncodeSingleElement;
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/codec/encode-stream.js": 
            /*!**********************************************************!*\
  !*** ./modules/solclient-sdt/lib/codec/encode-stream.js ***!
  \**********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const EncodeSingleElementLib = __webpack_require__(/*! ./encode-single-element */ "./modules/solclient-sdt/lib/codec/encode-single-element.js");
                const {
                    SDTStreamContainer
                } = __webpack_require__(/*! ../sdt-stream-container */ "./modules/solclient-sdt/lib/sdt-stream-container.js");
                const EncodeStream = {};
                EncodeStream.encodeStream = function encodeStream(sdtstream) {
                    const buf = [];
                    if (!(sdtstream instanceof SDTStreamContainer)) {
                        return null; // skip!
                    }
                    let sdtfield = null;
                    while (sdtstream.hasNext()) {
                        sdtfield = sdtstream.getNext();
                        if (sdtfield) {
                            EncodeSingleElementLib.EncodeSingleElement.encodeSingleElementToBuf(sdtfield, buf);
                        }
                    } // end iter over stream entries
                    return buf.join("");
                };
                module.exports.EncodeStream = EncodeStream;
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/codec/ieee754lib.js": 
            /*!*******************************************************!*\
  !*** ./modules/solclient-sdt/lib/codec/ieee754lib.js ***!
  \*******************************************************/
            /***/ module => {
                const IEEE754LIB = {
                    /**
   * @preserve
   * The MIT License
   *
   * Copyright (c) 2010 Alan Gutierrez
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
                    toIEEE754(vIn, ebits, fbits) {
                        let v = vIn;
                        const bias = (1 << ebits - 1) - 1;
                        // Compute sign, exponent, fraction
                        let s;
                        let e;
                        let f;
                        if (isNaN(v)) {
                            e = (1 << bias) - 1;
                            f = 1;
                            s = 0;
                        } else if (v === Infinity || v === -Infinity) {
                            e = (1 << bias) - 1;
                            f = 0;
                            s = v < 0 ? 1 : 0;
                        } else if (v === 0) {
                            e = 0;
                            f = 0;
                            s = 1 / v === -Infinity ? 1 : 0;
                        } else {
                            s = v < 0;
                            v = Math.abs(v);
                            if (v >= Math.pow(2, 1 - bias)) {
                                const ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);
                                e = ln + bias;
                                f = v * Math.pow(2, fbits - ln) - Math.pow(2, fbits);
                            } else {
                                e = 0;
                                f = v / Math.pow(2, 1 - bias - fbits);
                            }
                        }
                        // Pack sign, exponent, fraction
                        const bits = [];
                        for (let i = fbits; i; i -= 1) {
                            bits.push(f % 2 ? 1 : 0);
                            f = Math.floor(f / 2);
                        }
                        for (let i = ebits; i; i -= 1) {
                            bits.push(e % 2 ? 1 : 0);
                            e = Math.floor(e / 2);
                        }
                        bits.push(s ? 1 : 0);
                        bits.reverse();
                        let str = bits.join("");
                        // Bits to bytes
                        const bytes = [];
                        while (str.length) {
                            bytes.push(parseInt(str.substring(0, 8), 2));
                            str = str.substring(8);
                        }
                        return bytes;
                    },
                    fromIEEE754(bytes, ebits, fbits) {
                        // Bytes to bits
                        const bits = [];
                        for (let i = bytes.length; i; i -= 1) {
                            let byteI = bytes[i - 1];
                            for (let j = 8; j; j -= 1) {
                                bits.push(byteI % 2 ? 1 : 0);
                                byteI >>= 1;
                            }
                        }
                        bits.reverse();
                        const str = bits.join("");
                        // Unpack sign, exponent, fraction
                        const bias = (1 << ebits - 1) - 1;
                        const s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
                        const e = parseInt(str.substring(1, 1 + ebits), 2);
                        const f = parseInt(str.substring(1 + ebits), 2);
                        // Produce number
                        if (e === (1 << ebits) - 1) {
                            return f !== 0 ? NaN : s * Infinity;
                        }
                        if (e > 0) {
                            return s * Math.pow(2, e - bias) * (1 + f / Math.pow(2, fbits));
                        }
                        if (f !== 0) {
                            return s * Math.pow(2, -(bias - 1)) * (f / Math.pow(2, fbits));
                        }
                        return 0;
                    },
                    strToByteArr(str) {
                        const bytes = [];
                        for (let i = 0; i < str.length; i++) {
                            bytes.push(str.charCodeAt(i) & 255);
                        }
                        return bytes;
                    },
                    byteArrToStr(bytes) {
                        const str = [];
                        for (let i = 0; i < bytes.length; i++) {
                            str.push(String.fromCharCode(bytes[i] & 255));
                        }
                        return str.join("");
                    },
                    fromIEEE754Double(b) {
                        return this.fromIEEE754(this.strToByteArr(b), 11, 52);
                    },
                    toIEEE754Double(v) {
                        return this.byteArrToStr(this.toIEEE754(v, 11, 52));
                    },
                    fromIEEE754Single(b) {
                        return this.fromIEEE754(this.strToByteArr(b), 8, 23);
                    },
                    toIEEE754Single(v) {
                        return this.byteArrToStr(this.toIEEE754(v, 8, 23));
                    }
                };
                module.exports.IEEE754LIB = IEEE754LIB;
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/codec/parse-destination.js": 
            /*!**************************************************************!*\
  !*** ./modules/solclient-sdt/lib/codec/parse-destination.js ***!
  \**************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    DestinationFromNetwork,
                    DestinationType,
                    Queue
                } = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                const {
                    LOG_DEBUG,
                    LOG_INFO
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    SDTDestType
                } = __webpack_require__(/*! ../sdt-destination-types */ "./modules/solclient-sdt/lib/sdt-destination-types.js");
                const {
                    SDTField
                } = __webpack_require__(/*! ../sdt-field */ "./modules/solclient-sdt/lib/sdt-field.js");
                const {
                    SDTFieldType
                } = __webpack_require__(/*! ../sdt-field-types */ "./modules/solclient-sdt/lib/sdt-field-types.js");
                const {
                    Topic
                } = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                const ParseDestination = {};
                ParseDestination.parseDestination = function parseDestination(dataBuf, pos, len) {
                    const destType = dataBuf.readUInt8(pos);
                    const destBytes = dataBuf.toString("latin1", pos + 1, pos + len);
                    // first try to create a destination from the string, this handles strings with
                    // the preamble ('#P2P/QUE' or '#P2P/TQUE').
                    let destination = DestinationFromNetwork.createDestinationFromBytes(destBytes);
                    if (SDTDestType[destination.type] !== destType) {
                        // SDT destination type does not match the string format. This means either:
                        //    * that the string contains a queue preamble and the type is topic,
                        //      so just make it a topic
                        //    * that the type is queue and the string does not have the preamble, which means we
                        //      should construct a queue.
                        if (SDTDestType[DestinationType.QUEUE] === destType) {
                            destination = Queue.createFromLocalName(destBytes); //createFromLocal has issue with buffer
                        } else if (SDTDestType[DestinationType.TOPIC] === destType) {
                            LOG_DEBUG(`Found and allowed SDT field with  destination type ${destType} when decoding ${destBytes} to ${destination.type}`);
                            //
                            // override the format and set destType as specified in the SMF (i.e. TOPIC)
                            destination = new Topic(destBytes);
                        } else {
                            LOG_INFO(`Drop SDT field with invalid destination type ${destType} when decoding ${destBytes} to ${destination.type}`);
                            return null;
                        }
                    }
                    return SDTField.create(SDTFieldType.DESTINATION, destination);
                };
                module.exports.ParseDestination = ParseDestination;
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/codec/parse-field-header.js": 
            /*!***************************************************************!*\
  !*** ./modules/solclient-sdt/lib/codec/parse-field-header.js ***!
  \***************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ParseInteger
                } = __webpack_require__(/*! ./parse-integer */ "./modules/solclient-sdt/lib/codec/parse-integer.js");
                const {
                    autoDecodeVarLengthNumber
                } = ParseInteger;
                const ParseFieldHeader = {};
                // Parse the header part of an SDT field.
                // Returns [TYPE, DECLARED_LENGTH, VALUE_DATA_LENGTH, CONSUMED_BYTES]
                ParseFieldHeader.parseFieldHeader = function parseFieldHeader(dataBuf, offset) {
                    let pos = offset;
                    const onebyte = dataBuf.readUInt8(pos);
                    const elemType = (onebyte & 252) >> 2;
                    const lenBytes = (onebyte & 3) + 1;
                    pos++;
                    const elemLen = autoDecodeVarLengthNumber(dataBuf, pos, lenBytes);
                    pos += lenBytes;
                    const elemValLen = elemLen - (1 + lenBytes);
                    return [ elemType, elemLen, elemValLen, pos - offset ];
                };
                module.exports.ParseFieldHeader = ParseFieldHeader;
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/codec/parse-float.js": 
            /*!********************************************************!*\
  !*** ./modules/solclient-sdt/lib/codec/parse-float.js ***!
  \********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    SDTField
                } = __webpack_require__(/*! ../sdt-field */ "./modules/solclient-sdt/lib/sdt-field.js");
                const {
                    SDTFieldType
                } = __webpack_require__(/*! ../sdt-field-types */ "./modules/solclient-sdt/lib/sdt-field-types.js");
                const ParseFloat = {};
                ParseFloat.parseFloatField = function parseFloatField(buf, pos, len) {
                    switch (len) {
                      case 4:
                        return SDTField.create(SDTFieldType.FLOATTYPE, buf.readFloatBE(pos));

                      case 8:
                        return SDTField.create(SDTFieldType.DOUBLETYPE, buf.readDoubleBE(pos));

                      default:
                        return SDTField.create(SDTFieldType.UNKNOWN, buf.toString("latin1", pos, pos + len));
                    }
                };
                module.exports.ParseFloat = ParseFloat;
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/codec/parse-integer.js": 
            /*!**********************************************************!*\
  !*** ./modules/solclient-sdt/lib/codec/parse-integer.js ***!
  \**********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const Long = __webpack_require__(/*! long */ "./node_modules/long/umd/index.js");
                const {
                    SDTField
                } = __webpack_require__(/*! ../sdt-field */ "./modules/solclient-sdt/lib/sdt-field.js");
                const {
                    SDTFieldType
                } = __webpack_require__(/*! ../sdt-field-types */ "./modules/solclient-sdt/lib/sdt-field-types.js");
                const {
                    SDTUnsupportedValueError
                } = __webpack_require__(/*! ../sdt-unsupported-value-error */ "./modules/solclient-sdt/lib/sdt-unsupported-value-error.js");
                const {
                    SDTValueErrorSubcode
                } = __webpack_require__(/*! ../sdt-value-error-subcodes */ "./modules/solclient-sdt/lib/sdt-value-error-subcodes.js");
                const {
                    create: createField
                } = SDTField;
                const ParseInteger = {};
                // Util: decode 1, 2, 3, 4 byte UINT.
                ParseInteger.autoDecodeVarLengthNumber = function autoDecodeVarLengthNumber(dataBuf, pos, len) {
                    if ([ 1, 2, 3, 4 ].includes(len)) {
                        return dataBuf.readUIntBE(pos, len);
                    }
                    return false;
                };
                // Parse an integer SDT Field: [U]INT 8, 16, 32, 64.
                ParseInteger.parseIntegerField = function parseIntegerField(isSigned, dataBuf, pos, len) {
                    let val = 0;
                    switch (len) {
                      case 1:
                        if (isSigned) {
                            val = dataBuf.readInt8(pos);
                            return createField(SDTFieldType.INT8, val);
                        } // else unsigned:
                        val = dataBuf.readUInt8(pos);
                        return createField(SDTFieldType.UINT8, val);

                      case 2:
                        if (isSigned) {
                            val = dataBuf.readInt16BE(pos);
                            return createField(SDTFieldType.INT16, val);
                        } // else signed:
                        val = dataBuf.readUInt16BE(pos);
                        return createField(SDTFieldType.UINT16, val);

                      case 4:
                        if (isSigned) {
                            val = dataBuf.readInt32BE(pos);
                            return createField(SDTFieldType.INT32, val);
                        } // else signed:
                        val = dataBuf.readUInt32BE(pos);
                        return createField(SDTFieldType.UINT32, val);

                      case 8:
                        {
                            let error = null;
                            const longValue = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), !isSigned);
                            if (longValue.getNumBitsAbs() > 48) {
                                error = new SDTUnsupportedValueError("Value is not supported", SDTValueErrorSubcode.VALUE_OUTSIDE_SUPPORTED_RANGE, dataBuf.toString("latin1", pos, len));
                            }
                            val = longValue.toNumber();
                            const field = createField(isSigned ? SDTFieldType.INT64 : SDTFieldType.UINT64, val);
                            if (error) {
                                field.setError(error);
                            }
                            return field;
                        }

                      default:
                        return null;
                    }
                };
                module.exports.ParseInteger = ParseInteger;
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/codec/parse-map.js": 
            /*!******************************************************!*\
  !*** ./modules/solclient-sdt/lib/codec/parse-map.js ***!
  \******************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const ParseSingleElementLib = __webpack_require__(/*! ./parse-single-element */ "./modules/solclient-sdt/lib/codec/parse-single-element.js");
                const {
                    LOG_ERROR
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    ParseFieldHeader
                } = __webpack_require__(/*! ./parse-field-header */ "./modules/solclient-sdt/lib/codec/parse-field-header.js");
                const {
                    SDTDataTypes
                } = __webpack_require__(/*! ../sdt-data-types */ "./modules/solclient-sdt/lib/sdt-data-types.js");
                const {
                    SDTField
                } = __webpack_require__(/*! ../sdt-field */ "./modules/solclient-sdt/lib/sdt-field.js");
                const {
                    SDTFieldType
                } = __webpack_require__(/*! ../sdt-field-types */ "./modules/solclient-sdt/lib/sdt-field-types.js");
                const {
                    SDTMapContainer
                } = __webpack_require__(/*! ../sdt-map-container */ "./modules/solclient-sdt/lib/sdt-map-container.js");
                const ParseMap = {};
                ParseMap.parseMapAt = function parseMapAt(dataBuf, offset, datalen) {
                    const mapObj = new SDTMapContainer();
                    let pos = offset;
                    while (pos < offset + datalen) {
                        // === key field ===
                        const keyFieldHeader = ParseFieldHeader.parseFieldHeader(dataBuf, pos);
                        pos += keyFieldHeader[3]; // consumed bytes
                        // pos now points to start of string
                        if (keyFieldHeader[0] !== SDTDataTypes.String) {
                            // Fail!
                            LOG_ERROR("Error parsing SDTMAP, expected to find a string field as map key, and didn't");
                            LOG_ERROR(`Type of key: ${keyFieldHeader[0]}`);
                            return SDTField.create(SDTFieldType.MAP, null);
                        }
                        const keyString = dataBuf.toString("latin1", pos, pos + keyFieldHeader[2] - 1);
                        pos += keyFieldHeader[2];
                        // === value field ===
                        // pos now points to start of next value
                        const valueFieldHeader = ParseFieldHeader.parseFieldHeader(dataBuf, pos);
                        const valueField = ParseSingleElementLib.ParseSingleElement.parseSingleElement(dataBuf, pos);
                        pos += valueFieldHeader[1]; // declared field length
                        if (valueField) {
                            mapObj.addField(keyString, valueField);
                        }
                    }
                    return SDTField.create(SDTFieldType.MAP, mapObj);
                };
                module.exports.ParseMap = ParseMap;
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/codec/parse-single-element.js": 
            /*!*****************************************************************!*\
  !*** ./modules/solclient-sdt/lib/codec/parse-single-element.js ***!
  \*****************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Convert
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    LOG_DEBUG
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    ParseDestination
                } = __webpack_require__(/*! ./parse-destination */ "./modules/solclient-sdt/lib/codec/parse-destination.js");
                const {
                    ParseFieldHeader
                } = __webpack_require__(/*! ./parse-field-header */ "./modules/solclient-sdt/lib/codec/parse-field-header.js");
                const {
                    ParseFloat
                } = __webpack_require__(/*! ./parse-float */ "./modules/solclient-sdt/lib/codec/parse-float.js");
                const {
                    ParseInteger
                } = __webpack_require__(/*! ./parse-integer */ "./modules/solclient-sdt/lib/codec/parse-integer.js");
                const {
                    ParseMap
                } = __webpack_require__(/*! ./parse-map */ "./modules/solclient-sdt/lib/codec/parse-map.js");
                const {
                    ParseStream
                } = __webpack_require__(/*! ./parse-stream */ "./modules/solclient-sdt/lib/codec/parse-stream.js");
                const {
                    SDTDataTypes
                } = __webpack_require__(/*! ../sdt-data-types */ "./modules/solclient-sdt/lib/sdt-data-types.js");
                const {
                    SDTField
                } = __webpack_require__(/*! ../sdt-field */ "./modules/solclient-sdt/lib/sdt-field.js");
                const {
                    SDTFieldType
                } = __webpack_require__(/*! ../sdt-field-types */ "./modules/solclient-sdt/lib/sdt-field-types.js");
                const {
                    utf8ToUcs2
                } = Convert;
                const {
                    parseFieldHeader
                } = ParseFieldHeader;
                const {
                    parseFloatField
                } = ParseFloat;
                const {
                    parseIntegerField
                } = ParseInteger;
                const {
                    parseMapAt
                } = ParseMap;
                const {
                    parseStreamAt
                } = ParseStream;
                const {
                    parseDestination
                } = ParseDestination;
                const ParseSingleElement = {
                    // Parse single SDT element, returns SDTField
                    parseSingleElement(dataBuf, offset) {
                        const fieldHeader = parseFieldHeader(dataBuf, offset);
                        if (!fieldHeader) {
                            LOG_DEBUG(`parseSingleElement return false, fieldHeader=${fieldHeader}`);
                            return null;
                        }
                        const pos = offset + fieldHeader[3];
                        // For use inside switch
                        const elemValLen = fieldHeader[2];
                        switch (fieldHeader[0]) {
                          case SDTDataTypes.Null:
                            return SDTField.create(SDTFieldType.NULLTYPE, null);

                          case SDTDataTypes.Boolean:
                            return SDTField.create(SDTFieldType.BOOL, dataBuf.readUInt8(pos) !== 0);

                          case SDTDataTypes.Integer:
                            return parseIntegerField(true, dataBuf, pos, elemValLen);

                          case SDTDataTypes.UnsignedInteger:
                            return parseIntegerField(false, dataBuf, pos, elemValLen);

                          case SDTDataTypes.Float:
                            return parseFloatField(dataBuf, pos, elemValLen);

                          case SDTDataTypes.Char:
                            return SDTField.create(SDTFieldType.WCHAR, String.fromCharCode(dataBuf.readUInt16BE(pos)));

                          case SDTDataTypes.ByteArray:
                            return SDTField.create(SDTFieldType.BYTEARRAY, dataBuf.slice(pos, pos + elemValLen));

                          case SDTDataTypes.String:
                            // strip last byte (null-terminator)
                            return SDTField.create(SDTFieldType.STRING, utf8ToUcs2(dataBuf.toString("latin1", pos, pos + elemValLen - 1)));

                          case SDTDataTypes.Destination:
                            return parseDestination(dataBuf, pos, elemValLen);

                          case SDTDataTypes.SMFMessage:
                            return SDTField.create(SDTFieldType.SMF_MESSAGE, dataBuf.slice(pos, pos + elemValLen));

                          case SDTDataTypes.Map:
                            return parseMapAt(dataBuf, pos, elemValLen);

                          case SDTDataTypes.Stream:
                            return parseStreamAt(dataBuf, pos, elemValLen);

                          default:
                            // removed toString conversion as a test
                            return SDTField.create(SDTFieldType.UNKNOWN, dataBuf.toString("latin1", pos, pos + elemValLen));
                        }
                    }
                };
                const StringToBuffer = {
                    stringToBuffer(str) {
                        const BufferImpl = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;
                        return BufferImpl.from(str, "latin1");
                    }
                };
                module.exports.ParseSingleElement = ParseSingleElement;
                module.exports.StringToBuffer = StringToBuffer;
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/codec/parse-stream.js": 
            /*!*********************************************************!*\
  !*** ./modules/solclient-sdt/lib/codec/parse-stream.js ***!
  \*********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const ParseSingleElementLib = __webpack_require__(/*! ./parse-single-element */ "./modules/solclient-sdt/lib/codec/parse-single-element.js");
                const {
                    ParseFieldHeader
                } = __webpack_require__(/*! ./parse-field-header */ "./modules/solclient-sdt/lib/codec/parse-field-header.js");
                const {
                    SDTField
                } = __webpack_require__(/*! ../sdt-field */ "./modules/solclient-sdt/lib/sdt-field.js");
                const {
                    SDTFieldType
                } = __webpack_require__(/*! ../sdt-field-types */ "./modules/solclient-sdt/lib/sdt-field-types.js");
                const {
                    SDTStreamContainer
                } = __webpack_require__(/*! ../sdt-stream-container */ "./modules/solclient-sdt/lib/sdt-stream-container.js");
                const ParseStream = {};
                ParseStream.parseStreamAt = function parseStreamAt(dataBuf, offset, datalen) {
                    const streamObj = new SDTStreamContainer();
                    let pos = offset;
                    while (pos < offset + datalen) {
                        const valueFieldHeader = ParseFieldHeader.parseFieldHeader(dataBuf, pos);
                        const valueField = ParseSingleElementLib.ParseSingleElement.parseSingleElement(dataBuf, pos);
                        pos += valueFieldHeader[1]; // declared field length
                        if (valueField) {
                            streamObj.addField(valueField);
                        }
                    }
                    return SDTField.create(SDTFieldType.STREAM, streamObj);
                };
                module.exports.ParseStream = ParseStream;
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/sdt-data-types.js": 
            /*!*****************************************************!*\
  !*** ./modules/solclient-sdt/lib/sdt-data-types.js ***!
  \*****************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * @private
 * @enum {number}
 */
                const SDTDataTypes = {
                    Null: 0,
                    Boolean: 1,
                    Integer: 2,
                    UnsignedInteger: 3,
                    Float: 4,
                    Char: 5,
                    ByteArray: 6,
                    String: 7,
                    Destination: 8,
                    SMFMessage: 9,
                    Map: 10,
                    Stream: 11
                };
                module.exports.SDTDataTypes = Enum.new(SDTDataTypes);
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/sdt-destination-types.js": 
            /*!************************************************************!*\
  !*** ./modules/solclient-sdt/lib/sdt-destination-types.js ***!
  \************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    DestinationType
                } = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * An enumeration of all SDT data types.
 * @enum {number}
 * @namespace
 * @memberof solace
 * @private
 */
                const SDTDestType = {
                    [DestinationType.TOPIC]: 0,
                    [DestinationType.QUEUE]: 1,
                    [DestinationType.TEMPORARY_QUEUE]: 1
                };
                module.exports.SDTDestType = Enum.new(SDTDestType);
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/sdt-field-types.js": 
            /*!******************************************************!*\
  !*** ./modules/solclient-sdt/lib/sdt-field-types.js ***!
  \******************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * An enumeration of all SDT data types.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
                const SDTFieldType = {
                    /**
   * @type {Number}
   * @description Maps to a boolean.
   */
                    BOOL: 0,
                    /**
   * @type {Number}
   * @description Maps to a number.
   */
                    UINT8: 1,
                    /**
   * @type {Number}
   * @description Maps to a number.
   */
                    INT8: 2,
                    /**
   * @type {Number}
   * @description Maps to a number.
   */
                    UINT16: 3,
                    /**
   * @type {Number}
   * @description Maps to a number.
   */
                    INT16: 4,
                    /**
   * @type {Number}
   * @description Maps to a number.
   */
                    UINT32: 5,
                    /**
   *@type {Number}
   * @description Maps to a number.
   */
                    INT32: 6,
                    /**
   * @type {Number}
   * @description Maps to a number. <br>
   * <strong>Warning:</strong> Supports 48-bit integers (range: 0 to 2<sup>48</sup>-1).
   * When decoding, only the lower 48 bits are considered significant.
   */
                    UINT64: 7,
                    /**
   * @type {Number}
   * @description Maps to a number. <br>
   * <strong>Warning:</strong> Supports 48-bit integers + sign (range: -(2<sup>48</sup>-1) to
   * 2<sup>48</sup>-1). When decoding, only the lower 48 bits are considered significant.
   */
                    INT64: 8,
                    /**
   * @type {Number}
   * @description A single character; maps to a string.
   */
                    WCHAR: 9,
                    /**
   * @type {Number}
   * @description Maps to a string.
   */
                    STRING: 10,
                    /**
   * @type {Number}
   * @description Maps to a Uint8Array.
   *
   * Backward compatibility note:
   * Using the version_10 factory profile or older, the getValue() method of a BYTEARRAY sdtField
   * returns the byte array in 'latin1' String representation.
   * Later profiles return a Uint8Array (in the form of a nodeJS Buffer instance in fact)
   *
   * When creating a field of type BYTEARRAY, the following datatypes are all accepted as value:
   *   Buffer (the nodeJS native type or equivalent)
   *   ArrayBuffer,
   *   Any DataView or TypedArray,
   *   'latin1' String for backwards compatibility:
   *     each character has a code in the range 0-255
   *     representing exactly one byte in the attachment.
   */
                    BYTEARRAY: 11,
                    /**
   * @type {Number}
   * @description Single-precision float; maps to a number.
   */
                    FLOATTYPE: 12,
                    /**
   * @type {Number}
   * @description Double-precision float; maps to a number.
   */
                    DOUBLETYPE: 13,
                    /**
   * @type {Number}
   * @description Maps to {@link SDTMapContainer}.
   */
                    MAP: 14,
                    /**
   * @type {Number}
   * @description Maps to {@link SDTStreamContainer}.
   */
                    STREAM: 15,
                    /**
   * @type {Number}
   * @description Maps to {@link Destination}.
   */
                    DESTINATION: 16,
                    /**
   * @type {Number}
   * @description Maps to <code>null</code>.
   */
                    NULLTYPE: 17,
                    /**
   * @type {Number}
   * @description Maps to an unknown type.
   */
                    UNKNOWN: 18,
                    /**
   * @type {Number}
   * @description Maps to an encoded SMF message.
   */
                    SMF_MESSAGE: 19
                };
                module.exports.SDTFieldType = Enum.new(SDTFieldType);
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/sdt-field.js": 
            /*!************************************************!*\
  !*** ./modules/solclient-sdt/lib/sdt-field.js ***!
  \************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const SolclientFactoryLib = __webpack_require__(/*! solclient-factory */ "./modules/solclient-factory/api.js");
                const {
                    Convert
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    SDTFieldType
                } = __webpack_require__(/*! ./sdt-field-types */ "./modules/solclient-sdt/lib/sdt-field-types.js");
                const {
                    validateSdtField
                } = __webpack_require__(/*! ./validate-sdt-field */ "./modules/solclient-sdt/lib/validate-sdt-field.js");
                const {
                    anythingToBuffer
                } = Convert;
                const {
                    ProfileBinding
                } = SolclientFactoryLib;
                /**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 *
 * Represents a SDT (Structured Data Type) field. To create an instance of an <code>SDTField</code>,
 * call {@link solace.SDTField.create}.
 *
 * SDTField objects are used in Solace Containers ({@link solace.SDTMapContainer}
 * and {@link solace.SDTStreamContainer}). The <b>deprecated</b> usage of
 * {@link solace.SDTMapContainer#addField} and {@link solace.SDTStreamContainer#addField}
 * take a SDTField object as an argument. The preferred usage is to pass a
 * {@link solace.SDTFieldType} and value as arguments.
 *
 * SDTField objectts must be used as an argument to {@link solace.Message#setSdtContainer}.
 * The only valid SDTField objects for {@link solace.Message#setSdtContainer} are:
 * * {@link solace.SDTFieldType.STREAM}
 * * {@link solace.SDTFieldType.MAP}
 * * {@link solace.SDTFieldType.STRING}
 * @hideconstructor
 * @memberof solace
 */
                class SDTField {
                    /*
   * @constructor
   * @param {SDTFieldType} [type=SDTFieldType.NULLTYPE] The field type to construct
   * @param {*} value The value to be encapsulated
   * @throws {solace.OperationError} if value does not match type
   * @private
   */
                    constructor(type = SDTFieldType.NULLTYPE, value = null) {
                        const err = validateSdtField(type, value);
                        if (err !== null) {
                            throw err;
                        }
                        this._type = type;
                        if (type === SDTFieldType.BYTEARRAY) {
                            this._value = anythingToBuffer(value);
                        } else {
                            this._value = value;
                        }
                        this._error = undefined;
                    }
                    /**
   * Gets the type of field represented.
   * @returns {solace.SDTFieldType} The type of field represented.
   */
                    getType() {
                        return this._type;
                    }
                    /**
   * Gets the field value.
   * @returns {*} Field value (as one of the supported data types).
   * @throws {solace.SDTUnsupportedValueError} if value found in the field
   * is not in range supported by the platform/runtime.
   */
                    getValue() {
                        if (this._error !== undefined) {
                            throw this._error;
                        }
                        return this.getValueNoThrow();
                    }
                    /**
   * Gets the field value or error object.
   * @returns {*} Field value (as one of the supported data types) or
   * {solace.SDTUnsupportedValueError} if value found in the field
   * is not in range supported by the platform/runtime.
   * @private
   */
                    getValueNoThrow() {
                        if (this._error !== undefined) {
                            return this._error;
                        }
                        if (this._type === SDTFieldType.BYTEARRAY && ProfileBinding.value.byteArrayAsString) {
                            return this._value.toString("latin1");
                        }
                        return this._value;
                    }
                    /**
   * Sets an error on the object to be thrown on getValue().
   * Used only by parse-integer, as it is possible to receive
   * 64 bit integers that cannot be represented in a javaScript number.
   * JavaScript numbers are floats and can only hold a 48 bit integer.
   * @private
   * @param {solace.SDTUnsupportedValueError} err error object.
   */
                    setError(err) {
                        this._error = err;
                    }
                    toString() {
                        return `[SDTField type:${this._type} value:${this._value}]`;
                    }
                    /**
   * Create a new SDTField instance representing a Value of a given Type.
   *
   * @param {solace.SDTFieldType} type The type of field represented.
   * @param {*} value The corresponding value to store in the field.
   * @returns {solace.SDTField} The new SDT field with the given type and value
   * @throws {solace.OperationError} if value does not match type
   * @static
   */
                    static create(type, value) {
                        return new SDTField(type, value);
                    }
                }
                module.exports.SDTField = SDTField;
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/sdt-map-container.js": 
            /*!********************************************************!*\
  !*** ./modules/solclient-sdt/lib/sdt-map-container.js ***!
  \********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    SDTField
                } = __webpack_require__(/*! ./sdt-field */ "./modules/solclient-sdt/lib/sdt-field.js");
                /**
 * @classdesc
 * Defines a Structured Data Type (SDT) map container.
 * @memberof solace
 */
                class SDTMapContainer {
                    /**
   * @constructor
   */
                    constructor() {
                        this._map = []; // key-value mappings (keys are strings)
                    }
                    /**
   * Get the list of keys in this map, in unspecified order.
   * @returns {Array.<String>} Array of defined keys in the map.
   */
                    getKeys() {
                        return Object.keys(this._map);
                    }
                    /**
   * Return the SDTField with the given key.
   * @param {String} key The key to look up.
   * @returns {solace.SDTField} The field referenced by key.
   */
                    getField(key) {
                        return this._map[key];
                    }
                    /**
   * Delete an SDTField with the given key.
   * @param {String} key The field key to delete.
   */
                    deleteField(key) {
                        delete this._map[key];
                    }
                    /**
   * Adds a field to this map. If a key:value mapping already exists for this key, it is replaced.
   * <p>
   * <b>Deprecated</b> If <code>typeOrField</code> is a {@link solace.SDTField} instance,
   * it is added to the map.
   *
   * The preferred usage is to pass a {@link solace.SDTFieldType}, then the API will create a
   * SDTField of this type using <code>value</code> before adding it to the map.
   *
   * @param {String} key The key by which to store the given value.
   * @param {solace.SDTField|solace.SDTFieldType} typeOrField A SDTField instance or SDTFieldType.
   * @param {*} [value] The value to wrap as an SDTField.
   * @throws {solace.OperationError} if value does not match type
   * @throws {solace.SDTUnsupportedValueError} if value is not in range
   *  supported by the platform/runtime
   */
                    addField(key, typeOrField, value = undefined) {
                        if (typeOrField instanceof SDTField) {
                            this._map[key] = typeOrField;
                            return;
                        } else if (typeof value !== "undefined") {
                            this._map[key] = SDTField.create(typeOrField, value);
                            return;
                        }
                        throw new OperationError("Invalid parameters to addField: expected SDTField, or type and value", ErrorSubcode.PARAMETER_CONFLICT);
                    }
                }
                module.exports.SDTMapContainer = SDTMapContainer;
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/sdt-stream-container.js": 
            /*!***********************************************************!*\
  !*** ./modules/solclient-sdt/lib/sdt-stream-container.js ***!
  \***********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const SDTFieldLib = __webpack_require__(/*! ./sdt-field */ "./modules/solclient-sdt/lib/sdt-field.js");
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                /**
 * @classdesc
 * Defines a Structured Data Type (SDT) stream container. A stream is an iterable collection of
 * {@link solace.SDTField}s.
 * @memberof solace
 */
                class SDTStreamContainer {
                    /**
   * @constructor
   */
                    constructor() {
                        this._stream = [];
                        this._writable = true;
                        this._readPt = 0;
                    }
                    /**
   * Returns true if the stream has at least one more {@link solace.SDTField}
   * at the current position.
   * @returns {Boolean} true, if there is an available field at the read pointer; false, otherwise.
   */
                    hasNext() {
                        return this._stream.length > this._readPt;
                    }
                    /**
   * Returns the next field in the stream and advances the read pointer.
   * If the end of the stream is reached, it returns undefined.
   * @returns {solace.SDTField} The next field in the stream.
   */
                    getNext() {
                        return this._readPt < this._stream.length ? this._stream[this._readPt++] : undefined;
                    }
                    /**
   * Rewinds the read pointer to the beginning of the stream. Normally when {@link hasNext}
   * returns false, a client application must call rewind() to reiterate over the stream's fields.
   * @throws {@link solace.OperationError} if the stream cannot be rewound.
   */
                    rewind() {
                        this._readPt = 0;
                    }
                    /**
   * Appends a SDTField to the stream.
   * <p>
   * If <code>field</code> is a {@link solace.SDTField}, this field is appended to the stream.
   * <br>
   * If <code>field</code> is a {@link solace.SDTFieldType},
   * then the API will create a SDTField of this
   * type with a value of <code>optValue</code> and append this new SDTField to
   * the stream.
   *
   * @param {solace.SDTField|solace.SDTFieldType} field The field to append to the stream.
   * @param {*} [optValue] The value to wrap as an SDTField.
   */
                    /**
   * Appends a field to this stream.
   * <p>
   * @deprecated If <code>typeOrField</code> is a {@link solace.SDTField} instance,
   * it is appended to the stream.
   *
   * The preferred usage is to pass a {@link solace.SDTFieldType}, then the API will create a
   * SDTField of this type using <code>value</code> and append this new SDTField
   * to the stream.
   *
   * @param {solace.SDTField|solace.SDTFieldType} typeOrField A SDTField instance or SDTFieldType.
   * @param {*} [value] The value to wrap as an SDTField.
   * @throws {@link solace.OperationError} if value does not match type
   * @throws {@link solace.SDTUnsupportedValueError} if value is not in range
   *  supported by the platform/runtime
   */
                    addField(typeOrField, value = undefined) {
                        if (!this._writable) return;
                        if (typeOrField instanceof SDTFieldLib.SDTField) {
                            this._stream.push(typeOrField);
                            return;
                        }
                        if (typeof value !== "undefined") {
                            this._stream.push(SDTFieldLib.SDTField.create(typeOrField, value));
                            return;
                        }
                        throw new OperationError("Invalid parameters to addField: expected SDTField, or type and value", ErrorSubcode.PARAMETER_CONFLICT);
                    }
                }
                module.exports.SDTStreamContainer = SDTStreamContainer;
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/sdt-unsupported-value-error.js": 
            /*!******************************************************************!*\
  !*** ./modules/solclient-sdt/lib/sdt-unsupported-value-error.js ***!
  \******************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const DebugLib = __webpack_require__(/*! solclient-debug */ "./modules/solclient-debug/api.js");
                const {
                    SolaceError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                /**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 *
 * Represents a SDT unsupported value error.  An SDT field was assigned a value that is within
 * the type range for the given SDT type, but is not supported on this platform/runtime.
 * This occurs when a received {@link solace.SDTContainerMap} or {@link solace.SDTContainerStream}
 * contains a field with a value that can not represented in the local architecture.
 * Possible causes include:
 * * receive 64 bit integer that cannot be represented accurately in a javaScript number. JavaScript
 *   numbers are floats and can only hold a 48 bit integer without loss of precission. Any integer
 *   greater than 281474976710655 or less than -281474976710655 will cause this exception.
 * @hideconstructor
 * @extends solace.SolaceError
 * @memberof solace
 */
                class SDTUnsupportedValueError extends SolaceError {
                    /*
   * @constructor
   * @param {String} message The message associated with this error
   * @param {SDTValueErrorSubcode} subcode The subcode associated with this error
   * @param {Object} sourceData The original representation of the value
   */
                    constructor(message, subcode, sourceData) {
                        /**
     * The name of the error.
     * @name solace.SDTUnsupportedValueError#name
     * @type {String}
     * @readonly
     * @description 'SDTUnsupportedValue'
     */
                        super("SDTUnsupportedValue", message);
                        /**
     * The subcode for the error. see {@link solace.SDTValueErrorSubcode}
     * @name solace.SDTUnsupportedValueError#subcode
     * @type {solace.SDTValueErrorSubcode}
     */
                        this.subcode = subcode;
                        this.sourceData = sourceData || "";
                    }
                    inspect() {
                        return super.inspect({
                            subcode: null,
                            sourceData: v => DebugLib.Debug.formatDumpBytes(v, false, 0)
                        });
                    }
                    getSubcode() {
                        return this.subcode;
                    }
                    getSourceData() {
                        return this.sourceData;
                    }
                }
                module.exports.SDTUnsupportedValueError = SDTUnsupportedValueError;
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/sdt-value-error-subcodes.js": 
            /*!***************************************************************!*\
  !*** ./modules/solclient-sdt/lib/sdt-value-error-subcodes.js ***!
  \***************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Enumeration of {@link solace.SDTUnsuportedValueError} causes.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
                const SDTValueErrorSubcode = {
                    /**
   * @type {Number}
   * @description
   * The value for this field may be valid on other platforms, but is outside the
   * range that is supported on this platform for the given type.
   */
                    VALUE_OUTSIDE_SUPPORTED_RANGE: 1
                };
                module.exports.SDTValueErrorSubcode = Enum.new(SDTValueErrorSubcode);
                /***/
            },
            /***/ "./modules/solclient-sdt/lib/validate-sdt-field.js": 
            /*!*********************************************************!*\
  !*** ./modules/solclient-sdt/lib/validate-sdt-field.js ***!
  \*********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const DestinationLib = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                const SDTMapContainerLib = __webpack_require__(/*! ./sdt-map-container */ "./modules/solclient-sdt/lib/sdt-map-container.js");
                const SDTStreamContainerLib = __webpack_require__(/*! ./sdt-stream-container */ "./modules/solclient-sdt/lib/sdt-stream-container.js");
                const ValidateLib = __webpack_require__(/*! solclient-validate */ "./modules/solclient-validate/api.js");
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    SDTFieldType
                } = __webpack_require__(/*! ./sdt-field-types */ "./modules/solclient-sdt/lib/sdt-field-types.js");
                const baseTypes = (() => {
                    const result = [];
                    result[SDTFieldType.BOOL] = "boolean";
                    result[SDTFieldType.UINT8] = "number";
                    result[SDTFieldType.INT8] = "number";
                    result[SDTFieldType.UINT16] = "number";
                    result[SDTFieldType.INT16] = "number";
                    result[SDTFieldType.UINT32] = "number";
                    result[SDTFieldType.INT32] = "number";
                    result[SDTFieldType.UINT64] = "number";
                    result[SDTFieldType.INT64] = "number";
                    result[SDTFieldType.WCHAR] = "string";
                    result[SDTFieldType.STRING] = "string";
                    result[SDTFieldType.BYTEARRAY] = "object"; // Uint8Array
                    result[SDTFieldType.FLOATTYPE] = "number";
                    result[SDTFieldType.DOUBLETYPE] = "number";
                    return result;
                })();
                function failInvalidParameter(valueType) {
                    return new OperationError(`Invalid SDT type:value combination, expected value type ${valueType}`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                }
                function validateSdtField(type, value) {
                    if (baseTypes[type]) {
                        if (baseTypes[type] === "boolean" && typeof value !== "boolean" || baseTypes[type] === "number" && typeof value !== "number" || baseTypes[type] === "string" && typeof value !== "string") {
                            return failInvalidParameter(baseTypes[type]);
                        }
                    }
                    if (type === SDTFieldType.MAP && !ValidateLib.Check.instanceOf(value, SDTMapContainerLib.SDTMapContainer)) {
                        return failInvalidParameter("SDTMapContainer");
                    }
                    if (type === SDTFieldType.STREAM && !ValidateLib.Check.instanceOf(value, SDTStreamContainerLib.SDTStreamContainer)) {
                        return failInvalidParameter("SDTStreamContainer");
                    }
                    if (type === SDTFieldType.DESTINATION && !ValidateLib.Check.instanceOf(value, DestinationLib.Destination)) {
                        return failInvalidParameter("Destination");
                    }
                    return null;
                }
                module.exports.validateSdtField = validateSdtField;
                /***/
            },
            /***/ "./modules/solclient-session/api.js": 
            /*!******************************************!*\
  !*** ./modules/solclient-session/api.js ***!
  \******************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    AuthenticationScheme
                } = __webpack_require__(/*! ./lib/authentication-schemes */ "./modules/solclient-session/lib/authentication-schemes.js");
                const {
                    CapabilityType,
                    ClientCapabilityType
                } = __webpack_require__(/*! ./lib/capability-types */ "./modules/solclient-session/lib/capability-types.js");
                const {
                    MessageRxCBInfo
                } = __webpack_require__(/*! ./lib/message-rx-cb-info */ "./modules/solclient-session/lib/message-rx-cb-info.js");
                const {
                    MutableSessionProperty
                } = __webpack_require__(/*! ./lib/mutable-session-properties */ "./modules/solclient-session/lib/mutable-session-properties.js");
                const {
                    Session
                } = __webpack_require__(/*! ./lib/session */ "./modules/solclient-session/lib/session.js");
                const {
                    SessionEvent
                } = __webpack_require__(/*! ./lib/session-event */ "./modules/solclient-session/lib/session-event.js");
                const {
                    SessionEventCBInfo
                } = __webpack_require__(/*! ./lib/session-event-cb-info */ "./modules/solclient-session/lib/session-event-cb-info.js");
                const {
                    SessionEventCode
                } = __webpack_require__(/*! ./lib/session-event-codes */ "./modules/solclient-session/lib/session-event-codes.js");
                const {
                    SessionEventName
                } = __webpack_require__(/*! ./lib/session-event-names */ "./modules/solclient-session/lib/session-event-names.js");
                const {
                    SessionProperties
                } = __webpack_require__(/*! ./lib/session-properties */ "./modules/solclient-session/lib/session-properties.js");
                const {
                    SessionState
                } = __webpack_require__(/*! ./lib/session-states */ "./modules/solclient-session/lib/session-states.js");
                const {
                    SolclientFactory
                } = __webpack_require__(/*! solclient-factory */ "./modules/solclient-factory/api.js");
                const {
                    SslDowngrade
                } = __webpack_require__(/*! ./lib/ssl-downgrades */ "./modules/solclient-session/lib/ssl-downgrades.js");
                /**
 * Creates a session instance.
 * @param {solace.SessionProperties} sessionProperties Properties to configure the session.
 * @param {solace.MessageRxCBInfo} [messageCallbackInfo] <b>Deprecated:</b>
 *    Callback method for messages.  Instead applications should receive message events via
 *    `session.on(solace.SessionEventCode.MESSAGE, (message) => { ... });`
 * @param {solace.SessionEventCBInfo} [eventCallbackInfo] <b>Deprecated:</b> Callback method for
 *    events on the <i>Session</i>. Instaead applications should receive session events via
 *    `session.on(solace.SessionEventCode.<code>, (event) => { ... });`
 * @returns {solace.Session} The newly-created session.
 * @throws {solace.OperationError} if the parameters have an invalid type or value.
 *                          Subcode: {@link ErrorSubcode.PARAMETER_INVALID_TYPE}.
 * @method
 * @name solace.SolclientFactory.createSession
 */
                SolclientFactory.createSession = SolclientFactory.createFactory((sessionProperties, messageCallbackInfo, eventCallbackInfo) => new Session(sessionProperties, messageCallbackInfo, eventCallbackInfo));
                module.exports.AuthenticationScheme = AuthenticationScheme;
                module.exports.CapabilityType = CapabilityType;
                module.exports.ClientCapabilityType = ClientCapabilityType;
                module.exports.MessageRxCBInfo = MessageRxCBInfo;
                module.exports.MutableSessionProperty = MutableSessionProperty;
                module.exports.Session = Session;
                module.exports.SessionEventCBInfo = SessionEventCBInfo;
                module.exports.SessionEventCode = SessionEventCode;
                module.exports.SessionEvent = SessionEvent;
                module.exports.SessionEventName = SessionEventName;
                module.exports.SessionProperties = SessionProperties;
                module.exports.SessionState = SessionState;
                module.exports.SslDowngrade = SslDowngrade;
                /***/
            },
            /***/ "./modules/solclient-session/lib/authentication-schemes.js": 
            /*!*****************************************************************!*\
  !*** ./modules/solclient-session/lib/authentication-schemes.js ***!
  \*****************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Represents authentication schemes that can be used. The corresponding session
 * property is {@link solace.SessionProperties#authenticationScheme}.
 *
 * @readonly
 * @enum {String}
 * @memberof solace
 * @namespace
 */
                const AuthenticationScheme = {
                    /**
   * @description Username/Password based authentication scheme.
   * @type {String}
   */
                    BASIC: "AuthenticationScheme_basic",
                    /**
   * @name solace.AuthenticationScheme.CLIENT_CERTIFICATE
   * @default AuthenticationScheme_clientCertificate
   * @description Client-side certificate based authentication scheme.
   * @see {@link solace.SessionProperties#sslPfx}
   * @see {@link solace.SessionProperties#sslPfxPassword}
   * @see {@link solace.SessionProperties#sslPrivateKey}
   * @see {@link solace.SessionProperties#sslPrivateKeyPassword}
   * @see {@link solace.SessionProperties#sslCertificate}
   * @type {String}
   * @target node
   */
                    /**
   * @description Client-side certificate based authentication scheme.  The certificate and
   *   private key are provided by the browser.
   * @type {String}
   * @target browser
   */
                    CLIENT_CERTIFICATE: "AuthenticationScheme_clientCertificate",
                    /**
   * @deprecated Use {@link solace.AuthenticationScheme.BASIC} instead.
   * @type {String}
   */
                    AUTHENTICATION_SCHEME_BASIC: "AuthenticationScheme_basic",
                    /**
   * @deprecated Use {@link solace.AuthenticationScheme.CLIENT_CERTIFICATE} instead.
   * @type {String}
   */
                    AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE: "AuthenticationScheme_clientCertificate",
                    /**
   * @default AuthenticationScheme_oauth2
   * @description Oauth2 authentication scheme.
   * @see {@link solace.SessionProperties#accessToken}
   * @see {@link solace.SessionProperties#idToken}
   * @see {@link solace.SessionProperties#issuerIdentifier}
   * @type {String}
   */
                    OAUTH2: "AuthenticationScheme_oauth2"
                };
                module.exports.AuthenticationScheme = Enum.new(AuthenticationScheme);
                /***/
            },
            /***/ "./modules/solclient-session/lib/capability-types.js": 
            /*!***********************************************************!*\
  !*** ./modules/solclient-session/lib/capability-types.js ***!
  \***********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Represents an enumeration of peer capabilities.
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
                const CapabilityType = {
                    /**
   * Peer's software load version. Type: string.
   */
                    PEER_SOFTWARE_VERSION: 0,
                    /**
   * Peer's software release date. Type: string.
   */
                    PEER_SOFTWARE_DATE: 1,
                    /**
   * Peer's platform. Type: string.
   */
                    PEER_PLATFORM: 2,
                    /**
   * Speed (in Mbps) of the port the client connects to. Type: number.
   */
                    PEER_PORT_SPEED: 3,
                    /**
   * Type of the port the client has connected to (currently 0: Ethernet). Type: number.
   */
                    PEER_PORT_TYPE: 4,
                    /**
   * Maximum size of a Direct message (in bytes), including all optional message headers and data.
   * Type: number.
   */
                    MAX_DIRECT_MSG_SIZE: 5,
                    /**
   * Peer's router name. Type: string.
   *
   * This property is useful when sending SEMP requests to a peer's SEMP topic, which may be
   * constructed as `#P2P/routername/#client/SEMP`.
   */
                    PEER_ROUTER_NAME: 6,
                    /**
   * Peer supports message eliding. Type: boolean.
   */
                    MESSAGE_ELIDING: 7,
                    /**
   * Peer supports NoLocal option (client may avoid receiving messages published by itself).
   */
                    NO_LOCAL: 8,
                    /**
   * Peer supports Guaranteed Message Consumer connections for receiving guaranteed messages.
   */
                    GUARANTEED_MESSAGE_CONSUME: 9,
                    /**
   * Peer supports temporary endpoints.
   */
                    TEMPORARY_ENDPOINT: 10,
                    /**
   * Peer supports Guaranteed Message Publisher connections for sedning guaranteed messages.
   */
                    GUARANTEED_MESSAGE_PUBLISH: 11,
                    /**
   * Peer supports Guaranteed Messages Browser connections for receiving guaranteed messages
   */
                    GUARANTEED_MESSAGE_BROWSE: 12,
                    /**
   * Peer supports creating/modify/disposing endpoints.
   */
                    ENDPOINT_MGMT: 13,
                    /**
   * Peer supports selectors on Guaranteed Message Consumers.
   */
                    SELECTOR: 14,
                    /**
   * Maximum size of a Direct message (in bytes), including all optional message headers and data.
   * Type: number.
   */
                    MAX_GUARANTEED_MSG_SIZE: 15,
                    /**
   * Peer supports Guaranteed Messaging Consumer state change updates. Type: boolean
   */
                    ACTIVE_CONSUMER_INDICATION: 16,
                    /**
   * Peer accepts compressed (DEFLATE) data. Type: boolean.
   */
                    COMPRESSION: 17,
                    /**
   * Peer supports Guaranteed Messaging cut-through. Type: boolean
   */
                    CUT_THROUGH: 18,
                    /**
   * Peer supports provisioned queue and topic-endpoint discard behavior. Type: boolean
   */
                    ENDPOINT_DISCARD_BEHAVIOR: 19,
                    /**
   * Peer supports Guaranteed Messaging message TTL and Dead-Message Queues. Type: boolean
   */
                    ENDPOINT_MESSAGE_TTL: 20,
                    /**
   * Peer accepts JNDI queries. Type: boolean.
   */
                    JNDI: 21,
                    /**
   * Peer supports per topic sequence numbering for Guaranteed Messaging messages. Type: boolean
   */
                    PER_TOPIC_SEQUENCE_NUMBERING: 22,
                    /**
   * Peer supports QueueSubscriptionAdd for managing subscriptions on queue endpoints.
   * Type: boolean
   */
                    QUEUE_SUBSCRIPTIONS: 23,
                    /**
   * Peer supports add/remove subscriptions for a specified clientName. Type: boolean
   */
                    SUBSCRIPTION_MANAGER: 24,
                    /**
   * Peer supports transacted sessions. Type: boolean.
   */
                    TRANSACTED_SESSION: 25,
                    /**
   * Peer support Message Replay. Type: boolean.
   */
                    MESSAGE_REPLAY: 26,
                    /**
   * Peer supports TLS downgrade to compression (encrypted and plaintext) Type: boolean
   */
                    COMPRESSED_SSL: 27,
                    /**
   * The peer can support \#share and \#noexport subscriptions
   * Type: Boolean
   */
                    SHARED_SUBSCRIPTIONS: 28,
                    /**
   * The EndpointErrorId in replay bind responses can be trusted.
   */
                    BR_REPLAY_ERRORID: 29
                };
                /**
 * Represents an enumeration of client capabilities.
 * These are sent in the ClientCtrl login messages.
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
                const ClientCapabilityType = {
                    /**
   * Client implements acknowledgements to router unsolicited unbinds.
   * Always true.
   */
                    UNBIND_ACK: 0,
                    /**
   * Indicates whether a client will process an EndpointErrorId in a BindResponse message.
   * Always true
   */
                    BR_ERRORID: 1
                };
                module.exports.CapabilityType = Enum.new(CapabilityType);
                module.exports.ClientCapabilityType = Enum.new(ClientCapabilityType);
                /***/
            },
            /***/ "./modules/solclient-session/lib/correlated-request.js": 
            /*!*************************************************************!*\
  !*** ./modules/solclient-session/lib/correlated-request.js ***!
  \*************************************************************/
            /***/ module => {
                class CorrelatedRequest {
                    /**
   * Creates an instance of CorrelatedRequest.
   * @param {String} correlationTag The associated tag
   * @param {?} timer The opaque timer handle
   * @param {String} correlationKey The associated key
   * @param {function} respRecvdCallback The associated callback
   * @memberof CorrelatedRequest
   * @private
   */
                    constructor(correlationTag, timer, correlationKey, respRecvdCallback) {
                        this.correlationTag = correlationTag;
                        this.timer = timer;
                        this.correlationKey = correlationKey;
                        this.respRecvdCallback = respRecvdCallback;
                    }
                }
                module.exports.CorrelatedRequest = CorrelatedRequest;
                /***/
            },
            /***/ "./modules/solclient-session/lib/default-capabilities.js": 
            /*!***************************************************************!*\
  !*** ./modules/solclient-session/lib/default-capabilities.js ***!
  \***************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    CapabilityType
                } = __webpack_require__(/*! ./capability-types */ "./modules/solclient-session/lib/capability-types.js");
                module.exports.DefaultCapabilities = {
                    createDefaultCapabilities(sessionProperties) {
                        const defaultCapabilities = {
                            [CapabilityType.GUARANTEED_MESSAGE_CONSUME]: true,
                            [CapabilityType.GUARANTEED_MESSAGE_PUBLISH]: true,
                            [CapabilityType.SHARED_SUBSCRIPTIONS]: true,
                            // The others are set TRUE by CCSMP, but not relevant for us yet
                            // [CapabilityType.TEMPORARY_ENDPOINT]:   true,
                            // [CapabilityType.GUARANTEED_MESSAGE_BROWSE]:         true,
                            // [CapabilityType.ENDPOINT_MGMT]:        true,
                            // [CapabilityType.SELECTOR]:             true,
                            // [CapabilityType.COMPRESSION]:          true,
                            // [CapabilityType.CUT_THROUGH]:          true,
                            // [CapabilityType.QUEUE_SUBSCRIPTIONS]:  true,
                            // [CapabilityType.SUBSCRIPTION_MANAGER]: true,
                            [CapabilityType.MAX_GUARANTEED_MSG_SIZE]: sessionProperties.assumedMaxAdSize
                        };
                        return defaultCapabilities;
                    }
                };
                /***/
            },
            /***/ "./modules/solclient-session/lib/global-context.js": 
            /*!*********************************************************!*\
  !*** ./modules/solclient-session/lib/global-context.js ***!
  \*********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Process
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const C_2_32 = Math.pow(2, 32);
                function leftPad(str, len) {
                    if (len > str.length) {
                        return "0".repeat(len - str.length) + str;
                    }
                    return str;
                }
                function generateRandomId() {
                    const rand = (Math.random() * C_2_32).toFixed(0);
                    return leftPad(rand.toString(), 10);
                }
                /**
 * @private
 */
                const GlobalContext = {
                    sessionCounter: 0,
                    idCounter: 0,
                    RandId: generateRandomId(),
                    NextSessionCounter() {
                        const count = ++this.sessionCounter;
                        return leftPad(count.toString(), 4);
                    },
                    NextId() {
                        return ++this.idCounter;
                    },
                    GenerateClientName() {
                        const {
                            product,
                            platform
                        } = Process;
                        const result = `${product}/${platform}/${this.RandId}/${this.NextSessionCounter()}`;
                        return result;
                    },
                    GenerateUserIdentification() {
                        const {
                            product,
                            platform
                        } = Process;
                        return `${product}/${platform}/${this.RandId}`;
                    },
                    GenerateClientDescription() {
                        return `solclientjs/${Process.description}`.substring(0, 254);
                    }
                };
                module.exports.GlobalContext = GlobalContext;
                /***/
            },
            /***/ "./modules/solclient-session/lib/host-list-dns-filter.js": 
            /*!***************************************************************!*\
  !*** ./modules/solclient-session/lib/host-list-dns-filter.js ***!
  \***************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    LOG_TRACE
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    parseURL
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                let hostListDNSFilter;
                if (false) {} else {
                    /* eslint-env browser */
                    // Create an always-async callback that allows all hosts.
                    //hostListDNSFilter = (urls, cb) => setImmediate(() => {
                    hostListDNSFilter = (urls, cb) => setTimeout(() => {
                        try {
                            const result = urls.map(url => {
                                const host = parseURL(url).host;
                                return {
                                    url: url,
                                    host: host,
                                    address: host,
                                    resolved: false
                                };
                            });
                            return cb(null, result);
                        } catch (e) {
                            return cb(e);
                        }
                    }, 0);
                }
                module.exports.hostListDNSFilter = hostListDNSFilter;
                /***/
            },
            /***/ "./modules/solclient-session/lib/host-list.js": 
            /*!****************************************************!*\
  !*** ./modules/solclient-session/lib/host-list.js ***!
  \****************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    assert
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                const {
                    hostListDNSFilter
                } = __webpack_require__(/*! ./host-list-dns-filter */ "./modules/solclient-session/lib/host-list-dns-filter.js");
                const {
                    LogFormatter
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    parseURL
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                function parseURLs(rawURLs) {
                    if (Array.isArray(rawURLs)) {
                        return rawURLs.map(rawURL => parseURL(rawURL));
                    }
                    return parseURLs(rawURLs.split(/[,;]/));
                }
                /*
 *   "When using a host list, each time the API works through the host list without establishing
 *    a connection is considered an connect retry."
 *   SESSION_CONNECT_RETRIES: "When using a host list, this property defines how many times to
 *    try to connect or reconnect to a single host before moving to the next host in the list."
 *   Details: http://docs.solace.com/Solace-Messaging-APIs/Configuring-Connection-T.htm
*/
                // In general:
                // * set initial state to invalid so that we begin needing a transition.
                // * preincrement all try counts on transition.
                // Specifics:
                // * Select try count for entire list based on whether we were connected.
                // * Try count per host is the same for both connect and reconnect.
                // * When the host changes, the waitTime is 0.
                // * Overriding the above, when the host pointer wraps to 0, the waitTime is nonzero.
                class HostInfo {
                    constructor(props = {
                        url: null,
                        waitTime: 0
                    }) {
                        Object.assign(this, props);
                    }
                }
                /**
 * @private
 */
                class HostList {
                    constructor({
                        url,
                        connectRetries,
                        reconnectRetries,
                        connectRetriesPerHost,
                        reconnectRetryWaitInMsecs
                    } = {}) {
                        Object.assign(this, {
                            hosts: parseURLs(url).map(e => e.href),
                            // How many times will we traverse the host list without success?
                            // Try to connect one more than the 'retryCount' because we always try once.
                            connectTryCount: connectRetries === -1 ? Number.POSITIVE_INFINITY : connectRetries + 1,
                            // How many times will we traverse the host list after success?
                            reconnectTryCount: reconnectRetries === -1 ? Number.POSITIVE_INFINITY : reconnectRetries,
                            // A value of 1 in the next assignements means retry forever - "null" will mean that
                            // try to connect one more than the 'retryCount' because we always try once.
                            connectTryCountPerHost: connectRetriesPerHost === -1 ? Number.POSITIVE_INFINITY : connectRetriesPerHost + 1,
                            // How long do we wait before reattempting the same host or wrapping around the list?
                            reconnectRetryWaitInMsecs: reconnectRetryWaitInMsecs,
                            // Mutating operations affect only this.
                            _mutableState: {},
                            logger: new LogFormatter("[host-list]")
                        });
                        assert(this.hosts.length >= 1);
                        assert(this.connectTryCount >= 1);
                        assert(this.reconnectTryCount >= 0);
                        assert(this.connectTryCountPerHost >= 1);
                    }
                    /**
   * Call before first getNextHost() to validate that at least one URL contains a reachable
   * hostname.
   * @param {function(Error)} callback The callback to invoke when DNS resolution completes
   */
                    resolveHosts(callback) {
                        const {
                            LOG_TRACE,
                            LOG_WARN
                        } = this.logger;
                        hostListDNSFilter(this.hosts, (err, resolved) => {
                            // Exit immediately if the filter threw.
                            if (err) return callback(err);
                            assert(resolved.length === this.hosts.length, "Resolve did not return a result for all hosts");
                            LOG_TRACE("Resolve result", resolved);
                            let succeeded = 0;
                            resolved.forEach(result => {
                                if (result.address) {
                                    ++succeeded;
                                }
                                if (!result.resolved) {
                                    // Only log if the lookup was actually performed
                                    return;
                                }
                                if (result.address) {
                                    LOG_TRACE("DNS resolve OK:    ", result.address, "for", result.url);
                                } else {
                                    LOG_WARN("DNS resolve FAILED:", result.error.code, `${result.error.syscall}('${result.error.hostname}')`, "for", result.url);
                                }
                            });
                            return callback(succeeded === 0 ? "All hosts failed DNS resolution" : null);
                        });
                    }
                    /**
   * @param {Object} state Properties for host selection logic
   * @memberof HostList
   */
                    reset(state = {
                        wasConnected: false,
                        disconnected: false
                    }) {
                        // On reset, we always return to the beginning of the host list.
                        // This facilitates DR recovery by returning to the primary router.
                        // Set an invalid initial state that will trigger our first try.
                        Object.assign(this._mutableState, {
                            wasConnected: state.wasConnected,
                            disconnected: state.disconnected,
                            hostPointer: 0,
                            hostTries: 0,
                            listTries: 1,
                            exhausted: false,
                            lastHostInfo: new HostInfo()
                        });
                    }
                    /**
   * !returns {HostInfo} Connection information for the next host.
   * @returns {String} The URL for the next host
   * @memberof HostList
   */
                    getNextHost() {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        const state = this._mutableState;
                        const wasConnected = state.wasConnected;
                        const lastHostInfo = state.lastHostInfo;
                        assert(lastHostInfo, "Next host request with no prior host info -- did you call reset()?");
                        // Using a try/finally as a "goto end" to always log final state. Exceptions not expected
                        // here, although if an assertion fails, the finally log should be helpful.
                        try {
                            // If this was passed into reset, the session is telling us to enforce no more hosts.
                            if (state.disconnected) {
                                LOG_TRACE("Host list set to disconnected, providing null next host");
                                return null;
                            }
                            // If exhausted, this function has returned a null url already.
                            assert(!state.exhausted, "Next host request after host list exhausted");
                            // Pull immutable properties from the instance
                            const properties = Object.assign({
                                hosts: this.hosts,
                                hostTriesMax: this.connectTryCountPerHost,
                                listTriesMax: wasConnected ? this.reconnectTryCount : this.connectTryCount
                            });
                            LOG_TRACE("Getting next host\n", "properties", properties, "\nstate", state);
                            LOG_TRACE("Last host", lastHostInfo);
                            // Initial state was valid. This is a host try. Increment.
                            ++state.hostTries;
                            if (state.hostTries > properties.hostTriesMax) {
                                // Increment host pointer, possibly putting it out of bounds.
                                LOG_TRACE(`Exhausted ${state.hostTries} host tries for host ${lastHostInfo.url}.`);
                                ++state.hostPointer;
                                // If the host pointer is out of bounds, we are beginning a new list try.
                                // It was either set out of bounds deliberately by reset() or it was
                                // incremented out of bounds above.
                                if (state.hostPointer >= properties.hosts.length) {
                                    // This is a new list try.
                                    ++state.listTries;
                                    if (state.listTries > properties.listTriesMax) {
                                        // Beginning this list try has exceeded our inclusive max. The host list is
                                        // exhausted.
                                        LOG_TRACE(`Exhausted host list at ${properties.listTriesMax} traversals.`);
                                        state.exhausted = true;
                                    } else {
                                        // Resetting the host pointer to begin this list try.
                                        LOG_TRACE(`Host list try (${state.listTries}/${properties.listTriesMax})`);
                                        state.hostPointer = 0;
                                        state.hostTries = 1; // this is the first try for this host
                                    }
                                } else {
                                    state.hostTries = 1; // this is the first try for this host
                                }
                            } else {
                                // Continue with this host.
                                LOG_TRACE(`Host try (${state.hostTries}/${properties.hostTriesMax})`);
                            }
                            if (state.exhausted) {
                                LOG_TRACE("All hosts exhausted");
                                return null;
                            }
                            // Beyond this point, expect a valid host to be returned.
                            const url = properties.hosts[state.hostPointer];
                            assert(url, `No host at the host pointer! ${properties.hosts}[${state.hostPointer}]`);
                            // Wait time conditions:
                            // 1. On a new list (invalid lastHostInfo), zero waitTime.
                            const isNewList = lastHostInfo.url === null;
                            // 2a. On a new host, zero waitTime...
                            const isNewHost = lastHostInfo.url !== url;
                            // 2b. ...unless we are just restarting the list.
                            const didJustFinishList = lastHostInfo.url !== url && state.hostPointer === 0;
                            // (2b negates 2a for a new list)
                            const waitTime = isNewList || isNewHost && !didJustFinishList ? 0 : this.reconnectRetryWaitInMsecs;
                            // Session FSM was intended to use all of these, but handles its own events presently
                            // and expects waitTime to be a property of the list that mutates per host, so that is
                            // what is done.
                            const hostInfo = new HostInfo({
                                url: url,
                                waitTime: waitTime
                            });
                            // Set last host for next time, and return
                            LOG_TRACE("Returning host from", hostInfo);
                            state.lastHostInfo = hostInfo;
                            return hostInfo.url;
                        } finally {
                            LOG_TRACE("Final list state\n", state);
                        }
                    }
                    get connectWaitTimeInMsecs() {
                        assert(this._mutableState.lastHostInfo.url, "Getting connectWaitTimeInMsecs having never called getNextHostInfo");
                        return this._mutableState.lastHostInfo.waitTime;
                    }
                    currentHostToString() {
                        const state = this._mutableState;
                        const wasConnected = state.wasConnected;
                        // Pull immutable properties from the instance
                        const properties = Object.assign({
                            hosts: this.hosts,
                            hostTriesMax: this.connectTryCountPerHost,
                            listTriesMax: wasConnected ? this.reconnectTryCount : this.connectTryCount
                        });
                        // host pointer is zero based index into the host list
                        // so translate it to a human readable index
                        const hostNumber = state.hostPointer + 1;
                        return `host '${state.lastHostInfo.url}' (host ${hostNumber} of ${properties.hosts.length})(host connection attempt ${state.hostTries} of ${properties.hostTriesMax})(total ${wasConnected ? "reconnection" : "connection"} attempt ${state.listTries} of ${properties.listTriesMax})`;
                    }
                }
                module.exports.HostList = HostList;
                /***/
            },
            /***/ "./modules/solclient-session/lib/message-rx-cb-info.js": 
            /*!*************************************************************!*\
  !*** ./modules/solclient-session/lib/message-rx-cb-info.js ***!
  \*************************************************************/
            /***/ module => {
                /**
 * @classdesc
 *
 * Encapsulates the session's message receive callback function and
 * an optional user-specified object.
 *
 * This class is passed to {@link solace.SolclientFactory.createSession} when creating a session.
 * @deprecated The {@link solace.Session} is an <b>EventEmitter</b>.
 * Use <tt>sessionObject.on({@link solace.SessionEventCode.MESSAGE})</tt> instead.
 *
 * @memberof solace
 */
                class MessageRxCBInfo {
                    /**
   * Creates an instance of MessageRxCBInfo.
   *
   * @param {function(Session, Message, Object)} messageRxCBFunction
   *          Invoked by the API when a message is received
   *          over the session. The prototype of this function is the
   *          following: ({@link solace.Session},
   *                      {@link solace.Message},
   *                      {Object})
   * @param {Object} userObject
   *          An optional user-specified object passed on every message receive callback.
   *
   * @memberof solace
   */
                    constructor(messageRxCBFunction, userObject) {
                        /**
     * @type {function(Session, Message, Object)}
     * @description The prototype of this function is the
     * following: ({@link solace.Session}, {@link solace.Message}, userObject {Object})
     */
                        this.messageRxCBFunction = messageRxCBFunction;
                        /**
     * @type {Object}
     * @description user-specified object
     */
                        this.userObject = userObject;
                    }
                }
                module.exports.MessageRxCBInfo = MessageRxCBInfo;
                /***/
            },
            /***/ "./modules/solclient-session/lib/mutable-session-properties.js": 
            /*!*********************************************************************!*\
  !*** ./modules/solclient-session/lib/mutable-session-properties.js ***!
  \*********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Represents an enumeration of session properties that can be modified by
 * {@link solace.Session.updateProperty} after the {@link solace.Session} is originally
 * created.
 *
 * These correspond to session properties in {@link solace.SessionProperties}.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
                const MutableSessionProperty = {
                    /**
   * Client name: {@link solace.SessionProperties#clientName}
   * @type {Number}
   */
                    CLIENT_NAME: 1,
                    /**
   * Application description: {@link solace.SessionProperties#applicationDescription}
   * @type {Number}
   */
                    CLIENT_DESCRIPTION: 2
                };
                module.exports.MutableSessionProperty = Enum.new(MutableSessionProperty);
                /***/
            },
            /***/ "./modules/solclient-session/lib/outstanding-data-request.js": 
            /*!*******************************************************************!*\
  !*** ./modules/solclient-session/lib/outstanding-data-request.js ***!
  \*******************************************************************/
            /***/ module => {
                /**
 * @private
 */
                class OutstandingDataRequest {
                    constructor(correlationId, timer, replyReceivedCBFunction, reqFailedCBFunction, userObject) {
                        this.correlationId = correlationId;
                        this.timer = timer;
                        this.replyReceivedCBFunction = replyReceivedCBFunction;
                        this.reqFailedCBFunction = reqFailedCBFunction;
                        this.userObject = userObject;
                    }
                }
                module.exports.OutstandingDataRequest = OutstandingDataRequest;
                /***/
            },
            /***/ "./modules/solclient-session/lib/p2p-util.js": 
            /*!***************************************************!*\
  !*** ./modules/solclient-session/lib/p2p-util.js ***!
  \***************************************************/
            /***/ module => {
                const P2PUtil = {
                    getP2PInboxTopic(base) {
                        return `${base}/_`;
                    },
                    getP2PTopicSubscription(base) {
                        return `${base}/>`;
                    }
                };
                module.exports.P2PUtil = P2PUtil;
                /***/
            },
            /***/ "./modules/solclient-session/lib/session-event-cb-info.js": 
            /*!****************************************************************!*\
  !*** ./modules/solclient-session/lib/session-event-cb-info.js ***!
  \****************************************************************/
            /***/ module => {
                /**
 * @classdesc
 * Encapsulates the session's event callback function and an optional user-specified object.
 *
 * This class is passed to {@link solace.SolclientFactory.createSession} when creating a session.
 * @deprecated The {@link solace.Session} is an <b>EventEmitter</b>.  Register event handlers
 * against {@link solace.SessionEventCode} events instead.
 *
 * @memberof solace
 */
                class SessionEventCBInfo {
                    /**
   * Creates an instance of SessionEventCBInfo.
   *
   * @param {function(Session, SessionEvent, Object, Object)} sessionEventCBFunction
   *  invoked by the Messaging API when a session event occurs. The prototype
   *  of this function is the following: ({@link solace.Session},
   *                                      {@link solace.SessionEvent},
   *                                      {Object}})
   * @param {Object} userObject An optional user-specified object passed on
   * every session event callback.
   */
                    constructor(sessionEventCBFunction, userObject) {
                        /**
     * @type {Object}
     * @description user-specified object
     */
                        this.userObject = userObject;
                        /**
     * @type {function}
     * @description The prototype of this function is the
     * following:
     * ({@link solace.Session}, {@link solace.SessionEvent},
     * userObject {Object}, RFUObject {Object})
     */
                        this.sessionEventCBFunction = sessionEventCBFunction;
                    }
                }
                module.exports.SessionEventCBInfo = SessionEventCBInfo;
                /***/
            },
            /***/ "./modules/solclient-session/lib/session-event-codes.js": 
            /*!**************************************************************!*\
  !*** ./modules/solclient-session/lib/session-event-codes.js ***!
  \**************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * @callback solace.SessionEventCodes.sessionEvent
 * @function
 * @this {solace.Session} The message consumer for the event
 * @param {solace.SessionEvent|solace.OperationError} event The event. If the event is an
 *  error, the event will be an instance of {@link solace.OperationError} but will also be
 *  interface-compatible with {@link solace.SessionEvent}.
 */
                /**
 * An attribute of {@link SessionEvent}. This enumeration represents the
 * different events emitted by {@link Session} through the session event
 * callback.
 *
 * When a session is no longer in a usable state, the API tears down the underlying
 * connection and notifies the application with one of the following session events:
 *  * {@link solace.SessionEventCode#event:DOWN_ERROR}
 *  * {@link solace.SessionEventCode#event:CONNECT_FAILED_ERROR}
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
                const SessionEventCode = {
                    /**
   * The Session is ready to send/receive messages and perform control operations.
   *
   * At this point the transport session is up, the Session has logged in, and the
   * P2PInbox subscription is added.
   *
   * The session is established.
   * @event solace.SessionEventCode#UP_NOTICE
   */
                    UP_NOTICE: 0,
                    /**
   * The session was established and then went down.
   * @event solace.SessionEventCode#DOWN_ERROR
   * @param {solace.OperationError} error The details related to the session failure.
   */
                    DOWN_ERROR: 1,
                    /**
   * The session attempted to connect but was unsuccessful.
   * @event solace.SessionEventCode#CONNECT_FAILED_ERROR
   * @param {solace.OperationError} error The details related to the failed connection attempt.
   */
                    CONNECT_FAILED_ERROR: 2,
                    /**
   * The Solace Message Router rejected a published message.
   * @event solace.SessionEventCode#REJECTED_MESSAGE_ERROR
   * @param {solace.RequestError} error The details related to the rejected message.
   */
                    REJECTED_MESSAGE_ERROR: 4,
                    /**
   * The Solace Message Router rejected a subscription (add or remove).
   * @event solace.SessionEventCode#SUBSCRIPTION_ERROR
   * @param {solace.RequestError} error The details related to the failed subscription update.
   */
                    SUBSCRIPTION_ERROR: 5,
                    /**
   * The subscribe or unsubscribe operation succeeded.
   * @event solace.SessionEventCode#SUBSCRIPTION_OK
   * @param {solace.SessionEvent} event The details related to the successful subscription update.
   */
                    SUBSCRIPTION_OK: 6,
                    /**
   * The Solace Message Router's Virtual Router Name changed during a reconnect operation.
   * @event solace.SessionEventCode#VIRTUALROUTER_NAME_CHANGED
   * @param {solace.SessionEvent} event Information related to the event.
   */
                    VIRTUALROUTER_NAME_CHANGED: 7,
                    /**
   * @deprecated
   * A request was aborted because the session is being disconnected.
   * Use {@link solace.RequestFailEvent} instead.
   */
                    REQUEST_ABORTED: 8,
                    /**
   * @deprecated
   * The event represents a timed-out request API call.
   * Use {@link solace.RequestFailEvent} instead.
   */
                    REQUEST_TIMEOUT: 9,
                    /**
   * The event represents a successful update of a mutable session property.
   * @event solace.SessionEventCode#PROPERTY_UPDATE_OK
   * @param {solace.SessionEvent} event Information related to the successful property update.
   */
                    PROPERTY_UPDATE_OK: 10,
                    /**
   * The event represents a failed update of a mutable session property.
   * @event solace.SessionEventCode#PROPERTY_UPDATE_ERROR
   * @param {solace.RequestError} error The details related to the failed property update.
   */
                    PROPERTY_UPDATE_ERROR: 11,
                    /**
   * The session transport can accept data again.  This event will occur after an
   * {@link solace.OperationError} is thrown from an API call with a subcode of
   * {@link solace.ErrorSubcode.INSUFFICIENT_SPACE} to indicate the operation can be retried.
   * This event is used both after session-level transport buffer exhaustion,
   * and Guaranteed Messaging Window exhaustion.
   * @event solace.SessionEventCode#CAN_ACCEPT_DATA
   */
                    CAN_ACCEPT_DATA: 13,
                    /**
   * The session connect operation failed, or the session that was once up,
   * is now disconnected.
   * @event solace.SessionEventCode#DISCONNECTED
   */
                    DISCONNECTED: 14,
                    /**
   * The session has gone down, and an automatic reconnection attempt is in progress.
   * @event solace.SessionEventCode#RECONNECTING_NOTICE
   * @param {solace.SessionEvent} event The details related to the cause of the connection
   *    interruption.
   */
                    RECONNECTING_NOTICE: 22,
                    /**
   * The automatic reconnect of the Session was successful, and the session is established again.
   * @event solace.SessionEventCode#RECONNECTED_NOTICE
   * @param {solace.SessionEvent} event The details related to the re-establishment of the
   *    connection.
   */
                    RECONNECTED_NOTICE: 23,
                    /**
   * The session has automatically recovered after the Guaranteed Message publisher
   * failed to reconnect.
   * Messages sent but not acknowledged are being renumbered and retransmitted.
   * Some messages may be duplicated in the system.
   * @event solace.SessionEventCode#REPUBLISHING_UNACKED_MESSAGES
   * @param {solace.SessionEvent} event The details related to the republishing of messages on the
   *    session.  {@link solace.SessionEvent#infoStr} will indicate the number of messages being
   *    republished, which is an upper bound on the number of messages that could be duplicated due
   *    to this action.
   */
                    REPUBLISHING_UNACKED_MESSAGES: 24,
                    /**
   * A message was acknowledged by the router.
   * @event solace.SessionEventCode#ACKNOWLEDGED_MESSAGE
   * @param {solace.SessionEvent} event Allows the acknowledgement to be correlated to the sent
   *    message.
   */
                    ACKNOWLEDGED_MESSAGE: 25,
                    /**
   * Unsubscribing the topic from the Durable Topic Endpoint succeeded.
   * @event solace.SessionEventCode#UNSUBSCRIBE_TE_TOPIC_OK
   */
                    UNSUBSCRIBE_TE_TOPIC_OK: 26,
                    /**
   * Unsubscribing the topic from the Durable Topic Endpoint failed.
   * @event solace.SessionEventCode#UNSUBSCRIBE_TE_TOPIC_ERROR
   * @param {solace.OperationError} error The details related to the failed attempt to remove the
   *    subscription from a topic endpoint.
   */
                    UNSUBSCRIBE_TE_TOPIC_ERROR: 27,
                    /**
   * A Direct message was received on the session. This event code is only used
   * on the <b>EventEmitter</b> session interface.  If using the deprecated callback interface,
   * messages are received via the callback provided in {@link solace.MessageRxCBInfo}.
   * @event solace.SessionEventCode#MESSAGE
   * @param {solace.Message} message The message received on the session.
   */
                    MESSAGE: 28,
                    /**
   * Guaranteed Messaging Publisher has been closed by the Solace
   * message router. This usually indicates an operator has disabled the
   * message spool.
   * @event solace.SessionEventCode#GUARANTEED_MESSAGE_PUBLISHER_DOWN
   * @param {solace.OperationError} error Information related to the error.
   */
                    GUARANTEED_MESSAGE_PUBLISHER_DOWN: 29
                };
                module.exports.SessionEventCode = Enum.new(SessionEventCode);
                /***/
            },
            /***/ "./modules/solclient-session/lib/session-event-names.js": 
            /*!**************************************************************!*\
  !*** ./modules/solclient-session/lib/session-event-names.js ***!
  \**************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * @private
 * @enum {number}
 */
                const SessionEventName = {
                    CONNECT: "SessionConnect",
                    DISCONNECT: "SessionDisconnect",
                    DISPOSE: "SessionDispose",
                    CONNECT_TIMEOUT: "SessionConnectTimeout",
                    CONNECT_WAIT_TIMEOUT: "SessionConnectWaitTimeout",
                    DOWNGRADE_TIMEOUT: "SessionDowngradeTimeout",
                    TRANSPORT_UP: "SessionTransportUp",
                    TRANSPORT_DESTROYED: "SessionTransportDestroyed",
                    TRANSPORT_CAN_ACCEPT_DATA: "SessionTransportCanAcceptData",
                    TRANSPORT_PARSE_ERROR: "SessionTransportParseError",
                    TRANSPORT_PROTOCOL_SMP: "SessionSMPMessage",
                    TRANSPORT_PROTOCOL_CLIENTCTRL: "SessionClientCtrlMessage",
                    EXCEPTION: "SessionException",
                    SUBSCRIBE_TIMEOUT: "SessionSubscribeTimeout",
                    CREATE_SUBSCRIBER: "SessionCreateSubscriber",
                    FLOW_UP: "SessionFlowUp",
                    FLOW_FAILED: "SessionFlowFailed",
                    SEND_ERROR: "SessionSendError",
                    FLOWS_DISCONNECTED: "SessionFlowsDisconnected",
                    TRANSPORT_FLUSHED: "SessionTransportFlushed",
                    DNS_RESOLUTION_COMPLETE: "SessionDNSResolutionComplete",
                    TRANSPORT_CHANGE_DONE: "SessionTransportChangeDone"
                };
                module.exports.SessionEventName = Enum.new(SessionEventName);
                /***/
            },
            /***/ "./modules/solclient-session/lib/session-event.js": 
            /*!********************************************************!*\
  !*** ./modules/solclient-session/lib/session-event.js ***!
  \********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /* provided dependency */ var util_inspect = __webpack_require__(/*! browser-util-inspect */ "./node_modules/browser-util-inspect/index.js");
                const {
                    ErrorSubcode,
                    OperationError,
                    RequestError,
                    RequestEventCode
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    SessionEventCode
                } = __webpack_require__(/*! ./session-event-codes */ "./modules/solclient-session/lib/session-event-codes.js");
                function buildType(Superclass) {
                    /**
   * @classdesc
   * Represents a session event; events are passed to the application-provided
   * event handling callback provided when creating the session.
   * @memberof solace
   * @hideconstructor
   */
                    class SessionEvent extends Superclass {
                        /**
     * @constructor
     * @param {Array} superclassArgs Args to pass to super
     * @param {solace.SessionEventCode} sessionEventCode The event code
     * @param {String} infoStr Information string
     * @param {Number} [responseCode] Any associated router response code
     * @param {solace.ErrorSubcode} [errorSubcode] Any associated error subcode
     * @param {Object} [correlationKey] Any associated correlation key
     * @param {String} [reason] Any additional information
     * @private
     */
                        constructor(superclassArgs, sessionEventCode, infoStr, responseCode = undefined, errorSubcode = 0, correlationKey = undefined, reason = undefined) {
                            super(...superclassArgs);
                            this._sessionEventCode = sessionEventCode;
                            this._infoStr = infoStr;
                            this._responseCode = responseCode;
                            this._errorSubcode = errorSubcode;
                            this._correlationKey = correlationKey; // optional
                            this._reason = reason; // optional
                        }
                        /**
     * @type {solace.SessionEventCode}
     * @description Further qualifies the session event.
     */
                        get sessionEventCode() {
                            return this._sessionEventCode;
                        }
                        /**
     * @type {String}
     * @description if applicable, an information string returned by the Solace Message Router.
     */
                        get infoStr() {
                            return this._infoStr;
                        }
                        /**
     * @type {?Number}
     * @description if applicable, a response code returned by the Solace Message Router.
     */
                        get responseCode() {
                            return this._responseCode;
                        }
                        /**
     * @type {?solace.ErrorSubcode}
     * @description if applicable, an error subcode. Defined in {@link solace.ErrorSubcode}
     */
                        get errorSubcode() {
                            // _eslint-disable-next-line quote-property
                            return this.subcode || this._errorSubcode;
                        }
                        /**
     * @deprecated Use {@link solace.SessionEvent#errorSubcode} instead.
     * @readonly
     */
                        // coverity[identifier_typo]
                        get errorSubCode() {
                            return this.errorSubcode;
                        }
                        /**
     * @type {?Object}
     * @description A user-specified object
     * made available in the response or confirmation event by including it as a
     * parameter in the orignal API call.  If the user did not specify a
     * correlationKey, it will be <code>null</code>.
     */
                        get correlationKey() {
                            return this._correlationKey;
                        }
                        /**
     * @type {?String}
     * @description Additional information if it is applicable.
     * In case of subscribe or publish errors, it constains the topic.
     */
                        get reason() {
                            return this._reason;
                        }
                        /**
     * @param {Object} value The reason info object
     * @internal
     */
                        set reason(value) {
                            this._reason = value;
                        }
                        ["inspect"]() {
                            // Is this supposed to invoke the custom inspect function of the superclass if it exists?
                            return Object.assign(super["inspect"] || {}, {
                                sessionEventCode: SessionEventCode.describe(this.sessionEventCode),
                                infoStr: this.infoStr,
                                responseCode: this.responseCode,
                                errorSubcode: ErrorSubcode.describe(this.errorSubcode),
                                correlationKey: this.correlationKey ? this.correlationKey.toString() : null,
                                reason: this.reason ? this.reason : null
                            });
                        }
                        toString() {
                            return util_inspect(this);
                        }
                    }
                    return SessionEvent;
                }
                const SUPERCLASS_FOR_SESSION_EVENT = {
                    [SessionEventCode.CONNECT_FAILED_ERROR]: OperationError,
                    [SessionEventCode.DOWN_ERROR]: OperationError,
                    [SessionEventCode.GUARANTEED_MESSAGE_PUBLISHER_DOWN]: OperationError,
                    [SessionEventCode.PROPERTY_UPDATE_ERROR]: RequestError,
                    [SessionEventCode.REJECTED_MESSAGE_ERROR]: RequestError,
                    [SessionEventCode.SUBSCRIPTION_ERROR]: RequestError,
                    [SessionEventCode.UNSUBSCRIBE_TE_TOPIC_ERROR]: OperationError,
                    [RequestEventCode.REQUEST_ABORTED]: RequestError,
                    [RequestEventCode.REQUEST_TIMEOUT]: RequestError
                };
                const SUPERCLASS_ARGS = new Map().set(Object, () => []).set(OperationError, (sec, infoStr, rc, subcode, ck, reason) => [ infoStr, subcode, reason ]).set(RequestError, (sec, infoStr, rc, subcode, ck, reason) => [ infoStr, sec, ck, reason ]);
                const TYPE_CACHE = new Map();
                function build(sessionEventCode, infoStr, responseCode = undefined, errorSubcode = 0, correlationKey = undefined, reason = undefined) {
                    const Superclass = SUPERCLASS_FOR_SESSION_EVENT[sessionEventCode] || Object;
                    const SessionEvent = (() => {
                        let result = TYPE_CACHE.get(Superclass);
                        if (result) return result;
                        result = buildType(Superclass);
                        TYPE_CACHE.set(Superclass, result);
                        return result;
                    })();
                    const superclassArgsBuilder = SUPERCLASS_ARGS.get(Superclass) || (() => []);
                    const superclassArgs = superclassArgsBuilder(sessionEventCode, infoStr, responseCode, errorSubcode, correlationKey, reason);
                    return new SessionEvent(superclassArgs, sessionEventCode, infoStr, responseCode, errorSubcode, correlationKey, reason);
                }
                // Expose a type
                const SessionEvent = buildType(Object);
                SessionEvent.build = build;
                module.exports.SessionEvent = SessionEvent;
                /***/
            },
            /***/ "./modules/solclient-session/lib/session-fsm-event.js": 
            /*!************************************************************!*\
  !*** ./modules/solclient-session/lib/session-fsm-event.js ***!
  \************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /* provided dependency */ var util_inspect = __webpack_require__(/*! browser-util-inspect */ "./node_modules/browser-util-inspect/index.js");
                const {
                    ErrorSubcode
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    FsmEvent
                } = __webpack_require__(/*! solclient-fsm */ "./modules/solclient-fsm/api.js");
                const {
                    Hex
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    formatHexString
                } = Hex;
                /**
 * SessionFSMEvent extends {@link FsmEvent}.  This object should be used for all events
 * passed to the SessionFSM.  This extension provides members to carry information specfic to
 * the SessionFSM transitions.
 * @extends FsmEvent
 * @private
 */
                class SessionFSMEvent extends FsmEvent {
                    constructor(spec, fields) {
                        super(spec);
                        /**
     * @type {String}
     * @description Information String for the {SessionEvent}
     */
                        this.eventText = null;
                        /**
     * @type {ErrorSubcode}
     * @description The Solace ErrorSubcode for any generated {SessionEvent}
     */
                        this.errorSubcode = null;
                        /**
     * @type {String}
     * @description The reason string to be included in any generated {SessionEvent}
     */
                        this.eventReason = null;
                        /**
     * @type {TransportSMFMessage}
     * @description A decoded SMF message received from the transport. May be
     * either a {ClientCtrlMessage} or a {SMPMessage}
     */
                        this.smfMsg = null;
                        /**
     * @type {Object}
     * @description The Transport SessionId retrieved from a {TransportSessionEvent}
     */
                        this.sessionId = null;
                        /**
     * @type {Object}
     * @description The Publisher or Consumer object associated with a GM event.
     */
                        this.guaranteedFlowObject = null;
                        Object.assign(this, fields);
                    }
                    ["inspect"]() {
                        return {
                            eventText: this.eventText,
                            eventReason: this.eventReason,
                            errorSubcode: ErrorSubcode.describe(this.errorSubcode),
                            sessionId: this.sessionId && formatHexString(this.sessionId) || "N/A"
                        };
                    }
                    getExtraStringInfo() {
                        return util_inspect(this);
                    }
                }
                module.exports.SessionFSMEvent = SessionFSMEvent;
                /***/
            },
            /***/ "./modules/solclient-session/lib/session-fsm.js": 
            /*!******************************************************!*\
  !*** ./modules/solclient-session/lib/session-fsm.js ***!
  \******************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const ConsumerLib = __webpack_require__(/*! solclient-message-consumer */ "./modules/solclient-message-consumer/api.js");
                const PublisherLib = __webpack_require__(/*! solclient-message-publisher */ "./modules/solclient-message-publisher/api.js");
                const SMFLib = __webpack_require__(/*! solclient-smf */ "./modules/solclient-smf/api.js");
                const SolclientFactoryLib = __webpack_require__(/*! solclient-factory */ "./modules/solclient-factory/api.js");
                const TransportLib = __webpack_require__(/*! solclient-transport */ "./modules/solclient-transport/api.js");
                const {
                    assert
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                const {
                    CapabilityType
                } = __webpack_require__(/*! ./capability-types */ "./modules/solclient-session/lib/capability-types.js");
                const {
                    Check
                } = __webpack_require__(/*! solclient-validate */ "./modules/solclient-validate/api.js");
                const {
                    CorrelatedRequest
                } = __webpack_require__(/*! ./correlated-request */ "./modules/solclient-session/lib/correlated-request.js");
                const {
                    Destination
                } = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                const {
                    ErrorResponseSubcodeMapper,
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    FsmEvent,
                    State,
                    StateMachine
                } = __webpack_require__(/*! solclient-fsm */ "./modules/solclient-fsm/api.js");
                const {
                    Hex
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    LogFormatter
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    Message,
                    MessageDeliveryModeType
                } = __webpack_require__(/*! solclient-message */ "./modules/solclient-message/api.js");
                const {
                    P2PUtil
                } = __webpack_require__(/*! ./p2p-util */ "./modules/solclient-session/lib/p2p-util.js");
                const {
                    SessionEvent
                } = __webpack_require__(/*! ./session-event */ "./modules/solclient-session/lib/session-event.js");
                const {
                    SessionEventCode
                } = __webpack_require__(/*! ./session-event-codes */ "./modules/solclient-session/lib/session-event-codes.js");
                const {
                    SessionEventName
                } = __webpack_require__(/*! ./session-event-names */ "./modules/solclient-session/lib/session-event-names.js");
                const {
                    SessionFSMEvent
                } = __webpack_require__(/*! ./session-fsm-event */ "./modules/solclient-session/lib/session-fsm-event.js");
                const {
                    SessionRequestType
                } = __webpack_require__(/*! ./session-request-types */ "./modules/solclient-session/lib/session-request-types.js");
                const {
                    SessionStateName
                } = __webpack_require__(/*! ./session-state-names */ "./modules/solclient-session/lib/session-state-names.js");
                const {
                    SslDowngrade
                } = __webpack_require__(/*! ./ssl-downgrades */ "./modules/solclient-session/lib/ssl-downgrades.js");
                const {
                    StatType,
                    StatsByMode
                } = __webpack_require__(/*! solclient-stats */ "./modules/solclient-stats/api.js");
                const {
                    StringUtils
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const {
                    SubscriptionUpdateTimeoutMessages
                } = __webpack_require__(/*! ./subscription-update-timeout-messages */ "./modules/solclient-session/lib/subscription-update-timeout-messages.js");
                const {
                    formatHexString
                } = Hex;
                const {
                    stripNullTerminate
                } = StringUtils;
                const {
                    STAT_TX_BYMODE_BYTES,
                    STAT_TX_BYMODE_MSGS,
                    STAT_RX_BYMODE_BYTES,
                    STAT_RX_BYMODE_MSGS,
                    STAT_TX_BYMODE_REDELIVERED,
                    STAT_TX_BYMODE_BYTES_REDELIVERED
                } = StatsByMode;
                /**
 * @param {SessionProperties} sessionProperties The shared reference to the properties of the
 *  owning session
 * @param {Session} session The session owning this FSM
 * @extends StateMachine
 * @private
 */
                class SessionFSM extends StateMachine {
                    constructor(sessionProperties, session, stats, hosts) {
                        super({
                            name: "SessionFSM"
                        });
                        const fsm = this;
                        const logFormatter = function logFormatter(...args) {
                            return [ `[session-fsm=${fsm.sessionIdHex || "(N/A)"}]`, `[${fsm.getCurrentStateName()}]`, ...args ];
                        };
                        const logger = this.logger = new LogFormatter(logFormatter);
                        const {
                            LOG_TRACE,
                            LOG_DEBUG,
                            LOG_INFO
                        } = logger;
                        this.log = logger.wrap(this.log, this);
                        this._sessionProperties = sessionProperties;
                        this._session = session;
                        this._sessionStatistics = stats;
                        this._hosts = hosts;
                        this._consumers = new ConsumerLib.ConsumerFlows();
                        // This is a function that generates this interface. It takes the flow as a construction
                        // parameter, and for some methods, produces a partial application using that flow.
                        this._flowInterfaceFactory = flow => ({
                            getCorrelationTag: this.getCorrelationTag.bind(this),
                            incStat: this.incStat.bind(this),
                            sendData: message => this.send(message, flow, false),
                            sendToTransport: message => this.sendToTransport(message, flow, false),
                            sendControl: message => this.send(message, flow, true),
                            enqueueRequest: this.enqueueOutstandingCorrelatedReq.bind(this),
                            createDestinationFromDescriptor: session.createDestinationFromDescriptor.bind(session),
                            createTemporaryDestination: session.createTemporaryDestination.bind(session),
                            isCapable: session.isCapable.bind(session),
                            getCapability: session.getCapability.bind(session),
                            getCurrentStateName: this.getCurrentStateName.bind(this),
                            updateQueueSubscription: session.updateQueueSubscription.bind(session),
                            get sessionIdHex() {
                                return fsm.sessionIdHex;
                            },
                            get canAck() {
                                return session.canAck;
                            }
                        });
                        // Keeping track of transport backpressure (but not AD window exhaustion),
                        // so we can relieve it on transport reconnect:
                        this._userBackpressured = false;
                        this.clearCurrentError();
                        this.initial(function onInitial() {
                            return this.transitionTo(fsm.SessionDisconnected, context => context.getStateMachine().reset());
                        });
                        /**
     * Handles events in the unhandledEventHandler callback
     * @param {SessionFSMEvent} sEvent
     * @private
     */
                        this.unhandledEventReaction(function onUnhandledEvent(sEvent) {
                            const curState = fsm.getCurrentState();
                            switch (sEvent.getName()) {
                              case SessionEventName.CREATE_SUBSCRIBER:
                                // CREATE_SUBSCRIBER is only handled in CONNECTED state.
                                // In all other states we just add the consumer to our
                                // list of unbound consumers that need to be bound when
                                // the session up occurs.
                                assert(fsm._consumers, "collection has lifetime of FSM instance");
                                fsm._consumers.add(sEvent.guaranteedFlowObject);
                                return this;

                              case SessionEventName.DISPOSE:
                                LOG_DEBUG("Handling DISPOSE");
                                return curState.terminate(() => fsm.disposeInternal());

                              case SessionEventName.FLOW_UP:
                                LOG_DEBUG(`Ignoring FLOW_UP event from ${sEvent.guaranteedFlowObject}`);
                                return this;

                              default:
                                LOG_TRACE(`Ignoring event ${sEvent.getName()} in state ${fsm.getCurrentStateName()}`);
                                return this;
                            }
                        });
                        this.SessionConnecting = new State({
                            name: SessionStateName.CONNECTING,
                            parentContext: fsm
                        }, {
                            //
                            //  handleTransportDestroyed is called in response to TRANSPORT_DESTROYED
                            //  event and if transport create throws an exception. In both case there is
                            //  no underlying transport and the FSM must move on to the next host.
                            handleTransportDestroyed() {
                                // clear connectTimer, if it is still running
                                fsm.clearConnectTimer();
                                fsm._currentHost = fsm._hosts.getNextHost();
                                if (fsm._currentHost === null) {
                                    return this.transitionToExitPoint(fsm.SessionConnecting, "ErrorExit");
                                }
                                const {
                                    connectWaitTimeInMsecs
                                } = fsm._hosts;
                                LOG_TRACE(`Wait time for this host is ${connectWaitTimeInMsecs}`);
                                if (connectWaitTimeInMsecs > 0 && !fsm._connectWaitTimer) {
                                    fsm._connectWaitTimer = setTimeout(() => {
                                        fsm._connectWaitTimer = null;
                                        fsm.processEvent(new SessionFSMEvent({
                                            name: SessionEventName.CONNECT_WAIT_TIMEOUT
                                        }));
                                    }, connectWaitTimeInMsecs);
                                    return this.transitionTo(fsm.WaitingForInterConnectTimeout);
                                }
                                return this.transitionTo(fsm.WaitingForTransport);
                            }
                        }).entry(() => {
                            fsm.setConnectTimer();
                        }).entryPoint("DisconnectTransport", function onDisconnectTransport() {
                            fsm._hosts.reset({
                                wasConnected: undefined,
                                disconnected: true
                            });
                            //
                            // Set the error event, as we have reset the
                            // host list with disconnected:true, we always take the
                            // errorExit path to DISCONNECTED state after this entryPoint.
                            //
                            fsm._connectFailEvent = SessionEventCode.DISCONNECTED;
                            fsm._connectSuccessEvent = SessionEventCode.DISCONNECTED;
                            return this.transitionTo(fsm.DestroyingTransport);
                        }).entryPoint("ReconnectTransport", function onReconnectTransport() {
                            //
                            // Set the error event, this is only used
                            // if we take the errorExit path
                            //
                            fsm._connectFailEvent = SessionEventCode.DOWN_ERROR;
                            fsm._connectSuccessEvent = SessionEventCode.RECONNECTED_NOTICE;
                            // Should we try to reconnect?
                            const disconnected = fsm._sessionProperties._reconnectRetries === 0;
                            fsm._hosts.reset({
                                wasConnected: true,
                                disconnected: disconnected
                            });
                            if (!disconnected) {
                                // workaround to make sure session state is changed to connecting when
                                // application gets the session event
                                // positional parameters for SessionEvent constructor
                                // make sure we get the args and err setup now as by the time
                                // the postEventAction runs currentError will be reset.
                                const err = fsm._currentError || {};
                                const args = [ err.eventText, // infoString
                                err.responseCode, // responseCode
                                err.errorSubcode, // errorSubcode
                                undefined, // correlationKey ... N/A
                                err.eventReason ]; // eventReason
                                fsm.setPostEventAction(() => {
                                    fsm.setConnectTimer();
                                    fsm.emitSessionEvent(SessionEvent.build(SessionEventCode.RECONNECTING_NOTICE, ...args));
                                });
                            }
                            return this.transitionTo(fsm.DestroyingTransport);
                        }).initial(() => {
                            fsm.clearCurrentError();
                            //
                            // Set the error event this is only used
                            // if we take the errorExit path
                            //
                            fsm._connectFailEvent = SessionEventCode.CONNECT_FAILED_ERROR;
                            fsm._connectSuccessEvent = SessionEventCode.UP_NOTICE;
                            // Perform host resolution (guaranteed async; replaces a postEventAction)
                            // Do not perform host list operations until this completes (moved to callback)
                            fsm._hosts.resolveHosts(err => {
                                if (!fsm._hosts) {
                                    LOG_TRACE("Ignoring host filter fail because session was disposed");
                                    return null;
                                }
                                if (err) {
                                    LOG_TRACE("DNS filter failed:", err);
                                    fsm.setCurrentError({
                                        errorSubcode: ErrorSubcode.UNRESOLVED_HOSTS,
                                        eventText: err
                                    });
                                    fsm._hosts.reset({
                                        disconnected: true
                                    });
                                    return this.processEvent(new SessionFSMEvent({
                                        name: SessionEventName.EXCEPTION
                                    }));
                                }
                                // Now that the host list has been scanned, we can reset and get next host
                                fsm._hosts.reset({
                                    wasConnected: false
                                });
                                fsm._currentHost = fsm._hosts.getNextHost();
                                return this.processEvent(new SessionFSMEvent({
                                    name: SessionEventName.DNS_RESOLUTION_COMPLETE
                                }));
                            });
                            return this.transitionTo(fsm.WaitingForDNS);
                        }).reaction(SessionEventName.DNS_RESOLUTION_COMPLETE, function onDNSComplete() {
                            return this.transitionTo(fsm.WaitingForTransport);
                        }).reaction(SessionEventName.DISCONNECT, function onDisconnect() {
                            return this.transitionToEntryPoint(fsm.SessionConnecting, "DisconnectTransport");
                        }).reaction(SessionEventName.CONNECT_TIMEOUT, function onConnectTimeout() {
                            fsm.setCurrentError({
                                errorSubcode: ErrorSubcode.TIMEOUT,
                                eventText: "Connect timeout"
                            });
                            return this.transitionTo(fsm.DestroyingTransport);
                        }).reaction(SessionEventName.SEND_ERROR, function onSendError(sessionEvent) {
                            LOG_INFO(`SEND_ERROR reached SessionConnecting. ${sessionEvent}`);
                            fsm.setCurrentError(sessionEvent);
                            return this.transitionTo(fsm.DestroyingTransport);
                        }).reaction(SessionEventName.EXCEPTION, function onException(errEvent) {
                            fsm.setCurrentError(errEvent);
                            return this.transitionTo(fsm.DestroyingTransport);
                        }).reaction(SessionEventName.TRANSPORT_DESTROYED, function onTransportDestroyed(sessionEvent) {
                            fsm.setCurrentError(sessionEvent);
                            LOG_INFO("TRANSPORT_DESTROYED event");
                            return this.transitionTo(fsm.DestroyingTransport);
                        }).exit(() => {
                            fsm.clearConnectTimer();
                            if (fsm._connectWaitTimer) {
                                clearTimeout(fsm._connectWaitTimer);
                                fsm._connectWaitTimer = null;
                            }
                        }).exitPoint("ConnectedExit", () => {
                            // Normal exit to TransportUp.
                            // We need to notify the application they are connected. Use postEventAction to make sure
                            // session state has already changed to TransportUp when application gets the callback.
                            // Use _connectSuccessEvent to send RECONNECTED vs UP depending on entry point.
                            // The text included in the event is currently different for
                            // connect vs reconnect. We should store with as part of _connectSuccessEvent in
                            // the entry point.
                            fsm.setPostEventAction(() => {
                                fsm.emitSessionEvent(SessionEvent.build(fsm._connectSuccessEvent, `'${fsm._hosts.currentHostToString()}'`, 200, 0, null, null));
                                if (fsm._userBackpressured) {
                                    const sessionEvent = SessionEvent.build(SessionEventCode.CAN_ACCEPT_DATA, "", null, 0, null, "");
                                    fsm.emitSessionEvent(sessionEvent);
                                    fsm._userBackpressured = false;
                                }
                            });
                            // Clear current error as we have successfully connected or
                            // reconnected.
                            fsm.clearCurrentError();
                            return this.transitionTo(fsm.SessionTransportUp);
                        }).exitPoint("ErrorExit", function onExit() {
                            // Notify the application they are disconnected. Use postEventAction to make sure session
                            // state has already changed to disconnected when application gets the callback.
                            fsm.setPostEventAction(() => {
                                const err = fsm._currentError || {};
                                // positional parameters for SessionEvent constructor
                                const args = [ err.eventText, // infoString
                                err.responseCode, // responseCode
                                err.errorSubcode, // errorSubcode
                                undefined, // correlationKey ... N/A
                                err.eventReason ]; // eventReason
                                fsm.emitSessionEvent(SessionEvent.build(fsm._connectFailEvent, ...args));
                            });
                            return this.transitionTo(fsm.SessionDisconnected);
                        });
                        this.WaitingForDNS = new State({
                            name: SessionStateName.WAITING_FOR_DNS,
                            parentContext: fsm.SessionConnecting
                        });
                        this.DestroyingTransport = new State({
                            name: SessionStateName.DESTROYING_TRANSPORT,
                            parentContext: fsm.SessionConnecting
                        }).entry(() => {
                            LOG_INFO("Connecting, disposing transport");
                            fsm.clearConnectTimer(); // clear connectTimer, while destroying the transport
                            fsm.destroyTransportSession("Disconnecting session", 0);
                        }).reaction(SessionEventName.TRANSPORT_DESTROYED, function onTransportDestroyed(sessionEvent) {
                            fsm.setCurrentError(sessionEvent);
                            return fsm.SessionConnecting.handleTransportDestroyed.call(this);
                        });
                        this.WaitingForInterConnectTimeout = new State({
                            name: SessionStateName.WAITING_FOR_INTERCONNECT_TIMEOUT,
                            parentContext: fsm.SessionConnecting
                        }).reaction(SessionEventName.CONNECT_WAIT_TIMEOUT, function onConnectWaitTimeout() {
                            return this.transitionTo(fsm.WaitingForTransport);
                        });
                        this.WaitingForTransport = new State({
                            name: SessionStateName.WAITING_FOR_TRANSPORT,
                            parentContext: fsm.SessionConnecting
                        }).initial(() => {
                            const errorMessage = "Cannot establish transport session: creation failed";
                            fsm.setConnectTimer();
                            fsm.clearCurrentError();
                            try {
                                fsm.initTransport();
                            } catch (e) {
                                this.setCurrentError({
                                    eventText: e.message === errorMessage ? errorMessage : `${errorMessage}: ${e.message}`,
                                    errorSubcode: e.subcode || ErrorSubcode.INTERNAL_ERROR,
                                    eventReason: e
                                });
                                return fsm.SessionConnecting.handleTransportDestroyed.call(this);
                            }
                            return this.transitionTo(fsm.WaitingForTransportUp);
                        });
                        this.WaitingForTransportUp = new State({
                            name: SessionStateName.WAITING_FOR_TRANSPORT_UP,
                            parentContext: this.WaitingForTransport
                        }).entry(() => {
                            this._justEntered = true;
                        }).initial(() => {
                            if (!this._justEntered) {
                                return this;
                            }
                            this._justEntered = false;
                            const errorMessage = "Cannot establish transport session: connection failed";
                            try {
                                const returnCode = fsm._transport.connect();
                                if (returnCode !== TransportLib.TransportReturnCode.OK) {
                                    throw new OperationError(errorMessage, ErrorSubcode.CONNECTION_ERROR, TransportLib.TransportReturnCode.describe(returnCode));
                                }
                                LOG_INFO(`Attempting to connect session '${fsm.sessionId}' to ${fsm._hosts.currentHostToString()}`);
                            } catch (e) {
                                this.setCurrentError({
                                    eventText: e.message === errorMessage ? errorMessage : `${errorMessage}: ${e.message}`,
                                    errorSubcode: e.subcode || ErrorSubcode.INTERNAL_ERROR,
                                    eventReason: e
                                });
                                return fsm.SessionConnecting.handleTransportDestroyed.call(this);
                            }
                            return this;
                        }).reaction(SessionEventName.SEND_ERROR, function doNothing(sEvent) {
                            LOG_INFO(`SEND_ERROR while waiting for transport up, doing nothing. ${sEvent}`);
                            return this.internalTransition(null);
                        }).reaction(SessionEventName.TRANSPORT_UP, function onTransportUp(sEvent) {
                            fsm.sessionId = sEvent.sessionId || "";
                            const returnCode = fsm.sendClientCtrlLogin();
                            if (returnCode === TransportLib.TransportReturnCode.OK) {
                                return this.transitionTo(fsm.WaitingForLogin);
                            }
                            const err = {
                                eventText: "Failed to send Client Control Login",
                                errorSubcode: ErrorSubcode.LOGIN_FAILURE,
                                responseCode: 400
                            };
                            fsm.setCurrentError(err);
                            return this.transitionTo(fsm.DestroyingTransport);
                        });
                        this.WaitingForLogin = new State({
                            name: SessionStateName.WAITING_FOR_LOGIN,
                            parentContext: fsm.SessionConnecting
                        }).entry(() => {
                            fsm.setClientCtrlTimer();
                        }).reaction(SessionEventName.TRANSPORT_PROTOCOL_CLIENTCTRL, function onClientCtrl(sEvent) {
                            const clientCtrlMsg = sEvent.smfMsg;
                            const response = clientCtrlMsg.getResponse();
                            const respCode = response.responseCode;
                            const err = {
                                responseCode: respCode
                            };
                            fsm._responseCode = respCode;
                            if (respCode === 200) {
                                if (!fsm.checkNoLocal(clientCtrlMsg)) {
                                    Object.assign(err, {
                                        eventText: "No Local is not supported by the Solace Message Router",
                                        errorSubcode: ErrorSubcode.NO_LOCAL_NOT_SUPPORTED
                                    });
                                } else if (!fsm.checkCompressedSsl(clientCtrlMsg)) {
                                    Object.assign(err, {
                                        eventText: "Compressed TLS is not supported by the Solace Message Router",
                                        errorSubcode: ErrorSubcode.COMPRESSED_TLS_NOT_SUPPORTED
                                    });
                                } else {
                                    // Happy path
                                    fsm.updateReadonlySessionProps(clientCtrlMsg);
                                    return this.transitionTo(fsm.WaitForTransportChange);
                                }
                            } else {
                                const rawSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, response.responseString);
                                const subcode = rawSubcode === ErrorSubcode.UNKNOWN_ERROR ? ErrorSubcode.LOGIN_FAILURE : rawSubcode;
                                LOG_INFO(`Login failed. Subcode: ${subcode} respCode: ${respCode} ` + `respString: ${response.responseString}`);
                                Object.assign(err, {
                                    eventText: response.responseString,
                                    errorSubcode: subcode
                                });
                            }
                            LOG_TRACE("ClientCtrl error", err);
                            fsm.setCurrentError(err);
                            return this.transitionTo(fsm.DestroyingTransport);
                        }).reaction(SessionEventName.DOWNGRADE_TIMEOUT, function onDowngradeTimeout() {
                            if (!fsm._transport.requestDowngrade || fsm._transport.requestDowngrade("ClientCtrl timeout", ErrorSubcode.TIMEOUT) === false) {
                                fsm.setCurrentError({
                                    eventText: "ClientCtrl timeout",
                                    errorSubcode: ErrorSubcode.TIMEOUT
                                });
                                return this.transitionTo(fsm.DestroyingTransport);
                            }
                            // Don't recreate the transport, just try to connect it
                            LOG_TRACE("Downgrade accepted, returning to WaitingForTransportUp");
                            return this.transitionTo(fsm.WaitingForTransportUp);
                        }).exit(() => {
                            fsm.clearClientCtrlTimer();
                        });
                        // This is an intermediate state after a successful login.
                        // It gives time to the transport factory (more like a dealership at this point)
                        // to enable compression and/or shut down tls.
                        // The factory may return a new transport immediately,
                        // in which case there is no need to stay in this state.
                        // Or it may return null, and pass the new transport to the callback later.
                        // No messages can be sent while waiting for the callback.
                        this.WaitForTransportChange = new State({
                            name: SessionStateName.WAITING_FOR_TRANSPORT_CHANGE,
                            parentContext: fsm.SessionConnecting
                        }).initial(function onInitial() {
                            // Operates on the FSM, must be bound to it.
                            const callback = function onTransportChange(newTransport) {
                                this._transport = newTransport;
                                this.processEvent(new SessionFSMEvent({
                                    name: SessionEventName.TRANSPORT_CHANGE_DONE
                                }));
                            };
                            const rc = fsm.updateTransportCompression(callback.bind(fsm));
                            if (rc === null) {
                                // Factory needs time, stay in this state.
                                return this;
                            }
                            fsm._transport = rc;
                            return this.transitionTo(fsm.ReapplyingSubscriptions);
                        }).reaction(SessionEventName.TRANSPORT_CHANGE_DONE, function onTransportChangeDone() {
                            return this.transitionTo(fsm.ReapplyingSubscriptions);
                        });
                        this.ReapplyingSubscriptions = new State({
                            name: SessionStateName.REAPPLYING_SUBSCRIPTIONS,
                            parentContext: fsm.SessionConnecting
                        }).entry(() => {
                            LOG_INFO("ReapplyingSubscriptions: entry");
                            fsm.copySubscriptionCacheKeys();
                        }).initial(function onInitial() {
                            if (fsm.reapplySubscriptions() === true) {
                                // all subscriptions applied and waiting for a subscription confirm
                                return this.transitionTo(fsm.WaitForSubConfirm);
                            }
                            // flow controlled while reapplying
                            return this.transitionTo(fsm.WaitForCanAcceptData);
                        }).reaction(SessionEventName.SUBSCRIBE_TIMEOUT, function onSubscribeTimeout() {
                            const respText = "Subscription timeout while reapplying";
                            const subcode = ErrorSubcode.TIMEOUT;
                            fsm.setCurrentError({
                                eventText: respText,
                                errorSubcode: subcode
                            });
                            return this.transitionTo(fsm.DestroyingTransport);
                        }).exit(function onExit() {
                            fsm.clearSubscriptionCacheKeys();
                            return this;
                        });
                        this.WaitForSubConfirm = new State({
                            name: SessionStateName.WAITING_FOR_SUBCONFIRM,
                            parentContext: fsm.ReapplyingSubscriptions
                        }).reaction(SessionEventName.TRANSPORT_PROTOCOL_SMP, function onTransportProtocolSMP(sEvent) {
                            // process rxMsgObj
                            const smfRespHeader = sEvent.smfMsg.smfHeader;
                            const subscriptionStr = stripNullTerminate(sEvent.smfMsg.encodedUtf8Subscription);
                            const respCode = smfRespHeader.pm_respcode;
                            const respText = smfRespHeader.pm_respstr;
                            if (respCode !== 200) {
                                const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
                                LOG_INFO(`Waiting for subscription confirmation, got ${respCode} (${errorSubcode}) ` + `'${respText}' on subscription ${subscriptionStr}`);
                                fsm.setCurrentError({
                                    eventText: respText,
                                    responseCode: respCode,
                                    errorSubcode: errorSubcode
                                });
                                return this.transitionTo(fsm.DestroyTransport);
                            }
                            if (fsm._session.canConnectPublisher && fsm._defaultPublisher && fsm._defaultPublisher.isBindWaiting()) {
                                return this.transitionTo(fsm.WaitingForMessagePublisher);
                            }
                            return this.transitionToExitPoint(fsm.SessionConnecting, "ConnectedExit");
                        });
                        this.WaitForCanAcceptData = new State({
                            name: SessionStateName.WAITING_FOR_CAN_ACCEPT_DATA,
                            parentContext: fsm.ReapplyingSubscriptions
                        }).reaction(SessionEventName.TRANSPORT_PROTOCOL_SMP, function onTransportProtocolSMP(sEvent) {
                            // process rxMsgObj
                            const smfRespHeader = sEvent.smfMsg.smfHeader;
                            const subscriptionStr = stripNullTerminate(sEvent.smfMsg.encodedUtf8Subscription);
                            const respCode = smfRespHeader.pm_respcode;
                            const respText = smfRespHeader.pm_respstr;
                            // We are not expecting a SMP response as we have not sent a request-confirm
                            // so this is almost assuredly an error response to a subscription add
                            // check respCode anyway.  if its '200 OK' just ignore it.
                            if (respCode !== 200) {
                                const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
                                LOG_DEBUG(`Waiting for can accept data, got ${respCode} (subcode ${errorSubcode}) ` + `'${respText}' on subscription ${subscriptionStr}`);
                                fsm.setCurrentError({
                                    eventText: respText,
                                    responseCode: respCode,
                                    errorSubcode: errorSubcode
                                });
                                return this.transitionTo(fsm.DestroyingTransport);
                            }
                            // unexpected 200 OK repsonse, log it and continue
                            LOG_INFO(`Unexpected 200 OK response to subscription add for ${subscriptionStr}`);
                            return this.internalTransition(null);
                        }).reaction(SessionEventName.TRANSPORT_CAN_ACCEPT_DATA, function onTransportCanAcceptData() {
                            if (fsm.reapplySubscriptions() === true) {
                                // all subscriptions applied and waiting for a subscription confirm
                                return this.transitionTo(fsm.WaitForSubConfirm);
                            }
                            // flow controlled while reapplying
                            return this.internalTransition(null);
                        });
                        this.WaitingForMessagePublisher = new State({
                            name: SessionStateName.WAITING_FOR_PUBFLOW,
                            parentContext: fsm.SessionConnecting
                        }).entry(() => {
                            // Inform the publisher that the session is up and the flow establishment can begin.
                            fsm._defaultPublisher.connect();
                            fsm.sendPublisherSessionUpEvent(fsm._defaultPublisher);
                        }).reaction(SessionEventName.FLOW_UP, function onEvent() {
                            LOG_TRACE(`Flow up ${this}`);
                            if (!fsm._defaultPublisher.isBindWaiting()) {
                                LOG_TRACE("Publisher up");
                                return this.transitionToExitPoint(fsm.SessionConnecting, "ConnectedExit");
                            }
                            LOG_TRACE("Waiting for more publishers");
                            return this.internalTransition(null);
                        }).reaction(SessionEventName.FLOW_FAILED, function onEvent(sEvent) {
                            fsm.setCurrentError({
                                eventText: `Guaranteed Message Publisher Failed: ${sEvent.eventText}`,
                                errorSubcode: ErrorSubcode.LOGIN_FAILURE
                            });
                            return this.transitionTo(fsm.DestroyingTransport);
                        });
                        this.SessionTransportUp = new State({
                            name: SessionStateName.TRANSPORT_UP,
                            parentContext: fsm
                        }).entry(function onEntry() {
                            fsm.clearConnectTimer(); // clear connectTimer, once we successfully connect
                            return this;
                        }).initial(function onInitial() {
                            if (fsm._session.canConnectConsumer) {
                                // Inform the subscribers that the session is up and the flow establishment can begin.
                                fsm._consumers.flows.forEach(consumer => fsm.sendConsumerSessionUpEvent(consumer));
                                // Reconnecting flows need session state notification too.
                                fsm._consumers.reconnectingFlows.forEach(consumer => fsm.sendConsumerSessionUpEvent(consumer));
                            }
                            return this.transitionTo(fsm.FullyConnected);
                        }).reaction(SessionEventName.DISCONNECT, function onDisconnect() {
                            return this.transitionTo(fsm.SessionDisconnecting);
                        }).reaction(SessionEventName.EXCEPTION, function onException(sEvent) {
                            fsm.setCurrentError(sEvent);
                            fsm.cleanupSession();
                            return this.transitionToEntryPoint(fsm.SessionConnecting, "ReconnectTransport");
                        }).reaction(SessionEventName.SEND_ERROR, function onSendError(sEvent) {
                            fsm.setCurrentError(sEvent);
                            fsm.cleanupSession();
                            LOG_TRACE("Reconnecting transport after SEND_ERROR (not fully connected)");
                            return this.transitionToEntryPoint(fsm.SessionConnecting, "ReconnectTransport");
                        }).reaction(SessionEventName.TRANSPORT_DESTROYED, function onTransportDestroyed(sEvent) {
                            fsm.setCurrentError(sEvent);
                            LOG_INFO("Received unsolicited TRANSPORT_DESTROYED event while transport is up");
                            LOG_TRACE(`TRANSPORT_DESTROYED details: ${sEvent}`);
                            fsm.cleanupSession();
                            return this.transitionToEntryPoint(fsm.SessionConnecting, "ReconnectTransport");
                        }).reaction(SessionEventName.TRANSPORT_PROTOCOL_SMP, function onTransportProtocolSMP(sEvent) {
                            const smfRespHeader = sEvent.smfMsg.smfHeader;
                            const subscriptionStr = stripNullTerminate(sEvent.smfMsg.encodedUtf8Subscription);
                            const respCode = smfRespHeader.pm_respcode;
                            const respText = smfRespHeader.pm_respstr;
                            fsm.handleSubscriptionUpdateError(respCode, respText, subscriptionStr, undefined, false);
                            return this.internalTransition(null);
                        }).reaction(SessionEventName.TRANSPORT_CAN_ACCEPT_DATA, function onCanAcceptData(sEvent) {
                            // Notify client for republishing
                            const sessionEvent = SessionEvent.build(SessionEventCode.CAN_ACCEPT_DATA, "", null, 0, null, sEvent.toString());
                            fsm.emitSessionEvent(sessionEvent);
                            fsm._userBackpressured = false;
                            return this.internalTransition(null);
                        }).reaction(SessionEventName.CREATE_SUBSCRIBER, function onCreateSubscriber(sEvent) {
                            // Inform the consumer that the session is up and the flow establishment can begin.
                            const consumer = fsm._consumers.add(sEvent.guaranteedFlowObject);
                            fsm.sendConsumerSessionUpEvent(consumer);
                            return this;
                        }).exit(function onExit() {
                            fsm.clearKeepAlive();
                            return this;
                        });
                        this.FullyConnected = new State({
                            name: SessionStateName.FULLY_CONNECTED,
                            parentContext: fsm.SessionTransportUp
                        }).entry(() => {
                            fsm._connectFailEvent = SessionEventCode.DOWN_ERROR;
                            fsm.scheduleKeepAlive();
                        });
                        this.SessionDisconnected = new State({
                            name: SessionStateName.DISCONNECTED,
                            parentContext: fsm
                        }).reaction(SessionEventName.DISCONNECT, function onDisconnect() {
                            fsm.setPostEventAction(() => {
                                fsm.emitSessionEvent(SessionEvent.build(SessionEventCode.DISCONNECTED));
                            });
                            return this.internalTransition(null);
                        }).reaction(SessionEventName.CONNECT, function onConnect() {
                            return this.transitionTo(fsm.SessionConnecting);
                        }).reaction(SessionEventName.EXCEPTION, function onException() {
                            // do nothing
                            return this.internalTransition(null);
                        });
                        this.SessionDisconnecting = new State({
                            name: SessionStateName.DISCONNECTING,
                            parentContext: fsm
                        }).initial(() => {
                            LOG_INFO(`Disconnecting session ${fsm}`);
                            return this.transitionTo(fsm.DisconnectingFlows);
                        }).reaction(SessionEventName.DISCONNECT, function onDisconnect() {
                            return this.internalTransition(null);
                        }).reaction(SessionEventName.EXCEPTION, function onException(errEvent) {
                            //
                            // As we are in disconnecting state we have initiated the
                            // disconnect and need to preserve the error subcode that
                            // we set before destroying the transport. The transport, having
                            // no error, will usually return a subcode of zero here.
                            //
                            // This only changes the eventCode, not the subcode. Other properties
                            // are preserved.
                            //
                            fsm.setCurrentError({
                                errEvent: errEvent
                            });
                            fsm.cleanupSession();
                            return this.transitionToEntryPoint(fsm.SessionConnecting, "DisconnectTransport");
                        }).reaction(SessionEventName.TRANSPORT_DESTROYED, function onTransportDestroyed() {
                            LOG_INFO("Received unsolicited TRANSPORT_DESTROYED while disconnecting transport");
                            fsm.cleanupSession();
                            return this.transitionToEntryPoint(fsm.SessionConnecting, "DisconnectTransport");
                        });
                        this.DisconnectingFlows = new State({
                            name: SessionStateName.DISCONNECTING_FLOWS,
                            parentContext: fsm.SessionDisconnecting
                        }, {
                            // Get all flows to disconnect. This will need to be called at least once.
                            gatherPendingFlows() {
                                const {
                                    MessageConsumerEventName
                                } = ConsumerLib;
                                // Don't re-enter synchronously to look for new flows.
                                // Flows disconnect synchronously when they are already disconnected.
                                // If this is the case, they throw; they do not emit an event.
                                // If a consumer flow is up, it will immediately emit a BIND_WAITING event and we
                                // handle that.
                                // Since we know that flow#_disconnectSession neither creates a new flow
                                // nor calls a user callback that could do so, we need not look for new
                                // flows that were created.
                                assert(!this.isGathering);
                                this.isGathering = true;
                                const adaptedListenForDestroy = (flow, installfn, downEvents) => {
                                    assert(flow, "Trying to listen to undefined flow");
                                    // If we already know about this flow, skip it.
                                    if (this.known.has(flow)) return;
                                    LOG_TRACE(`Adding pending flow ${flow}`);
                                    this.known.add(flow);
                                    this.pending.add(flow);
                                    const onFlowDown = () => {
                                        LOG_TRACE(`Removing flow from pending ${flow}`);
                                        downEvents.forEach(event => flow._removeListener(event, onFlowDown));
                                        this.pending.delete(flow);
                                        if (!this.isGathering) this.checkPendingFlows();
                                    };
                                    downEvents.forEach(event => installfn.call(flow, event, onFlowDown));
                                    try {
                                        flow._disconnectSession(); // Session has been disconnected by user
                                    } catch (ex) {
                                        // Synchronously down
                                        LOG_TRACE("Flow disconnect threw");
                                        LOG_TRACE(ex);
                                        onFlowDown();
                                    }
                                };
                                // See SOL-13556: sending CloseFlow makes it impossible to recover the flow.
                                // This was the code that sent CloseFlow. I'm leaving it here temporarily
                                // in case we want a clean shutdown that waits for acks.
                                /*
        const { MessagePublisherEventName } = PublisherLib;
        if (fsm._defaultPublisher) {
          adaptedListenForDestroy(fsm._defaultPublisher,
                                  fsm._defaultPublisher.once,
                                  [MessagePublisherEventName.DOWN]);
        }
        */
                                if (fsm._consumers) {
                                    fsm._consumers.flows.forEach(flow => {
                                        adaptedListenForDestroy(flow, flow._once, [ MessageConsumerEventName.DOWN, MessageConsumerEventName.DOWN_ERROR ]);
                                    });
                                }
                                this.isGathering = false;
                            },
                            // This function is called whenever a flow comes down, whether sync or async.
                            // The body is wrapped in a basic debounce: if we are re-entering (synchronously),
                            // no new flows will be added.
                            checkPendingFlows() {
                                LOG_TRACE("Waiting for disconnects on", this.pending);
                                if (this.pending.size === 0) {
                                    // We are out of pending flows, but look for new flows that were just added
                                    this.gatherPendingFlows();
                                    // Were any flows just added?
                                    if (this.pending.size === 0) {
                                        this.proceed();
                                    }
                                }
                            },
                            proceed() {
                                // All done!
                                // Clear flow sets so they can be disposed
                                this.known = null;
                                this.pending = null;
                                LOG_INFO("All flows disconnected");
                                fsm.processEvent(new FsmEvent({
                                    name: SessionEventName.FLOWS_DISCONNECTED
                                }));
                            }
                        }).entry(function onEntry() {
                            this.known = new Set();
                            this.pending = new Set();
                            this.checkPendingFlows();
                        }).reaction(SessionEventName.FLOWS_DISCONNECTED, function onFlowsDisconnected() {
                            return this.transitionTo(fsm.FlushingTransport);
                        });
                        this.FlushingTransport = new State({
                            name: SessionStateName.FLUSHING_TRANSPORT,
                            parentContext: fsm.SessionDisconnecting
                        }, {
                            flushTransport() {
                                fsm.cleanupSession();
                                fsm.flushTransportSession(() => this.onTransportFlushed());
                                this.sessionId = null;
                            },
                            onTransportFlushed() {
                                fsm.processEvent(new FsmEvent({
                                    name: SessionEventName.TRANSPORT_FLUSHED
                                }));
                            }
                        }).entry(function onEntry() {
                            LOG_INFO("Flushing transport");
                            this.flushTransport();
                        }).reaction(SessionEventName.TRANSPORT_FLUSHED, function onTransportFlushed() {
                            LOG_INFO("Handle Transport Flushed");
                            return this.transitionToEntryPoint(fsm.SessionConnecting, "DisconnectTransport");
                        });
                    }
                    /**
   * @param {Destination} destination The topic to add
   * @private
   */
                    addToSubscriptionCache(destination) {
                        if (Check.nothing(destination) || !this._subscriptionCache) {
                            return;
                        }
                        const {
                            LOG_DEBUG
                        } = this.logger;
                        const key = destination.name;
                        if (this._subscriptionCache[key] === null || this._subscriptionCache[key] === undefined) {
                            LOG_DEBUG(`Cache subscription ${key}`);
                            this._subscriptionCache[key] = destination;
                            LOG_DEBUG("Increment cache count");
                            this._subscriptionCacheCount++;
                        } else {
                            LOG_DEBUG(`Cache subscription ${key}`);
                            this._subscriptionCache[key] = destination;
                        }
                    }
                    /**
   * @param {String} correlationTag The tag of the request to cancel
   * @returns {CorrelatedRequest} The cancelled request
   * @private
   */
                    cancelOutstandingCorrelatedReq(correlationTag) {
                        if (Check.nothing(correlationTag) || !this._correlatedReqs) {
                            return null;
                        }
                        const req = this._correlatedReqs[correlationTag];
                        if (req === null || req === undefined) {
                            return null;
                        }
                        const {
                            LOG_DEBUG,
                            LOG_ERROR
                        } = this.logger;
                        LOG_DEBUG(`Cancel outstanding ctrl request correlationTag=${correlationTag}`);
                        if (req.timer) {
                            clearTimeout(req.timer);
                            req.timer = null;
                        }
                        try {
                            const result = delete this._correlatedReqs[correlationTag];
                            if (!result) {
                                LOG_ERROR(`Cannot delete ctrl request ${correlationTag}`);
                            }
                        } catch (e) {
                            LOG_ERROR(`Cannot delete ctrl request ${correlationTag}`, e);
                        }
                        return req;
                    }
                    /**
   * @private
   */
                    cleanupSession() {
                        const {
                            LOG_INFO
                        } = this.logger;
                        LOG_INFO("Clean up session");
                        const {
                            ConsumerFSMEvent,
                            ConsumerFSMEventNames
                        } = ConsumerLib;
                        if (this._correlatedReqs) {
                            Object.keys(this._correlatedReqs).forEach(key => this.cancelOutstandingCorrelatedReq(key));
                        }
                        this.clearConnectTimer();
                        this.clearClientCtrlTimer();
                        this.clearKeepAlive();
                        this._consumers.flows.forEach(consumer => {
                            consumer.processFSMEvent(new ConsumerFSMEvent({
                                name: ConsumerFSMEventNames.SESSION_DOWN
                            }));
                        });
                        // Reconnecting flows need session state notification too.
                        this._consumers.reconnectingFlows.forEach(consumer => {
                            consumer.processFSMEvent(new ConsumerFSMEvent({
                                name: ConsumerFSMEventNames.SESSION_DOWN
                            }));
                        });
                        if (this._defaultPublisher) {
                            this._defaultPublisher.processFSMEvent(new PublisherLib.PublisherFSMEvent({
                                name: PublisherLib.PublisherFSMEventNames.SESSION_DOWN
                            }));
                        }
                        this._session.cleanupSession();
                    }
                    /**
   * @private
   */
                    clearClientCtrlTimer() {
                        if (!this._clientCtrlTimer) {
                            return;
                        }
                        clearTimeout(this._clientCtrlTimer);
                        this._clientCtrlTimer = null;
                    }
                    /**
   * @private
   */
                    clearConnectTimer() {
                        if (!this._connectTimer) {
                            return;
                        }
                        clearTimeout(this._connectTimer);
                        this._connectTimer = undefined;
                    }
                    /**
   * Cancel keep alive task
   * @private
   */
                    clearKeepAlive() {
                        const {
                            LOG_INFO
                        } = this.logger;
                        if (this._keepAliveTimer) {
                            LOG_INFO("Cancel keepalive timer");
                            clearInterval(this._keepAliveTimer);
                            this._keepAliveTimer = null;
                        }
                        this.resetKeepAliveCounter();
                    }
                    /**
   * @param {ClientCtrlMessage} clientCtrlMsg The message to parse
   * @returns {Boolean} true if No Local is supported by the router
   * @private
   */
                    checkNoLocal(clientCtrlMsg) {
                        let noLocalSupported = true;
                        if (this._sessionProperties.noLocal === true) {
                            const caps = clientCtrlMsg.getRouterCapabilities();
                            if (!caps) {
                                noLocalSupported = false;
                            } else {
                                // Guard for undefined OR non-boolean capability
                                noLocalSupported = typeof caps[CapabilityType.NO_LOCAL] === "boolean" ? caps[CapabilityType.NO_LOCAL] : false;
                            }
                        }
                        return noLocalSupported;
                    }
                    /**
   * Check against an odd router version which OKs logins with TLS downgrade to compression,
   * but does not actually support it, and just downgrades to plain text instead.
   * @param {ClientCtrlMessage} clientCtrlMsg The message to parse
   * @returns {Boolean} false if router should have rejected login for unsupported compressed TLS.
   * @private
   */
                    checkCompressedSsl(clientCtrlMsg) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        if (this._compressedTLS) {
                            const caps = clientCtrlMsg.getRouterCapabilities();
                            if (!caps || typeof caps[CapabilityType.COMPRESSED_SSL] !== "boolean") {
                                LOG_TRACE("Compressed SSL capability missing.");
                                return false;
                            }
                            return caps[CapabilityType.COMPRESSED_SSL] === true;
                        }
                        return true;
                    }
                    /**
   * Check destination against router capablilities
   * @param {Destination} destination to verify
   * @returns {?solace.OperationError} error for caller to throw otherwise null
   * @private
   */
                    checkSessionDestinationCapability(destination) {
                        let error = null;
                        if (destination && destination.getType()) {
                            if (destination.getSubscriptionInfo() && (destination.getSubscriptionInfo().isShare || destination.getSubscriptionInfo().isNoExport) && !this._session.isCapable(CapabilityType.SHARED_SUBSCRIPTIONS)) {
                                error = new OperationError("Shared subscriptions are not allowed by router for this client", ErrorSubcode.SHARED_SUBSCRIPTIONS_NOT_SUPPORTED, null);
                            }
                        }
                        return error;
                    }
                    /**
   * Clears the current error exit information for the FSM.
   */
                    clearCurrentError() {
                        this._currentError = null;
                    }
                    /**
   * @private
   */
                    clearSubscriptionCacheKeys() {
                        this._subscriptionCacheKeys = null;
                    }
                    /**
   * @private
   */
                    copySubscriptionCacheKeys() {
                        // reapply subscriptions if applicable
                        this.clearSubscriptionCacheKeys();
                        this._subscriptionCacheKeys = Object.keys(this._subscriptionCache || {});
                        // Add the P2P Inbox subscription, so the subscriptionCache always has
                        // at least one subscription.
                        const p2pTopic = P2PUtil.getP2PTopicSubscription(this._sessionProperties.p2pInboxBase);
                        this._subscriptionCacheKeys.push(p2pTopic);
                    }
                    createMessagePublisher() {
                        const {
                            LOG_DEBUG
                        } = this.logger;
                        if (!this._sessionProperties.publisherProperties.enabled) {
                            LOG_DEBUG("Publisher is disabled");
                            return;
                        }
                        const {
                            MessagePublisher,
                            MessagePublisherEventName
                        } = PublisherLib;
                        const publisher = new MessagePublisher({
                            properties: this._sessionProperties.publisherProperties,
                            sessionInterfaceFactory: this._flowInterfaceFactory
                        });
                        publisher.on(MessagePublisherEventName.UP, () => this.processEvent(new SessionFSMEvent({
                            name: SessionEventName.FLOW_UP
                        }, {
                            guaranteedFlowObject: publisher
                        })));
                        publisher.on(MessagePublisherEventName.CONNECT_FAILED_ERROR, event => this.processEvent(new SessionFSMEvent({
                            name: SessionEventName.FLOW_FAILED
                        }, {
                            guaranteedFlowObject: publisher,
                            event: event,
                            eventText: event.description
                        })));
                        publisher.on(MessagePublisherEventName.REJECTED_MESSAGE, (message, ctrlMessage) => {
                            const header = ctrlMessage.smfHeader;
                            const respCode = header.pm_respcode;
                            const respText = header.pm_respstr;
                            const errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(respCode, respText);
                            const event = SessionEvent.build(SessionEventCode.REJECTED_MESSAGE_ERROR, respText, respCode, errorSubcode, message.getCorrelationKey());
                            event["message"] = message; // eslint-disable-line dot-notation
                            this.emitSessionEvent(event);
                        });
                        publisher.on(MessagePublisherEventName.ACKNOWLEDGED_MESSAGE, message => {
                            const event = SessionEvent.build(SessionEventCode.ACKNOWLEDGED_MESSAGE, "Message(s) acknowledged", undefined, 0, message.getCorrelationKey());
                            event["message"] = message; // eslint-disable-line dot-notation
                            this.emitSessionEvent(event);
                        });
                        publisher.on(MessagePublisherEventName.FLOW_NAME_CHANGED, data => {
                            const {
                                messages,
                                count
                            } = data;
                            if (count > 0) {
                                const event = SessionEvent.build(SessionEventCode.REPUBLISHING_UNACKED_MESSAGES, `Republishing ${count} messages due to ` + "Guaranteed Message Publisher failed to reconnect");
                                event["messages"] = messages; // eslint-disable-line dot-notation
                                event["count"] = count; // eslint-disable-line dot-notation
                                this.emitSessionEvent(event);
                            }
                        });
                        publisher.on(MessagePublisherEventName.CAN_SEND, () => {
                            this.emitSessionEvent(SessionEvent.build(SessionEventCode.CAN_ACCEPT_DATA, `${publisher} window is now open and can send`));
                        });
                        publisher.on(MessagePublisherEventName.GUARANTEED_MESSAGING_DOWN, () => {
                            this.emitSessionEvent(SessionEvent.build(SessionEventCode.GUARANTEED_MESSAGE_PUBLISHER_DOWN, "Guaranteed Message Publishing shut down"));
                        });
                        this._defaultPublisher = publisher;
                    }
                    sendConsumerSessionUpEvent(consumer) {
                        const {
                            ConsumerFSMEvent,
                            ConsumerFSMEventNames
                        } = ConsumerLib;
                        const isAD = this._session.canConnectConsumer;
                        const event = new ConsumerFSMEvent({
                            name: isAD ? ConsumerFSMEventNames.SESSION_UP : ConsumerFSMEventNames.SESSION_UP_NO_AD
                        });
                        event.guaranteedFlowObject = consumer;
                        consumer.processFSMEvent(event);
                    }
                    sendPublisherSessionUpEvent(publisher) {
                        const isAD = this._session.canConnectPublisher;
                        const event = new PublisherLib.PublisherFSMEvent({
                            name: isAD ? PublisherLib.PublisherFSMEventNames.SESSION_UP : PublisherLib.PublisherFSMEventNames.SESSION_UP_NO_AD
                        });
                        event.guaranteedFlowObject = publisher;
                        publisher.processFSMEvent(event);
                    }
                    /**
   * Creates a Guaranteed Messaging Subscriber.
   *
   * @param {Object|MessageConsumerProperties} properties Properties for the flow.
   *  Expected fields: {@link solace.MessageConsumerProperties}
   * @returns {solace.MessageConsumer} The newly constructed consumer
   * @private
   */
                    createMessageConsumer(properties) {
                        const {
                            MessageConsumer
                        } = ConsumerLib;
                        const consumer = new MessageConsumer({
                            properties: properties,
                            sessionInterfaceFactory: this._flowInterfaceFactory
                        });
                        // use the consumer properties instead of properties to ensure the topicEndpointSubscription
                        // has a Topic object
                        const consumerProperties = consumer.getProperties();
                        if (consumerProperties.topicEndpointSubscription) {
                            //check topic supported
                            const error = this.checkSessionDestinationCapability(consumerProperties.topicEndpointSubscription);
                            if (error) {
                                throw error;
                            }
                        }
                        const info = {
                            guaranteedFlowObject: consumer
                        };
                        // Will be added to the guaranteed flow collection by dispatching
                        this.processEvent(new SessionFSMEvent({
                            name: SessionEventName.CREATE_SUBSCRIBER
                        }, info));
                        return consumer;
                    }
                    /**
   * Creates a Queue Browser.
   *
   * @param {Object|QueueBrowserProperties} properties Properties for the queue browser.
   *  Expected fields: {@link solace.QueueBrowserProperties}
   * @returns {solace.QueueBrowser} The newly constructed queue browser
   * @private
   */
                    createQueueBrowser(properties) {
                        const {
                            MessageConsumerAcknowledgeMode,
                            QueueBrowser
                        } = ConsumerLib;
                        const {
                            LOG_DEBUG
                        } = this.logger;
                        LOG_DEBUG(`Creating queue browser with properties:  ${properties}`);
                        const consumerProperties = {};
                        consumerProperties.queueDescriptor = properties.queueDescriptor;
                        consumerProperties.acknowledgeMode = MessageConsumerAcknowledgeMode.CLIENT;
                        consumerProperties.browser = true;
                        // Optional properties
                        if (Object.prototype.hasOwnProperty.call(properties, "connectTimeoutInMsecs")) {
                            consumerProperties.connectTimeoutInMsecs = properties.connectTimeoutInMsecs;
                        }
                        if (Object.prototype.hasOwnProperty.call(properties, "connectAttempts")) {
                            consumerProperties.connectAttempts = properties.connectAttempts;
                        }
                        if (Object.prototype.hasOwnProperty.call(properties, "windowSize")) {
                            consumerProperties.windowSize = properties.windowSize;
                        }
                        if (Object.prototype.hasOwnProperty.call(properties, "transportAcknowledgeTimeoutInMsecs")) {
                            consumerProperties.transportAcknowledgeTimeoutInMsecs = properties.transportAcknowledgeTimeoutInMsecs;
                        }
                        if (Object.prototype.hasOwnProperty.call(properties, "transportAcknowledgeThresholdPercentage")) {
                            consumerProperties.transportAcknowledgeThresholdPercentage = properties.transportAcknowledgeThresholdPercentage;
                        }
                        const consumer = this.createMessageConsumer(consumerProperties);
                        const browser = new QueueBrowser(consumer);
                        return browser;
                    }
                    /**
   * @param {String} msg The status message for the operation
   * @param {Subcode} subcode The subcode reason for the operation
   * @private
   */
                    destroyTransportSession(msg, subcode) {
                        if (Check.nothing(this._transport)) {
                            // Just send the event
                            this.processEvent(new SessionFSMEvent({
                                name: SessionEventName.TRANSPORT_DESTROYED
                            }));
                            return;
                        }
                        const {
                            LOG_INFO,
                            LOG_ERROR
                        } = this.logger;
                        LOG_INFO("Destroy transport session");
                        const returnCode = this._transport.destroy(msg, subcode);
                        this._smfClient = null;
                        if (returnCode !== TransportLib.TransportReturnCode.OK) {
                            LOG_ERROR(`Failed to destroy transport session, return code: ${TransportLib.TransportReturnCode.describe(returnCode)}`);
                        }
                    }
                    /**
   * Release all resources associated with the session.
   * @private
   */
                    disposeInternal() {
                        if (this._disposed) {
                            return;
                        }
                        const operations = {
                            transport: () => {
                                this.destroyTransportSession("Disposing", 0);
                                this._transport = null;
                                this._smfClient = null;
                            },
                            session: () => {
                                this.cleanupSession();
                                this._session = null;
                                this._sessionProperties = null;
                                this._correlatedReqs = null;
                                this._flowInterfaceFactory = null;
                            },
                            statistics: () => {
                                if (this._sessionStatistics) {
                                    this._sessionStatistics.resetStats();
                                    this._sessionStatistics = null;
                                }
                                this._kaStats = null;
                            },
                            "subscription cache": () => {
                                if (this._subscriptionCache) {
                                    Object.keys(this._subscriptionCache).forEach(key => this.removeFromSubscriptionCache(key));
                                    this._subscriptionCache = null;
                                }
                                this.clearSubscriptionCacheKeys();
                                this._subscriptionCacheCount = 0;
                            },
                            MessagePublishers: () => {
                                if (this._defaultPublisher) {
                                    this._defaultPublisher.dispose();
                                    this._defaultPublisher = null;
                                }
                            },
                            MessageConsumers: () => {
                                this._consumers.disposeAll();
                                this._consumers = null;
                            },
                            "host list": () => {
                                this._currentHost = null;
                                this._hosts = null;
                            }
                        };
                        Object.keys(operations).forEach(operationKey => {
                            const {
                                LOG_TRACE,
                                LOG_INFO
                            } = this.logger;
                            const operation = operations[operationKey];
                            try {
                                LOG_TRACE(`Dispose: ${operationKey}`);
                                operation();
                                LOG_TRACE(`Dispose: ${operationKey} succeeded`);
                            } catch (ex) {
                                LOG_INFO(`Dispose: ${operationKey} failed:`, ex, "...continuing");
                            }
                        });
                        this._disposed = true;
                    }
                    emitSessionEvent(event) {
                        // Don't log here; callee does it
                        this._session.sendEvent(event);
                    }
                    /**
   * @param {Number} correlationTag The correlation tag
   * @param {function} reqTimeoutCb The timeout callback
   * @param {Number} reqTimeout The timeout in milliseconds
   * @param {Object} correlationKey The correlation key
   * @param {function} respRecvCallback The success callback
   * @private
   */
                    enqueueOutstandingCorrelatedReq(correlationTag, reqTimeoutCb, reqTimeout, correlationKey, respRecvCallback) {
                        if (Check.nothing(correlationTag)) {
                            return;
                        }
                        const {
                            LOG_INFO
                        } = this.logger;
                        LOG_INFO(`Enqueue outstanding ctrl request correlationTag=${correlationTag}`);
                        let timer = null;
                        if (reqTimeoutCb) {
                            timer = setTimeout(reqTimeoutCb, reqTimeout || this._sessionProperties.readTimeoutInMsecs);
                        }
                        const outstandingReq = new CorrelatedRequest(correlationTag, timer, correlationKey, respRecvCallback);
                        this._correlatedReqs[correlationTag] = outstandingReq;
                    }
                    /**
   * @param {String} errorEventText Description of the error
   * @param {ErrorSubcode} errorSubcode Subcode for the error
   * @param {String} [eventReason] The reason for the error
   * @returns {undefined}
   * @memberof SessionFSM
   * @private
   */
                    errorInFsm(errorEventText, errorSubcode, eventReason = null) {
                        const {
                            LOG_INFO
                        } = this.logger;
                        const sEvent = new SessionFSMEvent({
                            name: SessionEventName.EXCEPTION
                        });
                        LOG_INFO(`Handling error in FSM: ${errorEventText} ${eventReason && eventReason.stack}`);
                        this.setCurrentError({
                            eventText: errorEventText,
                            errorSubcode: errorSubcode,
                            eventReason: eventReason
                        });
                        return this.processEvent(sEvent);
                    }
                    flushTransportSession(callback) {
                        if (this._transport) {
                            this._transport.flush(callback);
                        } else {
                            callback();
                        }
                    }
                    /**
   * @returns {Number} The next correlation tag
   * @private
   */
                    getCorrelationTag() {
                        return this._smfClient.nextCorrelationTag();
                    }
                    /**
   * Get current state name
   * @returns {String} The name of the current state, or SessionStateName.DISPOSED if the
   *  FSM is terminated
   * @private
   */
                    getCurrentStateName() {
                        const currentState = this.getCurrentState();
                        if (!currentState) return null;
                        if (currentState === this.getFinalState()) return SessionStateName.DISPOSED;
                        return this.getCurrentState().getName();
                    }
                    /**
   * Returns the value of a given {@link StatType}.
   *
   * @param {StatType} statType The statistic to query.
   * @returns {?Number} The value for the given stat, if available
   * @private
   */
                    getStat(statType) {
                        if (this._sessionStatistics === undefined) {
                            return undefined;
                        }
                        //
                        // TX_TOTAL_DATA_MSGS and TX_TOTAL_DATA_BYTES are summary counters
                        // These stats are calculated as the sum of DIRECT/PERSISTENT/NONPERSISTENT
                        // counters.  This is by design since day one.  As such they do not include
                        // the count of redelivered messages/bytes as TX_PERSISTENT_MSGS and TX_NONPERSISTENT_MSGS
                        // only includes the counts of messages successfully delivered. This is not consistent
                        // with receive stats but it is what it is. This definition is consistent with the other
                        // existing APIs (CCSMP and JCSMP).
                        //
                        if (statType === StatType.TX_TOTAL_DATA_MSGS) {
                            return this._sessionStatistics.getStat(StatType.TX_DIRECT_MSGS) + this._sessionStatistics.getStat(StatType.TX_PERSISTENT_MSGS) + this._sessionStatistics.getStat(StatType.TX_NONPERSISTENT_MSGS);
                        } else if (statType === StatType.TX_TOTAL_DATA_BYTES) {
                            return this._sessionStatistics.getStat(StatType.TX_DIRECT_BYTES) + this._sessionStatistics.getStat(StatType.TX_PERSISTENT_BYTES) + this._sessionStatistics.getStat(StatType.TX_NONPERSISTENT_BYTES);
                        }
                        return this._sessionStatistics.getStat(statType);
                    }
                    /**
   * Gets a transport session information string.
   * This string is informative only, and applications should not attempt to parse it.
   *
   * @returns {String} The current status of the transport
   */
                    getTransportInfo() {
                        if (Check.nothing(this._transport)) {
                            return "Not connected.";
                        }
                        return this._transport.getInfoStr();
                    }
                    /**
   * Handle an AD CTRL message given the message, its header, and the previously-identified
   * candidate flow, which is used if the message has no correlation tag.
   *
   * @param {AdProtocolMessage} message The message to handle
   * @param {SMFHeader} header The header of the message
   * @returns {SessionFSM} This FSM.
   * @private
   */
                    handleADCtrlMessage(message, header) {
                        const flowId = message.getFlowId();
                        const respText = header.pm_respstr;
                        const correlationTag = header.pm_corrtag;
                        const {
                            LOG_INFO,
                            LOG_DEBUG,
                            LOG_WARN
                        } = this.logger;
                        if (correlationTag) {
                            // Correlation tag is non-null
                            // Session handles correlated request-reply
                            this.updateRxStats(message);
                            LOG_INFO(`Handle SMF response for correlationTag ${correlationTag}`);
                            // find matching correlationTag to cancel timer
                            const cancelledRequest = this.cancelOutstandingCorrelatedReq(correlationTag);
                            if (Check.nothing(cancelledRequest)) {
                                return this.errorInFsm(`Cannot find matching request for response: ${respText}`, ErrorSubcode.INTERNAL_ERROR);
                            }
                            if (cancelledRequest.respRecvdCallback) {
                                // call callback referenced by cancelledRequest
                                // login or update property
                                cancelledRequest.respRecvdCallback(message, cancelledRequest);
                                return this;
                            }
                            LOG_DEBUG(`Dropping ADCTRL message due to mismatched correlation tag ${correlationTag}`);
                            this.incStat(StatType.RX_REPLY_MSG_DISCARD);
                            return this;
                        }
                        // Unsolicited control message
                        let flow;
                        const msgType = message.msgType;
                        const {
                            SMFAdProtocolMessageType
                        } = SMFLib;
                        switch (msgType) {
                          case SMFAdProtocolMessageType.CLIENTACK:
                          case SMFAdProtocolMessageType.CLIENTNACK:
                          case SMFAdProtocolMessageType.CLOSEPUBFLOW:
                            if (this._defaultPublisher.flowId === flowId) {
                                flow = this._defaultPublisher;
                            } // else drop.
                            break;

                          default:
                            flow = this._consumers.getFlowById(flowId);
                        }
                        if (flow && !flow.disposed) {
                            // Found a matching flow
                            this.updateRxStats(message, flow);
                            flow.handleUncorrelatedControlMessage(message);
                            return this;
                        }
                        // No matching flow
                        const response = message.getResponse();
                        const rc = response ? `"${response.responseCode} ${response.responseString}" ` : "";
                        LOG_WARN(`Dropping ADCTRL.${SMFLib.SMFAdProtocolMessageType.describe(message.msgType)} ${rc}for unknown flow ${flowId}`);
                        this.incStat(StatType.RX_DISCARD_NO_MATCHING_CONSUMER);
                        return this;
                    }
                    /**
   * @param {solace.Message} message The AD data message to handle
   * @param {SMFHeader} header The header for the message
   * @returns {MessageConsumer} The flow that handled the message, or `null`
   * @private
   */
                    handleADTrMessage(message, header) {
                        const {
                            LOG_DEBUG
                        } = this.logger;
                        const flowId = header.pm_ad_flowid;
                        // Get a flow from that ID if possible.
                        const flow = this._consumers.getFlowById(flowId);
                        if (!flow || flow.disposed) {
                            LOG_DEBUG("Dropped incoming AD message for " + `${flow ? "disposed" : "unknown"} flow ID ${flowId}`);
                            this.updateRxStats(message, this._sessionStatistics);
                            this.incStat(StatType.RX_DISCARD_NO_MATCHING_CONSUMER);
                            return null;
                        }
                        this.updateRxStats(message, flow);
                        flow.handleDataMessage(message);
                        return flow;
                    }
                    /**
   * @param {String} correlationTag The correlation tag for the timed out subscription request
   * @param {String} [timeoutMsg] The reason for the timeout
   * @private
   */
                    handleApiSubscriptionTimeout(correlationTag, timeoutMsg) {
                        // remove request from queue
                        if (this._correlatedReqs[correlationTag] === undefined || this._correlatedReqs[correlationTag] === null) {
                            return;
                        }
                        const {
                            LOG_INFO,
                            LOG_ERROR
                        } = this.logger;
                        LOG_INFO(`${timeoutMsg || "Subscription timeout"} for correlationTag=${correlationTag}`);
                        try {
                            const result = delete this._correlatedReqs[correlationTag];
                            if (!result) {
                                LOG_ERROR(`Cannot delete ctrl request ${correlationTag}`);
                            }
                        } catch (e) {
                            LOG_ERROR(`Cannot delete ctrl request ${correlationTag}, exception: ${e.message}`);
                        }
                    }
                    /**
   * @param {ClientCtrlMessage} message The message to handle
   * @param {SMFHeader} header The header from the message
   * @returns {undefined}
   * @private
   */
                    handleClientCtrlMessage(message, header) {
                        let correlationTag;
                        const {
                            LOG_INFO
                        } = this.logger;
                        this.updateRxStats(message);
                        if (message.msgType === SMFLib.SMFClientCtrlMessageType.LOGIN) {
                            // Currently, login requests don't use a correlation tag.
                            // Using here a fake internal one to match the request.
                            correlationTag = TransportLib.SMFClient.SMF_CLIENTCTRL_LOGIN_FAKE_CORRELATIONTAG;
                            LOG_INFO("Handle SMF response for ClientCTRL Login");
                        } else {
                            correlationTag = header.pm_corrtag;
                            LOG_INFO(`Handle SMF response for correlationTag ${correlationTag}`);
                        }
                        // find matching correlationTag to cancel timer
                        const cancelledRequest = this.cancelOutstandingCorrelatedReq(correlationTag);
                        if (Check.nothing(cancelledRequest)) {
                            const respText = header.pm_respstr;
                            return this.errorInFsm(`Cannot find matching request for response: ${respText}`, ErrorSubcode.INTERNAL_ERROR);
                        } else if (cancelledRequest.respRecvdCallback) {
                            // call callback referenced by cancelledRequest
                            // login or update property
                            return cancelledRequest.respRecvdCallback(message);
                        }
                        LOG_INFO(`Dropping ClientCtrl message due to mismatched correlation tag ${correlationTag}`);
                        return this.incStat(StatType.RX_REPLY_MSG_DISCARD);
                    }
                    /**
   * @param {ClientCtrlMessage} clientCtrlMsg The message to handle
   * @private
   */
                    handleClientCtrlResponse(clientCtrlMsg) {
                        const sEvent = new SessionFSMEvent({
                            name: SessionEventName.TRANSPORT_PROTOCOL_CLIENTCTRL
                        });
                        sEvent.smfMsg = clientCtrlMsg;
                        this.processEvent(sEvent);
                    }
                    /**
   * @private
   */
                    handleClientCtrlTimeout() {
                        const {
                            LOG_INFO
                        } = this.logger;
                        LOG_INFO("ClientCtrl timeout for session");
                        const sEvent = new SessionFSMEvent({
                            name: SessionEventName.DOWNGRADE_TIMEOUT
                        });
                        this.processEvent(sEvent);
                    }
                    /**
   * @private
   */
                    handleConnectTimeout() {
                        const {
                            LOG_INFO
                        } = this.logger;
                        LOG_INFO("Connection timeout. Disconnecting");
                        const sEvent = new SessionFSMEvent({
                            name: SessionEventName.CONNECT_TIMEOUT
                        });
                        this.processEvent(sEvent);
                    }
                    /**
   * Handle control request timeout
   * @param {String} correlationTag The correlation tag for the timed out operation
   * @param {String} timeoutMsg The message associated with the timeout
   * @private
   */
                    handleUpdatePropertyTimeout(correlationTag, timeoutMsg) {
                        const {
                            LOG_ERROR
                        } = this.logger;
                        // remove request from queue
                        try {
                            const result = delete this._correlatedReqs[correlationTag];
                            if (!result) {
                                LOG_ERROR(`Cannot delete ctrl request ${correlationTag}`);
                            }
                        } catch (e) {
                            LOG_ERROR(`Cannot delete ctrl request ${correlationTag}, exception: ${e.message}`);
                        }
                        // notify client
                        const sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, timeoutMsg, null, ErrorSubcode.TIMEOUT, null, null);
                        this.sendEvent(sessionEvent);
                    }
                    /**
   * @param {SMFHeader} header The header from the rejected message
   * @private
   */
                    handleRejectedTrMessage(header) {
                        // It is trmsg response. For direct message, it must be a failure response
                        const respCode = header.pm_respcode;
                        // Strip a trailing null character.
                        const topicNameRaw = header.pm_tr_topicname_bytes;
                        const topicName = topicNameRaw ? topicNameRaw.replace(/\0/g, "") : "";
                        const respText = header.pm_respstr;
                        const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
                        this.emitSessionEvent(SessionEvent.build(SessionEventCode.REJECTED_MESSAGE_ERROR, respText, respCode, errorSubcode, null, //correlation key
                        `Topic: ${topicName}`));
                    }
                    /**
   * @param {solace.Message} message The SMF message to handle
   * @returns {undefined}
   * @private
   */
                    handleSMFMessage(message) {
                        try {
                            // Stats for this message might affect both the session and the flow. Need to
                            // determine where the message is handled before handling stats.
                            // Some ADCTRL messages have no flow ID but only a correlation tag.
                            // These are OPENFLOW and we count them as handled by the session.
                            const header = message.smfHeader;
                            if (header.discardMessage) {
                                // UH==2 on an unknown parameter
                                if (this._sessionStatistics) {
                                    this._sessionStatistics.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
                                }
                                // do nothing.
                                return null;
                            }
                            // Each message type handler must call this.updateRxStats(message, target).
                            // The direct/TRmsg path includes the call here in the switch.
                            switch (header.smf_protocol) {
                              case SMFLib.SMFProtocol.TRMSG:
                                if (header.smf_adf) {
                                    return this.handleADTrMessage(message, header);
                                }
                                this.updateRxStats(message, this._sessionStatistics);
                                return header.pm_respcode === 0 ? this._session.handleDataMessage(message) : this.handleRejectedTrMessage(header);

                              case SMFLib.SMFProtocol.ADCTRL:
                                return this.handleADCtrlMessage(message, header);

                              case SMFLib.SMFProtocol.CLIENTCTRL:
                                return this.handleClientCtrlMessage(message, header);

                              case SMFLib.SMFProtocol.SMP:
                                return this.handleSMPMessage(message, header);

                              case SMFLib.SMFProtocol.KEEPALIVE:
                              case SMFLib.SMFProtocol.KEEPALIVEV2:
                                // do nothing
                                return null;

                              default:
                                return this.handleUnknownProtocolMessage(message, header);
                            }
                        } catch (e) {
                            const {
                                LOG_ERROR
                            } = this.logger;
                            LOG_ERROR(`Exception in handleSMFMessage, exception: ${e.stack}`);
                            return this.errorInFsm(`Exception in handleSMFMessage: ${e.message}`, e.subcode || ErrorSubcode.INTERNAL_ERROR, e);
                        }
                    }
                    /**
   * @param {TransportError} transportError The SMF parsing error passed from the transport
   * @returns {undefined}
   * @private
   */
                    handleSMFParseError(transportError) {
                        // fatal connection error
                        // notify client
                        return this.errorInFsm(transportError, ErrorSubcode.PROTOCOL_ERROR);
                    }
                    handleSMPMessage(message, header) {
                        this.updateRxStats(message);
                        // find matching correlationTag to cancel timer
                        const cancelledRequest = this.cancelOutstandingCorrelatedReq(header.pm_corrtag || "");
                        /*
     * If we find the correlationTag and it has a callback associated with it
     * then call that callback.  It is likely calling back straight to the application
     * due to a call to session.subscribe() or session.unsubscribe() or
     * session.updateProperty().
     * Otherwise just send a TRANSPORT_PROTOCOL_SMP event to the FSM.
     */
                        if (Check.nothing(cancelledRequest) || Check.nothing(cancelledRequest.respRecvdCallback)) {
                            /*
       * correlation tag not found, probably an error response to a subscription
       * request that did not request-confirm,  or it could be one of the
       * FSM generated subscriptions and the callback is the anonymous function
       * in state WaitingForSubConfirmm
       */
                            const sEvent = new SessionFSMEvent({
                                name: SessionEventName.TRANSPORT_PROTOCOL_SMP
                            });
                            sEvent.smfMsg = message;
                            return this.processEvent(sEvent);
                        }
                        // calling through the callback, this should  be a callback in the _session for
                        // applicated generated subscribe/unsubscribe/updateProperty(clientName)
                        return cancelledRequest.respRecvdCallback(message, cancelledRequest);
                    }
                    /**
   * @param {Number} respCode The router response code
   * @param {String} respText The router response text
   * @param {String} subscriptionStr The subscription cache key
   * @param {CorrelatedRequest} request The associated request
   * @param {Boolean} confirm Whether the user wanted confirmation for the request
   * @private
   */
                    handleSubscriptionUpdateError(respCode, respText, subscriptionStr, request, confirm) {
                        const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
                        //
                        // if it is a not-found or already-present error, it does not affect our subscription
                        // cache, otherwise remove it from the cache.
                        //
                        if (!(errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT || errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND)) {
                            // remove from cache
                            this.removeFromSubscriptionCache(subscriptionStr);
                        }
                        //
                        // notify the client
                        //
                        this._session.handleSubscriptionUpdateError(respCode, respText, subscriptionStr, request, confirm);
                    }
                    /**
   * @param {String} correlationTag The correlation tag for the timed out request
   * @private
   */
                    handleSubscriptionTimeout(correlationTag) {
                        // remove request from queue
                        const {
                            LOG_ERROR
                        } = this.logger;
                        try {
                            const result = delete this._correlatedReqs[correlationTag];
                            if (!result) {
                                LOG_ERROR(`Cannot delete ctrl request ${correlationTag}`);
                            }
                        } catch (e) {
                            LOG_ERROR(`Cannot delete ctrl request ${correlationTag}`, e);
                        }
                        const sEvent = new SessionFSMEvent({
                            name: SessionEventName.SUBSCRIBE_TIMEOUT
                        });
                        this.processEvent(sEvent);
                    }
                    /**
   * @param {TransportSessionEvent} transportEvent The event to handle
   * @returns {undefined}
   * @private
   */
                    handleTransportEvent(transportEvent) {
                        const {
                            LOG_INFO,
                            LOG_WARN
                        } = this.logger;
                        const infoStr = transportEvent.getInfoStr() || "";
                        LOG_INFO(`Receive transport event: ${transportEvent}`);
                        let sEvent;
                        switch (transportEvent.getTransportEventCode()) {
                          case TransportLib.TransportSessionEventCode.UP_NOTICE:
                            sEvent = new SessionFSMEvent({
                                name: SessionEventName.TRANSPORT_UP
                            });
                            sEvent.sessionId = transportEvent.getSessionId();
                            this.processEvent(sEvent);
                            break;

                          case TransportLib.TransportSessionEventCode.DESTROYED_NOTICE:
                            sEvent = new SessionFSMEvent({
                                name: SessionEventName.TRANSPORT_DESTROYED
                            });
                            sEvent.sessionId = transportEvent.getSessionId();
                            sEvent.eventText = infoStr;
                            sEvent.errorSubcode = transportEvent.getSubcode();
                            sEvent.eventReason = transportEvent;
                            this._smfClient = null; // calling reset does nothing useful here
                            this._transport = null; // transport has been destroyed
                            this.processEvent(sEvent);
                            break;

                          case TransportLib.TransportSessionEventCode.CAN_ACCEPT_DATA:
                            //
                            // unblock the publisher too
                            this.GuaranteedFlowControlledRelief();
                            sEvent = new SessionFSMEvent({
                                name: SessionEventName.TRANSPORT_CAN_ACCEPT_DATA
                            });
                            sEvent.sessionId = transportEvent.getSessionId();
                            this.processEvent(sEvent);
                            break;

                          case TransportLib.TransportSessionEventCode.SEND_ERROR:
                            sEvent = new SessionFSMEvent({
                                name: SessionEventName.SEND_ERROR
                            });
                            sEvent.sessionId = transportEvent.getSessionId();
                            sEvent.eventText = transportEvent.getInfoStr();
                            sEvent.errorSubcode = transportEvent.getSubcode();
                            sEvent.eventReason = transportEvent;
                            this.processEvent(sEvent);
                            break;

                          case TransportLib.TransportSessionEventCode.DATA_DECODE_ERROR:
                          case TransportLib.TransportSessionEventCode.PARSE_FAILURE:
                            // fatal connection error
                            return this.errorInFsm(transportEvent.getInfoStr(), transportEvent.getSubcode());

                          default:
                            LOG_WARN("Received unknown transport session event", transportEvent);
                        }
                        return true;
                    }
                    /**
   * @param {BaseMessage|Message} message The message to handle
   * @param {SMFHeader} [header] The SMF header from the message, if available
   * @returns {undefined}
   * @private
   */
                    handleUnknownProtocolMessage(message, header) {
                        const {
                            LOG_INFO,
                            LOG_ERROR
                        } = this.logger;
                        // unknown protocol
                        this.updateRxStats(message);
                        if (header && header.smf_protocol === SMFLib.SMFProtocol.TSESSION) {
                            // change state
                            LOG_ERROR(`Received transport session message instead of SMF message, protocol 0x${formatHexString(header.smf_protocol)}`);
                            LOG_ERROR(`Transport MessageType=${message.messageType}, target sessionId=${formatHexString(message.sessionId)}`);
                            // notify client
                            return this.errorInFsm("Received message with unknown protocol", ErrorSubcode.PARSE_FAILURE);
                        }
                        // Drop message of unknown protocol and increment stats
                        if (this._sessionStatistics) {
                            this._sessionStatistics.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
                        }
                        LOG_INFO(`Drop message with unknown protocol 0x${formatHexString(header.smf_protocol)}`);
                        return null;
                    }
                    /**
   * Increments a session statistic
   *
   * @param {StatType} statType The key to increment
   * @param {?Number} value The amount to increment the value by
   * @returns {?Number} The new value for the statistic
   * @private
   */
                    incStat(statType, value) {
                        return this._sessionStatistics ? this._sessionStatistics.incStat(statType, value) : undefined;
                    }
                    /**
   * @private
   */
                    initTransport() {
                        const {
                            LOG_INFO
                        } = this.logger;
                        const host = this._currentHost;
                        LOG_INFO(`Creating transport session ${host}`);
                        this._kaStats = {
                            lastMsgWritten: 0,
                            lastBytesWritten: 0
                        };
                        this._smfClient = new TransportLib.SMFClient(rxData => this.handleSMFMessage(rxData), rxError => this.handleSMFParseError(rxError), this);
                        this._transport = TransportLib.TransportFactory.createTransport(host, transportEvent => this.handleTransportEvent(transportEvent), this._smfClient, this._sessionProperties.clone(), () => this.sessionIdHex);
                        this.injectTransportInterceptor(this._transportInterceptor);
                    }
                    /**
   * Installs a transport interceptor for the current and any future transports.
   *
   * The object methods .installed(instance) and .removed(instance) will be called if present, with
   * the transport instance as a parameter.
   *
   * To stop using transport interceptors, supply a null interceptor argument.
   *
   * @param {Object} interceptor An object given access to the internals of the transport instance.
   * @private
   */
                    injectTransportInterceptor(interceptor) {
                        this._transportInterceptor = interceptor;
                        if (this._transport) {
                            this._transport.setInterceptor(interceptor);
                        }
                    }
                    /**
   * Call from keep alive scheduled task
   * @returns {undefined}
   * @private
   */
                    keepAliveTimeout() {
                        const {
                            LOG_TRACE,
                            LOG_DEBUG,
                            LOG_INFO
                        } = this.logger;
                        LOG_TRACE("KeepAlive timeout");
                        // session is in connected state but hasn't received keep alive response
                        // Less than or equal to because this is the number of *already sent* KAs
                        if (this._keepAliveCounter >= this._sessionProperties.keepAliveIntervalsLimit) {
                            LOG_INFO(`Exceed maximum keep alive intervals limit ${this._sessionProperties.keepAliveIntervalsLimit}`);
                            // stop timers
                            LOG_DEBUG("Stop keep alive timer");
                            if (this._keepAliveTimer) {
                                clearInterval(this._keepAliveTimer);
                            }
                            // change session state
                            return this.errorInFsm("Exceed maximum keep alive intervals limit", ErrorSubcode.KEEP_ALIVE_FAILURE);
                        }
                        LOG_TRACE("About to send keep alive");
                        const clientStats = this._transport.getClientStats();
                        const prestatMsgWritten = clientStats.msgWritten;
                        const prestatBytesWritten = clientStats.bytesWritten;
                        const kaMsg = new SMFLib.KeepAliveMessage();
                        const returnCode = this.send(kaMsg, null, true);
                        if (returnCode !== TransportLib.TransportReturnCode.OK) {
                            /*
       * TransportReturnCode.NO_SPACE is not possible.
       * Send is called with the forceAllowEnqueue parameter.
       * So whatever error is returned is fatal
       */
                            return this.errorInFsm("Cannot send keep alive message", ErrorSubcode.KEEP_ALIVE_FAILURE);
                        }
                        // We need to avoid incrementing the KA counter if we're in the process of
                        // sending a huge message and we've had no opportunity to write a KA message.
                        // Detection: last KA's snapshot of messages written is unchanged, but number of bytes
                        // written has gone up.
                        if (this._kaStats.lastMsgWritten === prestatMsgWritten && this._kaStats.lastBytesWritten < prestatBytesWritten) {
                            LOG_DEBUG("Keep alive sent", "Not incrementing keep alive counter due to large message send", `KA count = ${this._keepAliveCounter}`);
                        } else {
                            this._keepAliveCounter++;
                            LOG_TRACE(`Last message written: ${this._kaStats.lastMsgWritten}`);
                            LOG_TRACE(`Last bytes written: ${this._kaStats.lastBytesWritten}`);
                            LOG_TRACE(`Keep alive sent, increment keep alive counter, keep alive count = ${this._keepAliveCounter}`);
                        }
                        this._kaStats.lastBytesWritten = clientStats.bytesWritten;
                        this._kaStats.lastMsgWritten = clientStats.msgWritten;
                        return true;
                    }
                    /**
   * Prepares a message for sending and then invoke the transport
   * send method. For guaranteed messages, pass the transport send
   * method to the publisher so it can be invoked from there and errors
   * handled within the publisher FSM.
   * @param {BaseMessage} message The message to prepare.
   * @private
   */
                    prepareAndSendMessage(message) {
                        if (message instanceof Message) {
                            let returnCode;
                            // Delegate message preparation where appropriate
                            const deliveryMode = message.getDeliveryMode();
                            switch (deliveryMode) {
                              case MessageDeliveryModeType.DIRECT:
                                if (!this._transport) return;
                                message._payload_is_memoized = false;
                                message._memoized_csumm = null;
                                message._memoized_payload = null;
                                returnCode = this.sendToTransport(message);
                                break;

                              case MessageDeliveryModeType.PERSISTENT:
                              case MessageDeliveryModeType.NON_PERSISTENT:
                                if (!this._defaultPublisher) {
                                    const reason = this._session.adLocallyDisabled ? "locally disabled" : "remotely unsupported";
                                    throw new OperationError("Session does not provide Guaranteed Message Publish capability", ErrorSubcode.GM_UNAVAILABLE, reason);
                                } else {
                                    if (this._gmSendDisallowed) this._gmSendDisallowed(); // throws if present
                                    returnCode = this._defaultPublisher.prepareAdMessageAndSend(message);
                                }
                                break;

                              default:
                                {
                                    const {
                                        LOG_ERROR
                                    } = this.logger;
                                    LOG_ERROR("Unhandled message delivery mode", MessageDeliveryModeType.describe(deliveryMode));
                                }
                            }
                            if (returnCode !== TransportLib.TransportReturnCode.OK) {
                                if (returnCode === TransportLib.TransportReturnCode.NO_SPACE) {
                                    // Must be DIRECT message because the Publisher handles NO_SPACE returnCode
                                    // internally
                                    this._userBackpressured = true;
                                    throw new OperationError("Cannot send message - no space in transport", ErrorSubcode.INSUFFICIENT_SPACE, TransportLib.TransportReturnCode.describe(returnCode));
                                }
                                // This is a fatal session error
                                this.setCurrentError(new OperationError("Cannot send message", ErrorSubcode.INVALID_OPERATION, TransportLib.TransportReturnCode.describe(returnCode)));
                                this.processEvent(new SessionFSMEvent({
                                    name: SessionEventName.EXCEPTION
                                }));
                            }
                        }
                    }
                    GuaranteedFlowControlledRelief() {
                        if (this._defaultPublisher) {
                            this._defaultPublisher.processFSMEvent(new PublisherLib.PublisherFSMEvent({
                                name: PublisherLib.PublisherFSMEventNames.CAN_SEND
                            }));
                        }
                    }
                    /**
   * Reapply subscriptions.
   * @returns {Boolean} True if all subscriptions were reapplied. False if WOULD_BLOCK.
   * @private
   */
                    reapplySubscriptions() {
                        const {
                            LOG_INFO,
                            LOG_DEBUG
                        } = this.logger;
                        const {
                            SolclientFactory: {
                                createTopicDestination
                            }
                        } = SolclientFactoryLib;
                        LOG_INFO(`Reapplying subscriptions, count=${this._subscriptionCacheKeys.length}`);
                        // add subscriptions and ask for confirm on last one
                        if (!this._subscriptionCacheKeys) {
                            // Nothing to do
                            return true;
                        }
                        try {
                            while (this._subscriptionCacheKeys.length) {
                                //
                                // The key is the the topic string (topic.getName()).
                                // sendSubscribe() requires a destination, so we encode it here.
                                //
                                // on entry to reapplySubscriptions we added the P2P topic to
                                // subscriptionCacheKeys but there is no corresponding entry in
                                // _subscriptionCache so we no longer use the key to index that actual
                                // cache.
                                // If it becomes necesary to pass the Topic object to sendSubscribe in a
                                // a future enhancement (perhaps to remember flags like request-confirm) then
                                // this logic here needs to be revisisted.
                                const key = this._subscriptionCacheKeys.shift();
                                const requestConfirmation = this._subscriptionCacheKeys.length === 0;
                                const topicDestination = createTopicDestination(key);
                                const rc = this.sendSubscribe(topicDestination, requestConfirmation, null, this._sessionProperties.readTimeoutInMsecs, null);
                                if (rc !== TransportLib.TransportReturnCode.OK) {
                                    this.errorInFsm(`Error occurred sending subscription: ${TransportLib.TransportReturnCode.describe(rc)}`, ErrorSubcode.INTERNAL_ERROR);
                                }
                            }
                        } catch (e) {
                            if (e instanceof OperationError && e.subcode === ErrorSubcode.INSUFFICIENT_SPACE) {
                                LOG_DEBUG("Apply subscriptions blocked due to insufficient space, wait for can accept data event");
                                return false;
                            }
                            this.errorInFsm(`Unexpected expection occurred while reapplying subscriptions: ${e}`, e.subcode || ErrorSubcode.INTERNAL_ERROR, e);
                        }
                        return true; // sent all subscriptions
                    }
                    /**
   * @param {Destination} topic The topic to remove from the subscription cache
   * @returns {?Destination} The value in the subscription cache at that key
   * @private
   */
                    removeFromSubscriptionCache(topic) {
                        if (Check.nothing(topic) || !this._subscriptionCache) {
                            return null;
                        }
                        const {
                            LOG_DEBUG,
                            LOG_ERROR
                        } = this.logger;
                        const key = topic instanceof Destination ? topic.name : topic;
                        LOG_DEBUG(`Remove subscription ${key}`);
                        const sub = this._subscriptionCache[key];
                        if (sub === undefined || sub === null) {
                            return null;
                        }
                        try {
                            const result = delete this._subscriptionCache[key];
                            if (!result) {
                                LOG_ERROR(`Cannot remove subscription ${key}`);
                            } else {
                                this._subscriptionCacheCount--;
                            }
                        } catch (e) {
                            LOG_ERROR(`Cannot remove subscription ${key}`, e);
                        }
                        return sub;
                    }
                    /**
   * Reset the FSM state and release all objects. This method is called once from
   * SessionFSM.onInitial
   * @private
   */
                    reset() {
                        this.resetStats();
                        /**
     * The following fields are disposed when disconnect is called
     * and recreated when connect is called again.
     */
                        this.sessionId = null;
                        // Need to reschedule keepAliveTimer when some other write operation happens
                        this._keepAliveTimer = null;
                        this.resetKeepAliveCounter();
                        this._correlatedReqs = {};
                        this._disposed = false;
                        this._smfClient = null;
                        this._kaStats = {
                            lastMsgWritten: 0,
                            lastBytesWritten: 0
                        };
                        /**
     * The following fields are destroyed when dispose is called
     * and cannot be reinitialized.
     */
                        this._subscriptionCache = null;
                        this._subscriptionCacheKeys = null;
                        this._subscriptionCacheCount = 0;
                        if (this._sessionProperties.reapplySubscriptions) {
                            this._subscriptionCache = {};
                        }
                        // When negotiating the initial transport, we can fail and transparently reconnect.
                        // this.resetTransportProtocolHandler();
                        // this._lastKnownGoodTransport = null;
                        // event and error information
                        this._eventCode = null;
                        this._responseCode = null;
                        this.eventText = null;
                        this.errorSubcode = null;
                        this.eventReason = null;
                    }
                    /**
   * @private
   */
                    resetKeepAliveCounter() {
                        // Reset the KA counter. Called by the SMFClient on each SMF chunk received (whether full
                        // message or not).
                        this._keepAliveCounter = 0;
                    }
                    /**
   * @returns {?} The result of calling resetStats().
   * @private
   */
                    resetStats() {
                        return this._sessionStatistics ? this._sessionStatistics.resetStats() : undefined;
                    }
                    /**
   * Schedule keep alive task
   * @private
   */
                    scheduleKeepAlive() {
                        const {
                            LOG_DEBUG,
                            LOG_ERROR
                        } = this.logger;
                        const {
                            keepAliveIntervalInMsecs
                        } = this._sessionProperties;
                        if (keepAliveIntervalInMsecs === 0) {
                            // Keepalives disabled
                            return;
                        }
                        if (this._keepAliveTimer) {
                            clearInterval(this._keepAliveTimer);
                        }
                        this._keepAliveTimer = setInterval(() => {
                            try {
                                this.keepAliveTimeout();
                            } catch (e) {
                                LOG_ERROR("Error occurred in keepAliveTimeout", e);
                            }
                        }, keepAliveIntervalInMsecs);
                        LOG_DEBUG(`Create Keepalive timer with interval: ${keepAliveIntervalInMsecs}ms`);
                    }
                    /**
   * Provide a method for the session object to use to send
   * messages to the transport.  This method is only used internally by
   * the FSM.  The session send() API should invoke sendToTransport() directly
   * so errors are thrown back to the application.
   *
   * @param {solace.Message} message The message to send
   * @param {Object} [statTarget=this._sessionStatistics] The sender of this message, for stats.
   * @param {Boolean} [forceAllowEnqueue=false] Set to true to force enqueueing of control messages
   *
   * @returns {TransportReturnCode} The RC from the transport
   * @private
   */
                    send(message, statTarget = this._sessionStatistics, forceAllowEnqueue = false) {
                        try {
                            return this.sendToTransport(message, statTarget, forceAllowEnqueue);
                        } catch (ex) {
                            const {
                                LOG_TRACE
                            } = this.logger;
                            // The send operation threw (or we threw locally), which is always a SessionException.
                            LOG_TRACE(`Error sending message: ${ex.message}: ${ex.stack}`);
                            this.errorInFsm(`Send operation failed: ${ex.message}`, ex.subcode || ErrorSubcode.CONNECTION_ERROR);
                        }
                        return TransportLib.TransportReturnCode.CONNECTION_ERROR;
                    }
                    /**
   * Provide a method for the session object to use to send
   * messages to the transport.
   *
   * @param {solace.Message} message The message to send
   * @param {Object} [statTarget=this._sessionStatistics] The sender of this message, for stats.
   * @param {Boolean} [forceAllowEnqueue=false] Set to true to force enqueueing of control messages
   *
   * @returns {TransportReturnCode} The RC from the transport
   * @private
   */
                    sendToTransport(message, statTarget = this._sessionStatistics, forceAllowEnqueue = false) {
                        let returnCode = TransportLib.TransportReturnCode.CONNECTION_ERROR;
                        if (!this._transport) {
                            throw new OperationError("Transport has been destroyed", ErrorSubcode.INTERNAL_ERROR);
                        }
                        const content = SMFLib.Codec.Encode.encodeCompoundMessage(message);
                        returnCode = this._transport.send(content, forceAllowEnqueue);
                        switch (returnCode) {
                          case TransportLib.TransportReturnCode.OK:
                            this.updateTxStats(message, statTarget);
                            break;

                          case TransportLib.TransportReturnCode.NO_SPACE:
                            if (!forceAllowEnqueue) {
                                // This is allowed.
                                break;
                            }
                            // Else fall through

                          default:
                            throw new OperationError(`Transport returned ${TransportLib.TransportReturnCode.describe(returnCode)}`, ErrorSubcode.INTERNAL_ERROR);
                        }
                        return returnCode;
                    }
                    /**
   * Initiates the ClientCtrl handshake, called from transportSessionEvent callback
   * @returns {TransportReturnCode} The RC from the transport
   * @private
   */
                    sendClientCtrlLogin() {
                        const {
                            LOG_INFO,
                            LOG_DEBUG,
                            LOG_TRACE
                        } = this.logger;
                        this._compressedTLS = this._sessionProperties.compressionLevel > 0 && this._currentHost.match(/tcps:/i) !== null;
                        this._plaintextTLS = this._currentHost.match(/tcps:/i) !== null && this._sessionProperties.sslConnectionDowngradeTo === SslDowngrade.PLAINTEXT;
                        LOG_TRACE(`sendClientLogin plaintextTLS: ${this._plaintextTLS} _compressedTLS: ${this._compressedTLS}`);
                        // Don't use the correlation tag. For Login only, the router won't return it.
                        const clientCtrlMsg = SMFLib.ClientCtrlMessage.getLogin(this._sessionProperties, this._compressedTLS, this._plaintextTLS);
                        const returnCode = this.send(clientCtrlMsg);
                        if (returnCode !== TransportLib.TransportReturnCode.OK) {
                            this._responseCode = null;
                            this.eventReason = null;
                            // notify client
                            if (returnCode === TransportLib.TransportReturnCode.NO_SPACE) {
                                this.eventText = "Cannot send client control - no space in transport";
                                this.errorSubcode = ErrorSubcode.INSUFFICIENT_SPACE;
                            } else {
                                LOG_INFO(`Cannot send client ctrl, return code
          ${TransportLib.TransportReturnCode.describe(returnCode)}`);
                                this.eventText = "Cannot send client ctrl";
                                this.errorSubcode = ErrorSubcode.INVALID_OPERATION;
                            }
                        } else {
                            // enqueue outstanding request, use a fake correlation tag for Login only
                            const correlationTag = TransportLib.SMFClient.SMF_CLIENTCTRL_LOGIN_FAKE_CORRELATIONTAG;
                            LOG_INFO(`Using internally correlationTag=${correlationTag} for tracking ClientCTRL Login`);
                            this.enqueueOutstandingCorrelatedReq(correlationTag, null, null, null, rxMsgObj => this.handleClientCtrlResponse(rxMsgObj));
                            LOG_DEBUG("Sent client ctrl");
                        }
                        return returnCode;
                    }
                    /**
   *
   * Internal method for sending subscriptions from SessionConnecting state (reapply or P2P-inbox)
   *
   * @param {Destination} topic The topic to subscribe
   * @param {Boolean} requestConfirmation If true, expect a reply on success also
   * @param {String} correlationKey The correlation key for the request
   * @param {Number} requestTimeout The timeout for the request
   * @param {function} respRecvdCallback The callback on reply received
   * @returns {TransportReturnCode} The RC from the transport
   * @private
   */
                    sendSubscribe(topic, requestConfirmation, correlationKey, requestTimeout, respRecvdCallback) {
                        const {
                            LOG_INFO,
                            LOG_DEBUG
                        } = this.logger;
                        assert(topic instanceof Destination, "sendSubscribe requires a Destination, not a string");
                        LOG_DEBUG("Sending subscribe: ", topic, requestConfirmation, correlationKey);
                        const correlationTag = this.getCorrelationTag();
                        const smpMsg = SMFLib.SMPMessage.getSubscriptionMessage(correlationTag, topic, true, // set add == true
                        requestConfirmation);
                        assert(smpMsg.encodedUtf8Subscription, "Encoded SMP message was invalid");
                        const returnCode = this.send(smpMsg);
                        if (returnCode !== TransportLib.TransportReturnCode.OK) {
                            LOG_INFO("Subscribe failed", TransportLib.TransportReturnCode.describe(returnCode));
                            return returnCode;
                        }
                        if (requestConfirmation) {
                            this.enqueueOutstandingCorrelatedReq(correlationTag, () => this.handleSubscriptionTimeout(correlationTag), requestTimeout || this._sessionProperties.readTimeoutInMsecs, correlationKey, respRecvdCallback);
                        }
                        return returnCode;
                    }
                    /**
   *
   * @param {MutableSessionProperty} mutableSessionProperty The property key to change
   * @param {?} newValue The new value for the property
   * @param {String} correlationKey The correlation key for the request
   * @param {Number} requestTimeout The timeout for the request
   * @param {function} respRecvdCallback The callback on response
   * @returns {TransportReturnCode} The RC from the transport
   * @private
   */
                    sendUpdateProperty(mutableSessionProperty, newValue, correlationKey, requestTimeout, respRecvdCallback) {
                        const correlationTag = this._smfClient.nextCorrelationTag();
                        const smpMsg = SMFLib.ClientCtrlMessage.getUpdate(mutableSessionProperty, newValue, correlationTag);
                        const returnCode = this.send(smpMsg);
                        if (returnCode !== TransportLib.TransportReturnCode.OK) {
                            return returnCode;
                        }
                        this.enqueueOutstandingCorrelatedReq(correlationTag, () => this.handleUpdatePropertyTimeout(correlationTag), requestTimeout || this._sessionProperties.readTimeoutInMsecs, correlationKey, respRecvdCallback);
                        return returnCode;
                    }
                    /**
   * @private
   */
                    setClientCtrlTimer() {
                        this.clearClientCtrlTimer();
                        this._clientCtrlTimer = setTimeout(() => this.handleClientCtrlTimeout(), this._sessionProperties.transportDowngradeTimeoutInMsecs);
                    }
                    /**
   * @private
   */
                    setConnectTimer() {
                        this.clearConnectTimer();
                        // The hosts lists provides the wait time for inter-host timeouts.
                        // This timeout is for the entire list.
                        this._connectTimer = setTimeout(() => this.handleConnectTimeout(), this._sessionProperties.connectTimeoutInMsecs);
                    }
                    /**
   * Sets the error exit information for the FSM.
   *
   * This applies key-value pairs from properties to the current error object,
   * but does not allow overwriting and does not allow assignment of null or undefined values.
   *
   * Only the following fields are relevant, any other fields transferred to currentError by this
   * method are eventually ignored:
   *    * eventText
   *    * responseCode
   *    * errorSubcode
   *    * eventReason
   *
   * See SessionConnecting exitPoint 'errorExit'. This is the only place the information in
   * currentError is extracted.
   *
   * Could be implemented as `
   * this._currentError = Object.assign({}, filter(properties), this._currentError)
   * `
   * where `filter` is a key-value filter that works as described above.
   *
   * @param {Object} source An object with properties to be applied
   */
                    setCurrentError(source) {
                        const target = this._currentError || {};
                        const {
                            LOG_TRACE
                        } = this.logger;
                        Object.keys(source).forEach(key => {
                            if (source[key] === null || source[key] === undefined) return false;
                            if (target[key] !== null && target[key] !== undefined) {
                                LOG_TRACE(`Attempt to overwrite property {key=${key}, current value=${target[key]}, incoming value=${source[key]}}`);
                                return false;
                            }
                            target[key] = source[key];
                            return true;
                        });
                        this._currentError = target;
                    }
                    /**
   * Send a subscribe or unsubscribe request on behalf of the API.
   * @param {Destination} subject The target for the update
   * @param {Boolean} requestConfirmation Request a success message if true
   * @param {String} correlationKey The correlation key for the request
   * @param {Number} requestTimeout The timeout in milliseconds
   * @param {SessionRequestType} requestType The request type
   * @param {function} respRecvdCallback The callback on response
   * @returns {TransportReturnCode} The RC from the transport
   * @private
   */
                    subscriptionUpdate(subject, requestConfirmation, correlationKey, requestTimeout, requestType, respRecvdCallback) {
                        //check topic supported
                        const error = this.checkSessionDestinationCapability(subject);
                        if (error) {
                            throw error;
                        }
                        const timeoutMsg = SubscriptionUpdateTimeoutMessages[requestType] || SubscriptionUpdateTimeoutMessages.default;
                        const isSMP = requestType !== SessionRequestType.REMOVE_DTE_SUBSCRIPTION;
                        const add = requestType === SessionRequestType.ADD_SUBSCRIPTION || requestType === SessionRequestType.ADD_P2PINBOX;
                        const correlationTag = this.getCorrelationTag();
                        const generateMessage = isSMP ? SMFLib.SMPMessage.getSubscriptionMessage : SMFLib.AdProtocolMessage.getDTEUnsubscribeMessage;
                        const msg = generateMessage(correlationTag, subject, add, requestConfirmation);
                        const returnCode = this.send(msg);
                        if (returnCode !== TransportLib.TransportReturnCode.OK) {
                            return returnCode;
                        }
                        if (requestConfirmation) {
                            this.enqueueOutstandingCorrelatedReq(correlationTag, () => this.handleApiSubscriptionTimeout(correlationTag, timeoutMsg), requestTimeout || this._sessionProperties.readTimeoutInMsecs, correlationKey, respRecvdCallback);
                        }
                        if (requestType === SessionRequestType.ADD_SUBSCRIPTION && this._sessionProperties.reapplySubscriptions) {
                            this.addToSubscriptionCache(subject);
                        } else if (requestType === SessionRequestType.REMOVE_SUBSCRIPTION && this._sessionProperties.reapplySubscriptions) {
                            this.removeFromSubscriptionCache(subject);
                        }
                        return returnCode;
                    }
                    /**
   * Send a queue subscribe or unsubscribe request.
   * @param {Destination} subject The target for the update
   * @param {Destination} queue The queue where the subscription is added/removed
   * @param {Number} requestTimeout The timeout in milliseconds
   * @param {Boolean} add (if true) or remove (if false).
   * @param {function} respRecvdCallback The callback on response
   * @returns {TransportReturnCode} The RC from the transport
   * @private
   */
                    queueSubscriptionUpdate(subject, queue, requestTimeout, add, respRecvdCallback) {
                        const timeoutMsg = add ? SubscriptionUpdateTimeoutMessages[SessionRequestType.ADD_SUBSCRIPTION] : SubscriptionUpdateTimeoutMessages[SessionRequestType.REMOVE_SUBSCRIPTION];
                        const correlationTag = this.getCorrelationTag();
                        const msg = SMFLib.SMPMessage.getQueueSubscriptionMessage(correlationTag, subject, queue, add);
                        const returnCode = this.send(msg);
                        if (returnCode !== TransportLib.TransportReturnCode.OK) {
                            //TODO: act on this.
                            // (throw.)
                            return returnCode;
                        }
                        this.enqueueOutstandingCorrelatedReq(correlationTag, () => {
                            const origReq = this._correlatedReqs[correlationTag];
                            //TODO maybe just use the cancel method instead (which returns the original request)
                            this.handleApiSubscriptionTimeout(correlationTag, timeoutMsg);
                            respRecvdCallback(null, origReq);
                        }, requestTimeout || this._sessionProperties.readTimeoutInMsecs, null, // no need for session machinery to track flow correlationKey.
                        respRecvdCallback);
                        return returnCode;
                    }
                    /**
   * @param {BaseMessage|Message} smfMessage The message received
   * @param {Stats} [target] The statistics target to update, default is session stats
   * @private
   */
                    updateRxStats(smfMessage, target = this._sessionStatistics) {
                        if (!target) {
                            return;
                        }
                        const smfHeader = smfMessage.smfHeader;
                        if (!smfHeader) {
                            return;
                        }
                        const deliveryMode = smfHeader.pm_deliverymode || 0;
                        const msgStatKey = STAT_RX_BYMODE_MSGS[deliveryMode];
                        const bytesStatKey = STAT_RX_BYMODE_BYTES[deliveryMode];
                        const msgLength = smfHeader.messageLength;
                        switch (smfHeader.smf_protocol) {
                          case SMFLib.SMFProtocol.TRMSG:
                            if (smfHeader.pm_respcode === 0) {
                                target.incStat(StatType.RX_TOTAL_DATA_MSGS);
                                target.incStat(msgStatKey);
                                target.incStat(StatType.RX_TOTAL_DATA_BYTES, msgLength);
                                target.incStat(bytesStatKey, msgLength);
                                if (smfHeader.smf_di) {
                                    target.incStat(StatType.RX_DISCARD_MSG_INDICATION);
                                }
                            }
                            break;

                          case SMFLib.SMFProtocol.CLIENTCTRL:
                          case SMFLib.SMFProtocol.SMP:
                          case SMFLib.SMFProtocol.KEEPALIVE:
                          case SMFLib.SMFProtocol.KEEPALIVEV2:
                          case SMFLib.SMFProtocol.ADCTRL:
                            target.incStat(StatType.RX_CONTROL_MSGS);
                            target.incStat(StatType.RX_CONTROL_BYTES, msgLength);
                            break;

                          default:
                        }
                    }
                    /**
  * @param {BaseMessage|Message} smfMessage The message sent
  * @param {Stats} [target] The statistics target to update, default is session stats
  * @private
  */
                    updateTxStats(smfMessage, target = this._sessionStatistics) {
                        if (!target) {
                            return;
                        }
                        if (smfMessage.getReplyTo !== undefined && smfMessage.getReplyTo()) {
                            // update stats
                            target.incStat(StatType.TX_REQUEST_SENT);
                        }
                        const smfHeader = smfMessage.smfHeader;
                        if (!smfHeader) {
                            return;
                        }
                        const deliveryMode = smfHeader.pm_deliverymode || 0;
                        let msgStatKey = STAT_TX_BYMODE_MSGS[deliveryMode];
                        let bytesStatKey = STAT_TX_BYMODE_BYTES[deliveryMode];
                        //
                        // If this is a Guaranteed Message we may need to further refine the stats by the redelivered
                        // status
                        if (deliveryMode !== MessageDeliveryModeType.DIRECT) {
                            if (smfMessage.isRedelivered()) {
                                msgStatKey = STAT_TX_BYMODE_REDELIVERED[deliveryMode];
                                bytesStatKey = STAT_TX_BYMODE_BYTES_REDELIVERED[deliveryMode];
                            }
                        }
                        const msgLength = smfHeader.messageLength;
                        switch (smfHeader.smf_protocol) {
                          case SMFLib.SMFProtocol.TRMSG:
                            target.incStat(msgStatKey);
                            target.incStat(bytesStatKey, msgLength);
                            break;

                          case SMFLib.SMFProtocol.CLIENTCTRL:
                          case SMFLib.SMFProtocol.SMP:
                          case SMFLib.SMFProtocol.KEEPALIVE:
                          case SMFLib.SMFProtocol.KEEPALIVEV2:
                          case SMFLib.SMFProtocol.ADCTRL:
                            target.incStat(StatType.TX_CONTROL_MSGS);
                            target.incStat(StatType.TX_CONTROL_BYTES, msgLength);
                            break;

                          default:
                        }
                    }
                    /**
   * @param {ClientCtrlMessage} clientCtrlRespMsg The client control message with props
   * @private
   */
                    updateReadonlySessionProps(clientCtrlRespMsg) {
                        const props = this._sessionProperties; // Modify session properties in place
                        props._setVpnNameInUse(clientCtrlRespMsg.getVpnNameInUseValue() || "");
                        const oldVirtualRouterName = props.virtualRouterName;
                        const newVirtualRouterName = clientCtrlRespMsg.getVridInUseValue() || "";
                        props._setVirtualRouterName(newVirtualRouterName);
                        if (oldVirtualRouterName !== "" && oldVirtualRouterName !== newVirtualRouterName) {
                            this.handleVirtualRouterNameChange(oldVirtualRouterName, newVirtualRouterName);
                        }
                        // The Solace Message Router login response should always contain a P2P topic for this client
                        // name. If it doesn't that's an error (and we store "").
                        props._setP2pInboxBase(clientCtrlRespMsg.getP2PTopicValue() || "");
                        props._setP2pInboxInUse(P2PUtil.getP2PInboxTopic(props.p2pInboxBase));
                        this._session.updateCapabilities(clientCtrlRespMsg.getRouterCapabilities());
                        // Create and cache a guard for GM sending.
                        const gmCap = this._session._getCapability(CapabilityType.GUARANTEED_MESSAGE_PUBLISH);
                        this._gmSendDisallowed = typeof gmCap === "boolean" && !gmCap ? () => {
                            throw new OperationError("Sending guaranteed message is not allowed by router for this client", ErrorSubcode.INVALID_OPERATION, null);
                        } : null;
                    }
                    handleVirtualRouterNameChange(oldName, newName) {
                        if (this._consumers) {
                            this._consumers.flows.forEach(consumer => consumer.onVRNChanged());
                            this._consumers.reconnectingFlows.forEach(consumer => consumer.onVRNChanged());
                        }
                        this.emitSessionEvent(SessionEvent.build(SessionEventCode.VIRTUALROUTER_NAME_CHANGED, `Virtual router name is changed from ${oldName} to ${newName}`, null, 0, null, null));
                    }
                    /**
   * @returns {String} The session's ID in hexadecimal format
   * @private
   */
                    get sessionIdHex() {
                        return this.sessionId && formatHexString(this.sessionId) || "N/A";
                    }
                    updateTransportCompression(callback) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("updateTransportCompression called. " + `plaintextTLS: ${this._plaintextTLS} _compressedTLS: ${this._compressedTLS}`);
                        if (this._plaintextTLS) {
                            TransportLib.TransportFactory.severTls(this._transport, this._compressedTLS, callback);
                            return null;
                        }
                        if (this._compressedTLS) {
                            const newTransport = TransportLib.TransportFactory.startCompression(this._transport);
                            return newTransport;
                        }
                        // nothing to do.
                        return this._transport;
                    }
                }
                module.exports.SessionFSM = SessionFSM;
                /***/
            },
            /***/ "./modules/solclient-session/lib/session-operations.js": 
            /*!*************************************************************!*\
  !*** ./modules/solclient-session/lib/session-operations.js ***!
  \*************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * @private
 * @enum {number}
 */
                const SessionOperation = {
                    CONNECT: "CONNECT",
                    DISCONNECT: "DISCONNECT",
                    CTRL: "CTRL",
                    SEND: "SEND",
                    QUERY_OPERATION: "QUERY_OPERATION"
                };
                module.exports.SessionOperation = Enum.new(SessionOperation);
                /***/
            },
            /***/ "./modules/solclient-session/lib/session-properties-validator.js": 
            /*!***********************************************************************!*\
  !*** ./modules/solclient-session/lib/session-properties-validator.js ***!
  \***********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const PublisherLib = __webpack_require__(/*! solclient-message-publisher */ "./modules/solclient-message-publisher/api.js");
                const SessionPropertiesLib = __webpack_require__(/*! ./session-properties */ "./modules/solclient-session/lib/session-properties.js");
                const SMFLib = __webpack_require__(/*! solclient-smf */ "./modules/solclient-smf/api.js");
                const {
                    APIPropertiesValidators,
                    parseURL
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const {
                    AuthenticationScheme
                } = __webpack_require__(/*! ./authentication-schemes */ "./modules/solclient-session/lib/authentication-schemes.js");
                const {
                    Check
                } = __webpack_require__(/*! solclient-validate */ "./modules/solclient-validate/api.js");
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    LOG_WARN,
                    LOG_INFO
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    SslDowngrade
                } = __webpack_require__(/*! ./ssl-downgrades */ "./modules/solclient-session/lib/ssl-downgrades.js");
                const {
                    TransportProtocol
                } = __webpack_require__(/*! solclient-transport */ "./modules/solclient-transport/api.js");
                const {
                    validateInstance,
                    valArrayIsMember,
                    valArrayOfString,
                    valBoolean,
                    valLength,
                    valNotEmpty,
                    valNumber,
                    valRange,
                    valString,
                    valStringOrArray
                } = APIPropertiesValidators;
                const ALLOWED_PROTOCOLS = [ "http:", "https:", "ws:", "wss:", "tcp:", "tcps:" ];
                function valClientName(typeDesc, instance, name) {
                    // valString and valLength(160) have already been called.
                    const error = SMFLib.ClientCtrlMessage.validateClientName(instance[name], errorMessage => new OperationError(`${typeDesc} validation: Property '${name}': ${errorMessage}`, ErrorSubcode.PARAMETER_OUT_OF_RANGE));
                    if (error) {
                        throw error;
                    }
                }
                function valIsMember(typeDesc, instance, key, enumInstance, enumName, allowNull) {
                    const val = instance[key];
                    if (allowNull && val === null) return;
                    if (typeof val !== "undefined" && !enumInstance.values.some(v => v === val)) {
                        throw new OperationError(`${typeDesc} validation: Property '${key}' must be a member of ${enumName}`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                    }
                }
                function valSslExcludedProtocols(typeDesc, instance, name) {
                    const val = instance[name];
                    if (Check.array(val)) {
                        if (val.length > 0) {
                            const supported = SessionPropertiesLib.SessionProperties.SUPPORTED_SSL_PROTOCOLS;
                            val.forEach(protocol => {
                                const prtcl = protocol.toLowerCase();
                                if (supported.indexOf(prtcl) < 0) {
                                    throw new OperationError(`${typeDesc} validation: Property '${name}' contains unsupported protocol: ${protocol}`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                                }
                            });
                        }
                    }
                }
                function valSslCipherSuites(typeDesc, instance, name) {
                    const val = instance[name];
                    if (val && Check.string(val) && !Check.empty(val)) {
                        const ciphers = val.split(",");
                        const supported = SessionPropertiesLib.SessionProperties.SUPPORTED_CIPHER_SUITES;
                        ciphers.forEach(cipher => {
                            if (supported.indexOf(cipher.trim()) < 0) {
                                throw new OperationError(`${typeDesc} validation: Property '${name}' contains unsupported cipher suite: '${cipher}'`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                            }
                        });
                    }
                }
                // maximum number of common names is 16
                function valSslTrustedCommonNameList(typeDesc, instance, name) {
                    const val = instance[name];
                    if (Check.something(val) && Check.array(val) && val.length > 16) {
                        throw new OperationError(`${typeDesc} validation: Property '${name}' length exceeds limit of 16`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                }
                function valUrlList(typeDesc, instance, name) {
                    const val = instance[name];
                    const valArray = typeof val === "string" ? val.split(",") : val;
                    if (!Check.array(valArray)) {
                        throw new OperationError(`${typeDesc} validation: Property '${name}' not an array or comma-delimited string`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                    }
                    valArray.forEach(el => {
                        let url = null;
                        try {
                            url = parseURL(el);
                        } catch (ex) {
                            throw new OperationError(`${typeDesc} validation: Property '${name}' contained an invalid URL: ${el}`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                        if (!Check.included(url.protocol, ALLOWED_PROTOCOLS)) {
                            throw new OperationError(`${typeDesc} validation: Property '${name}' contained a URL'${url.href}' with an invalid protocol: '${url.protocol}'`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                    });
                }
                function isHttpTransport(transportProtocol) {
                    return transportProtocol && (transportProtocol === TransportProtocol.HTTP_BINARY_STREAMING || transportProtocol === TransportProtocol.HTTP_BINARY || transportProtocol === TransportProtocol.HTTP_BASE64);
                }
                function validatePropsSupportedByTransport(transportProtocol, nonHttpPropsSet) {
                    if (nonHttpPropsSet.length > 0 && isHttpTransport(transportProtocol)) {
                        const propNames = nonHttpPropsSet.length <= 5 ? nonHttpPropsSet : nonHttpPropsSet.slice(0, 5);
                        throw new OperationError(`SessionProperties validation: properties that are not supported by transport protocol ${transportProtocol} have been set: ${propNames}`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                }
                function matchUrl(instance, name, regex, all) {
                    const val = instance[name];
                    if (val instanceof Array) {
                        // host list is used, iterate to find at least one entry
                        const arrayLength = val.length;
                        for (let i = 0; i < arrayLength; i++) {
                            const currententry = val[i];
                            if (!all) {
                                if (Check.string(currententry) && currententry.match(regex)) {
                                    return true;
                                }
                            } else if (all) {
                                if (!Check.string(currententry) || !currententry.match(regex)) {
                                    return false;
                                }
                            }
                        }
                        if (!all) {
                            return false;
                        } else if (all) {
                            return true;
                        }
                    }
                    return Check.string(val) && val.match(regex);
                }
                function useSsl(instance, name, all) {
                    return matchUrl(instance, name, /^(https|wss|tcps):/i, all);
                }
                const SessionPropertiesValidator = {
                    validate(props) {
                        // Validation rules: same as JCSMP
                        const v = validateInstance.bind(null, "SessionProperties", props);
                        v("url", [ valNotEmpty ], [ valStringOrArray ], [ valUrlList ]);
                        v("userName", [ valString ], [ valLength, 189 ]);
                        v("password", [ valString ], [ valLength, 128 ]);
                        v("clientName", [ valString ], [ valLength, 160 ], [ valClientName ]);
                        v("applicationDescription", [ valString ], [ valLength, 254 ]);
                        v("vpnName", [ valString ], [ valLength, 32 ]);
                        v("connectTimeoutInMsecs", [ valNumber ], [ valRange, 1, Number.MAX_VALUE ]);
                        v("connectRetriesPerHost", [ valNumber ], [ valRange, -1, Number.MAX_VALUE ]);
                        v("connectRetries", [ valNumber ], [ valRange, -1, Number.MAX_VALUE ]);
                        v("reconnectRetries", [ valNumber ], [ valRange, -1, Number.MAX_VALUE ]);
                        v("reconnectRetryWaitInMsecs", [ valNumber ], [ valRange, 0, 6e4 ]);
                        v("readTimeoutInMsecs", [ valNumber ], [ valRange, 1, Number.MAX_VALUE ]);
                        v("sendBufferMaxSize", [ valNumber ], [ valRange, 1, Number.MAX_VALUE ]);
                        v("maxWebPayload", [ valNumber ], [ valRange, 100, Number.MAX_VALUE ]);
                        if (true) {
                            v("bufferedAmountQueryIntervalInMsecs", [ valNumber ], [ valRange, 4, Number.MAX_VALUE ]);
                        }
                        v("generateSendTimestamps", [ valBoolean ]);
                        v("generateReceiveTimestamps", [ valBoolean ]);
                        v("includeSenderId", [ valBoolean ]);
                        v("keepAliveIntervalInMsecs", [ valNumber ], [ valRange, 0, Number.MAX_VALUE ]);
                        v("keepAliveIntervalsLimit", [ valNumber ], [ valRange, 3, Number.MAX_VALUE ]);
                        v("generateSequenceNumber", [ valBoolean ]);
                        v("subscriberLocalPriority", [ valNumber ], [ valRange, 1, 4 ]);
                        v("subscriberNetworkPriority", [ valNumber ], [ valRange, 1, 4 ]);
                        v("ignoreDuplicateSubscriptionError", [ valBoolean ]);
                        v("ignoreSubscriptionNotFoundError", [ valBoolean ]);
                        v("reapplySubscriptions", [ valBoolean ]);
                        v("noLocal", [ valBoolean ]);
                        v("transportDowngradeTimeoutInMsecs", [ valNumber ], [ valRange, 1, Number.MAX_VALUE ]);
                        v("idToken", [ valString ]);
                        v("accessToken", [ valString ]);
                        if (props.transportProtocol && props.webTransportProtocolList) {
                            throw new OperationError("SessionProperties validation: Property 'transportProtocol' and " + "'webTransportProtocolList' cannot be set at the same time", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                        if (props.webTransportProtocolList !== null && props.webTransportProtocolList !== undefined) {
                            if (!Array.isArray(props.webTransportProtocolList)) {
                                throw new OperationError("Property 'webTransportProtocolList' must be an array if set", ErrorSubcode.PARAMETER_INVALID_TYPE);
                            }
                            if (props.webTransportProtocolList.length === 0) {
                                throw new OperationError("Property 'webTransportProtocolList' must be non-empty if set", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                            }
                        }
                        v("authenticationScheme", [ valIsMember, AuthenticationScheme, "AuthenticationScheme", false ]);
                        const useClientCert = props.authenticationScheme === AuthenticationScheme.CLIENT_CERTIFICATE;
                        if (!useSsl(props, "url", true) && useClientCert) {
                            throw new OperationError("SessionProperties validation: Property 'authenticationScheme' cannot be set to client certificate " + "for unsecured sessions", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                        if (Check.equal(props.authenticationScheme, AuthenticationScheme.OAUTH2)) {
                            if (!useSsl(props, "url", true)) {
                                throw new OperationError(`SessionProperties validation: Property 'authenticationScheme' ${""}cannot be set to '${AuthenticationScheme.OAUTH2}' unless the ${""}session property 'url' is written to use a secure ${""}communication protocol like tcps or https.`, ErrorSubcode.PARAMETER_CONFLICT);
                            }
                            if (Check.empty(props.idToken) && Check.empty(props.accessToken)) {
                                throw new OperationError(`SessionProperties validation: Property 'authenticationScheme' ${""}can be set to ${""}'${AuthenticationScheme.OAUTH2}' only if there ${""}is an accompanying token set as a session property. The ${""}token types that are ${""}supported for OAuth authentication are OAuth2.0 Access ${""}Tokens and OpenID Connect ID Tokens. To set an access token ${""}you can use the accessToken session property. To set an id ${""}you can use the idToken session property.`, ErrorSubcode.PARAMETER_CONFLICT);
                            }
                        } else if (!Check.empty(props.idToken) || !Check.empty(props.accessToken)) {
                            LOG_INFO(`SessionProperties validation: Property ${""}'authenticationScheme' must be set to ${""}'${AuthenticationScheme.OAUTH2}'in order to use either ${""} an OAUTH2 access token or an OpenID Connect ID token.`);
                        }
                        if (false) {}
                        v("transportProtocol", [ valIsMember, TransportProtocol, "TransportProtocol", true ]);
                        v("webTransportProtocolList", [ valArrayIsMember, TransportProtocol, "TransportProtocol", true, false, false ]);
                        validatePropsSupportedByTransport(props.transportProtocol, props.nonHTTPTransportPropsSet);
                        if (props.publisherProperties) {
                            PublisherLib.MessagePublisherPropertiesValidator.validate(props.publisherProperties);
                        }
                        // Non-errors
                        const recommendedMin = props.defaultConnectTimeoutInMsecs;
                        const connectTimeout = props.connectTimeoutInMsecs;
                        const transportCount = props.webTransportProtocolList ? props.webTransportProtocolList.length : 1;
                        if (transportCount > 1 && connectTimeout < recommendedMin) {
                            LOG_WARN(`Connect timeout of ${connectTimeout} msecs is less than default and recommended ` + `minimum of ${recommendedMin} msecs for current transport selection. Transport ` + "downgrades may not complete.");
                        }
                    }
                };
                module.exports.SessionPropertiesValidator = SessionPropertiesValidator;
                /***/
            },
            /***/ "./modules/solclient-session/lib/session-properties.js": 
            /*!*************************************************************!*\
  !*** ./modules/solclient-session/lib/session-properties.js ***!
  \*************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const NodeSslConstants = __webpack_require__(/*! constants */ "?c549");
                const PublisherLib = __webpack_require__(/*! solclient-message-publisher */ "./modules/solclient-message-publisher/api.js");
                const {
                    APIProperties
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const {
                    AuthenticationScheme
                } = __webpack_require__(/*! ./authentication-schemes */ "./modules/solclient-session/lib/authentication-schemes.js");
                const {
                    Check
                } = __webpack_require__(/*! solclient-validate */ "./modules/solclient-validate/api.js");
                const {
                    LOG_WARN
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    SslDowngrade
                } = __webpack_require__(/*! ./ssl-downgrades */ "./modules/solclient-session/lib/ssl-downgrades.js");
                function makeDefaults() {
                    // Defer binding. Publisher constructor may rely on profile.
                    const {
                        MessagePublisherProperties
                    } = PublisherLib;
                    return {
                        _vpnNameInUse: "",
                        _virtualRouterName: "",
                        _p2pInboxInUse: "",
                        _p2pInboxBase: "",
                        _userIdentification: "",
                        _tpProtocolInUse: null,
                        _tpContentType: "text/plain",
                        _publisherProperties: new MessagePublisherProperties()
                    };
                }
                const DEFAULT_CIPHER_SUITES = false ? 0 : null;
                const SUPPORTED_CIPHER_SUITES = false ? 0 : null;
                const SUPPORTED_SSL_PROTOCOLS = false ? 0 : null;
                /**
 * @lends SessionProperties
 *
 */
                class SessionPropertiesBrowser extends APIProperties {
                    /**
   * This property is deprecated.  It is recommended to use
   * {@link solace.SessionProperties#webTransportProtocolList} instead, which explicitly lists all
   * web transport protocols that may be used when establishing a session.
   *
   * This property specifies the web transport protocol that will initially be selected by the
   * session for its connection attempt. If this protocol fails, the session will attempt other
   * protocols in accordance with its transport protocol connect policy.
   *
   * If {@link solace.FactoryProfile#cometEnabled} is `true`, the selection of
   * any {@link solace.TransportProtocol} will result in the inclusion of
   * fallback protocols in {@link solace.SessionProperties#webTransportProtocolList}.
   * This makes the session incompatible with Guaranteed Messaging.
   *
   * To create a Guaranteed Messaging compatible session with
   * {@link solace.FactoryProfile#cometEnabled} set to `true`, ensure the session's
   * {@link solace.SessionProperties#webTransportProtocoList} is set to only
   * {@link solace.TransportProtocol.WS_BINARY}.
   *
   *  * Mutually exclusive to property webTransportProtocolList
   *
   * @name solace.SessionProperties#transportProtocol
   * @type {solace.TransportProtocol}
   * @default null
   * @deprecated
   * @target browser
   */
                    get transportProtocol() {
                        return Check.nothing(this._tpProtocol) ? null : this._tpProtocol;
                    }
                    set transportProtocol(newValue) {
                        this._tpProtocol = newValue;
                    }
                    /**
   * @name solace.SessionProperties#transportDowngradeTimeoutInMsecs
   * @type {Number}
   * @description The timeout, in milliseconds, that must elapse before the session will abandon a
   * connection attempt with the current transport protocol if no response is received, and begin
   * a new connection attempt with a downgraded transport protocol. If no remaining downgrades
   * exist, the session will continue the current connection attempt until the connection timeout
   * expires. Note that the WS_BINARY transport will also attempt a downgrade if the underlying
   * WebSocket fails to connect before this period elapses.
   *  * The valid range is > 0.
   * @default 3000
   * @target browser
   */
                    get transportDowngradeTimeoutInMsecs() {
                        return Check.nothing(this._tpDowngradeTimeout) ? 3e3 : this._tpDowngradeTimeout;
                    }
                    set transportDowngradeTimeoutInMsecs(newValue) {
                        this._tpDowngradeTimeout = newValue;
                    }
                    /**
   * @name solace.SessionProperties#webTransportProtocolList
   * @type {Array.<solace.TransportProtocol>}
   * @description The user provided web transport protocol list indicating the initial protocol
   * to be used by the session for its connection attempt, and the protocols to try
   * subsequently if the attempt fails.
   *  * Mutually exclusive to property transportProtocol
   * @default null
   * @target browser
   */
                    get webTransportProtocolList() {
                        return Check.nothing(this._transportProtocolList) ? null : this._transportProtocolList;
                    }
                    set webTransportProtocolList(newValue) {
                        this._transportProtocolList = newValue;
                    }
                    /**
   * @private
   * @name SessionProperties#bufferedAmountQueryIntervalInMsecs
   * @type {Number}
   * @description When WebSocket transport protocol is used, SolClient uses this property
   * and {@link solace.SessionProperties.maxWebPayload} to throttle the publishing rate in order to
   * avoid network saturation.
   *  * The valid range is >=4.
   * @default 100
   */
                    get bufferedAmountQueryIntervalInMsecs() {
                        return Check.nothing(this._bufferedAmountQueryInterval) ? 100 : this._bufferedAmountQueryInterval;
                    }
                    set bufferedAmountQueryIntervalInMsecs(newValue) {
                        this._bufferedAmountQueryInterval = newValue;
                    }
                    /**
   *
   * @name solace.SessionProperties#transportProtocolInUse
   * @type {String}
   * @description This property is deprecated.
   * Use {@link solace.SessionProperties#webTransportProtocolInUse} instead.
   * @readonly
   * @target browser
   * @deprecated
   */
                    get transportProtocolInUse() {
                        return this._tpProtocolInUse || null;
                    }
                    _setTransportProtocolInUse(value) {
                        this._tpProtocolInUse = value;
                    }
                    /**
   *
   * @name solace.SessionProperties#webTransportProtocolInUse
   * @type {String}
   * @description A read-only property about the web transport protocol that is currently being
   * used by the session for its current connection or connection attempt. To determine which
   * web transport protocol was successfully used by the API, interrogate this property after the
   * session event UP_NOTICE is dispatched.
   * @readonly
   * @target browser
   */
                    get webTransportProtocolInUse() {
                        return this._tpProtocolInUse || null;
                    }
                    _setWebTransportProtocolInUse(value) {
                        this._tpProtocolInUse = value;
                    }
                    /**
   *
   * @name solace.SessionProperties#transportContentType
   * @type {String}
   * @description Transport content-type override for HTTP transports
   * @default 'text/plain'
   * @internal
   */
                    get transportContentType() {
                        return this._tpContentType || "text/plain";
                    }
                    set transportContentType(newValue) {
                        this._tpContentType = newValue;
                    }
                    _lendsInspect() {
                        return {
                            bufferedAmountQueryIntervalInMsecs: this.bufferedAmountQueryIntervalInMsecs,
                            transportContentType: this.transportContentType,
                            transportDowngradeTimeoutInMsecs: this.transportDowngradeTimeoutInMsecs,
                            transportProtocol: this.transportProtocol,
                            transportProtocolInUse: this.transportProtocolInUse,
                            webTransportProtocolList: this.webTransportProtocolList
                        };
                    }
                }
                class SessionPropertiesNode extends APIProperties {
                    /**
   * @internal
   */
                    get transportProtocol() {
                        return this._tpProtocol;
                    }
                    set transportProtocol(value) {
                        this._tpProtocol = value;
                    }
                    /**
   * @internal
   */
                    get webTransportProtocolList() {
                        return this._transportProtocolList;
                    }
                    set webTransportProtocolList(value) {
                        this._transportProtocolList = value;
                    }
                    /**
   * @internal
   */
                    get transportDowngradeTimeoutInMsecs() {
                        return this._tpDowngradeTimeout || 864e5; // All day
                    }
                    set transportDowngradeTimeoutInMsecs(value) {
                        this._tpDowngradeTimeout = value;
                    }
                    /**
   * @internal
   * @deprecated
   */
                    get transportProtocolInUse() {
                        return this._tpProtocolInUse;
                    }
                    _setTransportProtocolInUse(value) {
                        this._tpProtocolInUse = value;
                    }
                    /**
   * @internal
   */
                    get webTransportProtocolInUse() {
                        return this._tpProtocolInUse;
                    }
                    _setWebTransportProtocolInUse(value) {
                        this._tpProtocolInUse = value;
                    }
                    /**
   * @internal
   */
                    get transportContentType() {
                        return this._tpContentType;
                    }
                    set transportContentType(value) {
                        this._tpContentType = value;
                    }
                    // TLS connection options
                    /**
   * @name solace.SessionProperties#sslExcludedProtocols
   * @type {Array.<String>}
   * @description An array of TLS protocols to be excluded when negotiating which protocol
   * to use.
   *  * Allowed values are: TLSv1, TLSv1.1, TLSv1.2
   *  * Note: when a protocol version is excluded without excluding all of its
   *    previous protocol versions, the effect is to also exclude all subsequent
   *    protocol versions.
   * @default null
   * @target node
   */
                    get sslExcludedProtocols() {
                        return Check.nothing(this._sslExcludedProtocols) ? null : this._sslExcludedProtocols;
                    }
                    set sslExcludedProtocols(newValue) {
                        this._sslExcludedProtocols = newValue;
                    }
                    /**
   * @name solace.SessionProperties#sslCipherSuites
   * @type {String}
   * @description A comma separated list of cipher suites in order of preference used for TLS
   * connections.
   *  * Allowed values:
   *     * AES128-GCM-SHA256
   *     * AES128-SHA
   *     * AES128-SHA256
   *     * AES256-GCM-SHA384
   *     * AES256-SHA
   *     * AES256-SHA256
   *     * DES-CBC3-SHA
   *     * ECDHE-RSA-AES128-GCM-SHA256
   *     * ECDHE-RSA-AES128-SHA
   *     * ECDHE-RSA-AES128-SHA256
   *     * ECDHE-RSA-AES256-GCM-SHA384
   *     * ECDHE-RSA-AES256-SHA
   *     * ECDHE-RSA-AES256-SHA384
   *     * ECDHE-RSA-DES-CBC3-SHA
   *     * RC4-SHA
   *     * RC4-MD5
   * @default {@link solace.SessionProperties.DEFAULT_CIPHER_SUITES}
   * @target node
   */
                    get sslCipherSuites() {
                        return Check.nothing(this._sslCipherSuites) ? DEFAULT_CIPHER_SUITES : this._sslCipherSuites;
                    }
                    set sslCipherSuites(newValue) {
                        this._sslCipherSuites = newValue;
                    }
                    /**
   *
   * @name solace.SessionProperties#sslValidateCertificate
   * @type {Boolean}
   * @description Whether the server certificate shall be verified against the list of
   * certificates in the trust stores. If set to false, all certificate validation is disabled,
   * including date, hostname and common name validation.
   * @default true
   * @target node
   */
                    get sslValidateCertificate() {
                        // if the value is undefined, then use environment variable
                        if (this._sslValidateCert === undefined) return process.env.NODE_TLS_REJECT_UNAUTHORIZED !== "0";
                        if (this._sslValidateCert === null) return true;
                        return this._sslValidateCert;
                    }
                    set sslValidateCertificate(newValue) {
                        this._sslValidateCert = newValue;
                    }
                    /**
   * @name solace.SessionProperties#sslTrustStores
   * @type {Array.<String>}
   * @description An array of file names of trusted certificates in PEM format.
   * If not set, and {@link solace.SessionProperties#sslValidateCertificate} is set to true,
   * the server certificate will be validated against well known "root" CAs.
   *    * Mutually exclusive to sslPfx property when
   *      {@link solace.SessionProperties#sslValidateCertificate} is set
   * @default null
   * @target node
   */
                    get sslTrustStores() {
                        return Check.nothing(this._sslTrustStores) ? null : this._sslTrustStores;
                    }
                    set sslTrustStores(newValue) {
                        this._sslTrustStores = newValue;
                    }
                    /**
   * @name solace.SessionProperties#sslTrustedCommonNameList
   * @type {Array.<String>}
   * @description An array of acceptable common names for matching with the server certificate.
   * If set to a non-empty array, the API will override the default hostname validation logic
   * provided by Node.js with its own implemenation; if set to empty array, no hostname
   * validation will be performed.
   *    * Only relevant when {@link solace.SessionProperties#sslValidateCertificate} is set
   *      to true
   *    * Note that leading and trailing whitespaces are considered to be part of the common
   *      names and are not ignored
   * @default null
   * @target node
   */
                    get sslTrustedCommonNameList() {
                        return Check.nothing(this._sslTrustedCNList) ? null : this._sslTrustedCNList;
                    }
                    set sslTrustedCommonNameList(newValue) {
                        this._sslTrustedCNList = newValue;
                    }
                    // Client certificates related
                    /**
   * @name solace.SessionProperties#sslPfx
   * @type {String}
   * @description The file name of a file containing private key, certificate and optional
   * CA certificates of the client in PFX or PKCS12 format.
   *    * Only relevant when
   *      {@link solace.AuthenticationScheme.CLIENT_CERTIFICATE} is used
   *    * Mutually exclusive to sslPrivateKey, sslCertificate and sslTrustStores properties
   * @default ""
   * @target node
   */
                    get sslPfx() {
                        return Check.nothing(this._sslPfx) ? "" : this._sslPfx;
                    }
                    set sslPfx(newValue) {
                        this._sslPfx = newValue;
                    }
                    /**
   * @name solace.SessionProperties#sslPfxPassword
   * @type {String}
   * @description A string containing password for the client pfx file.
   *    * Only relevant when
   *      {@link solace.AuthenticationScheme.CLIENT_CERTIFICATE} is used
   * @default empty string
   * @target node
   */
                    get sslPfxPassword() {
                        return Check.nothing(this._sslPfxPasswd) ? "" : this._sslPfxPasswd;
                    }
                    set sslPfxPassword(newValue) {
                        this._sslPfxPasswd = newValue;
                    }
                    /**
   * @name solace.SessionProperties#sslPrivateKey
   * @type {String}
   * @description The file name of a file containing private key of the client in PEM format.
   *    * Only relevant when
   *      {@link solace.AuthenticationScheme.CLIENT_CERTIFICATE} is used
   *    * Mutually exclusive to sslPfx property
   * @default empty string
   * @target node
   */
                    get sslPrivateKey() {
                        return Check.nothing(this._sslPrivateKey) ? "" : this._sslPrivateKey;
                    }
                    set sslPrivateKey(newValue) {
                        this._sslPrivateKey = newValue;
                    }
                    /**
   * @name solace.SessionProperties#sslPrivateKeyPassword
   * @type {String}
   * @description A string containg password for the client private key.
   *    * Only relevant when
   *      {@link solace.AuthenticationScheme.CLIENT_CERTIFICATE} is used
   * @default empty string
   * @target node
   */
                    get sslPrivateKeyPassword() {
                        return Check.nothing(this._sslPrivateKeyPasswd) ? "" : this._sslPrivateKeyPasswd;
                    }
                    set sslPrivateKeyPassword(newValue) {
                        this._sslPrivateKeyPasswd = newValue;
                    }
                    /**
   * @name solace.SessionProperties#sslCertificate
   * @type {String}
   * @description The file name of a file containing certificate key of the client in PEM
   * format.
   *    * Only relevant when
   *      {@link solace.AuthenticationScheme.CLIENT_CERTIFICATE} is used
   *    * Mutually exclusive to sslPfx property
   * @default empty string
   * @target node
   */
                    get sslCertificate() {
                        return Check.nothing(this._sslCertificate) ? "" : this._sslCertificate;
                    }
                    set sslCertificate(newValue) {
                        this._sslCertificate = newValue;
                    }
                    // TLS connection options
                    /**
   * @name SessionProperties#sslProtocol
   * @type {String}
   * @description The SSL protocols to use.
   *    * Allowed values are: SSLv3, TLSv1, TLSv1.1, TLSv1.2
   * @target node
   */
                    get sslProtocol() {
                        return this._sslProtocol;
                    }
                    set sslProtocol(newValue) {
                        this._sslProtocol = newValue;
                    }
                    /**
   * @name solace.SessionProperties#compressionLevel
   * @type {Number}
   * @description zlib compression level (1-9) or no compression (0)
   *
   * When this property is set to a valid, non-zero value (1-9):
   *
   * * tcp:// connections are established compressed.
   * This usually requires connecting to a different tcp port on the router,
   * 55003 by default.
   *
   * * tcps:// connections are established uncompressed,
   * but then negotiate compression on login.
   * Compression before encryption allows inference of similarities between messages
   * from observing packet sizes on the network.
   * This could lead to chosen Plaintext attacks.
   * Can be combined with sslDowngradeConnectionTo for no encryption beyond authentication.
   *
   * * ws(s):// and http(s):// transports do not support compression and are considered invalid.
   *
   * @default 0
   * @target node
   */
                    get compressionLevel() {
                        return Check.nothing(this._compressionLevel) ? 0 : this._compressionLevel;
                    }
                    set compressionLevel(newValue) {
                        this._compressionLevel = newValue;
                    }
                    /**
   * @name solace.SessionProperties#sslConnectionDowngradeTo
   * @type {solace.SslDowngrade}
   * @description Disable encryption after authentication
   *
   * When set to {@link solace.SslDowngrade.PLAINTEXT},
   * all message traffic beyond the initial login is unencrypted.
   * A TLS connection is negotiated on the regular TLS port (55443 by default),
   * TLS authentication schemes can be used, same as without this option.
   * After a successful login however, a TLS shutdown is performed,
   * and the same socket is then used for unencrypted message traffic.
   *
   * Please note this way plain text traffic passes on a port
   * usually associated with encryption (55443 by default)
   *
   * This downgrade is only supported for tcps:// connections,
   * all other URL schemes ignore this option.
   *
   * Can be combined with compressionLevel for
   * non-encrypted, compressed message transfer after login.
   *
   * @default {@link solace.SslDowngrade.NONE}
   * @target node
   */
                    get sslConnectionDowngradeTo() {
                        return Check.nothing(this._sslConnectionDowngradeTo) ? SslDowngrade.NONE : this._sslConnectionDowngradeTo;
                    }
                    set sslConnectionDowngradeTo(newValue) {
                        this._sslConnectionDowngradeTo = newValue;
                    }
                    _lendsInspect() {
                        return {
                            sslExcludedProtocols: this.sslExcludedProtocols,
                            sslCipherSuites: this.sslCipherSuites,
                            sslValidateCertificate: this.sslValidateCertificate,
                            sslTrustStores: this.sslTrustStores,
                            sslTrustedCommonNameList: this.sslTrustedCommonNameList,
                            sslPfx: this.sslPfx,
                            sslPfxPassword: this.sslPfxPassword ? "*****" : this.sslPfxPassword,
                            sslPrivateKey: this.sslPrivateKey,
                            sslPrivateKeyPassword: this.sslPrivateKeyPassword ? "*****" : this.sslPrivateKeyPassword,
                            sslCertificate: this.sslCertificate,
                            sslProtocol: this.sslProtocol,
                            compressionLevel: this.compressionLevel,
                            sslConnectionDowngradeTo: this.sslConnectionDowngradeTo
                        };
                    }
                }
                const SessionPropertiesBase = false ? 0 : SessionPropertiesBrowser;
                /**
 * @classdesc
 * Represents a session properties object. Passed in to
 * {@link solace.SolclientFactory.createSession} when creating a {@link solace.Session} instance.
 * @memberof solace
 * @extends APIProperties
 */
                class SessionProperties extends SessionPropertiesBase {
                    /**
   * @constructor
   * @param {Object} options Properties to apply to the newly constructed object.
   */
                    constructor(options) {
                        super(makeDefaults(), options);
                    }
                    /**
   * The authentication scheme used when establishing the session.
   * @name solace.SessionProperties#authenticationScheme
   * @type {solace.AuthenticationScheme}
   * @default {@link solace.AuthenticationScheme.BASIC}
   */
                    get authenticationScheme() {
                        return Check.nothing(this._authScheme) ? AuthenticationScheme.BASIC : this._authScheme;
                    }
                    set authenticationScheme(newValue) {
                        this._authScheme = newValue;
                    }
                    /**
   * @name solace.SessionProperties#accessToken
   * @type {String}
   * @description The access token required for OAUTH2 authentication.
   *    * This is only relevant if the
   *    {@link solace.AuthenticationScheme.OAUTH2}
   *    authentication scheme is being used.
   * @default ""
   */
                    get accessToken() {
                        return Check.empty(this._accessToken) ? "" : this._accessToken;
                    }
                    set accessToken(newValue) {
                        this._accessToken = newValue;
                    }
                    /**
   * @name solace.SessionProperties#idToken
   * @type {String}
   * @description The ID token required for OIDC authentication.
   *    * This is only relevant if the
   *    {@link solace.AuthenticationScheme.OAUTH2}
   *    authentication scheme is being used.
   * @default ""
   */
                    get idToken() {
                        return Check.empty(this._idToken) ? "" : this._idToken;
                    }
                    set idToken(newValue) {
                        this._idToken = newValue;
                    }
                    /**
   * @name solace.SessionProperties#issuerIdentifier
   * @type {String}
   * @description The issuer identifier is optional for OAUTH2 authentication.
   *    * This is only relevant if the
   *    {@link solace.AuthenticationScheme.OAUTH2}
   *    authentication scheme is being used.
   * @default ""
   */
                    get issuerIdentifier() {
                        return Check.empty(this._issuerIdentifier) ? "" : this._issuerIdentifier;
                    }
                    set issuerIdentifier(newValue) {
                        if (!Check.type(newValue, "string")) {
                            LOG_WARN(`Failed to set issuer identifier because the pased value ${""}was not of type String. The passed issuer identifier ${""}must be of type String. Setting issuer identifier to ${""}default value empty string.`);
                            this._issuerIdentifier = "";
                        } else if (Check.empty(newValue)) {
                            LOG_WARN(`Failed to set the issuer identifier because the passed string was empty ${""}or null. The passed issuer identifier must not be empty or null. Setting ${""}issuer identifier to default value empty string.`);
                        } else {
                            this._issuerIdentifier = newValue;
                        }
                    }
                    /**
   * The URL or URLs of the messaging service to connect to.  The URL is typically of the form
   * `<protocol>://<host[:port]>`, where:
   *  * `protocol` is one of `ws`, `wss`, `http`, `https`, `tcp` or `tcps`.
   *  (Note to developers who also use the browser variant of this SDK:
   *  Browsers do not support the `tcp` and `tcps` protocols.)
   *  * `host` is a hostname or IP address of the router to connect to.
   *  * `port` is the port on which the messaging service is listening. The default is the
   *    well-known port for the service associated with the given protocol, if any.
   *
   * Additionally, note:
   *  * When an Array is provided, each element is expected to be a string of the above format.
   *    The API will attempt to connect to these URLs in the specified order.
   *  * Numerical IPv6 addresses must be enclosed in square brackets, e.g. tcp://[2001:db8::1]
   * @name solace.SessionProperties#url
   * @type {String|Array.<String>}
   * @default ""
   * @target node
   */
                    /**
   * The URL or URLs of the messaging service to connect to.  The URL is typically of the form
   * `<protocol>://<host[:port]>`, where:
   *  * `protocol` is one of `ws`, `wss`, `http`, `https'.
   *  (Note to developers who also ise the NodeJS variant of this SDK:
   *  NodeJS also supports the 'tcp' and 'tcps' protocols, but browsers do not.)
   *  * `host` is a hostname or IP address of the router to connect to.
   *  * `port` is the port on which the messaging service is listening. The default is the
   *    well-known port for the service associated with the given protocol, if any.
   *
   * Additionally, note:
   *  * When an Array is provided, each element is expected to be a string of the above format.
   *    The API will attempt to connect to these URLs in the specified order.
   *  * Cross-domain restrictions should be taken into consideration when deploying web
   *    applications with messaging capabilities. See the API User Guide for more
   *    information.
   *  * Numerical IPv6 addresses must be enclosed in square brackets, e.g. ws://[2001:db8::1]
   * @name solace.SessionProperties#url
   * @type {String|Array.<String>}
   * @default ""
   * @target browser
   */
                    get url() {
                        return Check.nothing(this._url) ? "" : this._url;
                    }
                    set url(newValue) {
                        this._url = newValue;
                    }
                    //  ======================== Credentials  ========================
                    /**
   * @name solace.SessionProperties#password
   * @type {String}
   * @description The password required for authentication.
   * @default ""
   */
                    get password() {
                        return Check.nothing(this._password) ? "" : this._password;
                    }
                    set password(newValue) {
                        this._password = newValue;
                    }
                    /**
   * @name solace.SessionProperties#userName
   * @type {String}
   * @description  The client username required for authentication.
   * @default ""
   */
                    get userName() {
                        return Check.nothing(this._userName) ? "" : this._userName;
                    }
                    set userName(newValue) {
                        this._userName = newValue;
                    }
                    /**
   * @name solace.SessionProperties#clientName
   * @type {String}
   * @default '' (automatically generated)
   * @description The client name that is used during login as a unique identifier for the session
   * on the Solace Message Router.
   *  * An empty string causes a unique client name to be generated
   *     automatically.
   *  * If specified, it must be a valid Topic name, and a maximum of 160 bytes in length.
   *  * This property is also used to uniquely identify the sender in
   *    a message's senderId field if {@link solace.SessionProperties.includeSenderId}
   *    is set.
   * @default ""
   */
                    get clientName() {
                        return Check.nothing(this._clientName) ? "" : this._clientName;
                    }
                    set clientName(newValue) {
                        this._clientName = newValue;
                    }
                    /**
   * A string that uniquely describes the application instance.
   *  * If left blank, the API will generate a description string
   *    using the current user-agent string.
   * @default ""
   * @name solace.SessionProperties#applicationDescription
   * @type {String}
   */
                    get applicationDescription() {
                        return Check.nothing(this._appDesc) ? "" : this._appDesc;
                    }
                    set applicationDescription(newValue) {
                        this._appDesc = newValue;
                    }
                    /**
   * The Message VPN name that the client is requesting for this session.
   * @default ""
   * @name solace.SessionProperties#vpnName
   * @type {String}
   */
                    get vpnName() {
                        return Check.nothing(this._vpnName) ? "" : this._vpnName;
                    }
                    set vpnName(newValue) {
                        this._vpnName = newValue;
                    }
                    /**
   * A read-only session property that indicates which Message
   * VPN the session is connected to. When not connected, or when not in client mode,
   * an empty string is returned.
   * @default ""
   * @name solace.SessionProperties#vpnNameInUse
   * @type {String}
   * @readonly
   */
                    get vpnNameInUse() {
                        return Check.nothing(this._vpnNameInUse) ? "" : this._vpnNameInUse;
                    }
                    /**
   * @private
   * @param {String} value The vpn name currently being used.
   */
                    _setVpnNameInUse(value) {
                        this._vpnNameInUse = value;
                    }
                    /**
   * @name solace.SessionProperties#virtualRouterName
   * @type {String}
   * @description A read-only property that indicates the connected Solace Message Router's
   * virtual router name.
   * @default ""
   * @readonly
   */
                    get virtualRouterName() {
                        return Check.nothing(this._virtualRouterName) ? "" : this._virtualRouterName;
                    }
                    /**
   * @private
   * @param {String} value The current virtual router name.
   */
                    _setVirtualRouterName(value) {
                        this._virtualRouterName = value;
                    }
                    //  ======================== Connection Strategies ========================
                    /**
   * @name solace.SessionProperties#connectTimeoutInMsecs
   * @type {Number}
   * @description The timeout period (in milliseconds) for a connect operation to a given host.
   *  If no value is provided, the default is 8000.
   *   * The valid range is > 0.
   * @default 8000
   * @target node
   */
                    /**
   * @name solace.SessionProperties#connectTimeoutInMsecs
   * @type {Number}
   * @description The timeout period (in milliseconds) for a connect operation to a given host.
   *  If no value is provided, the default is calculated as shown below.
   *   * The valid range is > 0.
   * @default max(8000, 1000 + webTransportProtocolList.length * transportDowngradeTimeoutInMsecs)
   * @target browser
   */
                    get connectTimeoutInMsecs() {
                        if (Check.nothing(this._connectTimeout)) {
                            return this.defaultConnectTimeoutInMsecs;
                        }
                        return this._connectTimeout;
                    }
                    set connectTimeoutInMsecs(newValue) {
                        this._connectTimeout = newValue;
                    }
                    /**
   * @internal
   */
                    get defaultConnectTimeoutInMsecs() {
                        const minTimeout = 8e3;
                        const {
                            webTransportProtocolList,
                            transportDowngradeTimeoutInMsecs
                        } = this;
                        const transportCount = webTransportProtocolList ? webTransportProtocolList.length : 1;
                        const margin = transportCount > 1 ? 1e3 : 0;
                        const connectDowngradeDefault = transportCount * transportDowngradeTimeoutInMsecs + margin;
                        return Math.max(minTimeout, connectDowngradeDefault);
                    }
                    /**
   * @name solace.SessionProperties#connectRetries
   * @type {Number}
   * @description The number of times to retry connecting during initial connection setup.
   *
   * When using a host list, each traversal of the list is considered a try; therefore, if
   * `connectRetries === 2`, the host list will be traversed up to three times: once
   * for the initial try, and twice more for the retries. Each retry begins with the first host
   * listed. After each unsuccessful attempt to connect to a host, the API waits for the amount
   * of time set for {@link solace.SessionProperties#reconnectRetryWaitInMsecs} before attempting
   * another connection. The next connection attempt may be to the same host,
   * see {@link solace.SessionProperties#connectRetriesPerHost}.
   *
   * If an established connection fails, the reconnection is attempted with
   * {@link solace.SessionProperties#reconnectRetries} retries instead.
   *
   *  * The valid range is connectRetries >= -1.
   *  * -1 means try to connect forever.
   *  * 0 means no automatic connection retries; the API will try once and then give up.
   *  * connectRetries >= 1 means reattempt connection n times.
   * @default 20
   */
                    get connectRetries() {
                        return Check.nothing(this._connectRetries) ? 20 : this._connectRetries;
                    }
                    set connectRetries(newValue) {
                        this._connectRetries = newValue;
                    }
                    /**
   * @name solace.SessionProperties#connectRetriesPerHost
   * @type {Number}
   * @description When using a host list, this property defines how many times to
   * try to connect to a single host before moving to the next host in the list.
   *
   *  * The valid range is connectRetriesPerHost >= -1.
   *  * -1 means attempt an infinite number of connection retries. The API will only
   *    attempt to connect to the first host in the list.
   *  * 0 means make a single connection attempt per host, with no retries.
   * @default 0
   */
                    get connectRetriesPerHost() {
                        return Check.nothing(this._connectRetriesPerHost) ? 0 : this._connectRetriesPerHost;
                    }
                    set connectRetriesPerHost(newValue) {
                        this._connectRetriesPerHost = newValue;
                    }
                    /**
   * @name solace.SessionProperties#reconnectRetryWaitInMsecs
   * @type {Number}
   * @description How much time to wait (in ms) between each attempt to connect to
   * a host.
   * If a connect attempt is not successful, the API waits for the amount of time
   * specified, and then makes another attempt to connect.
   * {@link solace.SessionProperties#connectRetriesPerHost} sets how many connection
   * attempts will be made before moving on to the next host in the list.
   * The valid range is >= 0 and <= 60000.
   * @default 3000
   */
                    get reconnectRetryWaitInMsecs() {
                        return Check.nothing(this._reconnectRetryWaitInMsecs) ? 3e3 : this._reconnectRetryWaitInMsecs;
                    }
                    set reconnectRetryWaitInMsecs(newValue) {
                        this._reconnectRetryWaitInMsecs = newValue;
                    }
                    /**
   * @name solace.SessionProperties#reconnectRetries
   * @type {Number}
   * @description The number of times to retry connecting after a connected session goes down.
   *
   * When using a host list, each traversal of the list is considered a try; therefore, if
   * `reconnectRetries === 2`, the host list will be traversed up to three times: once
   * for the initial try, and twice more for the retries. Each retry begins with the first host
   * listed. After each unsuccessful attempt to connect to a host, the API waits for the amount
   * of time set for {@link solace.SessionProperties#reconnectRetryWaitInMsecs} before attempting
   * another connection. The next reconnect attempt may be to the same host,
   * see {@link solace.SessionProperties#connectRetriesPerHost}.
   *
   *  * The valid range is reconnectRetries >= -1.
   *  * -1 means try to reconnect forever.
   *  * 0 means no automatic reconnect retries; the API will try once and then give up.
   *  * reconnectRetries >= 1 means reattempt reconnect n times.
   * @default 20
   */
                    get reconnectRetries() {
                        return Check.nothing(this._reconnectRetries) ? 20 : this._reconnectRetries;
                    }
                    set reconnectRetries(newValue) {
                        this._reconnectRetries = newValue;
                    }
                    //  ======================== message properties ========================
                    /**
   * @name solace.SessionProperties#generateSendTimestamps
   * @type {Boolean}
   * @description When enabled, a send timestamp is automatically included
   * (if not already present) in the Solace-defined fields for
   * each message sent.
   * @default  false
   */
                    get generateSendTimestamps() {
                        return Check.nothing(this._genSendTimestamps) ? false : this._genSendTimestamps;
                    }
                    set generateSendTimestamps(newValue) {
                        this._genSendTimestamps = newValue;
                    }
                    /**
   * @name solace.SessionProperties#generateReceiveTimestamps
   * @type {Boolean}
   * @description When enabled, a receive timestamp is recorded for
   * each message and passed to the session's message callback receive handler.
   * @default  false
   */
                    get generateReceiveTimestamps() {
                        return Check.nothing(this._genReceiveTimestamps) ? false : this._genReceiveTimestamps;
                    }
                    set generateReceiveTimestamps(newValue) {
                        this._genReceiveTimestamps = newValue;
                    }
                    /**
   * @name solace.SessionProperties#includeSenderId
   * @type {Boolean}
   * @description When enabled, a sender ID is automatically included
   * (if not already present) in the Solace-defined fields for each message
   * sent.
   * @default  false
   */
                    get includeSenderId() {
                        return Check.nothing(this._includeSenderId) ? false : this._includeSenderId;
                    }
                    set includeSenderId(newValue) {
                        this._includeSenderId = newValue;
                    }
                    /**
   * @name solace.SessionProperties#generateSequenceNumber
   * @type {Boolean}
   * @description When enabled, a sequence number is automatically
   * included (if not already present) in the Solace-defined fields
   * for each message sent.
   * @default  false
   */
                    get generateSequenceNumber() {
                        return Check.nothing(this._genSequenceNumber) ? false : this._genSequenceNumber;
                    }
                    set generateSequenceNumber(newValue) {
                        this._genSequenceNumber = newValue;
                    }
                    //  ======================== Keep Alive ========================
                    /**
   * @name solace.SessionProperties#keepAliveIntervalInMsecs
   * @type {Number}
   * @description The amount of time (in milliseconds) to wait between sending
   * out keep-alive messages to the Solace Message Router.
   *  * The valid range is > 0.
   * @default  3000
   */
                    get keepAliveIntervalInMsecs() {
                        return Check.nothing(this._kaInterval) ? 3e3 : this._kaInterval;
                    }
                    set keepAliveIntervalInMsecs(newValue) {
                        this._kaInterval = newValue;
                    }
                    /**
   * @name solace.SessionProperties#keepAliveIntervalsLimit
   * @type {Number}
   * @description The maximum number of consecutive Keep-Alive messages that
   * can be sent without receiving a response before the session is declared down
   * and the connection is closed by the API.
   *  * The valid range is >= 3.
   * @default 3
   */
                    get keepAliveIntervalsLimit() {
                        return Check.nothing(this._kaIntervalsLimit) ? 3 : this._kaIntervalsLimit;
                    }
                    set keepAliveIntervalsLimit(newValue) {
                        this._kaIntervalsLimit = newValue;
                    }
                    // ======================== P2P Inbox ========================
                    /**
   * @name solace.SessionProperties#p2pInboxInUse
   * @type {String}
   * @description A read-only string that indicates the default
   * reply-to destination used for any request messages sent from this session.
   * See {@link solace.Session#sendRequest}.
   * This parameter is only valid when the session is connected.
   * @default ""
   * @readonly
   */
                    get p2pInboxInUse() {
                        return Check.nothing(this._p2pInboxInUse) ? "" : this._p2pInboxInUse;
                    }
                    /**
   * @private
   * @param {String} value The current P2P subscription.
   */
                    _setP2pInboxInUse(value) {
                        this._p2pInboxInUse = value;
                    }
                    /**
   * @private
   *
   * @name solace.SessionProperties#p2pInboxBase
   * @description A read-only information string that stores the P2P topic subscription
   * obtained from the Solace Message Router.
   * This parameter is only valid when the session is connected.
   * @default  ""
   * @readonly
   */
                    get p2pInboxBase() {
                        return Check.nothing(this._p2pInboxBase) ? "" : this._p2pInboxBase;
                    }
                    /**
   * @private
   * @param {String} value The current P2P inbox root subscription. The subscription on the router
   *   additionally contains '/>', so extra topic levels can be added to this root and messages to
   *   those topics will be attracted with the subscription.
   */
                    _setP2pInboxBase(value) {
                        this._p2pInboxBase = value;
                    }
                    /**
   * @name solace.SessionProperties#userIdentification
   * @type {String}
   * @description A read-only string providing information
   * about the application, such as the name of operating system
   * that is running the application.
   * @default  ""
   * @readonly
   */
                    get userIdentification() {
                        return Check.nothing(this._userIdentification) ? "" : this._userIdentification;
                    }
                    /**
   * @private
   * @param {String} value The current userId
   */
                    _setUserIdentification(value) {
                        this._userIdentification = value;
                    }
                    // ================== Subscriptions ========================
                    /**
   *
   * @name solace.SessionProperties#subscriberLocalPriority
   * @type {Number}
   * @description Subscriber priorities are used by the Solace Message Router to distribute messages
   * that have the {@link solace.Message#setDeliverToOne} flag set to true. These messages are sent
   * to the subscriber with the highest priority. Subscribers have two priorities; this
   * priority is for messages published locally.
   *  * The valid range is 1..4
   * @default 1
   * @deprecated Use Shared Subscriptions instead
   */
                    get subscriberLocalPriority() {
                        return Check.nothing(this._subLocalPriority) ? 1 : this._subLocalPriority;
                    }
                    set subscriberLocalPriority(newValue) {
                        this._subLocalPriority = newValue;
                    }
                    /**
   * @name solace.SessionProperties#subscriberNetworkPriority
   * @type {Number}
   * @description Subscriber priorities are used by the Solace Message Router to distribute messages
   * that have the {@link solace.Message#setDeliverToOne} flag set to true. These messages are sent
   * to the subscriber with the highest priority.
   *
   * Subscribers have two priorities; this priority is for messages published on Solace Message
   * Routers other than the one that the client is connected to.
   *  * The valid range is 1..4
   * @default  1
   * @deprecated Use Shared Subscriptions instead
   */
                    get subscriberNetworkPriority() {
                        return Check.nothing(this._subNetworkPriority) ? 1 : this._subNetworkPriority;
                    }
                    set subscriberNetworkPriority(newValue) {
                        this._subNetworkPriority = newValue;
                    }
                    /**
   * @name solace.SessionProperties#ignoreDuplicateSubscriptionError
   * @type {Boolean}
   * @description Used to ignore duplicate subscription errors on subscribe.
   * @default  true
   */
                    get ignoreDuplicateSubscriptionError() {
                        return Check.nothing(this._ignoreDupSubError) ? true : this._ignoreDupSubError;
                    }
                    set ignoreDuplicateSubscriptionError(newValue) {
                        this._ignoreDupSubError = newValue;
                    }
                    /**
   * @name solace.SessionProperties#ignoreSubscriptionNotFoundError
   * @type {Boolean}
   * @description Used to ignore subscription not found errors on unsubscribe.
   * @default  true
   */
                    get ignoreSubscriptionNotFoundError() {
                        return Check.nothing(this._ignoreSubNotFoundError) ? true : this._ignoreSubNotFoundError;
                    }
                    set ignoreSubscriptionNotFoundError(newValue) {
                        this._ignoreSubNotFoundError = newValue;
                    }
                    /**
   *
   * @name solace.SessionProperties#reapplySubscriptions
   * @type {Boolean}
   * @description Set to 'true' to have the API remember subscriptions and reapply them upon
   * calling {@link solace.Session#connect} on a disconnected session.
   * @default  false
   */
                    get reapplySubscriptions() {
                        return Check.nothing(this._reapplySubcriptions) ? false : this._reapplySubcriptions;
                    }
                    set reapplySubscriptions(newValue) {
                        this._reapplySubcriptions = newValue;
                    }
                    // ================== AD configuration ========================
                    /**
   * Sets the guaranteed messaging publisher properties for the session.
   * If the supplied value is not a {@link solace.MessagePublisherProperties},
   * one will be constructed using the supplied value as an argument.
   *
   * @name solace.SessionProperties#publisherProperties
   * @type {solace.MessagePublisherProperties|null|undefined}
   */
                    get publisherProperties() {
                        return this._publisherProperties;
                    }
                    set publisherProperties(val) {
                        const {
                            MessagePublisherProperties
                        } = PublisherLib;
                        this._publisherProperties = val instanceof MessagePublisherProperties ? val : new MessagePublisherProperties(val);
                    }
                    // ================== Transport configuration ========================
                    /**
   *
   * @name solace.SessionProperties#noLocal
   * @type {Boolean}
   * @description Set to 'true' to signal the Solace Message Router that messages published on the
   * session should not be received on the same session even if the client has a subscription that
   * matches the published topic. If this restriction is requested, and the Solace Message Router
   * does not have No Local support, the session connect will fail.
   * @default  false
   */
                    get noLocal() {
                        return Check.nothing(this._noLocal) ? false : this._noLocal;
                    }
                    set noLocal(newValue) {
                        this._noLocal = newValue;
                    }
                    /**
   * @name solace.SessionProperties#readTimeoutInMsecs
   * @type {Number}
   * @description The timeout period (in milliseconds) for a reply to
   * come back from the Solace Message Router. This timeout serves as the default
   * request timeout for {@link solace.Session#subscribe},
   * {@link solace.Session#unsubscribe}, {@link solace.Session#updateProperty}.
   *  * The valid range is >= 0.
   * @default 10000
   */
                    get readTimeoutInMsecs() {
                        return Check.nothing(this._readTimeout) ? 1e4 : this._readTimeout;
                    }
                    set readTimeoutInMsecs(newValue) {
                        this._readTimeout = newValue;
                    }
                    /**
   * @name solace.SessionProperties#sendBufferMaxSize
   * @type {Number}
   * @description The maximum buffer size for the transport session. This size must be bigger
   * than the largest message an application intends to send on the session.
   *
   * The session buffer size configured using the sendBufferMaxSize
   * session property controls SolClient buffering of transmit messages. When
   * sending small messages, the session buffer size should be set to multiple times
   * the typical message size to improve the performance. Regardless of the buffer
   * size, SolClient always accepts at least one message to transmit. So even if a
   * single message exceeds sendBufferMaxSize, it is accepted and
   * transmitted as long as the current buffered data is zero. However, no more
   * messages are accepted until the amount of data buffered is reduced
   * enough to allow room below sendBufferMaxSize.
   *  * The valid range is > 0.
   *
   * @default 65536 (64KB)
   */
                    get sendBufferMaxSize() {
                        return Check.nothing(this._sendBufferMaxSize) ? 64 * 1024 : this._sendBufferMaxSize;
                    }
                    set sendBufferMaxSize(newValue) {
                        this._sendBufferMaxSize = newValue;
                    }
                    /**
   * @name solace.SessionProperties#assumedMaxAdSize
   * @type {Number}
   * @description The assumed maximum AD message payload size before the session is established.
   * This value is irrelevant after session connection establishment,
   * because at that point the broker-reported AD size limit takes precedence.
   *
   * Before the session is connected, messages with payloads larger than this number
   * are rejected upon send().
   * The default value of 30000000 is appropriate for appliances, whereas for VMRs it should be set to 10000000.
   *
   *  * The valid range is > 0.
   *
   * @default 30000000 
   */
                    get assumedMaxAdSize() {
                        return Check.nothing(this._assumedMaxAdSize) ? 3e7 : this._assumedMaxAdSize;
                    }
                    set assumedMaxAdSize(newValue) {
                        this._assumedMaxAdSize = newValue;
                    }
                    /**
   * @name solace.SessionProperties#maxWebPayload
   * @type {Number}
   * @description The maximum payload size (in bytes) when sending data using the Web transport
   * protocol.  Large messages may fail to be sent to the Solace Message Router when the maximum web
   * payload is set to a small value. To avoid this, use a large maximum web payload.
   *  * The valid range is >= 100.
   * @default 1048576 (1MB)
   */
                    get maxWebPayload() {
                        return Check.nothing(this._maxWebPayload) ? 1024 * 1024 : this._maxWebPayload;
                    }
                    set maxWebPayload(newValue) {
                        this._maxWebPayload = newValue;
                    }
                    /**
   * @private
   */
                    get nonHTTPTransportPropsSet() {
                        // Calculate on demand based on presence of properties.
                        // Currently not tracking this so no property names listed.
                        return [].filter(k => Check.something(this[k]));
                    }
                    /**
   * @returns {String} A brief description of this object
   * @private
   */
                    ["inspect"]() {
                        return Object.assign(this._lendsInspect(), {
                            authenticationScheme: AuthenticationScheme.describe(this.authenticationScheme),
                            accessToken: this.accessToken ? "*****" : "Not Set",
                            idToken: this.idToken ? "*****" : "Not Set",
                            issuerIdentifier: this.issuerIdentifier ? "*****" : "Not Set",
                            url: this.url,
                            password: this.password ? "*****" : this.password,
                            userName: this.userName,
                            clientName: this.clientName,
                            applicationDescription: this.applicationDescription,
                            vpnName: this.vpnName,
                            vpnNameInUse: this.vpnNameInUse,
                            virtualRouterName: this.virtualRouterName,
                            connectTimeoutInMsecs: this.connectTimeoutInMsecs,
                            connectRetries: this.connectRetries,
                            connectRetriesPerHost: this.connectRetriesPerHost,
                            reconnectRetryWaitInMsecs: this.reconnectRetryWaitInMsecs,
                            reconnectRetries: this.reconnectRetries,
                            generateSendTimestamps: this.generateSendTimestamps,
                            generateReceiveTimestamps: this.generateReceiveTimestamps,
                            includeSenderId: this.includeSenderId,
                            generateSequenceNumber: this.generateSequenceNumber,
                            keepAliveIntervalInMsecs: this.keepAliveIntervalInMsecs,
                            keepAliveIntervalsLimit: this.keepAliveIntervalsLimit,
                            p2pInboxInUse: this.p2pInboxInUse,
                            p2pInboxBase: this.p2pInboxBase,
                            userIdentification: this.userIdentification,
                            subscriberLocalPriority: this.subscriberLocalPriority,
                            subscriberNetworkPriority: this.subscriberNetworkPriority,
                            ignoreDuplicateSubscriptionError: this.ignoreDuplicateSubscriptionError,
                            reapplySubscriptions: this.reapplySubscriptions,
                            publisherProperties: this.publisherProperties,
                            noLocal: this.noLocal,
                            readTimeoutInMsecs: this.readTimeoutInMsecs,
                            sendBufferMaxSize: this.sendBufferMaxSize,
                            maxWebPayload: this.maxWebPayload
                        });
                    }
                    /**
   * @name solace.SessionProperties#toString
   * @method
   * @description Returns a human-readable representation of this Session, subject to change.
   * @returns {String} A brief description of this object
   */
                    toString() {
                        return super.toString(); // only here for the docs
                    }
                }
                // Don't try to evaluate these constants in browser mode
                if (false) {}
                module.exports.SessionProperties = SessionProperties;
                /***/
            },
            /***/ "./modules/solclient-session/lib/session-request-types.js": 
            /*!****************************************************************!*\
  !*** ./modules/solclient-session/lib/session-request-types.js ***!
  \****************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * @private
 * @enum {number}
 */
                const SessionRequestType = {
                    ADD_SUBSCRIPTION: 0,
                    REMOVE_SUBSCRIPTION: 1,
                    ADD_P2PINBOX: 2,
                    REMOVE_P2PINBOX: 3,
                    REMOVE_DTE_SUBSCRIPTION: 100
                };
                module.exports.SessionRequestType = Enum.new(SessionRequestType);
                /***/
            },
            /***/ "./modules/solclient-session/lib/session-state-names.js": 
            /*!**************************************************************!*\
  !*** ./modules/solclient-session/lib/session-state-names.js ***!
  \**************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Internal session state
 * @enum {string}
 * @memberof solace
 * @private
 */
                const SessionStateName = {
                    DISCONNECTED: "SessionDisconnected",
                    CONNECTING: "SessionConnecting",
                    WAITING_FOR_TRANSPORT: "WaitingForTransport",
                    WAITING_FOR_TRANSPORT_UP: "WaitingForTransportUp",
                    WAITING_FOR_LOGIN: "WaitingForLogin",
                    TRANSPORT_UP: "SessionTransportUp",
                    FULLY_CONNECTED: "SessionFullyConnected",
                    SESSION_ERROR: "SessionError",
                    DISCONNECTING: "SessionDisconnecting",
                    REAPPLYING_SUBSCRIPTIONS: "ReapplyingSubscriptions",
                    WAITING_FOR_PUBFLOW: "WaitingForMessagePublisher",
                    DISPOSED: "SessionDisposed",
                    WAITING_FOR_SUBCONFIRM: "WaitForSubConfirm",
                    WAITING_FOR_CAN_ACCEPT_DATA: "WaitForCanAcceptData",
                    DISCONNECTING_FLOWS: "DisconnectingFlows",
                    FLUSHING_TRANSPORT: "FlushingTransport",
                    DESTROYING_TRANSPORT: "DestroyingTransport",
                    RECONNECTING: "Reconnecting",
                    TRANSPORT_FAIL: "TransportFail",
                    WAITING_FOR_INTERCONNECT_TIMEOUT: "WaitingForInterconnectTimeout",
                    WAITING_FOR_DNS: "WaitingForDNS",
                    WAITING_FOR_TRANSPORT_CHANGE: "WaitingForTransportChange"
                };
                module.exports.SessionStateName = Enum.new(SessionStateName);
                /***/
            },
            /***/ "./modules/solclient-session/lib/session-states.js": 
            /*!*********************************************************!*\
  !*** ./modules/solclient-session/lib/session-states.js ***!
  \*********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * @private
 * @enum {number}
 */
                const SessionState = {
                    /**
   * The session is connecting.
   */
                    CONNECTING: 1,
                    /**
   * The session is connected.
   */
                    CONNECTED: 2,
                    /**
   * The session experienced an error.
   */
                    SESSION_ERROR: 3,
                    /**
   * The session is disconnecting.
   */
                    DISCONNECTING: 4,
                    /**
   * The session is disconnected.
   */
                    DISCONNECTED: 5
                };
                module.exports.SessionState = Enum.new(SessionState);
                /***/
            },
            /***/ "./modules/solclient-session/lib/session.js": 
            /*!**************************************************!*\
  !*** ./modules/solclient-session/lib/session.js ***!
  \**************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /* provided dependency */ var util_inspect = __webpack_require__(/*! browser-util-inspect */ "./node_modules/browser-util-inspect/index.js");
                const DestinationLib = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                const MessageLib = __webpack_require__(/*! solclient-message */ "./modules/solclient-message/api.js");
                const SolclientFactoryLib = __webpack_require__(/*! solclient-factory */ "./modules/solclient-factory/api.js");
                const {
                    assert
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                const {
                    CacheSession,
                    CACHE_REQUEST_PREFIX
                } = __webpack_require__(/*! solclient-solcache-session */ "./modules/solclient-solcache-session/api.js");
                const {
                    CapabilityType
                } = __webpack_require__(/*! ./capability-types */ "./modules/solclient-session/lib/capability-types.js");
                const {
                    Check,
                    Parameter
                } = __webpack_require__(/*! solclient-validate */ "./modules/solclient-validate/api.js");
                const {
                    DefaultCapabilities
                } = __webpack_require__(/*! ./default-capabilities */ "./modules/solclient-session/lib/default-capabilities.js");
                const {
                    ErrorResponseSubcodeMapper,
                    ErrorSubcode,
                    OperationError,
                    RequestEventCode
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    EventEmitter
                } = __webpack_require__(/*! solclient-events */ "./modules/solclient-events/api.js");
                const {
                    GlobalContext
                } = __webpack_require__(/*! ./global-context */ "./modules/solclient-session/lib/global-context.js");
                const {
                    HostList
                } = __webpack_require__(/*! ./host-list */ "./modules/solclient-session/lib/host-list.js");
                const {
                    LogFormatter
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    MessageRxCBInfo
                } = __webpack_require__(/*! ./message-rx-cb-info */ "./modules/solclient-session/lib/message-rx-cb-info.js");
                const {
                    MutableSessionProperty
                } = __webpack_require__(/*! ./mutable-session-properties */ "./modules/solclient-session/lib/mutable-session-properties.js");
                const {
                    OutstandingDataRequest
                } = __webpack_require__(/*! ./outstanding-data-request */ "./modules/solclient-session/lib/outstanding-data-request.js");
                const {
                    P2PUtil
                } = __webpack_require__(/*! ./p2p-util */ "./modules/solclient-session/lib/p2p-util.js");
                const {
                    QueueDescriptor,
                    QueueType
                } = __webpack_require__(/*! solclient-queue */ "./modules/solclient-queue/api.js");
                const {
                    SDTField,
                    SDTFieldType
                } = __webpack_require__(/*! solclient-sdt */ "./modules/solclient-sdt/api.js");
                const {
                    SessionEvent
                } = __webpack_require__(/*! ./session-event */ "./modules/solclient-session/lib/session-event.js");
                const {
                    SessionEventCBInfo
                } = __webpack_require__(/*! ./session-event-cb-info */ "./modules/solclient-session/lib/session-event-cb-info.js");
                const {
                    SessionEventCode
                } = __webpack_require__(/*! ./session-event-codes */ "./modules/solclient-session/lib/session-event-codes.js");
                const {
                    SessionEventName
                } = __webpack_require__(/*! ./session-event-names */ "./modules/solclient-session/lib/session-event-names.js");
                const {
                    SessionFSM
                } = __webpack_require__(/*! ./session-fsm */ "./modules/solclient-session/lib/session-fsm.js");
                const {
                    SessionFSMEvent
                } = __webpack_require__(/*! ./session-fsm-event */ "./modules/solclient-session/lib/session-fsm-event.js");
                const {
                    SessionOperation
                } = __webpack_require__(/*! ./session-operations */ "./modules/solclient-session/lib/session-operations.js");
                const {
                    SessionProperties
                } = __webpack_require__(/*! ./session-properties */ "./modules/solclient-session/lib/session-properties.js");
                const {
                    SessionPropertiesValidator
                } = __webpack_require__(/*! ./session-properties-validator */ "./modules/solclient-session/lib/session-properties-validator.js");
                const {
                    SessionRequestType
                } = __webpack_require__(/*! ./session-request-types */ "./modules/solclient-session/lib/session-request-types.js");
                const {
                    SessionState
                } = __webpack_require__(/*! ./session-states */ "./modules/solclient-session/lib/session-states.js");
                const {
                    SessionStateName
                } = __webpack_require__(/*! ./session-state-names */ "./modules/solclient-session/lib/session-state-names.js");
                const {
                    Stats,
                    StatType
                } = __webpack_require__(/*! solclient-stats */ "./modules/solclient-stats/api.js");
                const {
                    StringUtils
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const {
                    TransportCapabilities,
                    TransportProtocol,
                    TransportReturnCode
                } = __webpack_require__(/*! solclient-transport */ "./modules/solclient-transport/api.js");
                function transportProtocolDefaultList() {
                    const {
                        ProfileBinding
                    } = SolclientFactoryLib;
                    if (false) {}
                    const result = [];
                    if (TransportCapabilities.web.webSocket()) {
                        result.push(TransportProtocol.WS_BINARY);
                    }
                    const profile = ProfileBinding.value;
                    if (profile.cometEnabled) {
                        if (TransportCapabilities.web.xhrBinary()) {
                            if (TransportCapabilities.web.streaming()) {
                                result.push(TransportProtocol.HTTP_BINARY_STREAMING);
                            }
                            result.push(TransportProtocol.HTTP_BINARY);
                        }
                        result.push(TransportProtocol.HTTP_BASE64);
                    }
                    return result;
                }
                function isValidADTransport(transportProtocol) {
                    return transportProtocol && (transportProtocol !== TransportProtocol.HTTP_BINARY_STREAMING && transportProtocol !== TransportProtocol.HTTP_BINARY && transportProtocol !== TransportProtocol.HTTP_BASE64);
                }
                function formatEventName(eventName) {
                    return `SessionEventCode.${SessionEventCode.describe(eventName)}`;
                }
                /**
 * @private
 */
                const SOLCLIENT_REQUEST_PREFIX = "#REQ";
                /**
 * A callback that returns replies to requests sent via {@link solace.Session#sendRequest}.
 * The replyReceivedCallback <b>must</b> be provided to the API as the third argument of
 * {@link solace.Session#sendRequest}.
 * @callback
 * @function
 * @name solace.Session.replyReceivedCallback
 * @param {solace.Session} session The session object that received the reply.
 * @param {solace.Message} message The reply message received.
 * @param {Object} userObject The user object associated with the callback. 'undefined' when
 * not provided to <i>sendRequest</i>
 */
                /**
 * A callback that returns errors associated with requests sent via
 * {@link solace.Session#sendRequest}. The requestFailedCallback <b>must</b> be
 * provided to the API as the fourth argument of
 * {@link solace.Session#sendRequest}
 * @callback
 * @function
 * @name solace.Session.requestFailedCallback
 * @param {solace.Session} session The session object associated with the event.
 * @param {solace.RequestError} error The event associated with the failure.
 * @param {Object} userObject The user object associated with the callback. 'undefined' when
 * not provided to <i>sendRequest</i>
 */
                /**
 * @classdesc
 * <b>This class is not exposed for construction by API users.</b>
 * Applications must use {@link solace.SolclientFactory.createSession} to create a session.
 *
 * Represents a client Session.
 *
 * Session provides these major functions:
 *  * Subscriber control, such as updating subscriptions;
 *  * Publishes both Direct and Guaranteed Messages to the router;
 *  * Receives direct messages from the router.
 *
 * The Session object is an
 * {@link https://nodejs.org/api/events.html#events_class_eventemitter|EventEmitter}, and will emit
 * events with event names from {@link solace.SessionEventCode} when Session events occur.
 * Each session event can be subscribed using {@link solace.Session#on} with the corresponding
 * {@link solace.SessionEventCode}. If any of the registered event listeners throw an exception,
 * the exception will be emitted on the 'error' event.
 *
 * @fires solace.SessionEventCode#ACKNOWLEDGED_MESSAGE
 * @fires solace.SessionEventCode#CAN_ACCEPT_DATA
 * @fires solace.SessionEventCode#CONNECT_FAILED_ERROR
 * @fires solace.SessionEventCode#DISCONNECTED
 * @fires solace.SessionEventCode#DOWN_ERROR
 * @fires solace.SessionEventCode#GUARANTEED_MESSAGE_PUBLISHER_DOWN
 * @fires solace.SessionEventCode#MESSAGE
 * @fires solace.SessionEventCode#PROPERTY_UPDATE_ERROR
 * @fires solace.SessionEventCode#PROPERTY_UPDATE_OK
 * @fires solace.SessionEventCode#RECONNECTED_NOTICE
 * @fires solace.SessionEventCode#RECONNECTING_NOTICE
 * @fires solace.SessionEventCode#REJECTED_MESSAGE_ERROR
 * @fires solace.SessionEventCode#REPUBLISHING_UNACKED_MESSAGES
 * @fires solace.SessionEventCode#SUBSCRIPTION_ERROR
 * @fires solace.SessionEventCode#SUBSCRIPTION_OK
 * @fires solace.SessionEventCode#UNSUBSCRIBE_TE_TOPIC_ERROR
 * @fires solace.SessionEventCode#UNSUBSCRIBE_TE_TOPIC_OK
 * @fires solace.SessionEventCode#UP_NOTICE
 * @fires solace.SessionEventCode#VIRTUALROUTER_NAME_CHANGED
 *
 * @hideconstructor
 * @memberof solace
 */
                class Session extends EventEmitter {
                    /*
   * Applications must use {@link solace.SolclientFactory.createSession} to create a session.
   *
   * @param {solace.SessionProperties} properties Properties to use for constructing
   *        the session.
   * @param {solace.MessageRxCBInfo} [messageCallback] Message callback info. The application can
   *    also receive message events via
   *    `session.on(solace.SessionEventCode.MESSAGE, (message) => { ... });`
   * @param {solace.SessionEventCBInfo} [eventCallback] Event callback info. The application can
   *    also receive session events via
   *    `session.on(solace.SessionEventCode.<code>, (event) => { ... });`
   *
   * @throws {solace.OperationError} if the parameters have an invalid type or value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * @private
   * @constructor
   */
                    constructor(properties, messageCallback, eventCallback) {
                        super({
                            emits: SessionEventCode.values,
                            direct: SessionEventCode.MESSAGE,
                            formatEventName: formatEventName
                        });
                        const self = this;
                        this.logger = new LogFormatter();
                        this.logger.formatter = function formatter(...args) {
                            return [ `[session=${self._sessionFSM ? self._sessionFSM.sessionIdHex : "(N/A)"}]`, ...args ];
                        };
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Session constructor called.");
                        if (properties !== undefined && properties !== null) {
                            const {
                                LOG_DEBUG
                            } = this.logger;
                            LOG_DEBUG("Incoming session properties:\n", properties);
                        }
                        // Default error handler prints the exception:
                        this.on("error", error => {
                            const {
                                LOG_ERROR
                            } = self.logger;
                            LOG_ERROR(error.info.error);
                        });
                        const sessionProperties = new SessionProperties(properties);
                        {
                            const {
                                LOG_DEBUG
                            } = this.logger;
                            LOG_DEBUG("Eventual session properties:\n", sessionProperties);
                        }
                        // Callbacks to client application.
                        // Get/set for these is private, so they can only be changed in-API (e.g. by CacheSession)
                        // The user-supplied one cannot be changed.
                        // The configuration of the exceptions generated by these needs to match EventEmitter, so that
                        // the handleGenericErrorEvent above can behave consistently
                        this._messageCallbackInfo = this.wrapMessageCallback(messageCallback);
                        this._eventCallbackInfo = this.wrapEventCallback(eventCallback);
                        // client name generation is applicable
                        if (Check.empty(sessionProperties.clientName)) {
                            // Auto-gen clientName
                            sessionProperties.clientName = GlobalContext.GenerateClientName();
                        }
                        // generate userIdentification
                        sessionProperties._setUserIdentification(GlobalContext.GenerateUserIdentification());
                        // client description generation is applicable
                        if (Check.empty(sessionProperties.applicationDescription)) {
                            // Auto-gen applicationDescription
                            sessionProperties.applicationDescription = GlobalContext.GenerateClientDescription();
                        }
                        // Set webTransportProtocolList after validation so we're not basing it on an
                        // invalid transport selection...so we're not checking transportProtocol/
                        // webTransportProtocolList except for parameter conflict.
                        // Now that we have touched up the properties as much as possible, validate
                        // This also validates the subordinate MessagePublisherProperties
                        SessionPropertiesValidator.validate(sessionProperties);
                        // We want a protocol list, but historically we also accept a single protocol.
                        // Create a web transport protocol list from the transport protocol
                        // option if that is all that was set. (If both were set, we failed validation)
                        if (Check.nothing(sessionProperties.webTransportProtocolList)) {
                            // Create a fallback list that starts with the selected protocol.
                            // If the selected protocol is not in the fallback list, it is not
                            // a valid protocol for the platform so return an empty list.
                            const selectedProtocol = sessionProperties.transportProtocol;
                            const defaultList = transportProtocolDefaultList();
                            const sliceIndex = selectedProtocol ? defaultList.indexOf(selectedProtocol) : 0;
                            if (sliceIndex < 0) {
                                // The user explicitly selected a protocol that wasn't valid
                                throw new OperationError(`Selected transport protocol ${TransportProtocol.describe(selectedProtocol)} is disabled or invalid for this platform`, ErrorSubcode.PARAMETER_CONFLICT);
                            }
                            // Slice index is valid
                            sessionProperties.webTransportProtocolList = defaultList.slice(sliceIndex);
                            if (sessionProperties.webTransportProtocolList.length === 0) {
                                // Even before AD restrictions, no valid protocols.
                                // User error.
                                throw new OperationError(`No usable transport protocol or fallback from ${TransportProtocol.describe(selectedProtocol)}`, ErrorSubcode.PARAMETER_CONFLICT);
                            }
                            // Check that the generated list is compatible with AD.
                            const validForAD = sessionProperties.webTransportProtocolList.filter(x => isValidADTransport(x));
                            if (validForAD.length === 0) {
                                this._adDisabledReason = "Guaranteed messaging not compatible with any available " + `transport protocol: ${sessionProperties.webTransportProtocolList.map(k => TransportProtocol.describe(k)).join(", ")}`;
                            }
                            // Don't fold this into the check below -- for that one, every
                            // protocol must be valid because the user explicitly requested all of them.
                            // In this case, we ensure that at least one of our generated list is valid.
                            if (sessionProperties.publisherProperties.enabled) {
                                if (this._adDisabledReason) {
                                    throw new OperationError("Invalid transport protocol(s) for session with Guaranteed Messaging Publisher", ErrorSubcode.PARAMETER_CONFLICT, this._adDisabledReason);
                                }
                                // AD was not disabled by having no protocols available
                                sessionProperties.webTransportProtocolList = validForAD;
                            }
                            // A valid protocol list is ready to use.
                        } else {
                            // User provided transport protocol list
                            // Check for parameter conflict between session and publisher
                            // Already checked these for parameter conflict; only one will be set
                            // Already checked that user list was not empty
                            const transportProtocols = sessionProperties.webTransportProtocolList;
                            const validForAD = transportProtocols.every(isValidADTransport);
                            if (!validForAD) {
                                const invalid = transportProtocols.filter(x => !isValidADTransport(x));
                                this._adDisabledReason = `Guaranteed messaging incompatible with selected transport protocols: ${invalid.map(k => TransportProtocol.describe(k)).join(", ")}`;
                                if (sessionProperties.publisherProperties.enabled) {
                                    throw new OperationError("Invalid transport protocol(s) for session with Guaranteed Messaging Publisher", ErrorSubcode.PARAMETER_CONFLICT, this._adDisabledReason);
                                }
                            }
                        }
                        // Assign the final properties and start the state machine.
                        this._sessionProperties = sessionProperties;
                        this._sessionStats = new Stats();
                        this._hosts = new HostList(sessionProperties);
                        this._sessionFSM = new SessionFSM(this._sessionProperties, this, this._sessionStats, this._hosts);
                        this._sessionFSM.start();
                        this._sessionFSM.createMessagePublisher();
                        /**
     * The following fields are destroyed when disconnect is called
     * and recreated when connect is called again.
     * @private
     */
                        this._outstandingDataReqs = {};
                        this._capabilities = DefaultCapabilities.createDefaultCapabilities(sessionProperties);
                        this._seqNum = 1;
                    }
                    /**
   * Connects the session to the Solace Message Router as configured in
   * the {@link solace.SessionProperties#url}.
   *
   * When the session is successfully connected to the Solace Message Router, the
   * {@link solace.SessionEventCode#UP_NOTICE} event is emitted if a listener has been registered.
   *
   * If {@link solace.SessionProperties#reapplySubscriptions} is set to true, this operation
   * re-registers previously registered subscriptions. The connected session event
   * ({@link solace.SessionEventCode#event:UP_NOTICE}) is emitted only when all the subscriptions
   * are successfully added to the router.
   *
   * If the API is unable to connect within {@link solace.SessionProperties#connectTimeoutInMsecs}
   * or due to login failures, the session's state transitions back to 'disconnected' and an event
   * is generated.
   *
   * **Note:** Before the session's state transitions to 'connected', a client
   * application cannot use the session; any attempt to call functions will throw
   * {@link solace.OperationError}.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed, already connected or connecting.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the underlying transport cannot be established.
   *   Subcode: {@link solace.ErrorSubcode.CONNECTION_ERROR}.
   */
                    connect() {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Session connect called.");
                        const result = this.allowOperation(SessionOperation.CONNECT);
                        if (result) {
                            throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        }
                        const sEvent = new SessionFSMEvent({
                            name: SessionEventName.CONNECT
                        });
                        this._sessionFSM.processEvent(sEvent);
                    }
                    /**
   * @returns {Boolean} True if the session can be used to acknolwedge a message
   * @readonly
   * @private
   */
                    get canAck() {
                        /*
     * If the user wants to ack a message, it was received on a session (else ack will throw),
     * and so we know that the session was connected at some point.
     *
     * If the session is in any of the following states, we know it is either connecting or
     * connected.
     *
     * Since we know the session was previously connected, this implies the session is either
     * RECONNECTING or connected.
     *
     * We allow acks when the session is reconnecting or connected.
     */
                        const statesCanAck = [ SessionStateName.CONNECTING, SessionStateName.TRANSPORT_UP, SessionStateName.DISCONNECTING ];
                        // Allow ack if there is some acceptable state name such that getActiveState returns the state.
                        return statesCanAck.some(stateName => !!this._sessionFSM.getActiveState(stateName));
                    }
                    /**
   * Disconnects the session. The session attempts to disconnect cleanly, concluding all operations
   * in progress. The disconnected session event {@link solace.SessionEventCode#event:DISCONNECTED}
   * is emitted when these operations complete and the session has completely disconnected.
   *
   * @throws {solace.OperationError} if the session is disposed, or has never been connected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   */
                    disconnect() {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Session disconnect called.");
                        const result = this.allowOperation(SessionOperation.DISCONNECT);
                        if (result) {
                            throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        }
                        const sEvent = new SessionFSMEvent({
                            name: SessionEventName.DISCONNECT
                        });
                        this._sessionFSM.processEvent(sEvent);
                    }
                    /**
   * Release all resources associated with the session.
   * It is recommended to call disconnect() first for proper handshake with the message-router.
   */
                    dispose() {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Session dispose called.");
                        if (this._disposed) return;
                        //setImmediate(() => {
                        setTimeout(() => {
                            this._sessionFSM.processEvent(new SessionFSMEvent({
                                name: SessionEventName.DISPOSE
                            })); // yield for disconnect if any
                            this._sessionFSM.terminateFsm();
                            this.disableEmitter();
                            this._disposed = true;
                        }, 0);
                    }
                    /**
   * Subscribe to a topic, optionally requesting a confirmation from the router.
   *
   * If requestConfirmation is set to true:
   * {@link solace.SessionEventCode.SUBSCRIPTION_OK} is generated when subscription is
   * added successfully; otherwise, session event
   * {@link solace.SessionEventCode.SUBSCRIPTION_ERROR} is generated.
   *
   * If requestConfirmation is set to false, only session event
   * {@link solace.SessionEventCode.SUBSCRIPTION_ERROR} is generated upon failure.
   *
   * When the application receives session event
   * {@link solace.SessionEventCode.SUBSCRIPTION_ERROR}, it
   * can obtain the failed topic subscription by calling
   * {@link solace.SessionEvent#reason}.
   * The returned string is in the format of "Topic: <failed topic subscription>".
   *
   * @param {solace.Destination} topic The topic destination subscription to add.
   * @param {Boolean} requestConfirmation true, to request a confirmation; false otherwise.
   * @param {Object|String|undefined} correlationKey If specified, and if requestConfirmation is true, this value is
   *                                echoed in the session event within {@link SessionEvent}.
   * @param {Number|null|undefined} requestTimeout The request timeout period (in milliseconds). If specified, this
   *                                value overwrites readTimeoutInMsecs property in
   *                                {@link SessionProperties}.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the parameters have an invalid value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   * * if the topic has invalid syntax.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_TOPIC_SYNTAX}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   * * if the topic is a shared subscription and the peer router does not support Shared
   *   Subscriptions.
   *   Subcode: {@link solace.ErrorSubcode.SHARED_SUBSCRIPTIONS_NOT_SUPPORTED}.
   * * if the topic is a shared subscription and the client does not allowed Shared
   *   Subscriptions.
   *   Subcode: {@link solace.ErrorSubcode.SHARED_SUBSCRIPTIONS_NOT_ALLOWED}.
   */
                    subscribe(topic, requestConfirmation, correlationKey, requestTimeout) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Session subscribe called for topic ", topic && topic.toString && topic.toString());
                        const result = this.allowOperation(SessionOperation.CTRL);
                        if (result) {
                            throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        }
                        Parameter.isInstanceOf("topic", topic, DestinationLib.Destination);
                        topic.validate();
                        if (topic.getType() !== DestinationLib.DestinationType.TOPIC) {
                            throw new OperationError(`Topic is required for subscribe; ${DestinationLib.DestinationType.describe(topic.getType())}`, ErrorSubcode.INVALID_TOPIC_SYNTAX);
                        }
                        Parameter.isBooleanOrNothing("requestConfirmation", requestConfirmation);
                        Parameter.isNumberOrNothing("requestTimeout", requestTimeout);
                        Parameter.isRangeCompareOrNothing("requestTimeout", requestTimeout, ">", 0);
                        this._sessionFSM.subscriptionUpdate(topic, !!requestConfirmation, correlationKey, requestTimeout, SessionRequestType.ADD_SUBSCRIPTION, (rxMsgObj, cancelledRequest) => this.handleSubscriptionUpdateResponse(rxMsgObj, cancelledRequest, requestConfirmation));
                    }
                    updateQueueSubscription(topic, queue, add, messageConsumer, callback, requestTimeout) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Queue subscribe called for topic ", topic && topic.toString && topic.toString(), " for queue ", queue && queue.toString && queue.toString());
                        LOG_TRACE("queue: ", queue);
                        const result = this.allowOperation(SessionOperation.CTRL);
                        if (result) {
                            throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        }
                        Parameter.isInstanceOf("topic", topic, DestinationLib.Destination);
                        topic.validate();
                        if (topic.getType() !== DestinationLib.DestinationType.TOPIC) {
                            throw new OperationError(`Topic is required for queue subscribe; ${DestinationLib.DestinationType.describe(topic.getType())}`, ErrorSubcode.INVALID_TOPIC_SYNTAX);
                        }
                        Parameter.isInstanceOf("queue", queue, DestinationLib.Destination);
                        queue.validate();
                        if (queue.getType() !== DestinationLib.DestinationType.QUEUE && queue.getType() !== DestinationLib.DestinationType.TEMPORARY_QUEUE) {
                            throw new OperationError(`Queue is required for queue subscribe; ${DestinationLib.DestinationType.describe(queue.getType())}`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                        Parameter.isNumberOrNothing("requestTimeout", requestTimeout);
                        Parameter.isRangeCompareOrNothing("requestTimeout", requestTimeout, ">", 0);
                        this._sessionFSM.queueSubscriptionUpdate(topic, queue, requestTimeout, add, (rxMsgObj, cancelledRequest) => this.handleQueueSubscriptionUpdateResponse(rxMsgObj, cancelledRequest, callback));
                    }
                    /**
   * Unsubscribe from a topic, and optionally request a confirmation from the router.
   *
   * If requestConfirmation is set to true, session event
   * {@link solace.SessionEventCode.SUBSCRIPTION_OK} is generated when subscription is removed
   * successfully; otherwise, session event
   * {@link solace.SessionEventCode.SUBSCRIPTION_ERROR} is generated.
   *
   * If requestConfirmation is set to false, only session event
   * {@link solace.SessionEventCode.SUBSCRIPTION_ERROR} is generated upon failure.
   *
   * When the application receives session event
   * {@link solace.SessionEventCode.SUBSCRIPTION_ERROR}, it
   * can obtain the failed topic subscription by calling
   * {@link solace.SessionEvent#reason}. The returned
   * string is in the format "Topic: <failed topic subscription>".
   *
   * @param {solace.Destination} topic The topic destination subscription to remove.
   * @param {Boolean} requestConfirmation true, to request a confirmation; false otherwise.
   * @param {Object|String|undefined} correlationKey If <code>null</code> or undefined, a Correlation Key is not set
   *                                in the confirmation session event.
   * @param {Number|null|undefined} requestTimeout The request timeout period (in milliseconds). If specified, this
   *                                value overwrites readTimeoutInMsecs property in
   *                                {@link SessionProperties}.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the parameters have an invalid value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   * * if the topic has invalid syntax.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_TOPIC_SYNTAX}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   * * if the topic is a shared subscription and the peer router does not support Shared
   *   Subscriptions.
   *   Subcode: {@link solace.ErrorSubcode.SHARED_SUBSCRIPTIONS_NOT_SUPPORTED}.
   * * if the topic is a shared subscription and the client does not allowed Shared
   *   Subscriptions.
   *   Subcode: {@link solace.ErrorSubcode.SHARED_SUBSCRIPTIONS_NOT_ALLOWED}.
   */
                    unsubscribe(topic, requestConfirmation, correlationKey, requestTimeout) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Session unsubscribe called for topic ", topic && topic.toString && topic.toString());
                        const result = this.allowOperation(SessionOperation.CTRL);
                        if (result) {
                            throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        }
                        Parameter.isInstanceOf("topic", topic, DestinationLib.Destination);
                        topic.validate();
                        if (topic.getType() !== DestinationLib.DestinationType.TOPIC) {
                            throw new OperationError(`Topic is required for unsubscribe; ${DestinationLib.DestinationType.describe(topic.getType())}`, ErrorSubcode.INVALID_TOPIC_SYNTAX);
                        }
                        Parameter.isBooleanOrNothing("requestConfirmation", requestConfirmation);
                        Parameter.isNumberOrNothing("requestTimeout", requestTimeout);
                        Parameter.isRangeCompareOrNothing("requestTimeout", requestTimeout, ">", 0);
                        this._sessionFSM.subscriptionUpdate(topic, !!requestConfirmation, correlationKey, requestTimeout, SessionRequestType.REMOVE_SUBSCRIPTION, (rxMsgObj, cancelledRequest) => this.handleSubscriptionUpdateResponse(rxMsgObj, cancelledRequest, requestConfirmation));
                    }
                    /**
   * Request that a Durable Topic Endpoint stop receiving data on a topic. Unsubscribe
   * requests are only allowed by the router when no clients are bound to the DTE.
   * If the unubscribe request is successful, the DTE will stop attracting messages,
   * and all messages spooled to the DTE will be deleted.
   *
   * {@link solace.SessionEventCode.UNSUBSCRIBE_TE_TOPIC_OK} is generated when the
   * subscription is removed successfully; otherwise,
   * {@link solace.SessionEventCode.UNSUBSCRIBE_TE_TOPIC_ERROR} is generated.
   *
   * When the application receives session event
   * {@link solace.SessionEventCode.UNSUBSCRIBE_TE_TOPIC_ERROR}, it
   * can obtain the failed topic subscription by calling
   * {@link solace.SessionEvent#reason}.
   *
   * @param {solace.AbstractQueueDescriptor|solace.QueueDescriptor} queueDescriptor A description
   *  of the queue to which the topic is subscribed.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the parameters have an invalid value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   */
                    unsubscribeDurableTopicEndpoint(queueDescriptor) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Session unsubscribeDurableTopicEndpoint called for queue descriptor ", queueDescriptor && queueDescriptor.toString && queueDescriptor.toString());
                        const result = this.allowOperation(SessionOperation.CTRL);
                        if (result) {
                            throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        }
                        // emulate subscription
                        const destination = this.createDestinationFromDescriptor(QueueDescriptor.createFromSpec(queueDescriptor));
                        const requestConfirmation = true;
                        this._sessionFSM.subscriptionUpdate(destination, requestConfirmation, undefined, undefined, SessionRequestType.REMOVE_DTE_SUBSCRIPTION, (rxMsgObj, cancelledRequest) => this.handleDTEUnsubscribeResponse(rxMsgObj, cancelledRequest));
                    }
                    /**
   * Modify a session property after creation of the session.
   *
   * This method only works for a select few properties,
   * and updates their value on the live broker session.
   *
   * @param {MutableSessionProperty} mutableSessionProperty The property key to modify.
   * @param {Object} newValue The new property value.
   * @param {Number} requestTimeout The request timeout period (in milliseconds). If specified, it
   *                                overwrites readTimeoutInMsecs
   * @param {Object} correlationKey If specified, this value is echoed in the session event within
   *                                {@link SessionEvent} property in {@link SessionProperties}
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the parameters have an invalid value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   */
                    updateProperty(mutableSessionProperty, newValue, requestTimeout, correlationKey) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Session updateProperty called: ", mutableSessionProperty, newValue);
                        const result = this.allowOperation(SessionOperation.CTRL);
                        if (result) {
                            throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        }
                        const {
                            Topic
                        } = DestinationLib;
                        LOG_TRACE("Updating property ", mutableSessionProperty, newValue);
                        Parameter.isEnumMember("mutableSessionProperty", mutableSessionProperty, MutableSessionProperty);
                        Parameter.isNumberOrNothing("requestTimeout", requestTimeout);
                        Parameter.isRangeCompareOrNothing("requestTimeout", requestTimeout, ">", 0);
                        let sessionEvent;
                        /*
     Response CB to the CLIENTCTRL UPDATE response

     This is pretty complicated: we define the whole process in here
     using callbacks to preserve state such as the correlationKey of the user
     request.
     That is, this entire multi-step process executes under the context of that one call to
     updateProperty with a single correlationKey value.
     */
                        const responseCallback = respMsg => {
                            const response = respMsg.getResponse();
                            if (response.responseCode === 200) {
                                if (mutableSessionProperty === MutableSessionProperty.CLIENT_DESCRIPTION) {
                                    // update property and notify client
                                    this._sessionProperties.applicationDescription = newValue;
                                    sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_OK, response.responseString, response.responseCode, 0, correlationKey, null);
                                    this.sendEvent(sessionEvent);
                                } else if (mutableSessionProperty === MutableSessionProperty.CLIENT_NAME) {
                                    // replace P2P subscription: REM and ADD
                                    const oldP2pTopicName = P2PUtil.getP2PTopicSubscription(this._sessionProperties.p2pInboxBase);
                                    const oldP2pTopic = Topic.createFromName(oldP2pTopicName);
                                    const newP2pTopicName = P2PUtil.getP2PTopicSubscription(respMsg.getP2PTopicValue());
                                    const newP2pTopic = Topic.createFromName(newP2pTopicName);
                                    const afterAddCallback = smpResp => {
                                        const resp = smpResp.getResponse();
                                        if (resp.responseCode === 200) {
                                            // notify client
                                            this._sessionProperties._setP2pInboxBase(respMsg.getP2PTopicValue() || "");
                                            this._sessionProperties._setP2pInboxInUse(P2PUtil.getP2PInboxTopic(this._sessionProperties.p2pInboxBase));
                                            this._sessionProperties.clientName = newValue;
                                            sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_OK, resp.responseString, resp.responseCode, 0, correlationKey, null);
                                            this.sendEvent(sessionEvent);
                                        } else {
                                            const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(resp.responseCode, resp.responseString);
                                            if (errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT && this._sessionProperties.ignoreDuplicateSubscriptionError) {
                                                // notify client
                                                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_OK, resp.responseString, resp.responseCode, 0, correlationKey, null);
                                                this.sendEvent(sessionEvent);
                                            } else if (errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT || errorSubcode === ErrorSubcode.SUBSCRIPTION_ATTRIBUTES_CONFLICT || errorSubcode === ErrorSubcode.SUBSCRIPTION_INVALID || errorSubcode === ErrorSubcode.SUBSCRIPTION_ACL_DENIED || errorSubcode === ErrorSubcode.SUBSCRIPTION_TOO_MANY) {
                                                // notify client
                                                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, resp.responseString, resp.responseCode, errorSubcode, correlationKey, null);
                                                this.sendEvent(sessionEvent);
                                            } else {
                                                // notify client
                                                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, resp.responseString, resp.responseCode, ErrorSubcode.SUBSCRIPTION_ERROR_OTHER, correlationKey, null);
                                                this.sendEvent(sessionEvent);
                                            }
                                        }
                                    };
                                    const afterRemoveCallback = smpResp => {
                                        const resp = smpResp.getResponse();
                                        if (resp.responseCode === 200) {
                                            // second add new P2P
                                            this._sessionFSM.subscriptionUpdate(newP2pTopic, true, // request confirm
                                            correlationKey, this._sessionProperties.readTimeoutInMsecs, SessionRequestType.ADD_P2PINBOX, afterAddCallback);
                                        } else {
                                            const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(resp.responseCode, resp.responseString);
                                            if (errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND && this._sessionProperties.ignoreSubscriptionNotFoundError) {
                                                // add new P2P anyway: the error is simply the old P2P
                                                // was not found on remove.  It's notable though.
                                                this._sessionFSM.subscriptionUpdate(newP2pTopic, true, // request confirm
                                                correlationKey, this._sessionProperties.readTimeoutInMsecs, SessionRequestType.ADD_P2PINBOX, afterAddCallback);
                                            } else if (errorSubcode === ErrorSubcode.SUBSCRIPTION_ATTRIBUTES_CONFLICT || errorSubcode === ErrorSubcode.SUBSCRIPTION_INVALID || errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND || errorSubcode === ErrorSubcode.SUBSCRIPTION_ACL_DENIED) {
                                                // notify client
                                                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, resp.responseString, resp.responseCode, errorSubcode, null, null);
                                                this.sendEvent(sessionEvent);
                                            } else {
                                                // notify client
                                                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, resp.responseString, resp.responseCode, ErrorSubcode.SUBSCRIPTION_ERROR_OTHER, null, null);
                                                this.sendEvent(sessionEvent);
                                            }
                                        }
                                    };
                                    // first remove old P2P
                                    this._sessionFSM.subscriptionUpdate(oldP2pTopic, true, // request confirm
                                    correlationKey, this._sessionProperties.readTimeoutInMsecs, SessionRequestType.REMOVE_P2PINBOX, afterRemoveCallback);
                                }
                            } else {
                                // notify client error
                                const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(response.responseCode, response.responseString);
                                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, response.responseString, response.responseCode, errorSubcode, correlationKey, null);
                                this.sendEvent(sessionEvent);
                            }
                        }; // end CB (response to UPDATE request)
                        const returnCode = this._sessionFSM.sendUpdateProperty(mutableSessionProperty, newValue, correlationKey, requestTimeout, responseCallback);
                        if (returnCode !== TransportReturnCode.OK) {
                            // do not change session state
                            if (returnCode === TransportReturnCode.NO_SPACE) {
                                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, "Property update failed - no space in transport", null, ErrorSubcode.INSUFFICIENT_SPACE, null, null);
                            } else {
                                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, "Property update failed", null, ErrorSubcode.INVALID_OPERATION, null, null);
                            }
                            this.sendEvent(sessionEvent);
                        }
                    }
                    /**
   * Modify (some) authentication-related session properties.
   * The modifications take effect the next time the session connects or reconnects to the broker.
   * There is no change to the active connection.
   * Calling this method does not in itself trigger any kind of reconnection, reauthentication or renegotiation.
   *
   * **Note:** the update of "accessToken" and "idToken" properties is currently supported.
   * Authentication Properties
   * - accessToken to update previously set access token required for OAUTH2 authentication.
   * - idToken to update previously set ID token required for OIDC authentication
   * Example: updateAuthenticationOnReconnect({accessToken : my_new_token});
   *
   *
   * @param {Object} authenticationProperties to be set
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the parameters have an invalid value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   * * if unsupported properties attempted to be set.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_CONFLICT}.
   */
                    updateAuthenticationOnReconnect(authenticationProperties) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        const allowedProperties = [ "accessToken", "idToken" ];
                        const result = this.allowOperation(SessionOperation.QUERY_OPERATION);
                        if (result) {
                            throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        }
                        if (!authenticationProperties || typeof authenticationProperties !== "object") {
                            throw new OperationError("updateAuthenticationOnReconnect parameter must be a non-empty object.", ErrorSubcode.PARAMETER_INVALID_TYPE, null);
                        }
                        var key;
                        for (key in authenticationProperties) {
                            if (!allowedProperties.includes(key)) {
                                throw new OperationError("Invalid property in updateAuthenticationOnReconnect parameter.", ErrorSubcode.PARAMETER_CONFLICT, null);
                            }
                        }
                        const newProps = this.getSessionProperties();
                        Object.assign(newProps, authenticationProperties);
                        SessionPropertiesValidator.validate(newProps);
                        this._sessionProperties = newProps;
                        Object.assign(this._sessionFSM._sessionProperties, authenticationProperties);
                        LOG_TRACE("updateAuthenticationOnReconnect applied new token(s).");
                    }
                    /**
   * Publish (send) a message over the session. The message is sent to its set destination.
   *
   * This method is used for sending both direct and Guaranteed Messages.  If the message's
   * {@link solace.MessageDeliveryModeType} is {@link solace.MessageDeliveryModeType.DIRECT}, the
   * message is a direct message; otherwise, it is a guaranteed message.
   *
   * @param {solace.Message} message The message to send. It must have a destination set.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the message does not have a topic.
   *   Subcode: {@link solace.ErrorSubcode.TOPIC_MISSING}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   * * if no Guaranteed Message Publisher is available and the message deliveryMode is
   *   {@link solace.MessageDeliveryModeType.PERSISTENT} or
   *   {@link solace.MessageDeliveryModeType.NON_PERSISTENT}.
   *   Subcode: {@link solace.ErrorSubcode.GM_UNAVAILABLE}.
   * * if the message deliveryMode is
   *   {@link solace.MessageDeliveryModeType.PERSISTENT} or
   *   {@link solace.MessageDeliveryModeType.NON_PERSISTENT},
   *   and the message payload size is above the broker's limit.
   *   Subcode: {@link solace.ErrorSubcode.MESSAGE_TOO_LARGE}.
   * 
   */
                    send(message) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Session send() called.");
                        const result = this.allowOperation(SessionOperation.SEND, message);
                        if (result) {
                            throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        }
                        Parameter.isInstanceOf("message", message, MessageLib.Message);
                        this.validateAndSendMessage(message);
                    }
                    /**
   * Sends a request using user-specified callback functions.
   * <br>
   * <strong>Note:</strong>
   * The API sets the correlationId and replyTo fields of the message being sent;
   * this overwrites any existing correlationId and replyTo values on the message.
   *
   * @param {solace.Message} message The request message to send.
   * @param {Number} [timeout] The timeout value (in milliseconds). The minimum value is 100 msecs.
   * @param {solace.Session.replyReceivedCallback} [replyReceivedCBFunction] The callback to notify
   *    when a reply is received.
   * @param {solace.Session.requestFailedCallback} [requestFailedCBFunction] The callback to notify
   *    when the request failed.
   * @param {Object} [userObject] An optional correlation object to use in the response callback.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the parameters have an invalid value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   * * if the message does not have a topic.
   *   Subcode: {@link solace.ErrorSubcode.TOPIC_MISSING}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   * * if no Guaranteed Message Publisher is available and the message deliveryMode is
   *   {@link solace.MessageDeliveryModeType.PERSISTENT} or
   *   {@link solace.MessageDeliveryModeType.NON_PERSISTENT}.
   *   Subcode: {@link solace.ErrorSubcode.GM_UNAVAILABLE}.
   * * if the message deliveryMode is
   *   {@link solace.MessageDeliveryModeType.PERSISTENT} or
   *   {@link solace.MessageDeliveryModeType.NON_PERSISTENT},
   *   and the message payload size is above the broker's limit.
   *   Subcode: {@link solace.ErrorSubcode.MESSAGE_TOO_LARGE}.
   */
                    sendRequest(message, timeout = undefined, replyReceivedCBFunction = undefined, requestFailedCBFunction = undefined, userObject = undefined) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Session sendRequest called.");
                        const result = this.allowOperation(SessionOperation.SEND, message);
                        if (result) {
                            throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        }
                        Parameter.isInstanceOf("message", message, MessageLib.Message);
                        Parameter.isNumberOrNothing("timeout", timeout);
                        Parameter.isRangeCompareOrNothing("timeout", timeout, ">=", 100);
                        Parameter.isFunctionOrNothing("replyReceivedCBFunction", replyReceivedCBFunction);
                        Parameter.isFunctionOrNothing("requestFailedCBFunction", requestFailedCBFunction);
                        // set correlationId and replyTo fields if not set by the application
                        const correlationId = message.getCorrelationId();
                        if (correlationId === null || correlationId === undefined) {
                            message.setCorrelationId(SOLCLIENT_REQUEST_PREFIX + GlobalContext.NextId());
                        }
                        const replyTo = message.getReplyTo();
                        if (replyTo === null || replyTo === undefined) {
                            const replyToTopic = DestinationLib.Topic.createFromName(this._sessionProperties.p2pInboxInUse);
                            message.setReplyTo(replyToTopic);
                        }
                        this.validateAndSendMessage(message);
                        // enqueue request
                        this.enqueueOutstandingDataReq(message.getCorrelationId(), requestFailedCBFunction, timeout, replyReceivedCBFunction, userObject);
                    }
                    /**
   * Sends a reply message to the destination specified in messageToReplyTo.
   *
   * If `messageToReplyTo` is non-null:
   *  * {@link solace.Message#getReplyTo} is copied from `messageToReplyTo` to
   *    {@link solace.Message#setDestination} on `replyMessage`, unless `replyTo` is null.
   *  * {@link solace.Message#setCorrelationId} is copied from `messageToReplyTo` to
   *    {@link solace.Message#setCorrelationId} on `replyMessage`, unless `correlationId` is null.
   *
   * If `messageToReplyTo` is null, the application is responsible for setting
   * the `destination` and `correlationId` on the `replyMessage`.
   *
   * @param {solace.Message} messageToReplyTo The message to which a reply will be sent.
   * @param {solace.Message} replyMessage The reply to send.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed or disconnected.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   * * if the parameters have an invalid value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   * * if the message does not have a topic.
   *   Subcode: {@link solace.ErrorSubcode.TOPIC_MISSING}.
   * * if there's no space in the transport to send the request.
   *   Subcode: {@link solace.ErrorSubcode.INSUFFICIENT_SPACE}.  See:
   *   {@link solace.SessionEventCode#event:CAN_ACCEPT_DATA}.
   * * if no Guaranteed Message Publisher is available and the message deliveryMode is
   *   {@link solace.MessageDeliveryModeType.PERSISTENT} or
   *   {@link solace.MessageDeliveryModeType.NON_PERSISTENT}.
   *   Subcode: {@link solace.ErrorSubcode.GM_UNAVAILABLE}.
   * * if the message deliveryMode is
   *   {@link solace.MessageDeliveryModeType.PERSISTENT} or
   *   {@link solace.MessageDeliveryModeType.NON_PERSISTENT},
   *   and the message payload size is above the broker's limit.
   *   Subcode: {@link solace.ErrorSubcode.MESSAGE_TOO_LARGE}.
   */
                    sendReply(messageToReplyTo, replyMessage) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Session sendReply called.");
                        const result = this.allowOperation(SessionOperation.SEND, replyMessage);
                        if (result) {
                            throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        }
                        Parameter.isInstanceOfOrNothing("messageToReplyTo", messageToReplyTo, MessageLib.Message);
                        Parameter.isInstanceOf("replyMessage", replyMessage, MessageLib.Message);
                        replyMessage.setAsReplyMessage(true);
                        if (messageToReplyTo) {
                            replyMessage.setCorrelationId(messageToReplyTo.getCorrelationId());
                            const replyTo = messageToReplyTo.getReplyTo();
                            if (replyTo === null || replyTo === undefined) {
                                throw new OperationError("ReplyTo destination may not be null.", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                            }
                            replyMessage.setDestination(messageToReplyTo.getReplyTo());
                        }
                        this.validateAndSendMessage(replyMessage);
                    }
                    /**
   * Returns the value of a given {@link solace.StatType}.
   *
   * @param {solace.StatType} statType The statistic to query.
   * @returns {Number} The value of the requested statistic.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the StatType is invalid.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_OUT_OF_RANGE}.
   */
                    getStat(statType) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Session getStat called.");
                        const result = this.allowOperation(SessionOperation.QUERY_OPERATION);
                        if (result) {
                            throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        }
                        Parameter.isEnumMember("statType", statType, StatType);
                        return this._sessionFSM.getStat(statType);
                    }
                    /**
   * Reset session statistics to initial values.
   *
   * @throws {solace.OperationError} if the session is disposed.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   */
                    resetStats() {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Session resetStats called.");
                        const result = this.allowOperation(SessionOperation.QUERY_OPERATION);
                        if (result) {
                            throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        }
                        this._sessionFSM.resetStats();
                    }
                    /**
   * Returns a clone of the properties for this session.
   *
   * @returns {solace.SessionProperties} A clone of this session's properties.
   * @throws {solace.OperationError} if the session is disposed.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   */
                    getSessionProperties() {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Session getSessionProperties called.");
                        const result = this.allowOperation(SessionOperation.QUERY_OPERATION);
                        if (result) {
                            throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        }
                        const properties = this._sessionProperties.clone();
                        const sessionState = this.getSessionState();
                        if (sessionState !== SessionStateName.DISCONNECTED && this._sessionFSM._transport) {
                            properties._setWebTransportProtocolInUse(this._sessionFSM._transport.getTransportProtocol());
                        }
                        return properties;
                    }
                    /**
   * Check the value of a boolean router capability.
   *
   * This function is a shortcut for {@link solace.Session#getCapability}. It performs the same
   * operation, but instead of returning a {@link solace.SDTField} wrapping a capability value, it
   * just returns the boolean value.
   *
   *  Attempting to query a non-boolean capability will return `null`.
   *
   * @param {solace.CapabilityType} capabilityType The capability to check.
   *
   * @returns {Boolean} the value of the capability queried.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type or value.
   *   Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   */
                    isCapable(capabilityType) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Session isCapable called.");
                        const result = this.allowOperation(SessionOperation.QUERY_OPERATION);
                        if (result) {
                            throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        }
                        Parameter.isNumber("capabilityType", capabilityType);
                        const caps = this._capabilities;
                        if (!caps) {
                            return false;
                        }
                        // Guard for undefined OR non-boolean capability
                        return typeof caps[capabilityType] === "boolean" ? caps[capabilityType] : false;
                    }
                    /**
   * Get the value of an router capability, or null if unknown. This function must
   * be called after connecting the session.
   *
   * SDT Type conversions:
   *
   *  * {string} values are returned as {@link solace.SDTFieldType.STRING}.
   *  * {boolean} values are returned as {@link solace.SDTFieldType.BOOL}.
   *  * All numeric values are returned as {@link solace.SDTFieldType.INT64}.
   *
   * @param {solace.CapabilityType} capabilityType The router capability to query.
   * @returns {solace.SDTField} The result of the capability query.
   *
   * @throws {solace.OperationError}
   * * if the session is disposed
   *    Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * * if the parameters have an invalid type or value.
   *    Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}.
   */
                    getCapability(capabilityType) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Session getCapability called.");
                        const result = this.allowOperation(SessionOperation.QUERY_OPERATION);
                        if (result) {
                            throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        }
                        Parameter.isNumber("capabilityType", capabilityType);
                        const val = this._getCapability(capabilityType);
                        if (typeof val === "boolean") {
                            return SDTField.create(SDTFieldType.BOOL, val);
                        }
                        if (typeof val === "number") {
                            return SDTField.create(SDTFieldType.INT64, val);
                        }
                        if (typeof val === "string") {
                            return SDTField.create(SDTFieldType.STRING, val);
                        }
                        return null;
                    }
                    _getCapability(capabilityType) {
                        const caps = this._capabilities;
                        if (!caps) return null;
                        const value = caps[capabilityType];
                        return value === undefined ? null : value;
                    }
                    /**
   * Returns the session's state. This is a third-choice method to determine session
   * state; the first is notifications on FSM transitions, and the second choice is
   * the finer-grained states of the FSM that are used in this mapping.
   *
   * @returns {SessionState} The current state of the session.
   * @throws {solace.OperationError} if the session is disposed.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}.
   * @internal
   */
                    getSessionState() {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Session getSessionState called.");
                        const result = this.allowOperation(SessionOperation.QUERY_OPERATION);
                        if (result) {
                            throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                        }
                        const sessionStateName = this.getFSMState();
                        switch (sessionStateName) {
                          case SessionStateName.FULLY_CONNECTED:
                            return SessionState.CONNECTED;

                          case SessionStateName.DISCONNECTING:
                            return SessionState.DISCONNECTING;

                          case SessionStateName.DISCONNECTED:
                            return SessionState.DISCONNECTED;

                          case SessionStateName.SESSION_ERROR:
                            return SessionState.SESSION_ERROR;

                          case SessionStateName.CONNECTING:
                          case SessionStateName.WAITING_FOR_INTERCONNECT_TIMEOUT:
                          case SessionStateName.WAITING_FOR_DNS:
                          case SessionStateName.WAITING_FOR_TRANSPORT_UP:
                          case SessionStateName.WAITING_FOR_SESSION_UP:
                          case SessionStateName.WAITING_FOR_LOGIN:
                          case SessionStateName.WAITING_FOR_P2PINBOX_REG:
                          case SessionStateName.WAITING_FOR_PUBFLOW:
                          case SessionStateName.REAPPLYING_SUBSCRIPTIONS:
                            return SessionState.CONNECTING;

                          default:
                            {
                                // State names unaccounted for --
                                // WAITING_FOR_SUBCONFIRM
                                // WAITING_FOR_CAN_ACCEPT_DATA
                                // DISCONNECTING_FLOWS
                                // FLUSHING_TRANSPORT
                                // DESTROYING_TRANSPORT
                                // RECONNECTING
                                // TRANSPORT_FAIL
                                //
                                // Alternatively, we could use StateMachine#isStateActive on key parent states,
                                // instead of having to enumerate all child states.ant
                                const {
                                    LOG_INFO
                                } = this.logger;
                                LOG_INFO(`Unmapped session state ${SessionStateName.describe(sessionStateName)}`);
                                return null;
                            }
                        }
                    }
                    /**
   * Gets the fine grained state name from the session FSM.
   * @returns {solace.SessionStateName} The FSM state name
   * @private
   */
                    getFSMState() {
                        return this._sessionFSM.getCurrentStateName();
                    }
                    /**
   * Creates a {@link solace.CacheSession} object that uses this Session to service its
   * cache requests.
   *
   * It should be disposed when the application no longer requires a CacheSession, by calling
   * {@link solace.CacheSession#dispose}.
   *
   * @param {solace.CacheSessionProperties} properties The properties for the cache session.
   *
   * @returns {solace.CacheSession} The newly created cache session.
   *
   * @throws {solace.OperationError} if a CacheSession is already associated with this Session.
   *   Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}
   */
                    createCacheSession(properties) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Session createCacheSession called.");
                        return new CacheSession(properties, this, {
                            // bind instead of arrow func for varargs
                            // due to bubl transpiler bug
                            incStat: this._sessionFSM.incStat.bind(this._sessionFSM)
                        });
                    }
                    /**
   * Creates a {@link solace.MessageConsumer} to receive Guaranteed Messages in this Session.
   *
   * Consumer characteristics and behavior are defined by properties. The consumer properties are
   * supplied as an object; the pertinent fields are exposed in
   * {@link solace.MessageConsumerProperties};
   * other property names are ignored. If the Message Consumer creation
   * specifies a non-durable endpoint,
   * {@link solace.QueueProperties} can be used to change the default properties on the
   * non-durable endpoint. Any values not supplied are set to default values.
   *
   * When the consumer is created, a consumer object is returned to the caller. This is the object
   * from which events are emitted, and upon which operations (for example, starting and stopping
   * the consumer) are performed.
   *
   * If this session does not support Guaranteed Messaging, this method will throw. The following
   * must be true in order to create a MessageConsumer:
   *  * The transport protocol list does not contain any HTTP transport protocols. See
   *    {@link solace.SessionProperties#transportProtocol} and
   *    {@link solace.FactoryProfile#cometEnabled}
   *  * The Solace Messaging Router must support Guaranteed Messaging
   *
   * @method solace.Session#createMessageConsumer
   * @param {solace.MessageConsumerProperties|Object} consumerProperties The properties for the
   *    consumer.
   * @returns {solace.MessageConsumer} The newly created Message Consumer.
   * @throws {solace.OperationError} when Guaranteed Message Consume is not
   *    supported on this session.
   * @target browser
   */
                    /**
   * Creates a {@link solace.MessageConsumer} to receive Guaranteed Messages in this Session.
   *
   * Consumer characteristics and behavior are defined by properties. The consumer properties are
   * supplied as an object; the pertinent fields are exposed in
   * {@link solace.MessageConsumerProperties};
   * other property names are ignored. If the Message Consumer creation
   * specifies a non-durable endpoint,
   * {@link solace.QueueProperties} can be used to change the default properties on the
   * non-durable endpoint. Any values not supplied are set to default values.
   *
   * When the consumer is created, a consumer object is returned to the caller. This is the object
   * from which events are emitted, and upon which operations (for example, starting and stopping
   * the consumer) are performed.
   *
   * If this session does not support Guaranteed Messaging, this method will throw. The Solace
   * Messaging Router must support Guaranteed Messaging.
   *
   * @method solace.Session#createMessageConsumer
   * @param {solace.MessageConsumerProperties|Object} consumerProperties The properties for the
   *    consumer.
   * @returns {solace.MessageConsumer} The newly created Message Consumer.
   * @throws {solace.OperationError} if Guaranteed Message Consume is not supported on this session.
   * @target node
   */
                    createMessageConsumer(consumerProperties) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Session createMessageConsumer called.");
                        if (this._adDisabledReason) {
                            throw new OperationError("Session does not provide MessageConsumer capability", ErrorSubcode.GM_UNAVAILABLE, this._adDisabledReason);
                        }
                        if (consumerProperties !== undefined && consumerProperties !== null) {
                            const {
                                LOG_DEBUG
                            } = this.logger;
                            LOG_DEBUG("createMessageConsumer - Consumer properties:\n", consumerProperties);
                        }
                        return this._sessionFSM.createMessageConsumer(consumerProperties);
                    }
                    /**
   * Creates a {@link solace.QueueBrowser} to browse Guaranteed Messages on a specified queue in
   * this Session.
   *
   * Browser characteristics and behavior are defined by properties. The browser properties are
   * supplied as an object; the pertinent fields are exposed in
   * {@link solace.QueueBrowserProperties};
   * other property names are ignored. Any values not supplied are set to default values.
   *
   * Delivery restrictions imposed by the queues Access type (exclusive or non-exclusive),
   * do not apply when browsing messages with a Browser.
   *
   * When the queue browser is created, a queue browser object is returned to the caller. This is
   * the object from which events are emitted, and upon which operations (for example, starting and
   * stopping the browser) are performed.
   *
   * If this session does not support Guaranteed Messaging, this method will throw. The following
   * must be true in order to create a QueueBrowser:
   *  * The transport protocol list does not contain any HTTP transport protocols. See
   *    {@link solace.SessionProperties#transportProtocol} and
   *    {@link solace.FactoryProfile#cometEnabled}
   *  * The Solace Messaging Router must support Guaranteed Messaging
   *
   * @method solace.Session#createQueueBrowser
   * @param {solace.QueueBrowserProperties|Object} browserProperties The properties for the
   *    browser.
   * @returns {solace.QueueBrowser} The newly created Queue Browser.
   * @throws {solace.OperationError} when Guaranteed Messaging is not
   *    supported on this session.
   * @target browser
   */
                    /**
   * Creates a {@link solace.QueueBrowser} to receive Guaranteed Messages in this Session.
   *
   * Browser characteristics and behavior are defined by properties. The properties are
   * supplied as an object; the pertinent fields are exposed in
   * {@link solace.QueueBrowserProperties};
   * other property names are ignored.
   *
   * Delivery restrictions imposed by the queues Access type (exclusive or non-exclusive),
   * do not apply when browsing messages with a Browser.
   *
   * When the browser is created, a browser object is returned to the caller. This is the object
   * from which events are emitted, and upon which operations (for example, starting and stopping
   * the browser) are performed.
   *
   * If this session does not support Guaranteed Messaging, this method will throw. The Solace
   * Messaging Router must support Guaranteed Messaging.
   *
   * @method solace.Session#createQueueBrowser
   * @param {solace.QueueBrowserProperties|Object} browserProperties The properties for the
   *    browser.
   * @returns {solace.QueueBrowser} The newly created Queue Browser.
   * @throws {solace.OperationError} if Guaranteed Messaging is not supported on this session.
   * @target node
   */
                    createQueueBrowser(browserProperties) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Session createQueueBrowser called.");
                        if (this._adDisabledReason) {
                            throw new OperationError("Session does not provide QueueBrowser capability", ErrorSubcode.GM_UNAVAILABLE, this._adDisabledReason);
                        }
                        if (browserProperties !== undefined && browserProperties !== null) {
                            const {
                                LOG_DEBUG
                            } = this.logger;
                            LOG_DEBUG("createQueueBrowser - Browser properties:\n", browserProperties);
                        }
                        return this._sessionFSM.createQueueBrowser(browserProperties);
                    }
                    /**
   * Creates a publishing destination from a queue descriptor.
   *
   * A MessageConsumer is the only object that has any business
   * doing this, but it should not be concerned with the internals
   * which depend on the session.
   *
   * @param {AbstractQueueDescriptor|QueueDescriptor} queueDescriptor The consumer's descriptor
   * @returns {Destination} A destination that publishes to the descriptor.
   * @memberof Session
   * @private
   */
                    createDestinationFromDescriptor(queueDescriptor) {
                        const {
                            DestinationType,
                            Queue,
                            Topic
                        } = DestinationLib;
                        let destinationType = DestinationType.TOPIC;
                        if (queueDescriptor.type === QueueType.QUEUE) {
                            destinationType = queueDescriptor.durable ? DestinationType.QUEUE : DestinationType.TEMPORARY_QUEUE;
                        }
                        const name = queueDescriptor.name || null;
                        if (queueDescriptor.durable) {
                            assert(name, "Durable endpoint with generated name is not a valid configuration");
                            const factoryMethod = queueDescriptor.getType() === QueueType.QUEUE ? Queue.createFromLocalName : Topic.createFromName;
                            return factoryMethod(name);
                        }
                        return this.createTemporaryDestination(destinationType, name);
                    }
                    /**
   * Creates a temporary destination.
   * @param {DestinationType} destinationType Type of destination
   * @param {String} [name] Name if any
   * @returns {Destination} Temporary destination
   * @private
   */
                    createTemporaryDestination(destinationType, name) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        const {
                            DestinationFromNetwork,
                            DestinationUtil
                        } = DestinationLib;
                        // TRANSPORT_UP is chosen because this is when the session tells subscribers
                        // that they may begin connecting
                        const vrn = this.getSessionProperties().virtualRouterName;
                        if (!this.isCapable(CapabilityType.TEMPORARY_ENDPOINT) || vrn === null || vrn === undefined || vrn.length === 0) {
                            throw new OperationError("Attempt to generate temporary destination or endpoint without suitable session", ErrorSubcode.INVALID_OPERATION);
                        }
                        // Non-durable case; avoid re-prefixing
                        const localName = name && name.startsWith("#P2P") ? name : DestinationUtil.createTemporaryName(destinationType, vrn, name);
                        LOG_TRACE("Generated name:", localName);
                        return DestinationFromNetwork.createDestinationFromName(localName);
                    }
                    /**
   * @param {solace.SessionEvent} sessionEvent The event to send
   * @private
   */
                    sendEvent(sessionEvent) {
                        if (!sessionEvent) return;
                        if (this._disposed) return;
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE(`Sending event ${sessionEvent}`);
                        this._eventCallbackInfo.sessionEventCBFunction(this, sessionEvent, this._eventCallbackInfo.userObject);
                    }
                    /**
   * Gets a transport session information string.
   * This string is informative only, and applications should not attempt to parse it.
   *
   * @returns {String} A description of the current session's transport.
   */
                    getTransportInfo() {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE("Session getTransportInfo called.");
                        return this._sessionFSM.getTransportInfo();
                    }
                    /**
   * @param {Object} interceptor The transport interceptor to set
   * @private
   */
                    injectTransportInterceptor(interceptor) {
                        this._sessionFSM.injectTransportInterceptor(interceptor);
                    }
                    /**
   * @param {solace.SessionOperation} operationEnum the id of the operation
   * @param {solace.Message} message The message to send
   * @returns {?String} error message if not allowed; otherwise null
   * @private
   */
                    allowOperation(operationEnum, message) {
                        if (!this._sessionFSM) return false;
                        let allow = true;
                        const sessionStateName = this._sessionFSM.getCurrentStateName();
                        if (sessionStateName === SessionStateName.DISPOSED) {
                            allow = false;
                        } else if (Check.anything(operationEnum)) {
                            switch (operationEnum) {
                              case SessionOperation.CONNECT:
                                if (sessionStateName !== SessionStateName.NEW && sessionStateName !== SessionStateName.DISCONNECTED) {
                                    allow = false;
                                }
                                break;

                              case SessionOperation.DISCONNECT:
                                if (sessionStateName === SessionStateName.NEW) {
                                    allow = false;
                                }
                                break;

                              case SessionOperation.SEND:
                              case SessionOperation.CTRL:
                                allow = sessionStateName === SessionStateName.FULLY_CONNECTED || message && message.getDeliveryMode() !== MessageLib.MessageDeliveryModeType.DIRECT;
                                break;

                              case SessionOperation.QUERY_OPERATION:
                                allow = true;
                                break;

                              default:
                                allow = false;
                            }
                        } else {
                            allow = false;
                        }
                        if (allow) {
                            return null;
                        }
                        return `Cannot perform operation ${operationEnum} while in state ${sessionStateName}`;
                    }
                    /**
   * @param {smf.ClientCtrlMessage} routerCapabilities The message containing the router caps
   * @private
   */
                    updateCapabilities(routerCapabilities) {
                        this._capabilities = routerCapabilities;
                    }
                    /**
   * @param {solace.Message} message The message to send
   * @private
   */
                    validateAndSendMessage(message) {
                        // Sanity checks on the message before attempting to send it
                        //  * do we have a destination?
                        const sendDest = message.getDestination();
                        if (Check.nothing(sendDest) || Check.empty(sendDest.getName())) {
                            throw new OperationError("Message must have a valid Destination", ErrorSubcode.TOPIC_MISSING);
                        }
                        const senderTimestamp = message.getSenderTimestamp();
                        const noSenderTimestamp = senderTimestamp === null || senderTimestamp === undefined;
                        if (this._sessionProperties.generateSendTimestamps && (noSenderTimestamp || message.hasAutoSenderTimestamp)) {
                            const now = new Date();
                            message.setSenderTimestamp(now.getTime());
                            message.hasAutoSenderTimestamp = true;
                        }
                        const sequenceNumber = message.getSequenceNumber();
                        const noSequenceNumber = sequenceNumber === null || sequenceNumber === undefined;
                        if (this._sessionProperties.generateSequenceNumber && (noSequenceNumber || message.hasAutoSequenceNumber)) {
                            message.setSequenceNumber(this._seqNum++);
                            message.hasAutoSequenceNumber = true;
                        }
                        const senderId = message.getSenderId();
                        const noSenderId = senderId === null || senderId === undefined;
                        if (this._sessionProperties.includeSenderId && noSenderId) {
                            message.setSenderId(this._sessionProperties.clientName);
                        }
                        // Allow the FSM and its delegates to prepare and send the message
                        // This may mutate the delegates, so we need to validate first
                        // this may throw if the message is guaranteed and the window is closed.
                        // If this returns true, the message can be sent to the transport
                        // (always true for direct messages whne there is a transport). If
                        // this returns false, the message has been prepared and queued for
                        // transport but may not be sent now.
                        this._sessionFSM.prepareAndSendMessage(message);
                    }
                    /**
   * @param {String} correlationId The internal correlation ID for the message
   * @param {function(...[*])} reqFailedCb The callback on request failure
   * @param {Number} reqTimeout The request timeout in ms
   * @param {function(*)} replyRecvdCb The callback on reply received
   * @param {Object} userObject A user object to pass back to the callback (legacy)
   * @private
   */
                    enqueueOutstandingDataReq(correlationId, reqFailedCb, reqTimeout, replyRecvdCb, userObject) {
                        if (Check.none(correlationId)) {
                            return;
                        }
                        const {
                            LOG_TRACE,
                            LOG_ERROR
                        } = this.logger;
                        // empty string is valid
                        LOG_TRACE(`Enqueue outstanding data request correlationId=${correlationId}`);
                        const timer = setTimeout(() => {
                            this._sessionFSM.incStat(StatType.TX_REQUEST_TIMEOUT);
                            // remove request from queue
                            try {
                                const result = delete this._outstandingDataReqs[correlationId];
                                if (!result) {
                                    LOG_ERROR(`Cannot delete data request ${correlationId}`);
                                }
                            } catch (e) {
                                LOG_ERROR(`Cannot delete data request ${correlationId}`, e);
                            }
                            if (Check.anything(reqFailedCb)) {
                                const requestEvent = SessionEvent.build(RequestEventCode.REQUEST_TIMEOUT, "Request timeout", correlationId);
                                reqFailedCb(this, requestEvent, userObject);
                            }
                        }, reqTimeout || this._sessionProperties.readTimeoutInMsecs);
                        const outstandingReq = new OutstandingDataRequest(correlationId, timer, replyRecvdCb, reqFailedCb, userObject);
                        this._outstandingDataReqs[correlationId] = outstandingReq;
                    }
                    /**
   * @param {String} correlationId The internal ID of the request to cancel
   * @returns {OutstandingDataRequest} The request that was cancelled, if any
   * @private
   */
                    cancelOutstandingDataReq(correlationId) {
                        const {
                            LOG_TRACE,
                            LOG_ERROR
                        } = this.logger;
                        if (Check.none(correlationId) || !this._outstandingDataReqs) {
                            return null;
                        }
                        const req = this._outstandingDataReqs[correlationId];
                        if (req === undefined || req === null) {
                            return null;
                        }
                        LOG_TRACE(`Cancel outstanding data request correlationId=${correlationId}`);
                        if (req.timer) {
                            clearTimeout(req.timer);
                            req.timer = null;
                        }
                        try {
                            const result = delete this._outstandingDataReqs[correlationId];
                            if (!result) {
                                LOG_ERROR(`Cannot delete data request ${correlationId}`);
                            }
                        } catch (e) {
                            LOG_ERROR(`Cannot delete data request ${correlationId}`, e);
                        }
                        return req;
                    }
                    /**
   * @private
   */
                    cleanupSession() {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        if (this._outstandingDataReqs) {
                            LOG_TRACE("Cancel all outstanding data requests");
                            Object.keys(this._outstandingDataReqs).forEach(key => {
                                const dataReq = this.cancelOutstandingDataReq(key);
                                if (dataReq && dataReq.reqFailedCBFunction) {
                                    const requestEvent = SessionEvent.build(RequestEventCode.REQUEST_ABORTED, "Request aborted", key);
                                    dataReq.reqFailedCBFunction(this, requestEvent, dataReq.userObject);
                                }
                            });
                        }
                    }
                    /**
   * @param {Message} dataMessageIn The received direct TRmsg
   * @private
   */
                    handleDataMessage(dataMessageIn) {
                        const {
                            LOG_TRACE,
                            LOG_INFO
                        } = this.logger;
                        const dataMessage = dataMessageIn;
                        if (this._sessionProperties.generateReceiveTimestamps) {
                            const now = new Date();
                            dataMessage._receiverTimestamp = now.getTime();
                        }
                        if (dataMessage.isReplyMessage()) {
                            const correlationId = dataMessage.getCorrelationId();
                            if (Check.anything(correlationId)) {
                                const dataReq = this.cancelOutstandingDataReq(correlationId);
                                if (dataReq !== null) {
                                    this._sessionFSM.incStat(StatType.RX_REPLY_MSG_RECVED);
                                    LOG_TRACE("Calling application replyReceivedCallback");
                                    dataReq.replyReceivedCBFunction(this, dataMessage, dataReq.userObject);
                                    LOG_TRACE("application replyReceivedCallback returns");
                                    return;
                                }
                                if (correlationId.startsWith(SOLCLIENT_REQUEST_PREFIX)) {
                                    // if a reply message doesn't have outstanding request and correlationId
                                    // starts with #REQ it is assumed to be a delayed reply and has to be discarded
                                    LOG_INFO("DROP: Discard reply message due to missing outstanding request");
                                    this._sessionFSM.incStat(StatType.RX_REPLY_MSG_DISCARD);
                                    return;
                                }
                                if (correlationId.startsWith(CACHE_REQUEST_PREFIX) && !(CacheSession && this._messageCallbackInfo.userObject instanceof CacheSession)) {
                                    // If it's a cache message, only pass it along if the listener is a cache message
                                    // listener. The listener may drop it and increment the DISCARD stat if no
                                    // cache session recognizes the reply.
                                    LOG_INFO("DROP: Discard cache reply due to no cache session active");
                                    this._sessionFSM.incStat(StatType.RX_REPLY_MSG_DISCARD);
                                    return;
                                }
                            }
                        }
                        // notify client message callback
                        LOG_TRACE("Calling application messageCallback");
                        this._messageCallbackInfo.messageRxCBFunction(this, dataMessage, this._messageCallbackInfo.userObject);
                        LOG_TRACE("application messageCallback returns");
                    }
                    /**
   * Callback function for subscribe/unsubscribe response
   * @param {solace.SMPMessage} smpMsg The SMP response to the subscription request
   * @param {CorrelatedRequest} request The originating request object
   * @param {Boolean} requestConfirm Whether the user asked for confirmation on the request
   * @private
   */
                    handleSubscriptionUpdateResponse(smpMsg, request, requestConfirm) {
                        const response = smpMsg.getResponse();
                        const {
                            responseCode,
                            responseString
                        } = response;
                        const {
                            correlationKey
                        } = request;
                        // If we don't request confirmation, the router doesn't send one for the OK case,
                        // so we don't need to guard for that.
                        // The router always replies on SUBSCRIPTION_ERROR, so we track whether confirmation
                        // was requested and suppress the reply in certain cases.
                        if (responseCode === 200) {
                            // notify client
                            const sessionEvent = SessionEvent.build(SessionEventCode.SUBSCRIPTION_OK, responseString, responseCode, 0, correlationKey, null);
                            this.sendEvent(sessionEvent);
                        } else {
                            const subscriptionStr = StringUtils.stripNullTerminate(smpMsg.encodedUtf8Subscription);
                            this._sessionFSM.handleSubscriptionUpdateError(responseCode, responseString, subscriptionStr, correlationKey, requestConfirm);
                        }
                    }
                    /**
   * Callback function for queue subscribe/unsubscribe response
   * @param {solace.SMPMessage} smpMsg The SMP response to the subscription request
   * @param {CorrelatedRequest} request The originating request object
   * @param {function} callback The callback on response
   * @private
   */
                    handleQueueSubscriptionUpdateResponse(smpMsg, request, callback) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        if (!smpMsg) {
                            // reuest timed out.
                            LOG_TRACE("handleQueueSubscriptionUpdateResponse called on timeout.");
                            callback(false, ErrorSubcode.TIMEOUT, 0, "Timeout");
                            return;
                        }
                        const response = smpMsg.getResponse();
                        const {
                            responseCode,
                            responseString
                        } = response;
                        const errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode, responseString);
                        LOG_TRACE("handleQueueSubscriptionUpdateResponse called.", smpMsg);
                        if (responseCode === 200 || errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT || errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND) {
                            callback(true, 0, responseCode, responseString);
                        } else {
                            callback(false, errorSubcode, responseCode, responseString);
                        }
                    }
                    /**
   * Callback function for DTE unsubscribe response
   *
   * @param {solace.AdMessage} adCtrlMessage The Guaranteed Message Protocol
   *                           control response to the DTE unsub message
   * @param {CorrelatedRequest} request The originating request object
   * @private
   */
                    handleDTEUnsubscribeResponse(adCtrlMessage, request) {
                        const response = adCtrlMessage.getResponse();
                        const {
                            responseCode,
                            responseString
                        } = response;
                        const {
                            correlationKey
                        } = request;
                        const eventCode = responseCode === 200 ? SessionEventCode.UNSUBSCRIBE_TE_TOPIC_OK : SessionEventCode.UNSUBSCRIBE_TE_TOPIC_ERROR;
                        const subcode = responseCode === 200 ? 0 : ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode, responseString);
                        this.sendEvent(SessionEvent.build(eventCode, responseString, responseCode, subcode, correlationKey));
                    }
                    /**
   * @param {Number} respCode The returned response code
   * @param {String} respText The returned response text
   * @param {String} subscriptionStr The requested topic name
   * @param {*} correlationKey The user-supplied correlation key
   * @param {Boolean} requestConfirm Whether confirmation was requested on subscription
   * @private
   */
                    handleSubscriptionUpdateError(respCode, respText, subscriptionStr, correlationKey, requestConfirm) {
                        const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
                        if (errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT && this._sessionProperties.ignoreDuplicateSubscriptionError || errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND && this._sessionProperties.ignoreSubscriptionNotFoundError) {
                            if (requestConfirm) {
                                // notify client
                                const sessionEvent = SessionEvent.build(SessionEventCode.SUBSCRIPTION_OK, respText, respCode, 0, correlationKey, null);
                                this.sendEvent(sessionEvent);
                            }
                        } else {
                            // notify client
                            const sessionEvent = SessionEvent.build(SessionEventCode.SUBSCRIPTION_ERROR, respText, respCode, errorSubcode, correlationKey, `Topic: ${subscriptionStr}`);
                            this.sendEvent(sessionEvent);
                        }
                    }
                    /**
   * @returns {SessionEventCBInfo} The session's event callback
   * @private
   */
                    getEventCBInfo() {
                        return this._eventCallbackInfo;
                    }
                    /**
   * @param {SessionEventCBInfo} eventCBInfo The new event callback to set
   * @private
   */
                    setEventCBInfo(eventCBInfo) {
                        this._eventCallbackInfo = eventCBInfo;
                    }
                    /**
   * @returns {MessageRxCBInfo} The session's message callback
   * @private
   */
                    getMessageCBInfo() {
                        return this._messageCallbackInfo;
                    }
                    /**
   * @param {MessageRxCBInfo} messageCBInfo The new message callback to set
   * @private
   */
                    setMessageCBInfo(messageCBInfo) {
                        this._messageCallbackInfo = messageCBInfo;
                    }
                    /**
   * @returns {String} The next correlation tag for this session.
   * @private
   */
                    getCorrelationTag() {
                        return this._sessionFSM.getCorrelationTag();
                    }
                    /**
   * Wraps a SessionEventCBInfo or a bare function with an event emitting function.
   * @param {SessionEventCBInfo|function|undefined} eventCallback The callback to wrap
   * @returns {SessionEventCBInfo} A SessionEventCBInfo object that handles all callbacks.
   * @private
   */
                    wrapEventCallback(eventCallback) {
                        const {
                            LOG_WARN
                        } = this.logger;
                        const eventCallbackInfo = (() => {
                            if (!eventCallback) return null;
                            if (eventCallback.sessionEventCBFunction) return eventCallback;
                            return new SessionEventCBInfo(eventCallback);
                        })();
                        return new SessionEventCBInfo((session, sessionEvent, obj, rfu) => {
                            const {
                                sessionEventCode
                            } = sessionEvent;
                            if (eventCallbackInfo) {
                                try {
                                    eventCallbackInfo.sessionEventCBFunction(session, sessionEvent, obj, rfu);
                                } catch (ex) {
                                    const error = Object.assign(new OperationError(`Unhandled error in SessionEventRxCBInfo callback on sessionEventCode ${SessionEventCode.describe(sessionEventCode)}`, ErrorSubcode.CALLBACK_ERROR, `On event: ${[ sessionEventCode, sessionEvent, obj, rfu ]} ${ex}`), {
                                        stack: ex.stack,
                                        info: {
                                            event: {
                                                name: sessionEventCode,
                                                formattedName: `SessionEventCode.${SessionEventCode.describe(sessionEventCode)}`,
                                                args: [ sessionEvent, obj, rfu ]
                                            },
                                            error: ex
                                        }
                                    });
                                    LOG_WARN(error.toString(), error.info);
                                }
                            }
                            this.emit(sessionEventCode, sessionEvent);
                        });
                    }
                    /**
   * Wraps a CBInfo or a bare function with an event emitting function.
   * @param {MessageCBInfo|function|undefined} messageCallback The callback to wrap
   * @returns {MessageCBInfo} A MessageCBInfo object that handles all callbacks.
   * @private
   */
                    wrapMessageCallback(messageCallback) {
                        const {
                            LOG_WARN
                        } = this.logger;
                        const messageCallbackInfo = (() => {
                            if (!messageCallback) return null;
                            if (messageCallback.messageRxCBFunction) return messageCallback;
                            return new MessageRxCBInfo(messageCallback);
                        })();
                        const formattedName = `SessionEventCode.${SessionEventCode.describe(SessionEventCode.MESSAGE)}`;
                        const buildErrorEvent = (ex, message, object) => Object.assign(new OperationError(`Unhandled error in MessageRxCBInfo callback/handler for ${formattedName}`, ErrorSubcode.CALLBACK_ERROR), {
                            stack: ex.stack,
                            info: {
                                event: {
                                    name: SessionEventCode.MESSAGE,
                                    formattedName: formattedName,
                                    args: [ message, object ]
                                },
                                error: ex
                            }
                        });
                        return new MessageRxCBInfo((session, message, object) => {
                            if (messageCallbackInfo) {
                                try {
                                    messageCallbackInfo.messageRxCBFunction(session, message, object);
                                } catch (ex) {
                                    const error = buildErrorEvent(ex, message, object).toString();
                                    LOG_WARN(error, error.info, ex);
                                }
                            }
                            try {
                                this.emitDirect(message);
                            } catch (ex) {
                                this.emit("error", buildErrorEvent(ex, message, object));
                            }
                        });
                    }
                    /**
   * @readonly
   * @private
   */
                    get adLocallyDisabled() {
                        return !!this._adDisabledReason;
                    }
                    /**
   * @readonly
   * @private
   */
                    get canConnectConsumer() {
                        if (this.adLocallyDisabled) return false;
                        if (this._capabilities) {
                            return this.isCapable(CapabilityType.GUARANTEED_MESSAGE_CONSUME);
                        }
                        return undefined;
                    }
                    /**
   * @readonly
   * @private
   */
                    get canConnectPublisher() {
                        if (this.adLocallyDisabled) return false;
                        if (this._capabilities) {
                            return this.isCapable(CapabilityType.GUARANTEED_MESSAGE_PUBLISH);
                        }
                        return undefined;
                    }
                    /**
   * @readonly
   * @private
   */
                    get disposed() {
                        return this._disposed;
                    }
                    ["inspect"]() {
                        return {
                            sessionId: this._sessionFSM && this._sessionFSM.sessionIdHex || "(N/A)",
                            transport: this.getTransportInfo(),
                            state: SessionState.describe(this.getSessionState())
                        };
                    }
                    toString() {
                        return util_inspect(this);
                    }
                }
                module.exports.Session = Session;
                /***/
            },
            /***/ "./modules/solclient-session/lib/ssl-downgrades.js": 
            /*!*********************************************************!*\
  !*** ./modules/solclient-session/lib/ssl-downgrades.js ***!
  \*********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Effectively a boolean governing TLS downgrade to plain text after authentication.
 * @see {@link solace.SessionProperties#sslConnectionDowngradeTo}
 *
 * @target node
 * @readonly
 * @enum {String}
 * @memberof solace
 * @namespace
 */
                const SslDowngrade = {
                    /**
   * @description No downgrade, TLS connection remains encrypted.
   * @type {String}
   */
                    NONE: "NONE",
                    /**
   * @description TLS connection downgrades to plain text after authentication.
   * USE WITH CAUTION! Message traffic is not encrypted!
   */
                    PLAINTEXT: "PLAIN_TEXT"
                };
                module.exports.SslDowngrade = Enum.new(SslDowngrade);
                /***/
            },
            /***/ "./modules/solclient-session/lib/subscription-update-timeout-messages.js": 
            /*!*******************************************************************************!*\
  !*** ./modules/solclient-session/lib/subscription-update-timeout-messages.js ***!
  \*******************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    SessionRequestType
                } = __webpack_require__(/*! ./session-request-types */ "./modules/solclient-session/lib/session-request-types.js");
                module.exports = {
                    SubscriptionUpdateTimeoutMessages: {
                        [SessionRequestType.ADD_SUBSCRIPTION]: "Add subscription request timeout",
                        [SessionRequestType.REMOVE_SUBSCRIPTION]: "Remove subscription request timeout",
                        [SessionRequestType.ADD_P2PINBOX]: "Add P2P inbox subscription timeout",
                        [SessionRequestType.REMOVE_P2PINBOX]: "Remove P2P inbox subscription timeout",
                        [SessionRequestType.REMOVE_DTE_SUBSCRIPTION]: "Remove endpoint topic subscription",
                        default: "Request timeout"
                    }
                };
                /***/
            },
            /***/ "./modules/solclient-smf/api.js": 
            /*!**************************************!*\
  !*** ./modules/solclient-smf/api.js ***!
  \**************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const CodecLib = __webpack_require__(/*! ./lib/codec */ "./modules/solclient-smf/lib/codec/api.js");
                const {
                    AdProtocolMessage,
                    BinaryMetaBlock,
                    ClientCtrlMessage,
                    KeepAliveMessage,
                    SMPMessage
                } = __webpack_require__(/*! ./lib/message-objects */ "./modules/solclient-smf/lib/message-objects/api.js");
                const {
                    SMFAdProtocolMessageType
                } = __webpack_require__(/*! ./lib/smf-adprotocol-message-types */ "./modules/solclient-smf/lib/smf-adprotocol-message-types.js");
                const {
                    SMFAdProtocolParam
                } = __webpack_require__(/*! ./lib/smf-adprotocol-params */ "./modules/solclient-smf/lib/smf-adprotocol-params.js");
                const {
                    SMFClientCtrlMessageType
                } = __webpack_require__(/*! ./lib/smf-client-ctrl-message-types */ "./modules/solclient-smf/lib/smf-client-ctrl-message-types.js");
                const {
                    SMFClientCtrlParam
                } = __webpack_require__(/*! ./lib/smf-client-ctrl-params */ "./modules/solclient-smf/lib/smf-client-ctrl-params.js");
                const {
                    SMFParameterType,
                    SMFExtendedParameterType
                } = __webpack_require__(/*! ./lib/smf-parameter-types */ "./modules/solclient-smf/lib/smf-parameter-types.js");
                const {
                    SMFProtocol
                } = __webpack_require__(/*! ./lib/smf-protocols */ "./modules/solclient-smf/lib/smf-protocols.js");
                const {
                    SMFSMPMessageType
                } = __webpack_require__(/*! ./lib/smf-smp-message-types */ "./modules/solclient-smf/lib/smf-smp-message-types.js");
                const {
                    SMFSMPMessageTypeFlags
                } = __webpack_require__(/*! ./lib/smf-smp-message-type-flags */ "./modules/solclient-smf/lib/smf-smp-message-type-flags.js");
                const {
                    SMFTransportSessionMessageType
                } = __webpack_require__(/*! ./lib/smf-transport-session-message-types */ "./modules/solclient-smf/lib/smf-transport-session-message-types.js");
                module.exports.AdProtocolMessage = AdProtocolMessage;
                module.exports.BinaryMetaBlock = BinaryMetaBlock;
                module.exports.ClientCtrlMessage = ClientCtrlMessage;
                module.exports.Codec = CodecLib;
                module.exports.KeepAliveMessage = KeepAliveMessage;
                module.exports.SMFAdProtocolMessageType = SMFAdProtocolMessageType;
                module.exports.SMFAdProtocolParam = SMFAdProtocolParam;
                module.exports.SMFClientCtrlMessageType = SMFClientCtrlMessageType;
                module.exports.SMFClientCtrlParam = SMFClientCtrlParam;
                module.exports.SMFParameterType = SMFParameterType;
                module.exports.SMFProtocol = SMFProtocol;
                module.exports.SMFSMPMessageTypeFlags = SMFSMPMessageTypeFlags;
                module.exports.SMFSMPMessageType = SMFSMPMessageType;
                module.exports.SMFTransportSessionMessageType = SMFTransportSessionMessageType;
                module.exports.SMPMessage = SMPMessage;
                module.exports.SMFExtendedParameterType = SMFExtendedParameterType;
                /***/
            },
            /***/ "./modules/solclient-smf/lib/codec/adprotocol.js": 
            /*!*******************************************************!*\
  !*** ./modules/solclient-smf/lib/codec/adprotocol.js ***!
  \*******************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const SMFLib = __webpack_require__(/*! solclient-smf */ "./modules/solclient-smf/api.js");
                const {
                    AdProtocolMessage,
                    SMFParameter
                } = __webpack_require__(/*! ../message-objects */ "./modules/solclient-smf/lib/message-objects/api.js");
                const {
                    Bits,
                    Convert
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    LOG_DEBUG,
                    LOG_INFO,
                    LOG_ERROR
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    ReplayStartType
                } = __webpack_require__(/*! solclient-replaystart */ "./modules/solclient-replaystart/api.js");
                // const { SMFAdProtocolParam } = require('solclient-smf');
                const {
                    get: bits,
                    set: setBits
                } = Bits;
                const {
                    int8ToStr,
                    int16ToStr,
                    int24ToStr,
                    int32ToStr
                } = Convert;
                function parseAdpAt(dataBuf, offset) {
                    if (offset + 3 > dataBuf.length) {
                        //not enough data
                        LOG_DEBUG("Not enough data to read an ADP message.");
                        return false;
                    }
                    let pos = offset;
                    let onebyte = dataBuf.readUInt8(pos);
                    pos++;
                    // var msgRFU = bits(onebyte, 6, 2);
                    const adpVersion = bits(onebyte, 0, 6);
                    let msgLength;
                    let msgType;
                    if (adpVersion < 3) {
                        const twobyte = dataBuf.readUInt16BE(pos);
                        pos += 2;
                        msgType = bits(twobyte, 12, 4);
                        // length in 32 bit words is in the lower 12 bits
                        msgLength = bits(twobyte, 0, 12);
                        // convert length to number of bytes
                        msgLength <<= 2;
                    } else if (adpVersion === 3) {
                        onebyte = dataBuf.readUInt8(pos);
                        pos++;
                        msgType = bits(onebyte, 0, 8);
                        msgLength = dataBuf.readUInt32BE(pos);
                        pos += 4;
                    } else {
                        LOG_ERROR("Found unsupported ADP Version", adpVersion);
                        return false; //unsupported type
                    }
                    //
                    // Verify that the ADP header length does not exceed the entire
                    // contents of the SMF message.
                    if (offset + msgLength > dataBuf.length) {
                        LOG_ERROR(`Invalid Asssured Control Protocol length=${msgLength} exceeds remaining message buffer = ${dataBuf.length - offset}`);
                        return false; // invalid message format
                    }
                    const adpMsg = new AdProtocolMessage(msgType, adpVersion);
                    while (pos < offset + msgLength) {
                        onebyte = dataBuf.readUInt8(pos);
                        pos++;
                        const paramUH = bits(onebyte, 6, 2);
                        const paramType = bits(onebyte, 0, 6);
                        // Look for and skip padding bytes
                        if (paramType === 0) {
                            continue;
                        }
                        if (pos >= offset + msgLength) {
                            LOG_ERROR(`Invalid Asssured Control Protocol parameter=${paramType} at position =${pos}`);
                            return false; // Assured Control parsing fail
                        }
                        let paramLen = dataBuf.readUInt8(pos);
                        let paramValueLen;
                        pos++;
                        // If paramLen == 0, then this is an extended length format
                        // and there is a 4 byte length following the '0'
                        if (paramLen === 0) {
                            // need at least 5 more bytes in the buffer
                            if (pos + 5 > offset + msgLength) {
                                LOG_ERROR(`Invalid Asssured Control Protocol parameter=${paramType} at position =${pos}`);
                                return false; // Assured Control parsing fail
                            }
                            paramLen = dataBuf.readUInt32BE(pos);
                            pos += 4;
                            paramValueLen = paramLen - 5;
                        } else {
                            paramValueLen = paramLen - 2;
                        }
                        if (paramLen <= 0) {
                            return false; // Assured Control parsing fail
                        }
                        //
                        // make sure there is enough buffer for paramValueLen
                        if (pos + paramValueLen > offset + msgLength) {
                            LOG_ERROR(`Invalid Asssured Control Protocol parameter=${paramType} length =${paramValueLen} invalid at position =${pos}`);
                            return false; // Assured Control parsing fail
                        }
                        const smfParam = new SMFParameter(paramUH, paramType, null, dataBuf, pos, pos + paramValueLen);
                        adpMsg.addParameter(smfParam);
                        pos += paramValueLen;
                    }
                    return adpMsg;
                }
                function encAdp0Param(uh, paramtype) {
                    const data = [];
                    let byte1 = 0;
                    byte1 = Bits.set(byte1, uh, 6, 2);
                    byte1 = Bits.set(byte1, paramtype, 0, 6);
                    data.push(Convert.int8ToStr(byte1));
                    data.push(Convert.int8ToStr(2)); // length
                    return data.join("");
                }
                function encAdp8Param(uh, paramtype, value) {
                    const data = [];
                    let byte1 = 0;
                    byte1 = Bits.set(byte1, uh, 6, 2);
                    byte1 = Bits.set(byte1, paramtype, 0, 6);
                    data.push(Convert.int8ToStr(byte1));
                    data.push(Convert.int8ToStr(3)); // length
                    data.push(Convert.int8ToStr(value));
                    return data.join("");
                }
                function encAdp16Param(uh, paramtype, value) {
                    const data = [];
                    let byte1 = 0;
                    byte1 = Bits.set(byte1, uh, 6, 2);
                    byte1 = Bits.set(byte1, paramtype, 0, 6);
                    data.push(Convert.int8ToStr(byte1));
                    data.push(Convert.int8ToStr(4)); // length
                    data.push(Convert.int16ToStr(value));
                    return data.join("");
                }
                function encAdp32Param(uh, paramtype, value) {
                    const data = [];
                    let byte1 = 0;
                    byte1 = Bits.set(byte1, uh, 6, 2);
                    byte1 = Bits.set(byte1, paramtype, 0, 6);
                    data.push(Convert.int8ToStr(byte1));
                    data.push(Convert.int8ToStr(6)); // length
                    data.push(Convert.int32ToStr(value));
                    return data.join("");
                }
                function encAdp64Param(uh, paramtype, value) {
                    const data = [];
                    let byte1 = 0;
                    byte1 = Bits.set(byte1, uh, 6, 2);
                    byte1 = Bits.set(byte1, paramtype, 0, 6);
                    data.push(Convert.int8ToStr(byte1));
                    data.push(Convert.int8ToStr(10)); // length
                    data.push(Convert.int64ToStr(value));
                    return data.join("");
                }
                // map of replay start value types to parameter lengths
                const RSValueLenMap = {};
                RSValueLenMap[ReplayStartType.BEGINNING] = 3; // 2 (TLV) + 1 (replay start type)
                RSValueLenMap[ReplayStartType.DATE] = 11; // 2 (TLV) + 1 (replay start type) + 8 (date value)
                RSValueLenMap[ReplayStartType.RGMID] = 19; //2 (TLV) + 1 (replay start type) + 16 (rgmid value)
                // special case for message replay value, a 1 byte type
                // followed by 0 bytes of begining, 8 bytes of date or 16 bytes of rgmid
                // Note replay Start type 0 is handled using encAdp8Param as there is no value
                function encAdpReplayParam(uh, paramtype, value) {
                    const data = [];
                    const valType = value.type;
                    const valObj = value.value;
                    let byte1 = 0;
                    byte1 = Bits.set(byte1, uh, 6, 2);
                    byte1 = Bits.set(byte1, paramtype, 0, 6);
                    data.push(Convert.int8ToStr(byte1));
                    data.push(Convert.int8ToStr(RSValueLenMap[valType])); // length
                    data.push(Convert.int8ToStr(valType)); // replay start type, 1 == date, 2 == RGMID
                    switch (valType) {
                      case ReplayStartType.DATE:
                        // encode 64 bit date
                        data.push(Convert.int64ToStr(valObj)); // value is Long type
                        break;

                      case ReplayStartType.RGMID:
                        // encode 128 bit replication group message id
                        // expected value object of
                        // {
                        //   suid (Long),
                        //   messageId (Long),
                        // }
                        data.push(Convert.int64ToStr(valObj.suid)); // get Long suid
                        data.push(Convert.int64ToStr(valObj.messageId)); // get Long messageId
                        break;

                      case ReplayStartType.BEGINNING:
                        // in this case there is no value to encode
                        break;

                      default:
                        // should not happen until there are more replay start type but those
                        // should be handled in a case above
                        break;
                    }
                    return data.join("");
                }
                function encAdp64AckPairParam(uh, paramtype, min, max) {
                    const data = [];
                    let byte1 = 0;
                    byte1 = Bits.set(byte1, uh, 6, 2);
                    byte1 = Bits.set(byte1, paramtype, 0, 6);
                    data.push(Convert.int8ToStr(byte1));
                    data.push(Convert.int8ToStr(18)); // length
                    data.push(Convert.int64ToStr(min));
                    data.push(Convert.int64ToStr(max));
                    return data.join("");
                }
                function encAdpUTF8NTParam(uh, paramtype, value) {
                    // value is already UTF8 encoded and null terminated.
                    const data = [];
                    let byte1 = 0;
                    byte1 = Bits.set(byte1, uh, 6, 2);
                    byte1 = Bits.set(byte1, paramtype, 0, 6);
                    data.push(Convert.int8ToStr(byte1));
                    let byte2 = 0;
                    if (value.length <= 253) {
                        byte2 = value.length + 2; // full length of param
                        data.push(Convert.int8ToStr(byte2));
                    } else {
                        byte2 = 0; // extended-length
                        data.push(Convert.int8ToStr(byte2));
                        data.push(Convert.int32ToStr(value.length + 5));
                    }
                    data.push(value);
                    return data.join("");
                }
                function encAdp(adpMsg) {
                    const paramspace = [];
                    const paramarray = adpMsg.getParameterArray();
                    let p;
                    for (p = 0; p < paramarray.length; p++) {
                        const param = paramarray[p];
                        // It's not a flat array, we have gaps!
                        if (param === undefined) {
                            continue;
                        }
                        switch (param.getType()) {
                          /*
       * 8 bit parameters
       */
                            case SMFLib.SMFAdProtocolParam.WINDOW:
                          case SMFLib.SMFAdProtocolParam.EP_DURABLE:
                          case SMFLib.SMFAdProtocolParam.ACCESSTYPE:
                          case SMFLib.SMFAdProtocolParam.FLOWTYPE:
                          case SMFLib.SMFAdProtocolParam.EP_RESPECTS_TTL:
                          case SMFLib.SMFAdProtocolParam.TRANSACTION_CTRL_MESSAGE_TYPE:
                          case SMFLib.SMFAdProtocolParam.TRANSACTED_SESSION_STATE:
                          case SMFLib.SMFAdProtocolParam.ACTIVE_FLOW_INDICATION:
                          case SMFLib.SMFAdProtocolParam.WANT_FLOW_CHANGE_NOTIFY:
                          case SMFLib.SMFAdProtocolParam.MAX_REDELIVERY:
                            paramspace.push(encAdp8Param(param.getUh(), param.getType(), param.getValue()));
                            break;
                            /*
       * 16 bit parameters
       */

                          case SMFLib.SMFAdProtocolParam.EP_BEHAVIOUR:
                            paramspace.push(encAdp16Param(param.getUh(), param.getType(), param.getValue()));
                            break;
                            /*
       * 32 bit parameters
       */

                          case SMFLib.SMFAdProtocolParam.FLOWID:
                          case SMFLib.SMFAdProtocolParam.TRANSPORT_WINDOW:
                          case SMFLib.SMFAdProtocolParam.EP_ALLOTHER_PERMISSION:
                          case SMFLib.SMFAdProtocolParam.EP_QUOTA:
                          case SMFLib.SMFAdProtocolParam.EP_MAX_MSGSIZE:
                          case SMFLib.SMFAdProtocolParam.GRANTED_PERMISSION:
                          case SMFLib.SMFAdProtocolParam.TRANSACTED_SESSION_ID:
                          case SMFLib.SMFAdProtocolParam.PUBLISHER_ID:
                            paramspace.push(encAdp32Param(param.getUh(), param.getType(), param.getValue()));
                            break;
                            /*
       * 64 bit parameters
       */

                          case SMFLib.SMFAdProtocolParam.LASTMSGIDSENT:
                          case SMFLib.SMFAdProtocolParam.LASTMSGIDACKED:
                          case SMFLib.SMFAdProtocolParam.LASTMSGIDRECEIVED:
                          case SMFLib.SMFAdProtocolParam.TRANSACTION_ID:
                          case SMFLib.SMFAdProtocolParam.ENDPOINT_ERROR_ID:
                            paramspace.push(encAdp64Param(param.getUh(), param.getType(), param.getValue()));
                            break;
                            /*
       * Replay start location can be either a 0 bit, 64 bit or 128 bit parameter.
       */

                          case SMFLib.SMFAdProtocolParam.REPLAY_START_LOCATION:
                            {
                                const replayParamVal = param.getValue();
                                if (undefined === replayParamVal.value) {
                                    // replay start location with 0 bit values, type only
                                    paramspace.push(encAdp8Param(param.getUh(), param.getType(), replayParamVal.type)); // start location type 0
                                } else {
                                    // replay start location with > 0 bit values, type + value
                                    paramspace.push(encAdpReplayParam(param.getUh(), param.getType(), replayParamVal));
                                }
                                break;
                            }
                            /*
       * application ack
       */

                          case SMFLib.SMFAdProtocolParam.APPLICATION_ACK:
                            {
                                // Unpack this to multiple parameters
                                const ranges = param.getValue();
                                const uh = param.getUh();
                                const type = param.getType();
                                for (let i = 0; i < ranges.length; ++i) {
                                    const range = ranges[i];
                                    paramspace.push(encAdp64AckPairParam(uh, type, range[0], range[1]));
                                }
                                break;
                            }
                            /*
       * string and other variable length parameters
       */

                          case SMFLib.SMFAdProtocolParam.QUEUENAME:
                          case SMFLib.SMFAdProtocolParam.DTENAME:
                          case SMFLib.SMFAdProtocolParam.TOPICNAME:
                          case SMFLib.SMFAdProtocolParam.FLOWNAME:
                          case SMFLib.SMFAdProtocolParam.SELECTOR:
                          case SMFLib.SMFAdProtocolParam.TRANSACTED_SESSION_NAME:
                            paramspace.push(encAdpUTF8NTParam(param.getUh(), param.getType(), param.getValue()));
                            break;
                            /*
       * Transaction Publisher Notify
       */

                          case SMFLib.SMFAdProtocolParam.TRANSACTION_FLOW_DESCRIPTOR_PUB_NOTIFY:
                            break;
                            /*
       * Transaction Publisher Ack
       */

                          case SMFLib.SMFAdProtocolParam.TRANSACTION_FLOW_DESCRIPTOR_PUB_ACK:
                            break;
                            /*
       * Transaction Subscriber Ack
       */

                          case SMFLib.SMFAdProtocolParam.TRANSACTION_FLOW_DESCRIPTOR_SUB_ACK:
                            break;
                            /*
       * No Local Parameter has no data
       * Cut Through Parameter has no data
       */

                          case SMFLib.SMFAdProtocolParam.NOLOCAL:
                          case SMFLib.SMFAdProtocolParam.CUT_THROUGH:
                            paramspace.push(encAdp0Param(param.getUh(), param.getType()));
                            break;
                            /*
       * Application Publisher Acknowledge
       */

                          case SMFLib.SMFAdProtocolParam.APPLICATION_PUB_ACK:
                            break;

                          default:
                            LOG_INFO("Unrecognized ADProtocol Parameter in Message");
                            break;
                        }
                    }
                    const paramdata = paramspace.join("");
                    const data = [];
                    if (adpMsg.version === 2) {
                        let threebytes = 0;
                        threebytes = setBits(threebytes, 0, 22, 2); // RFU
                        threebytes = setBits(threebytes, adpMsg.version, 16, 6); // RFU
                        threebytes = setBits(threebytes, adpMsg.msgType, 12, 4); // msgtype
                        // length in 32 bit words means the real length must always be a multiple of 4, so pad as
                        // necessary
                        // 4 - how many bytes passed a 4 byte boundary
                        let padBytes = 4 - (3 + paramdata.length & 3);
                        // calculate the total length, 3 bytes header + params, in 32 bit words
                        const length = 3 + paramdata.length + padBytes >> 2;
                        threebytes = setBits(threebytes, length, 0, 12);
                        data.push(int24ToStr(threebytes)); // first 3B (RFU, version, msgtype, length)
                        data.push(paramdata);
                        if (padBytes === 4) padBytes = 0; // don't add 4 pad bytes
                        while (padBytes > 0) {
                            data.push(int8ToStr(0));
                            padBytes--;
                        }
                    } else if (adpMsg.version === 3) {
                        let twobytes = 0;
                        twobytes = setBits(twobytes, 0, 14, 2); // RFU
                        twobytes = setBits(twobytes, adpMsg.version, 8, 6); // version
                        twobytes = setBits(twobytes, adpMsg.msgType, 0, 8); // msgtype
                        data.push(int16ToStr(twobytes)); // first 2B (RFU, version, msgtype)
                        data.push(int32ToStr(6 + paramdata.length)); //length: 6B header + params
                        data.push(paramdata);
                    } else {
                        LOG_ERROR(`Invalid Version ${adpMsg.version} found while encoding`);
                    }
                    return data.join("");
                }
                module.exports.parseAdpAt = parseAdpAt;
                module.exports.encAdp = encAdp;
                /***/
            },
            /***/ "./modules/solclient-smf/lib/codec/api.js": 
            /*!************************************************!*\
  !*** ./modules/solclient-smf/lib/codec/api.js ***!
  \************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ContentSummaryType
                } = __webpack_require__(/*! ./content-summary-types */ "./modules/solclient-smf/lib/codec/content-summary-types.js");
                const {
                    Decode
                } = __webpack_require__(/*! ./decode */ "./modules/solclient-smf/lib/codec/decode.js");
                const {
                    Encode
                } = __webpack_require__(/*! ./encode */ "./modules/solclient-smf/lib/codec/encode.js");
                const {
                    ParamParse
                } = __webpack_require__(/*! ./param-parse */ "./modules/solclient-smf/lib/codec/param-parse.js");
                const {
                    ParseSMF
                } = __webpack_require__(/*! ./parse-smf */ "./modules/solclient-smf/lib/codec/parse-smf.js");
                const {
                    Transport
                } = __webpack_require__(/*! ./transport */ "./modules/solclient-smf/lib/codec/transport.js");
                module.exports.ContentSummaryType = ContentSummaryType;
                module.exports.Encode = Encode;
                module.exports.Decode = Decode;
                module.exports.ParamParse = ParamParse;
                module.exports.ParseSMF = ParseSMF;
                module.exports.Transport = Transport;
                /***/
            },
            /***/ "./modules/solclient-smf/lib/codec/client-ctrl.js": 
            /*!********************************************************!*\
  !*** ./modules/solclient-smf/lib/codec/client-ctrl.js ***!
  \********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Bits,
                    Convert
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    ClientCtrlMessage,
                    SMFParameter
                } = __webpack_require__(/*! ../message-objects */ "./modules/solclient-smf/lib/message-objects/api.js");
                const {
                    LOG_ERROR
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    get: bits,
                    set: setBits
                } = Bits;
                const {
                    int8ToStr,
                    /*strToInt8,*/
                    int16ToStr,
                    /*strToInt16,*/
                    int32ToStr
                } = Convert;
                function parseCCAt(dataBuf, offset, payloadLen) {
                    const ccMsg = new ClientCtrlMessage();
                    if (payloadLen < 6 || offset + 6 > dataBuf.length) {
                        // not enough data! Return empty.
                        // This is required because we can get an empty CC payload as a router response
                        return ccMsg;
                    }
                    let pos = offset;
                    const twobytes = dataBuf.readUInt16BE(pos);
                    pos += 2;
                    // var uh = bits(twobytes, 15, 1);
                    const version = bits(twobytes, 8, 3);
                    const msgType = bits(twobytes, 0, 8);
                    const len = dataBuf.readUInt32BE(pos);
                    pos += 4;
                    // Sanity check: we support ClientCtrl v1
                    if (version !== 1) {
                        LOG_ERROR(`Unsupported ClientCtrl version ${version}`);
                        return false;
                    }
                    if (len <= 0 || offset + len > dataBuf.length) {
                        return false;
                    }
                    ccMsg.msgType = msgType;
                    ccMsg.version = version;
                    while (pos < offset + len) {
                        const onebyte = dataBuf.readUInt8(pos);
                        pos++;
                        const paramUh = bits(onebyte, 7, 1);
                        const paramType = bits(onebyte, 0, 7);
                        const paramLen = dataBuf.readUInt32BE(pos);
                        if (paramLen <= 0) {
                            return false; // SMF parsing fail
                        }
                        pos += 4;
                        const paramValueLen = paramLen - 5;
                        const smfP = new SMFParameter(paramUh, paramType, null, dataBuf, pos, pos + paramValueLen);
                        ccMsg.addParameter(smfP);
                        pos += paramValueLen;
                    }
                    return ccMsg;
                }
                function encCC(ccMsg) {
                    const paramSpace = [];
                    const paramArray = ccMsg.getParameterArray();
                    /*
    ClientCtrl Parameter formatting:
        1 byte uh/type
        4 bytes length
        N bytes value
     */
                    for (let p = 0, n = paramArray.length; p < n; ++p) {
                        const currentParam = paramArray[p];
                        // It's not a flat array, we have gaps!
                        if (currentParam === undefined) {
                            continue;
                        }
                        let currentParamOneByte = 0;
                        currentParamOneByte = setBits(currentParamOneByte, currentParam.getUh(), 7, 1);
                        currentParamOneByte = setBits(currentParamOneByte, currentParam.getType(), 0, 7);
                        paramSpace.push(int8ToStr(currentParamOneByte));
                        paramSpace.push(int32ToStr(currentParam.getValue().length + 5));
                        paramSpace.push(currentParam.getValue());
                    }
                    const paramData = paramSpace.join("");
                    let twobytes = 0;
                    twobytes = setBits(twobytes, 0, 15, 1); // uh
                    twobytes = setBits(twobytes, 0, 11, 4); // RFU
                    twobytes = setBits(twobytes, 1, 8, 3); // version
                    twobytes = setBits(twobytes, ccMsg.msgType, 0, 8); // msgtype
                    const data = [];
                    data.push(int16ToStr(twobytes)); // first 2B (uh, version, msgtype)
                    data.push(int32ToStr(6 + paramData.length)); // length: 6B header + params
                    data.push(paramData);
                    return data.join("");
                }
                module.exports.parseCCAt = parseCCAt;
                module.exports.encCC = encCC;
                /***/
            },
            /***/ "./modules/solclient-smf/lib/codec/content-summary-element.js": 
            /*!********************************************************************!*\
  !*** ./modules/solclient-smf/lib/codec/content-summary-element.js ***!
  \********************************************************************/
            /***/ module => {
                class ContentSummaryElement {
                    constructor(type = null, position = 0, length = 0) {
                        this.type = type;
                        this.position = position;
                        this.length = length;
                    }
                }
                module.exports.ContentSummaryElement = ContentSummaryElement;
                /***/
            },
            /***/ "./modules/solclient-smf/lib/codec/content-summary-types.js": 
            /*!******************************************************************!*\
  !*** ./modules/solclient-smf/lib/codec/content-summary-types.js ***!
  \******************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Type maching SMF encoding value
 * @enum {number}
 * @memberof solace
 * @private
 */
                const ContentSummaryType = {
                    XML_META: 0,
                    XML_PAYLOAD: 1,
                    BINARY_ATTACHMENT: 2,
                    CID_LIST: 3,
                    BINARY_METADATA: 4
                };
                module.exports.ContentSummaryType = Enum.new(ContentSummaryType);
                /***/
            },
            /***/ "./modules/solclient-smf/lib/codec/decode.js": 
            /*!***************************************************!*\
  !*** ./modules/solclient-smf/lib/codec/decode.js ***!
  \***************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const DebugLib = __webpack_require__(/*! solclient-debug */ "./modules/solclient-debug/api.js");
                const SolclientDestinationLib = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                const SolclientMessageLib = __webpack_require__(/*! solclient-message */ "./modules/solclient-message/api.js");
                const SolclientSDTLib = __webpack_require__(/*! solclient-sdt */ "./modules/solclient-sdt/api.js");
                const {
                    BinaryMetaBlock,
                    KeepAliveMessage
                } = __webpack_require__(/*! ../message-objects */ "./modules/solclient-smf/lib/message-objects/api.js");
                const {
                    ContentSummaryType
                } = __webpack_require__(/*! ./content-summary-types */ "./modules/solclient-smf/lib/codec/content-summary-types.js");
                const {
                    Hex,
                    Long
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    Lazy
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                const {
                    LogFormatter
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    parseAdpAt
                } = __webpack_require__(/*! ./adprotocol */ "./modules/solclient-smf/lib/codec/adprotocol.js");
                const {
                    parseCCAt
                } = __webpack_require__(/*! ./client-ctrl */ "./modules/solclient-smf/lib/codec/client-ctrl.js");
                const {
                    ParseSMF
                } = __webpack_require__(/*! ./parse-smf */ "./modules/solclient-smf/lib/codec/parse-smf.js");
                const {
                    PriorityUserCosMap
                } = __webpack_require__(/*! ./priority-user-cos-map */ "./modules/solclient-smf/lib/codec/priority-user-cos-map.js");
                const {
                    SMFProtocol
                } = __webpack_require__(/*! ../smf-protocols */ "./modules/solclient-smf/lib/smf-protocols.js");
                const {
                    SMP
                } = __webpack_require__(/*! ./smp */ "./modules/solclient-smf/lib/codec/smp.js");
                const {
                    Transport
                } = __webpack_require__(/*! ./transport */ "./modules/solclient-smf/lib/codec/transport.js");
                const {
                    formatHexString
                } = Hex;
                const {
                    lazyValue
                } = Lazy;
                const {
                    parseSMFAt
                } = ParseSMF;
                const {
                    parseSMPAt
                } = SMP;
                const {
                    parseTsSmfMsgAt
                } = Transport;
                const logger = new LogFormatter("[smf-decode]");
                const {
                    LOG_DEBUG,
                    LOG_ERROR
                } = logger;
                const userCosForPriority = lazyValue(() => new PriorityUserCosMap().reverse);
                const BIN_STRUCTYPES = {
                    10: SolclientMessageLib.MessageType.MAP,
                    11: SolclientMessageLib.MessageType.STREAM,
                    7: SolclientMessageLib.MessageType.TEXT
                };
                function adaptBinaryMetaToMessage(binaryMeta, messageIn) {
                    const message = messageIn;
                    const messageSdt = SolclientSDTLib.Codec.parseSingleElement(binaryMeta.payload, 0);
                    if (!(messageSdt && messageSdt.getType() === SolclientSDTLib.SDTFieldType.STREAM)) {
                        return;
                    }
                    const sdtstream = messageSdt.getValue();
                    let sdtfield = sdtstream.getNext();
                    if (sdtfield && sdtfield.getType() === SolclientSDTLib.SDTFieldType.BYTEARRAY && sdtfield._value && sdtfield._value.length > 0) {
                        // Preamble byte array is present
                        const preambleByte0 = sdtfield._value.readUInt8(0);
                        if ((preambleByte0 & 128) === 0) {
                            // structured message: override default "BIN" message type
                            message._messageType = BIN_STRUCTYPES[preambleByte0 & 15] || SolclientMessageLib.MessageType.BINARY;
                        }
                        if (sdtfield._value.length > 1) {
                            const preambleByte1 = sdtfield._value.readUInt8(1);
                            message.setAsReplyMessage((preambleByte1 & 128) !== 0);
                        }
                    }
                    sdtfield = sdtstream.getNext();
                    if (sdtfield && sdtfield.getType() === SolclientSDTLib.SDTFieldType.MAP) {
                        const sdtMap = sdtfield.getValue();
                        const p = sdtMap.getField("p");
                        const h = sdtMap.getField("h");
                        if (p) {
                            message.setUserPropertyMap(p.getValue());
                        }
                        if (h) {
                            const headerMap = h.getValue();
                            const ci = headerMap.getField("ci");
                            const mi = headerMap.getField("mi");
                            const mt = headerMap.getField("mt");
                            const rt = headerMap.getField("rt");
                            const si = headerMap.getField("si");
                            const sn = headerMap.getField("sn");
                            const ts = headerMap.getField("ts");
                            const ex = headerMap.getField("ex");
                            if (ci) {
                                message.setCorrelationId(ci.getValue());
                            }
                            if (mi) {
                                message.setApplicationMessageId(mi.getValue());
                            }
                            if (mt) {
                                message.setApplicationMessageType(mt.getValue());
                            }
                            if (rt) {
                                message.setReplyTo(rt.getValue());
                            }
                            if (si) {
                                message.setSenderId(si.getValue());
                            }
                            if (sn) {
                                message.setSequenceNumber(sn.getValueNoThrow());
                            }
                            if (ts) {
                                message.setSenderTimestamp(ts.getValue());
                            }
                            if (ex) {
                                message.setGMExpiration(ex.getValue());
                            }
                        }
                    }
                }
                function adaptSmfToMessage(smfHeader, messageIn, stream, offset) {
                    const message = messageIn;
                    message._setDeliverToOne(!!smfHeader.smf_dto);
                    message._setDeliveryMode(smfHeader.pm_deliverymode || SolclientMessageLib.MessageDeliveryModeType.DIRECT);
                    if (smfHeader.pm_tr_topicname_bytes !== null) {
                        message._setDestination(SolclientDestinationLib.DestinationFromNetwork.createDestinationFromBytes(smfHeader.pm_tr_topicname_bytes));
                    }
                    message._setDiscardIndication(!!smfHeader.smf_di);
                    message._setElidingEligible(!!smfHeader.smf_elidingEligible);
                    message._setDMQEligible(!!smfHeader.smf_deadMessageQueueEligible);
                    message._setUserCos(userCosForPriority.value.get(smfHeader.smf_priority));
                    message._setPriority(smfHeader.pm_msg_priority);
                    if (smfHeader.pm_userdata) message._setUserData(smfHeader.pm_userdata);
                    message.setRedelivered(!!smfHeader.pm_ad_redelflag || !!smfHeader.pm_ad_flowredelflag);
                    message.setFlowId(smfHeader.pm_ad_flowid);
                    message.setGuaranteedMessageId(smfHeader.pm_ad_msgid);
                    message.setGuaranteedPreviousMessageId(smfHeader.pm_ad_prevmsgid);
                    message.setPublisherId(smfHeader.pm_ad_publisherid);
                    message.setPublisherMessageId(smfHeader.pm_ad_publishermsgid);
                    message.setTopicSequenceNumber(smfHeader.pm_ad_topicSequenceNumber);
                    if (message.getDeliveryMode() === SolclientMessageLib.MessageDeliveryModeType.DIRECT) {
                        message.setDeliveryCount(-1);
                    } else if (smfHeader.pm_ad_redeliveryCount) {
                        message.setDeliveryCount(smfHeader.pm_ad_redeliveryCount + 1);
                    } else {
                        // AD, but delivery count header not present
                        // Only the flow knows whether the qEndpointBehaviour DC flag was set,
                        // so it overrides the value before passing it to the user with -1 if it wasn't.
                        message.setDeliveryCount(1);
                    }
                    // set the suid for the message if present
                    if (smfHeader.pm_ad_spooler_unique_id) {
                        message._setSpoolerUniqueId(smfHeader.pm_ad_spooler_unique_id);
                    }
                    // set the message id of the replication group message id using
                    // ASSURED_DELIVERY_REPLICATION_MATE_ACK_MESSAGE_ID if present
                    // otherwise use ASSURED_DELIVERY_ACK_MESSAGE_ID if present
                    // otherwise let the Mesage.getReplicationGroupMessageId use
                    // the value set by message.setGuaranteedMessageId
                    if (smfHeader.pm_ad_replication_mate_ack_message_id) {
                        message._setSpoolerMessageId(smfHeader.pm_ad_replication_mate_ack_message_id);
                    } else if (smfHeader.pm_ad_local_spooler_message_id) {
                        message._setSpoolerMessageId(smfHeader.pm_ad_local_spooler_message_id);
                    }
                    if (Long.isLong(smfHeader.pm_ad_ttl)) {
                        message.setTimeToLive(smfHeader.pm_ad_ttl.toNumber());
                    } else {
                        message.setTimeToLive(smfHeader.pm_ad_ttl);
                    }
                    // Copy content into fields (from input bytes)
                    const payloadOffset = offset + smfHeader.headerLength;
                    const cs = smfHeader.pm_content_summary;
                    if (!(cs && cs.length)) {
                        // No content-summary, assume binary attachment
                        message._setBinaryAttachment(smfHeader.payloadLength > 0 ? stream.slice(payloadOffset, payloadOffset + smfHeader.payloadLength) : undefined);
                        return;
                    }
                    for (let i = 0, n = cs.length; i < n; ++i) {
                        const currentChunk = cs[i];
                        const chunkBegin = payloadOffset + currentChunk.position;
                        const chunkEnd = payloadOffset + currentChunk.position + currentChunk.length;
                        switch (currentChunk.type) {
                          case ContentSummaryType.BINARY_ATTACHMENT:
                            message._setBinaryAttachment(stream.slice(chunkBegin, chunkEnd));
                            break;

                          case ContentSummaryType.BINARY_METADATA:
                            {
                                const binaryMeta = BinaryMetaBlock.fromEncodedSmf(stream, chunkBegin);
                                message.binaryMetadataChunk = binaryMeta;
                                if (binaryMeta.type === 0) {
                                    // we have SDT JMS metadata
                                    adaptBinaryMetaToMessage(binaryMeta, message);
                                }
                                break;
                            }

                          case ContentSummaryType.XML_META:
                            message._setXmlMetadata(stream.toString("latin1", chunkBegin, chunkEnd));
                            break;

                          case ContentSummaryType.XML_PAYLOAD:
                            message._setXmlContentInternal(stream.toString("latin1", chunkBegin, chunkEnd));
                            break;

                          default:
                            LOG_ERROR(`Unhandled ContentSummaryType: ${ContentSummaryType.describe(currentChunk.type)}`);
                        }
                    }
                }
                function decodeCompoundMessage(dataBuf, pos) {
                    const header = parseSMFAt(dataBuf, pos);
                    if (!header) {
                        LOG_DEBUG("decodeCompoundMessage: SMF parsing failed");
                        return null;
                    }
                    // the parser determined there was a full SMF message
                    const payloadPosition = pos + header.headerLength;
                    const payloadLen = header.payloadLength;
                    let message;
                    switch (header.smf_protocol) {
                      case SMFProtocol.TSESSION:
                        message = parseTsSmfMsgAt(dataBuf, payloadPosition, header);
                        if (!message) break;
                        message.smfHeader = header;
                        return message;

                      case SMFProtocol.TRMSG:
                        message = new SolclientMessageLib.Message();
                        message._smfHeader = header;
                        adaptSmfToMessage(header, message, dataBuf, pos);
                        return message;

                      case SMFProtocol.ADCTRL:
                        message = parseAdpAt(dataBuf, payloadPosition, payloadLen);
                        message.smfHeader = header;
                        return message;

                      case SMFProtocol.CLIENTCTRL:
                        message = parseCCAt(dataBuf, payloadPosition, payloadLen);
                        if (!message) break;
                        message.smfHeader = header;
                        return message;

                      case SMFProtocol.SMP:
                        message = parseSMPAt(dataBuf, payloadPosition);
                        if (!message) break;
                        message.smfHeader = header;
                        return message;

                      case SMFProtocol.KEEPALIVE:
                      case SMFProtocol.KEEPALIVEV2:
                        message = new KeepAliveMessage();
                        message.smfHeader = header;
                        return message;

                      default:
                        LOG_ERROR(`Unknown protocol: 0x${formatHexString(header.smf_protocol)}, ` + `dump message content: \n${DebugLib.Debug.formatDumpBytes(dataBuf.slice(pos, pos + header.messageLength).toString("latin1"), true, 0)}`);
                        break;
                    }
                    return null;
                }
                const Decode = {
                    decodeCompoundMessage: decodeCompoundMessage
                };
                module.exports.Decode = Decode;
                /***/
            },
            /***/ "./modules/solclient-smf/lib/codec/encode.js": 
            /*!***************************************************!*\
  !*** ./modules/solclient-smf/lib/codec/encode.js ***!
  \***************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const MessageLib = __webpack_require__(/*! solclient-message */ "./modules/solclient-message/api.js");
                const {
                    Base64,
                    Bits,
                    Convert
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    BinaryMetaBlock,
                    SMFHeader,
                    SMPMessage
                } = __webpack_require__(/*! ../message-objects */ "./modules/solclient-smf/lib/message-objects/api.js");
                const {
                    Check
                } = __webpack_require__(/*! solclient-validate */ "./modules/solclient-validate/api.js");
                const {
                    ClientCtrlMessage,
                    KeepAliveMessage,
                    AdProtocolMessage
                } = __webpack_require__(/*! ../message-objects */ "./modules/solclient-smf/lib/message-objects/api.js");
                const {
                    Codec: SDTCodec
                } = __webpack_require__(/*! solclient-sdt */ "./modules/solclient-sdt/api.js");
                const {
                    ContentSummaryElement
                } = __webpack_require__(/*! ./content-summary-element */ "./modules/solclient-smf/lib/codec/content-summary-element.js");
                const {
                    ContentSummaryType
                } = __webpack_require__(/*! ./content-summary-types */ "./modules/solclient-smf/lib/codec/content-summary-types.js");
                const {
                    DestinationType
                } = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                const {
                    encAdp
                } = __webpack_require__(/*! ./adprotocol */ "./modules/solclient-smf/lib/codec/adprotocol.js");
                const {
                    encCC
                } = __webpack_require__(/*! ./client-ctrl */ "./modules/solclient-smf/lib/codec/client-ctrl.js");
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    Lazy
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                const {
                    LOG_TRACE,
                    LOG_INFO
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    ParamParse
                } = __webpack_require__(/*! ./param-parse */ "./modules/solclient-smf/lib/codec/param-parse.js");
                const {
                    PriorityUserCosMap
                } = __webpack_require__(/*! ./priority-user-cos-map */ "./modules/solclient-smf/lib/codec/priority-user-cos-map.js");
                const {
                    SDTField,
                    SDTFieldType,
                    SDTMapContainer,
                    SDTStreamContainer
                } = __webpack_require__(/*! solclient-sdt */ "./modules/solclient-sdt/api.js");
                const {
                    SMFParameterType,
                    SMFExtendedParameterType
                } = __webpack_require__(/*! ../smf-parameter-types */ "./modules/solclient-smf/lib/smf-parameter-types.js");
                const {
                    SMFProtocol
                } = __webpack_require__(/*! ../smf-protocols */ "./modules/solclient-smf/lib/smf-protocols.js");
                const {
                    SMP
                } = __webpack_require__(/*! ./smp */ "./modules/solclient-smf/lib/codec/smp.js");
                const {
                    encode: base64Encode
                } = Base64;
                const {
                    set: setBits
                } = Bits;
                const {
                    int8ToStr,
                    int16ToStr,
                    int24ToStr,
                    int32ToStr,
                    int64ToStr
                } = Convert;
                const {
                    lazyValue
                } = Lazy;
                const {
                    encContentSummary,
                    encDeliveryMode,
                    encLightSMFParam,
                    encodeSMFParam,
                    encodeSMFExtendedParam
                } = ParamParse;
                const {
                    encodeSingleElement
                } = SDTCodec;
                const {
                    encSmp
                } = SMP;
                const priorityForUserCos = lazyValue(() => new PriorityUserCosMap().forward);
                function addContentElementToArrays(csumm, payloadArray, dataChunk, cstype) {
                    if (Check.anything(dataChunk) && dataChunk.length > 0) {
                        const cse = new ContentSummaryElement(cstype, NaN, dataChunk.length);
                        csumm.push(cse);
                        payloadArray.push(dataChunk);
                    }
                }
                function addToMapIfPresent(headerMap, key, type, value) {
                    if (Check.anything(value)) {
                        headerMap.addField(key, SDTField.create(type, value));
                    }
                }
                // Return the binary attachment as string, sets the binaryMetaData on the message.
                // Not nice, but fast.
                function adaptMessageToBinaryMeta(message) {
                    let result;
                    // solace header map
                    const headerMap = new SDTMapContainer();
                    addToMapIfPresent(headerMap, "ci", SDTFieldType.STRING, message.getCorrelationId());
                    addToMapIfPresent(headerMap, "mi", SDTFieldType.STRING, message.getApplicationMessageId());
                    addToMapIfPresent(headerMap, "mt", SDTFieldType.STRING, message.getApplicationMessageType());
                    addToMapIfPresent(headerMap, "rt", SDTFieldType.DESTINATION, message.getReplyTo());
                    addToMapIfPresent(headerMap, "si", SDTFieldType.STRING, message.getSenderId());
                    addToMapIfPresent(headerMap, "sn", SDTFieldType.INT64, message.getSequenceNumber());
                    addToMapIfPresent(headerMap, "ts", SDTFieldType.INT64, message.getSenderTimestamp());
                    addToMapIfPresent(headerMap, "ex", SDTFieldType.INT64, message.getGMExpiration());
                    // container map: solace headers + user prop map
                    const sdtMap = new SDTMapContainer();
                    if (message.getUserPropertyMap()) {
                        sdtMap.addField("p", SDTField.create(SDTFieldType.MAP, message.getUserPropertyMap()));
                    }
                    if (headerMap.getKeys().length > 0) {
                        sdtMap.addField("h", SDTField.create(SDTFieldType.MAP, headerMap));
                    }
                    let preambleByte0 = 0;
                    switch (message.getType()) {
                      case MessageLib.MessageType.BINARY:
                        preambleByte0 |= 128;
                        break;

                      case MessageLib.MessageType.MAP:
                        preambleByte0 |= 10;
                        result = encodeSingleElement(message._structuredContainer);
                        break;

                      case MessageLib.MessageType.STREAM:
                        preambleByte0 |= 11;
                        result = encodeSingleElement(message._structuredContainer);
                        break;

                      case MessageLib.MessageType.TEXT:
                        preambleByte0 |= 7;
                        result = encodeSingleElement(message._structuredContainer);
                        break;

                      default:
                        LOG_INFO(`Unhandled messageType: ${message.getType()}`);
                        break;
                    }
                    const preambleByte1 = message.isReplyMessage() ? 128 : 0;
                    const sdtPreamble = SDTField.create(SDTFieldType.BYTEARRAY, String.fromCharCode(preambleByte0, preambleByte1));
                    // Putting it all together: a stream with the preamble and map
                    const sdtStreamContainer = new SDTStreamContainer();
                    sdtStreamContainer.addField(sdtPreamble);
                    sdtStreamContainer.addField(SDTField.create(SDTFieldType.MAP, sdtMap));
                    const binaryMeta = new BinaryMetaBlock();
                    binaryMeta.type = 0;
                    binaryMeta.payload = encodeSingleElement(SDTField.create(SDTFieldType.STREAM, sdtStreamContainer));
                    message.binaryMetadataChunk = binaryMeta;
                    return result;
                }
                function adaptMessageToSmf_nonPayload(message, smfHeaderIn) {
                    const smfHeader = smfHeaderIn;
                    const deliveryMode = message.getDeliveryMode();
                    smfHeader.smf_dto = message.isDeliverToOne();
                    smfHeader.pm_deliverymode = deliveryMode;
                    smfHeader.smf_adf = deliveryMode === MessageLib.MessageDeliveryModeType.DIRECT ? 0 : 1;
                    smfHeader.smf_di = message.isDiscardIndication();
                    smfHeader.smf_elidingEligible = message.isElidingEligible();
                    smfHeader.smf_deadMessageQueueEligible = message.isDMQEligible();
                    smfHeader.pm_ad_flowid = message.getFlowId();
                    smfHeader.pm_ad_publisherid = message.getPublisherId();
                    smfHeader.pm_ad_publishermsgId = message.getPublisherMessageId();
                    smfHeader.pm_ad_msgid = message.getGuaranteedMessageId();
                    smfHeader.pm_ad_prevmsgid = message.getGuaranteedPreviousMessageId();
                    smfHeader.pm_ad_ttl = message.getTimeToLive();
                    smfHeader.pm_ad_ackimm = message.isAcknowledgeImmediately();
                    smfHeader.pm_ad_redelflag = message.isRedelivered();
                    const dest = message.getDestination();
                    if (dest) {
                        smfHeader.pm_tr_topicname_bytes = dest.getBytes();
                        if (dest.type === DestinationType.QUEUE || dest.type === DestinationType.TEMPORARY_QUEUE) {
                            const {
                                offset
                            } = dest;
                            smfHeader.pm_queue_len = smfHeader.pm_tr_topicname_bytes.length - offset;
                            smfHeader.pm_queue_offset = offset;
                        }
                    }
                    smfHeader.smf_priority = priorityForUserCos.value.get(message.getUserCos());
                    if (message.getPriority() !== undefined && typeof message.getPriority() === "number" && message.getPriority() <= 255 && message.getPriority() >= 0) {
                        smfHeader.pm_msg_priority = message.getPriority();
                    } else {
                        smfHeader.pm_msg_priority = null;
                    }
                    const userData = message.getUserData();
                    smfHeader.pm_userdata = userData === null || userData === undefined ? null : message.getUserData();
                }
                function adaptMessageToSmf_payloadMemoize(message) {
                    let encodedSdtPayload;
                    // Setup user properties, header properties, msgtype
                    if (message.getCorrelationId() || message.getApplicationMessageId() || message.getApplicationMessageType() || message.getReplyTo() || message.getSenderId() || message.getSequenceNumber() || message.getSenderTimestamp() || message.getUserPropertyMap() || message.isReplyMessage() || message.getType() !== MessageLib.MessageType.BINARY) {
                        // add SDT binary metadata
                        encodedSdtPayload = adaptMessageToBinaryMeta(message);
                    }
                    // Build array of ContentSummaryElements
                    const csumm = [];
                    const payload = [];
                    addContentElementToArrays(csumm, payload, message.getXmlMetadata(), ContentSummaryType.XML_META);
                    addContentElementToArrays(csumm, payload, message.getXmlContent(), ContentSummaryType.XML_PAYLOAD);
                    if (encodedSdtPayload) {
                        addContentElementToArrays(csumm, payload, encodedSdtPayload, ContentSummaryType.BINARY_ATTACHMENT);
                    } else {
                        addContentElementToArrays(csumm, payload, message._binaryAttachment ? message._binaryAttachment.toString("latin1") : "", ContentSummaryType.BINARY_ATTACHMENT);
                    }
                    const binaryMeta = message.binaryMetadataChunk;
                    if (binaryMeta !== null) {
                        const binaryMetaSMF = binaryMeta.asEncodedSmf();
                        const MAX_24BITS = 16777215;
                        if (binaryMetaSMF.length > MAX_24BITS) {
                            LOG_TRACE(`binary-meta data (${binaryMetaSMF.length}) over the ${MAX_24BITS} limit`);
                            throw new OperationError(`binary-meta data (${binaryMetaSMF.length}) over the ${MAX_24BITS} limit`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        } else {
                            addContentElementToArrays(csumm, payload, binaryMetaSMF, ContentSummaryType.BINARY_METADATA);
                        }
                    }
                    message._memoized_csumm = csumm;
                    message._memoized_payload = payload.join("");
                    message._payload_is_memoized = true;
                    return message._memoized_payload ? message._memoized_payload.length : 0;
                }
                function adaptMessageToSmf_payloadFinalize(message, smfHeaderIn) {
                    const smfHeader = smfHeaderIn;
                    if (!message._payload_is_memoized) {
                        adaptMessageToSmf_payloadMemoize(message);
                    }
                    const csumm = message._memoized_csumm;
                    const payloadBytes = message._memoized_payload;
                    if (csumm.length === 0 || csumm.length === 1 && csumm[0].type === ContentSummaryType.BINARY_ATTACHMENT) {
                        // NULL or RAW payload (no content-summary)
                        //  Was this here to invert the condition?
                        // LOG_TRACE('NULL or RAW payload (no content-summary)');
                    } else {
                        smfHeader.pm_content_summary = csumm;
                    }
                    smfHeader.payload = payloadBytes;
                }
                function adaptMessageToSmf(message, smfHeaderIn) {
                    adaptMessageToSmf_payloadFinalize(message, smfHeaderIn);
                    adaptMessageToSmf_nonPayload(message, smfHeaderIn);
                }
                /**
 * Creates an array of all values that fit in the given number of bits.
 * e.g. bitRange(1) => [0, 1], bitRange(2) => [0, 1, 2, 3]
 * @param {Number} bits The number of bits in the range
 * @returns {Number} All values that fit in that number of bits
 * @private
 */
                const bitRange = bits => Array.from(Array(Math.pow(2, bits))).map((el, i) => i);
                const maskValues = (shift, bits) => bitRange(bits).map(val => setBits(0, val, shift, bits));
                const DI_BIT = maskValues(31, 1);
                const ELIDING_ELIGIBLE_BIT = maskValues(30, 1);
                const DTO_BIT = maskValues(29, 1);
                const ADF_BIT = maskValues(28, 1);
                const DMQE_BIT = maskValues(27, 1);
                const VERSION_BITS = maskValues(24, 3);
                const UH_BITS = maskValues(22, 2);
                const PROTOCOL_BITS = maskValues(16, 6);
                const PRIORITY_BITS = maskValues(12, 4);
                const TTL_BITS = maskValues(0, 8);
                const QT_OFFSET_BYTES = maskValues(8, 8);
                const QT_LEN_BYTES = maskValues(0, 8);
                function encodeSMF(header) {
                    // First 4 bytes: protocol, ttl, etc
                    let w1 = 0;
                    // PERF: single expression to make w1 const
                    w1 |= DI_BIT[header.smf_di && 1 || 0];
                    w1 |= ELIDING_ELIGIBLE_BIT[header.smf_elidingEligible && 1 || 0];
                    w1 |= DTO_BIT[header.smf_dto && 1 || 0];
                    w1 |= ADF_BIT[header.smf_adf && 1 || 0];
                    w1 |= DMQE_BIT[header.smf_deadMessageQueueEligible && 1 || 0];
                    w1 |= VERSION_BITS[header.smf_version || 0];
                    w1 |= UH_BITS[header.smf_uh || 0];
                    w1 |= PROTOCOL_BITS[header.smf_protocol || 0];
                    w1 |= PRIORITY_BITS[header.smf_priority || 0];
                    w1 |= TTL_BITS[header.smf_ttl || 0]; // PERF: or set w1 to ttl initially.
                    const params = [];
                    // Encode all standard SMF parameters
                    // Topic name and queue/topic offsets are supposed to come first
                    if (header.pm_tr_topicname_bytes) {
                        params.push(encodeSMFParam(2, SMFParameterType.TR_TOPICNAME, `${header.pm_tr_topicname_bytes}`));
                    }
                    if (header.pm_queue_len) {
                        params.push(encLightSMFParam(0, SMFParameterType.LIGHT_QUEUE_NAME_OFFSET, int16ToStr(QT_OFFSET_BYTES[header.pm_queue_offset] | QT_LEN_BYTES[header.pm_queue_len])));
                    }
                    if (header.pm_topic_len) {
                        params.push(encLightSMFParam(0, SMFParameterType.LIGHT_TOPIC_NAME_OFFSET, int16ToStr(QT_OFFSET_BYTES[header.pm_topic_offset] | QT_OFFSET_BYTES[header.pm_topic_len])));
                    }
                    if (header.pm_corrtag !== null && header.pm_corrtag !== undefined) {
                        params.push(encLightSMFParam(0, SMFParameterType.LIGHT_CORRELATION, int24ToStr(header.pm_corrtag)));
                    }
                    if (header.pm_ad_ackimm) {
                        params.push(encLightSMFParam(0, SMFParameterType.LIGHT_ACK_IMMEDIATELY, ""));
                    }
                    if (header.pm_msg_priority !== null) {
                        params.push(encodeSMFParam(0, SMFParameterType.MESSAGEPRIORITY, int8ToStr(header.pm_msg_priority)));
                    }
                    if (header.pm_userdata !== null && header.pm_userdata !== "") {
                        params.push(encodeSMFParam(0, SMFParameterType.USERDATA, header.pm_userdata));
                    }
                    if (header.pm_username) {
                        // do a sloppy base64 (no newlines)
                        params.push(encodeSMFParam(0, SMFParameterType.USERNAME, base64Encode(header.pm_username)));
                    }
                    if (header.pm_password) {
                        // do a sloppy base64 (no newlines)
                        params.push(encodeSMFParam(0, SMFParameterType.PASSWORD, base64Encode(header.pm_password)));
                    }
                    if (header.pm_respcode) {
                        // not useful API->router
                        params.push(encodeSMFParam(0, SMFParameterType.RESPONSE, int32ToStr(header.pm_respcode) + header.pm_respstr));
                    }
                    if (header.pm_deliverymode !== null) {
                        params.push(encodeSMFParam(0, SMFParameterType.DELIVERY_MODE, encDeliveryMode(header.pm_deliverymode)));
                    }
                    if (header.pm_ad_msgid !== undefined) {
                        params.push(encodeSMFParam(2, SMFParameterType.ASSURED_MESSAGE_ID, int64ToStr(header.pm_ad_msgid)));
                        params.push(encodeSMFParam(2, SMFParameterType.ASSURED_PREVMESSAGE_ID, int64ToStr(header.pm_ad_prevmsgid)));
                    }
                    if (header.pm_ad_flowid) {
                        params.push(encodeSMFParam(0, SMFParameterType.ASSURED_FLOWID, int32ToStr(header.pm_ad_flowid)));
                    }
                    // header.pm_ad_redelflag
                    // Ad redelivered
                    if (header.pm_ad_redelflag) {
                        params.push(encodeSMFParam(0, SMFParameterType.ASSURED_REDELIVERED_FLAG, undefined));
                    }
                    // header.pm_ad_flowredelflag
                    if (header.pm_ad_ttl !== undefined) {
                        params.push(encodeSMFParam(0, SMFParameterType.AD_TIMETOLIVE, int64ToStr(header.pm_ad_ttl)));
                    }
                    // sequence number?
                    if (header.pm_ad_publisherid) {
                        params.push(encodeSMFParam(0, SMFParameterType.PUBLISHER_ID, int32ToStr(header.pm_ad_publisherid)));
                    }
                    if (header.pm_ad_publisherMsgId) {
                        params.push(encodeSMFParam(0, SMFParameterType.PUBLISHER_MSGID, int64ToStr(header.pm_ad_publisherMsgId)));
                    }
                    // transactions: ackmessageid, transactionid, transactionflags
                    if (header.pm_content_summary) {
                        params.push(encodeSMFParam(2, SMFParameterType.MESSAGE_CONTENT_SUMMARY, encContentSummary(header.pm_content_summary)));
                    }
                    // done common SMF parameters!
                    // pre-collect and push extended parameters (once we have any)
                    let extendedStreamContents = "";
                    let extendedUH = 0;
                    if (header.pm_oauth2_access_token) {
                        extendedStreamContents += encodeSMFExtendedParam(0, SMFExtendedParameterType.OAUTH2_ACCESS_TOKEN, header.pm_oauth2_access_token);
                        extendedUH = extendedUH || 0;
                    }
                    if (header.pm_oidc_id_token) {
                        extendedStreamContents += encodeSMFExtendedParam(0, SMFExtendedParameterType.OIDC_ID_TOKEN, header.pm_oidc_id_token);
                        extendedUH = extendedUH || 0;
                    }
                    if (header.pm_oauth2_issuer_identifier) {
                        extendedStreamContents += encodeSMFExtendedParam(0, SMFExtendedParameterType.OAUTH2_ISSUER_IDENTIFIER, header.pm_oauth2_issuer_identifier);
                        extendedUH = extendedUH || 0;
                    }
                    if (extendedStreamContents.length > 0) {
                        params.push(encodeSMFParam(extendedUH, SMFParameterType.EXTENDED_TYPE_STREAM, extendedStreamContents));
                    }
                    // compute header size and full message size
                    const encodedParams = params.join("");
                    const hdrlen = 12 + encodedParams.length;
                    const msglen = hdrlen + header.payloadLength;
                    // ? Already encoded. Why bother?
                    header.setMessageSizes(hdrlen, header.payloadLength);
                    return int32ToStr(w1) + int32ToStr(hdrlen) + int32ToStr(msglen) + encodedParams;
                }
                function encodeCompoundMessage(msg) {
                    let payload = "";
                    if (msg instanceof MessageLib.Message) {
                        if (!msg.smfHeader) {
                            msg.smfHeader = new SMFHeader(SMFProtocol.TRMSG, 255);
                        }
                        adaptMessageToSmf(msg, msg._smfHeader);
                        payload = msg._smfHeader.payload;
                    } else if (msg instanceof ClientCtrlMessage) {
                        payload = encCC(msg);
                    } else if (msg instanceof SMPMessage) {
                        payload = encSmp(msg);
                    } else if (msg instanceof KeepAliveMessage) {
                        LOG_TRACE("Skipping retrieve payload as there is none in a KeepAliveMessage");
                    } else if (msg instanceof AdProtocolMessage) {
                        payload = encAdp(msg);
                    }
                    const header = msg.smfHeader;
                    header.setPayloadSize(payload.length);
                    const encodedHeader = encodeSMF(header);
                    return encodedHeader + payload;
                }
                const Encode = {
                    encodeCompoundMessage: encodeCompoundMessage,
                    encodeSMF: encodeSMF,
                    adaptMessageToSmf_payloadMemoize: adaptMessageToSmf_payloadMemoize
                };
                module.exports.Encode = Encode;
                /***/
            },
            /***/ "./modules/solclient-smf/lib/codec/param-parse.js": 
            /*!********************************************************!*\
  !*** ./modules/solclient-smf/lib/codec/param-parse.js ***!
  \********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const MessageLib = __webpack_require__(/*! solclient-message */ "./modules/solclient-message/api.js");
                const {
                    BidiMap,
                    Lazy
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                const {
                    Bits,
                    Convert
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    ContentSummaryElement
                } = __webpack_require__(/*! ./content-summary-element */ "./modules/solclient-smf/lib/codec/content-summary-element.js");
                const {
                    ContentSummaryType
                } = __webpack_require__(/*! ./content-summary-types */ "./modules/solclient-smf/lib/codec/content-summary-types.js");
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    LOG_ERROR
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    SMFUH
                } = __webpack_require__(/*! ../message-objects */ "./modules/solclient-smf/lib/message-objects/api.js");
                const {
                    lazyValue
                } = Lazy;
                const {
                    int8ToStr,
                    int16ToStr,
                    int24ToStr,
                    int32ToStr
                } = Convert;
                const delModeEnumBidiMap = lazyValue(() => {
                    // Single bidirectional map for lookups. Note that the forward
                    // keys are converted to strings.
                    const source = [ [ 0, MessageLib.MessageDeliveryModeType.NON_PERSISTENT ], [ 1, MessageLib.MessageDeliveryModeType.PERSISTENT ], [ 2, MessageLib.MessageDeliveryModeType.DIRECT ] ].map(el => [ el[0], el[1] ]);
                    return new BidiMap(...source);
                });
                const lutDelModeToEnum = lazyValue(() => delModeEnumBidiMap.value.forward);
                const lutEnumToDelMode = lazyValue(() => delModeEnumBidiMap.value.reverse);
                /**
 * SMF TLV Param LUT
 * utTypeMap[uh][paramtype] is the binary prefix for a regular (not LW) TLV
 * parameter with uh and paramtype values as accessed in the array.
 *
 * @private
 */
                const uhTypeMap = (() => {
                    const result = [];
                    const paramTypeBits = 5;
                    const paramTypeCount = Math.pow(2, paramTypeBits);
                    SMFUH.values.forEach(uh => {
                        result[uh] = [];
                        for (let i = 0; i < paramTypeCount; ++i) {
                            let byte1 = 0;
                            byte1 = Bits.set(byte1, uh, 6, 2);
                            byte1 = Bits.set(byte1, i, 0, paramTypeBits);
                            result[uh][i] = int8ToStr(byte1);
                        }
                    });
                    return result;
                })();
                /**
 * SMF TLV length map LUT
 *
 * lenMap[x] === String.fromCharCode(x)
 *
 * @private
 */
                const lenMap = new Array(256).fill(null).map((_, idx) => int8ToStr(idx));
                /**
 * SMF Lightweight Param LUT
 *
 * lightMap[uh][paramtype][len] is the prefix for an SMF LWP
 * with uh, paramtype and len values as accessed in the array.
 *
 * @private
 */
                const lightMap = (() => {
                    const result = [];
                    const paramTypeBits = 3;
                    const paramTypeCount = Math.pow(2, paramTypeBits);
                    const lenBits = 2;
                    const lenCount = Math.pow(2, lenBits);
                    SMFUH.values.forEach(uh => {
                        result[uh] = [];
                        for (let i = 0; i < paramTypeCount; ++i) {
                            result[uh][i] = [];
                            for (let j = 0; j < lenCount; ++j) {
                                let byte1 = 0;
                                byte1 = Bits.set(byte1, uh, 6, 2);
                                byte1 = Bits.set(byte1, 1, 5, 1);
                                byte1 = Bits.set(byte1, i, 2, 3);
                                byte1 = Bits.set(byte1, j, 0, 2);
                                result[uh][i][j] = int8ToStr(byte1);
                            }
                        }
                    });
                    return result;
                })();
                const ContentSummaryDecodeMap = [ ContentSummaryType.XML_META, ContentSummaryType.XML_PAYLOAD, ContentSummaryType.BINARY_ATTACHMENT, ContentSummaryType.CID_LIST, ContentSummaryType.BINARY_METADATA ];
                const ParamParse = {};
                ParamParse.parseTopicQueueOffsets = function parseTopicQueueOffsets(dataBuf, offset) {
                    const result = [];
                    result[0] = dataBuf.readUInt8(offset);
                    result[1] = dataBuf.readUInt8(offset + 1);
                    return result;
                };
                ParamParse.parseResponseParam = function parseResponseParam(dataBuf, offset, paramLen) {
                    const result = [];
                    result[0] = dataBuf.readInt32BE(offset);
                    if (paramLen > 4) {
                        result[1] = dataBuf.toString("latin1", offset + 4, offset + paramLen);
                    } else {
                        result[1] = "";
                    }
                    return result;
                };
                ParamParse.parseDeliveryMode = function parseDeliveryMode(dataBuf, offset) {
                    const delmode = dataBuf.readUInt8(offset);
                    const lookup = lutDelModeToEnum.value.get(delmode);
                    return lookup !== undefined ? lookup : MessageLib.MessageDeliveryModeType.DIRECT;
                };
                ParamParse.encDeliveryMode = function encDeliveryMode(delmode) {
                    const lut = lutEnumToDelMode.value;
                    const lookup = lut.get(delmode);
                    return int8ToStr(lookup !== undefined ? lookup : MessageLib.MessageDeliveryModeType.DIRECT);
                };
                ParamParse.parseContentSummary = function parseContentSummary(dataBuf, offset, length) {
                    const elements = [];
                    let cumulativeSize = 0;
                    let pos = offset;
                    while (pos < offset + length) {
                        const byte1 = dataBuf.readUInt8(pos);
                        const elementType = Bits.get(byte1, 4, 4);
                        const elementDeclaredLength = Bits.get(byte1, 0, 4);
                        let elementSize = 0;
                        switch (elementDeclaredLength) {
                          case 2:
                            elementSize = dataBuf.readUInt8(pos + 1);
                            break;

                          case 3:
                            elementSize = dataBuf.readUInt16BE(pos + 1);
                            break;

                          case 4:
                            elementSize = dataBuf.readUIntBE(pos + 1, 3);
                            break;

                          case 5:
                            elementSize = dataBuf.readInt32BE(pos + 1);
                            break;

                          default:
                            // Allow 1 and continue;
                            break;
                        }
                        if (elementDeclaredLength === 0) {
                            LOG_ERROR("Invalid content summary parameter - pos not advancing");
                            return null;
                        }
                        pos += elementDeclaredLength;
                        const cst = ContentSummaryDecodeMap[elementType];
                        if (cst === undefined) {
                            LOG_ERROR(`Unhandled element type ${elementType}`);
                        }
                        const currentElement = new ContentSummaryElement(cst, cumulativeSize, elementSize);
                        elements.push(currentElement);
                        cumulativeSize += elementSize;
                    } // end while loop
                    return elements;
                };
                ParamParse.encContentSummary = function encContentSummary(contentSummaryArr) {
                    const messageElementDescriptions = [];
                    for (let i = 0, n = contentSummaryArr.length; i < n; ++i) {
                        // a ContentSummaryElement
                        const currentContentSummary = contentSummaryArr[i];
                        let currentSizeStr = "";
                        let firstByte = Bits.set(0, currentContentSummary.type, 4, 4);
                        if (currentContentSummary.length <= 255) {
                            // element length: 2
                            firstByte = Bits.set(firstByte, 2, 0, 4);
                            currentSizeStr = int8ToStr(currentContentSummary.length);
                        } else if (currentContentSummary.length <= 65535) {
                            firstByte = Bits.set(firstByte, 3, 0, 4);
                            currentSizeStr = int16ToStr(currentContentSummary.length);
                        } else if (currentContentSummary.length <= 16777215) {
                            firstByte = Bits.set(firstByte, 4, 0, 4);
                            currentSizeStr = int24ToStr(currentContentSummary.length);
                        } else {
                            firstByte = Bits.set(firstByte, 5, 0, 4);
                            currentSizeStr = int32ToStr(currentContentSummary.length);
                        }
                        messageElementDescriptions.push(int8ToStr(firstByte));
                        messageElementDescriptions.push(currentSizeStr);
                    }
                    return messageElementDescriptions.join("");
                };
                ParamParse.encodeSMFParam = function encodeSMFParam(uh, paramtype, value) {
                    if (value === undefined) {
                        return uhTypeMap[uh][paramtype] + lenMap[2];
                    }
                    const len = value.length;
                    if (len <= 253) {
                        return uhTypeMap[uh][paramtype] + lenMap[len + 2] + value;
                    }
                    return uhTypeMap[uh][paramtype] + lenMap[0] + int32ToStr(len + 6) + value;
                };
                ParamParse.encodeSMFExtendedParam = function encodeSMFExtendedParam(uh, paramtype, value) {
                    let byte1 = 0;
                    byte1 = Bits.set(byte1, uh ? 1 : 0, 7, 1);
                    const length = value === undefined || value === null ? 0 : value.length;
                    // Bits 1-3 of an extended param (not named in the spec, lengthMode here)
                    // can indicate value lengths 0-8 bytes, or 1-2 byte variable length.
                    const lengthModeMap = {
                        0: 0,
                        1: 1,
                        2: 2,
                        4: 3,
                        8: 4
                    };
                    let lengthMode = 0;
                    let lengthString = "";
                    // EsLint made me do it.
                    if (Object.prototype.hasOwnProperty.call(lengthModeMap, length)) {
                        lengthMode = lengthModeMap[length];
                    } else if (length < 253) {
                        lengthMode = 5;
                        lengthString = int8ToStr(length + 3);
                    } else if (length < 256 * 256 - 4) {
                        lengthMode = 6;
                        lengthString = int16ToStr(length + 4);
                    } else {
                        LOG_ERROR(`Extended parameter type ${paramtype} is too long (${length} bytes) `);
                        throw new OperationError(`Extended parameter (${paramtype}) over the 2^16 byte limit`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                    byte1 = Bits.set(byte1, lengthMode, 4, 3);
                    byte1 = Bits.set(byte1, paramtype >> 8, 0, 4);
                    const byte2 = paramtype & 255;
                    return int8ToStr(byte1) + int8ToStr(byte2) + lengthString + value;
                };
                ParamParse.encLightSMFParam = function encLightSMFParam(uh, paramtype, value) {
                    return lightMap[uh][paramtype][value.length] + value;
                };
                module.exports.ParamParse = ParamParse;
                /***/
            },
            /***/ "./modules/solclient-smf/lib/codec/parse-smf.js": 
            /*!******************************************************!*\
  !*** ./modules/solclient-smf/lib/codec/parse-smf.js ***!
  \******************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const Long = __webpack_require__(/*! long */ "./node_modules/long/umd/index.js");
                const {
                    LOG_DEBUG,
                    LOG_ERROR,
                    LOG_INFO,
                    LOG_TRACE
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    Base64,
                    Bits
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    ParamParse
                } = __webpack_require__(/*! ./param-parse */ "./modules/solclient-smf/lib/codec/param-parse.js");
                const {
                    SMFHeader
                } = __webpack_require__(/*! ../message-objects */ "./modules/solclient-smf/lib/message-objects/api.js");
                const {
                    SMFParameterType
                } = __webpack_require__(/*! ../smf-parameter-types */ "./modules/solclient-smf/lib/smf-parameter-types.js");
                const {
                    decode: base64Decode
                } = Base64;
                const {
                    get: bits
                } = Bits;
                function isSMFHeaderAvailable(dataBuf, offset) {
                    const remaining = dataBuf.length - offset;
                    if (remaining < 12) {
                        return false;
                    }
                    return true;
                }
                function isSMFHeaderValid(dataBuf, offset) {
                    if (!isSMFHeaderAvailable(dataBuf, offset)) {
                        return false;
                    }
                    const version = dataBuf.readUInt8(offset) & 7;
                    if (version !== 3) {
                        LOG_ERROR(`Invalid smf version in smf header, version=${version}`);
                        return false;
                    }
                    return true;
                }
                function isSMFAvailable(dataBuf, offset) {
                    if (!isSMFHeaderValid(dataBuf, offset)) {
                        return false;
                    }
                    const remaining = dataBuf.length - offset;
                    const totalLen = dataBuf.readUInt32BE(offset + 8);
                    return totalLen <= remaining;
                }
                /**
 * Parse the Extended Parameters from an Extended Type Stream.
 * See section "4.2.4 Extended Parameter Types" in the SMF spec.
 * @param {SMFHeader} smfHeader The SMF header to add the extended parameters to.
 * @param {Buffer} dataBuf The binary data to parse
 * @param {Number} offset The offset in the data to begin parsing (ETS payload)
 * @param {Number} streamLen ETS length
 * @returns {Boolean} false if framing is lost, true otherwise.
 * @private
 */
                function parseSMFExtendedStream(smfHeader, dataBuf, offset, streamLen) {
                    /* eslint-disable no-unused-vars */
                    let pos = offset;
                    while (pos < offset + streamLen) {
                        if (pos + 2 > offset + streamLen) {
                            LOG_ERROR("Extended parameter stream had padding inside.");
                            break;
                        }
                        // The first 2 bytes of Extended Parameters is fixed (MSB order):
                        // 1 bit UH
                        // 3 bits length mode selector (0-, 1-, 2-, 4-, 8-byte, or variable)
                        // 12 bits Type
                        const byte1 = dataBuf.readUInt8(pos);
                        const byte2 = dataBuf.readUInt8(pos + 1);
                        const pUH = bits(byte1, 7, 1);
                        const lengthMode = bits(byte1, 4, 3);
                        const type = (bits(byte1, 0, 4) << 8) + byte2; //FIGURE OUT WHAT bits does
                        pos += 2;
                        const lengthModeMap = {
                            0: 0,
                            1: 1,
                            2: 2,
                            3: 4,
                            4: 8
                        };
                        let valueLen = 0;
                        // EsLint made me do it
                        if (Object.prototype.hasOwnProperty.call(lengthModeMap, lengthMode)) {
                            valueLen = lengthModeMap[lengthMode];
                        } else if (lengthMode === 5) {
                            // 1-byte variable length value
                            valueLen = dataBuf.readUInt8(pos) - 3;
                            pos++;
                        } else if (lengthMode === 6) {
                            // 2-byte variable length value
                            valueLen = dataBuf.readUInt16BE(pos) - 4;
                            pos += 2;
                        } else {
                            LOG_ERROR(`Invalid length mode ${lengthMode} in Extended Parameter type ${type}`);
                            // We must be reading garbage, disconnect:
                            return false;
                        }
                        switch (type) {
                          case SMFParameterType.AD_REDELIVERY_COUNT:
                            smfHeader.pm_ad_redeliveryCount = dataBuf.readUInt32BE(pos);
                            break;

                          case SMFParameterType.AD_SPOOLER_UNIQUE_ID:
                            smfHeader.pm_ad_spooler_unique_id = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                            break;

                          case SMFParameterType.AD_ACK_MESSAGE_ID:
                            smfHeader.pm_ad_local_spooler_message_id = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                            break;

                          case SMFParameterType.AD_REPL_MATE_ACK_MSGID:
                            smfHeader.pm_ad_replication_mate_ack_message_id = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                            break;

                          default:
                            if (pUH === 0) {
                                LOG_TRACE("Dropping unrecognised extended parameter " + `type ${type} value length ${valueLen} UH ${pUH}`);
                            } else {
                                smfHeader.discardMessage = true;
                                LOG_TRACE("Dropping whole message due to unrecognised extended parameter " + `type ${type} value length ${valueLen} UH ${pUH}`);
                            }
                            break;
                        }
                        pos += valueLen;
                    }
                    if (pos > offset + streamLen) {
                        LOG_ERROR(`Last extended parameter ran beyond extended stream length by ${pos - (offset + streamLen)}.`);
                    }
                    return true;
                    /* eslint-enable no-unused-vars */
                }
                /**
 * Parse SMF in the given data buffer at the supplied offset.
 * @param {Buffer} dataBuf The binary data to parse
 * @param {Number} offset The offset in the data to begin parsing
 * @param {Boolean} readHeaderOnly If true, stop parsing at end of header
 * @returns {SMFHeader|null} The SMF header, if possible
 * @private
 */
                function parseSMFAt(dataBuf, offset, readHeaderOnly = false) {
                    if (!isSMFHeaderValid(dataBuf, offset)) {
                        LOG_DEBUG("Valid SMF header not available");
                        return null;
                    }
                    let pos = offset;
                    // Reading fixed header block (12 bytes)
                    const word1 = dataBuf.readUInt32BE(pos);
                    const headerLen = dataBuf.readUInt32BE(pos + 4);
                    const word3 = dataBuf.readUInt32BE(pos + 8);
                    const smfHeader = new SMFHeader();
                    smfHeader.smf_di = bits(word1, 31, 1);
                    smfHeader.smf_elidingEligible = bits(word1, 30, 1);
                    smfHeader.smf_dto = bits(word1, 29, 1);
                    smfHeader.smf_adf = bits(word1, 28, 1);
                    smfHeader.smf_deadMessageQueueEligible = bits(word1, 27, 1);
                    smfHeader.smf_version = bits(word1, 24, 3);
                    smfHeader.smf_uh = bits(word1, 22, 2);
                    smfHeader.smf_protocol = bits(word1, 16, 6);
                    smfHeader.smf_priority = bits(word1, 12, 4);
                    smfHeader.smf_ttl = bits(word1, 0, 8);
                    const payloadLen = word3 - headerLen;
                    if (payloadLen < 0) {
                        LOG_ERROR("SMF parse error: lost framing");
                        return null; // SMF parse error: lost framing
                    }
                    smfHeader.setMessageSizes(headerLen, payloadLen);
                    if (readHeaderOnly) {
                        return smfHeader;
                    }
                    pos += 12;
                    // Reading variable-length params
                    const end = offset + headerLen;
                    while (pos < end) {
                        const paramByte1 = dataBuf.readUInt8(pos);
                        ++pos;
                        const prmUh = bits(paramByte1, 6, 2);
                        const paramIsLightweight = bits(paramByte1, 5, 1) !== 0;
                        if (paramIsLightweight) {
                            // LIGHTWEIGHT param
                            const lwpType = bits(paramByte1, 2, 3);
                            const lwpLen = bits(paramByte1, 0, 2) + 1;
                            const lwpValueLen = lwpLen - 1;
                            if (lwpLen <= 0) {
                                LOG_ERROR("Invalid lightweight parameter length");
                                return null; // Invalid parameter
                            }
                            switch (lwpType) {
                              case SMFParameterType.LIGHT_CORRELATION:
                                smfHeader.pm_corrtag = dataBuf.readUIntBE(pos, 3);
                                break;

                              case SMFParameterType.LIGHT_TOPIC_NAME_OFFSET:
                                {
                                    const parsedQueueOffsets = ParamParse.parseTopicQueueOffsets(dataBuf, pos);
                                    smfHeader.pm_queue_offset = parsedQueueOffsets[0];
                                    smfHeader.pm_queue_len = parsedQueueOffsets[1];
                                    break;
                                }

                              case SMFParameterType.LIGHT_QUEUE_NAME_OFFSET:
                                {
                                    const parsedTopicOffsets = ParamParse.parseTopicQueueOffsets(dataBuf, pos);
                                    smfHeader.pm_topic_offset = parsedTopicOffsets[0];
                                    smfHeader.pm_topic_len = parsedTopicOffsets[1];
                                    break;
                                }

                              case SMFParameterType.LIGHT_ACK_IMMEDIATELY:
                                smfHeader.pm_ad_ackimm = !!dataBuf.readUInt8(pos);
                                break;

                              default:
                                if (prmUh === 0) {
                                    // Ignore, and silently discard the parameter.
                                    LOG_TRACE(`Unhandled LIGHTWEIGHT parameter type: ${lwpType} UH is ${prmUh} discarding parameter.`);
                                } else {
                                    // Ignore, and silently discard the entire message.
                                    LOG_TRACE(`Unhandled LIGHTWEIGHT parameter type: ${lwpType} UH is ${prmUh} discarding message.`);
                                    smfHeader.discardMessage = true;
                                }
                                break;
                            }
                            pos += lwpValueLen;
                        } else {
                            // REGULAR encoded param (including breakout for Extended Type Stream)
                            const pStart = pos;
                            const pType = bits(paramByte1, 0, 5);
                            if (pType === 0) {
                                break; // PADDING (break while: header finished)
                            }
                            let pLen = dataBuf.readUInt8(pos);
                            pos++;
                            let pValueLen;
                            if (pLen === 0) {
                                // extended-length parameter (32-bit)
                                // Works for Extended Parameters too.
                                pLen = dataBuf.readUInt32BE(pos);
                                pos += 4;
                                pValueLen = pLen - 6;
                            } else {
                                pValueLen = pLen - 2;
                            }
                            if (pLen <= 0) {
                                LOG_ERROR(`Invalid regular parameter length ${pLen}/${pValueLen} with suspect type ${SMFParameterType.describe(pType)} at parameter at position ${pStart}`);
                                return null; // Invalid parameter
                            }
                            switch (pType) {
                              case SMFParameterType.PUBLISHER_ID:
                                smfHeader.pm_ad_publisher_id = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                                break;

                              case SMFParameterType.PUBLISHER_MSGID:
                                smfHeader.pm_ad_publishermsgid = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                                break;

                              case SMFParameterType.MESSAGEPRIORITY:
                                smfHeader.pm_msg_priority = dataBuf.readUInt8(pos);
                                break;

                              case SMFParameterType.USERDATA:
                                smfHeader.pm_userdata = dataBuf.toString("latin1", pos, pos + pValueLen);
                                break;

                              case SMFParameterType.USERNAME:
                                // only useful on API -> router
                                smfHeader.pm_username = base64Decode(dataBuf.toString("latin1", pos, pos + pValueLen));
                                break;

                              case SMFParameterType.PASSWORD:
                                // only useful on API -> router
                                smfHeader.pm_password = base64Decode(dataBuf.toString("latin1", pos, pos + pValueLen));
                                break;

                              case SMFParameterType.RESPONSE:
                                {
                                    const parsedResponse = ParamParse.parseResponseParam(dataBuf, pos, pValueLen); //CHECK
                                    smfHeader.pm_respcode = parsedResponse[0];
                                    smfHeader.pm_respstr = parsedResponse[1];
                                    break;
                                }

                              case SMFParameterType.SUB_ID_LIST:
                              case SMFParameterType.GENERIC_ATTACHMENT:
                              case SMFParameterType.BINARY_ATTACHMENT:
                                LOG_INFO("Skipping deprecated parameter type");
                                // deprecated
                                break;

                              case SMFParameterType.DELIVERY_MODE:
                                // DeliveryMode is DIRECT unless the AD flag is set. The
                                // deliveryMode parameter (and all other guaranteed messaging
                                // parameters may be present in demoted messages reflecting how
                                // the message was published.
                                // IF ever solClientJS must support the horror that is cut-through
                                // persistence, then we must defer setting deliveryMode back to
                                // DIRECT until the session decides whether it is a true direct
                                // message or a cut-through direct message.  But until that is
                                // forced upon us, the cleanest place to set deliveryMode is always
                                // here in the parser.
                                if (smfHeader.smf_adf) {
                                    smfHeader.pm_deliverymode = ParamParse.parseDeliveryMode(dataBuf, pos);
                                }
                                break;

                              case SMFParameterType.ASSURED_MESSAGE_ID:
                                smfHeader.pm_ad_msgid = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                                break;

                              case SMFParameterType.ASSURED_PREVMESSAGE_ID:
                                smfHeader.pm_ad_prevmsgid = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                                break;

                              case SMFParameterType.ASSURED_REDELIVERED_FLAG:
                                smfHeader.pm_ad_redelflag = true;
                                break;

                              case SMFParameterType.AD_TIMETOLIVE:
                                smfHeader.pm_ad_ttl = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                                break;

                              case SMFParameterType.AD_TOPICSEQUENCE_NUMBER:
                                smfHeader.pm_ad_topicSequenceNumber = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                                break;

                              case SMFParameterType.MESSAGE_CONTENT_SUMMARY:
                                {
                                    const contentSummary = ParamParse.parseContentSummary(dataBuf, pos, pValueLen);
                                    if (!contentSummary) {
                                        LOG_ERROR(`Invalid message content summary at ${pos}, len ${pValueLen}`);
                                        return false; // invalid message content summary parameter
                                    }
                                    smfHeader.pm_content_summary = contentSummary;
                                    break;
                                }

                              case SMFParameterType.ASSURED_FLOWID:
                                smfHeader.pm_ad_flowid = dataBuf.readUInt32BE(pos);
                                break;

                              case SMFParameterType.TR_TOPICNAME:
                                // copy bytes. Don't strip null terminator
                                smfHeader.pm_tr_topicname_bytes = dataBuf.toString("latin1", pos, pos + pValueLen);
                                break;

                              case SMFParameterType.AD_FLOWREDELIVERED_FLAG:
                                smfHeader.pm_ad_flowredelflag = true;
                                break;

                              case SMFParameterType.EXTENDED_TYPE_STREAM:
                                {
                                    const extSuccess = parseSMFExtendedStream(smfHeader, dataBuf, pos, pValueLen);
                                    if (!extSuccess) {
                                        return null;
                                    }
                                    break;
                                }

                              default:
                                if (prmUh === 0) {
                                    // Ignore, and silently discard the parameter.
                                    LOG_TRACE(`Unhandled SMF parameter type: ${pType} UH is ${prmUh} discarding parameter.`);
                                } else {
                                    // Ignore, and silently discard the entire message.
                                    LOG_TRACE(`Unhandled SMF parameter type: ${pType} UH is ${prmUh} discarding message.`);
                                    smfHeader.discardMessage = true;
                                }
                                break;
                            } // end param type switch block
                            pos += pValueLen;
                        } // end (regular param)
                    } // end while
                    return smfHeader;
                }
                const ParseSMF = {
                    isSMFHeaderAvailable: isSMFHeaderAvailable,
                    isSMFHeaderValid: isSMFHeaderValid,
                    isSMFAvailable: isSMFAvailable,
                    parseSMFAt: parseSMFAt
                };
                module.exports.ParseSMF = ParseSMF;
                /***/
            },
            /***/ "./modules/solclient-smf/lib/codec/priority-user-cos-map.js": 
            /*!******************************************************************!*\
  !*** ./modules/solclient-smf/lib/codec/priority-user-cos-map.js ***!
  \******************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const MessageLib = __webpack_require__(/*! solclient-message */ "./modules/solclient-message/api.js");
                const {
                    BidiMap
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                class PriorityUserCosMap extends BidiMap {
                    constructor() {
                        super([ MessageLib.MessageUserCosType.COS1, 0 ], [ MessageLib.MessageUserCosType.COS2, 1 ], [ MessageLib.MessageUserCosType.COS3, 2 ]);
                    }
                }
                module.exports.PriorityUserCosMap = PriorityUserCosMap;
                /***/
            },
            /***/ "./modules/solclient-smf/lib/codec/smp.js": 
            /*!************************************************!*\
  !*** ./modules/solclient-smf/lib/codec/smp.js ***!
  \************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Bits,
                    Convert
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    LOG_DEBUG,
                    LOG_TRACE
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    SMFSMPMessageType
                } = __webpack_require__(/*! ../smf-smp-message-types */ "./modules/solclient-smf/lib/smf-smp-message-types.js");
                const {
                    SMPMessage
                } = __webpack_require__(/*! ../message-objects */ "./modules/solclient-smf/lib/message-objects/api.js");
                const {
                    get: bits,
                    set: setBits
                } = Bits;
                const {
                    int8ToStr,
                    int32ToStr
                } = Convert;
                const SMP = {};
                SMP.parseSMPAt = function parseSMPAt(dataBuf, offset) {
                    if (offset + 6 > dataBuf.length) {
                        // not enough data
                        LOG_DEBUG("Not enough data to read an SMP message.");
                        return false;
                    }
                    let pos = offset;
                    const onebyte = dataBuf.readUInt8(pos);
                    pos++;
                    // var msgUh = bits(onebyte, 7, 1);
                    const msgType = bits(onebyte, 0, 7);
                    const smpMsg = new SMPMessage();
                    if (!(msgType === SMFSMPMessageType.ADDSUBSCRIPTION || msgType === SMFSMPMessageType.REMSUBSCRIPTION || msgType === SMFSMPMessageType.ADDQUEUESUBSCRIPTION || msgType === SMFSMPMessageType.REMQUEUESUBSCRIPTION)) {
                        LOG_DEBUG(`Found unsupported SMP messageType ${msgType}`);
                        return false; // unsupported type
                    }
                    LOG_TRACE("SMP.parseSMPAt called, ", dataBuf.toString("latin1"));
                    const msgLength = dataBuf.readUInt32BE(pos);
                    pos += 4;
                    if (offset + msgLength > dataBuf.length) {
                        // not enough data
                        LOG_DEBUG(`Invalid declared length of ${msgLength}, unable to read SMP message.`);
                        return false;
                    }
                    const msgFlags = dataBuf.readUInt8(pos);
                    pos++;
                    smpMsg.msgType = msgType;
                    smpMsg.smpFlags = msgFlags;
                    if (msgType === SMFSMPMessageType.ADDSUBSCRIPTION || msgType === SMFSMPMessageType.REMSUBSCRIPTION) {
                        // 6 is the base len (msgLength - 6)
                        smpMsg.encodedUtf8Subscription = dataBuf.toString("latin1", pos, pos + msgLength - 6);
                    } else {
                        const queueLength = dataBuf.readUInt8(pos);
                        pos++;
                        smpMsg.encodedUtf8QueueName = dataBuf.toString("latin1", pos, pos + queueLength);
                        pos += queueLength;
                        const subsLength = dataBuf.readUInt8(pos);
                        pos++;
                        smpMsg.encodedUtf8Subscription = dataBuf.toString("latin1", pos, pos + subsLength);
                        pos += subsLength;
                    }
                    return smpMsg;
                };
                SMP.encSmp = function encSmp(smpMsg) {
                    if (!(smpMsg.msgType === SMFSMPMessageType.ADDSUBSCRIPTION || smpMsg.msgType === SMFSMPMessageType.REMSUBSCRIPTION || smpMsg.msgType === SMFSMPMessageType.ADDQUEUESUBSCRIPTION || smpMsg.msgType === SMFSMPMessageType.REMQUEUESUBSCRIPTION)) {
                        LOG_DEBUG(`Unsupported SMP message for encoding: ${smpMsg}`);
                        return false;
                    }
                    LOG_TRACE("encSmp called.", smpMsg);
                    const data = [];
                    let onebyte = 0;
                    onebyte = setBits(onebyte, 1, 7, 1);
                    onebyte = setBits(onebyte, smpMsg.msgType, 0, 7);
                    data.push(int8ToStr(onebyte));
                    let msgLength = 6 + smpMsg.encodedUtf8Subscription.length;
                    if (smpMsg.msgType === SMFSMPMessageType.ADDQUEUESUBSCRIPTION || smpMsg.msgType === SMFSMPMessageType.REMQUEUESUBSCRIPTION) {
                        msgLength += 2 + smpMsg.encodedUtf8QueueName.length; //both strings have a 1-byte length.
                    }
                    data.push(int32ToStr(msgLength)); // length
                    data.push(int8ToStr(smpMsg.smpFlags));
                    if (smpMsg.msgType === SMFSMPMessageType.ADDQUEUESUBSCRIPTION || smpMsg.msgType === SMFSMPMessageType.REMQUEUESUBSCRIPTION) {
                        //TODO: validate the lengths are < 251 including null termination!
                        // Somewhere else though.
                        data.push(int8ToStr(smpMsg.encodedUtf8QueueName.length));
                        data.push(smpMsg.encodedUtf8QueueName);
                        data.push(int8ToStr(smpMsg.encodedUtf8Subscription.length));
                        data.push(smpMsg.encodedUtf8Subscription);
                    } else {
                        data.push(smpMsg.encodedUtf8Subscription);
                    }
                    return data.join("");
                };
                module.exports.SMP = SMP;
                /***/
            },
            /***/ "./modules/solclient-smf/lib/codec/transport.js": 
            /*!******************************************************!*\
  !*** ./modules/solclient-smf/lib/codec/transport.js ***!
  \******************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Bits,
                    Convert
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    Lazy
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                const {
                    LOG_ERROR
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    SMFTransportSessionMessageType
                } = __webpack_require__(/*! ../smf-transport-session-message-types */ "./modules/solclient-smf/lib/smf-transport-session-message-types.js");
                const {
                    TransportSMFMessage
                } = __webpack_require__(/*! ../message-objects */ "./modules/solclient-smf/lib/message-objects/api.js");
                const {
                    get: bits
                } = Bits;
                const {
                    int16ToStr,
                    int32ToStr
                } = Convert;
                const {
                    lazyValue
                } = Lazy;
                // ========== TSSMF ==========
                function remains(dataBuf, offset) {
                    return dataBuf.length - offset;
                }
                function parseTsSmfHdrAt(dataBuf, offset, smfheader) {
                    let pos = offset;
                    if (remains(dataBuf, pos) < 10) {
                        LOG_ERROR("TsSmf parse failed: not enough data, expected at least 10B");
                        return false;
                    }
                    const transportSMFMessage = new TransportSMFMessage();
                    transportSMFMessage.smfHeader = smfheader;
                    const twobyte = dataBuf.readUInt16BE(pos);
                    pos += 2;
                    transportSMFMessage.uh = bits(twobyte, 15, 1);
                    transportSMFMessage.messageType = bits(twobyte, 8, 7);
                    const tsHdrLen = bits(twobyte, 0, 8);
                    transportSMFMessage.tsHeaderLength = tsHdrLen;
                    transportSMFMessage.sessionId = dataBuf.toString("latin1", pos, pos + 8);
                    pos += 8;
                    if (transportSMFMessage.messageType === SMFTransportSessionMessageType.CREATE_RESP) {
                        // parse extra chunk: routerTag
                        const rtrTagLen = dataBuf.readUInt8(pos);
                        pos++;
                        if (remains(dataBuf, pos) < rtrTagLen) {
                            LOG_ERROR(`TsSmf parse failed: not enough data for RouterTag, expected ${rtrTagLen}B`);
                            return false;
                        }
                        transportSMFMessage.routerTag = dataBuf.toString("latin1", pos, pos + rtrTagLen);
                        pos += rtrTagLen;
                    }
                    // FFWD any remaining TsSmf padding?
                    pos = offset + tsHdrLen;
                    // Length of encapsulated message payload:
                    // the SMF msg payload length - bytes consumed in TsSmf
                    if (smfheader.payloadLength === 4294967295) {
                        // special "streaming" unknown-length header
                        transportSMFMessage.payloadLength = smfheader.payloadLength;
                    } else {
                        transportSMFMessage.payloadLength = smfheader.payloadLength - tsHdrLen;
                    }
                    return transportSMFMessage; // Header with no payload field
                }
                // Generates an SMF header up to, but not including the the total length
                // This is fixed for all client generated transport session messages
                const tsHeaderPreLength = lazyValue(() => int32ToStr(51642369) + // SMF version, TransportSession, TTL
                int32ToStr(12) // Header length
                );
                const tsDestroyHeaderPreSid = lazyValue(() => tsHeaderPreLength.value + // Header up to the message length field
                int32ToStr(22) + // Total length
                int16ToStr(33290) // msgType(destroy), length
                );
                const tsCreateHeader = lazyValue(() => tsHeaderPreLength.value + // Header up to the message length field
                int32ToStr(22) + // Total length
                int16ToStr(32778) + // msgType(create), length
                int32ToStr(0) + // Session ID (first half)
                int32ToStr(0) // Session ID (second half)
                );
                const tsDataTokenPreSid = lazyValue(() => int32ToStr(60030977) + int32ToStr(12) + int32ToStr(22) + int16ToStr(34058));
                const tsDataStreamTokenPreSid = lazyValue(() => int32ToStr(60030977) + int32ToStr(12) + int32ToStr(24) + int16ToStr(34316));
                // Generate a full Transport Session Create header
                function genTsCreateHeader() {
                    return tsCreateHeader.value;
                }
                // Generate a full Transport Session Destroy header
                function genTsDestroyHeader(sid) {
                    return tsDestroyHeaderPreSid.value + sid;
                }
                // Generate a data token message
                function genTsDataTokenMsg(sid) {
                    return tsDataTokenPreSid.value + sid;
                }
                // Generate a STREAMING data token message
                function genTsDataStreamTokenMsg(sid, paddingBytes) {
                    return tsDataStreamTokenPreSid.value + sid + (paddingBytes && paddingBytes > 0 ? int16ToStr(paddingBytes) : int16ToStr(0));
                }
                function genTsDataMsgHeaderParts(sid) {
                    return [ int32ToStr(60030977) + int32ToStr(12), int16ToStr(33802) + sid ];
                }
                function parseTsSmfMsgAt(dataBuf, offset, smfheader) {
                    const transportSMFMessage = parseTsSmfHdrAt(dataBuf, offset, smfheader);
                    if (!transportSMFMessage) {
                        return null;
                    }
                    // need to FF to pos
                    const pos = offset + transportSMFMessage.tsHeaderLength;
                    // Length of encapsulated message payload:
                    // the SMF msg payload length - bytes consumed in TsSmf
                    if (remains(dataBuf, pos) < transportSMFMessage.payloadLength) {
                        LOG_ERROR(`Couldn't read full encapsulated TsSmf payload, expected ${transportSMFMessage.payloadLength}B`);
                        return null;
                    }
                    transportSMFMessage.payload = dataBuf.slice(pos, pos + transportSMFMessage.payloadLength);
                    return transportSMFMessage;
                }
                const Transport = {
                    genTsCreateHeader: genTsCreateHeader,
                    genTsDestroyHeader: genTsDestroyHeader,
                    genTsDataTokenMsg: genTsDataTokenMsg,
                    genTsDataStreamTokenMsg: genTsDataStreamTokenMsg,
                    genTsDataMsgHeaderParts: genTsDataMsgHeaderParts,
                    parseTsSmfHdrAt: parseTsSmfHdrAt,
                    parseTsSmfMsgAt: parseTsSmfMsgAt
                };
                module.exports.Transport = Transport;
                /***/
            },
            /***/ "./modules/solclient-smf/lib/message-objects/adprotocol-message.js": 
            /*!*************************************************************************!*\
  !*** ./modules/solclient-smf/lib/message-objects/adprotocol-message.js ***!
  \*************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /**
 * Created by rpaulson on 06/02/2017.
 */
                const {
                    BaseMessage
                } = __webpack_require__(/*! ./base-message */ "./modules/solclient-smf/lib/message-objects/base-message.js");
                const {
                    Convert,
                    Long
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    DestinationType
                } = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                const {
                    LOG_TRACE
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    QueueAccessType,
                    QueueDiscardBehavior
                } = __webpack_require__(/*! solclient-queue */ "./modules/solclient-queue/api.js");
                const {
                    QueuePermissions,
                    QueueType
                } = __webpack_require__(/*! solclient-queue */ "./modules/solclient-queue/api.js");
                const {
                    ReplayStartType
                } = __webpack_require__(/*! solclient-replaystart */ "./modules/solclient-replaystart/api.js");
                const {
                    SMFAdProtocolMessageType
                } = __webpack_require__(/*! ../smf-adprotocol-message-types */ "./modules/solclient-smf/lib/smf-adprotocol-message-types.js");
                const {
                    SMFAdProtocolParam
                } = __webpack_require__(/*! ../smf-adprotocol-params */ "./modules/solclient-smf/lib/smf-adprotocol-params.js");
                const {
                    SMFHeader
                } = __webpack_require__(/*! ./smf-header */ "./modules/solclient-smf/lib/message-objects/smf-header.js");
                const {
                    SMFParameter
                } = __webpack_require__(/*! ./smf-parameter */ "./modules/solclient-smf/lib/message-objects/smf-parameter.js");
                const {
                    SMFProtocol
                } = __webpack_require__(/*! ../smf-protocols */ "./modules/solclient-smf/lib/smf-protocols.js");
                const {
                    SMFUH
                } = __webpack_require__(/*! ./smf-uh */ "./modules/solclient-smf/lib/message-objects/smf-uh.js");
                const {
                    StringUtils
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                // eslint-disable-next-line global-require
                const BufferImpl = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;
                const {
                    strToInt8,
                    strToInt16,
                    strToUInt32,
                    strToUInt64
                } = Convert;
                const bUInt8 = BufferImpl.prototype.readUInt8;
                const bUInt16BE = BufferImpl.prototype.readUInt16BE;
                const bUInt32BE = BufferImpl.prototype.readUInt32BE;
                const bUInt64BE = function bUInt64BE(pos) {
                    // invoked with "this" as the buffer.
                    return Long.fromBits(this.readUInt32BE(pos + 4), this.readUInt32BE(pos), true);
                };
                const {
                    nullTerminate,
                    stripNullTerminate
                } = StringUtils;
                // QUEUENAME/TOPICNAME
                const EndpointTypeToParam = {
                    [DestinationType.TOPIC]: SMFAdProtocolParam.DTENAME,
                    [DestinationType.QUEUE]: SMFAdProtocolParam.QUEUENAME
                };
                //Same as above, but for CREATE.
                const QueueDescriptorTypeToParam = {
                    [QueueType.TOPIC_ENDPOINT]: SMFAdProtocolParam.DTENAME,
                    [QueueType.QUEUE]: SMFAdProtocolParam.QUEUENAME
                };
                const QUEUE_PERMISSIONS_TO_BITS = {
                    [QueuePermissions.NONE]: 0,
                    [QueuePermissions.READ_ONLY]: 1,
                    [QueuePermissions.CONSUME]: 3,
                    [QueuePermissions.MODIFY_TOPIC]: 7,
                    [QueuePermissions.DELETE]: 15
                };
                const ACCESS_TYPE_INT_TO_ENUM = {
                    1: QueueAccessType.EXCLUSIVE,
                    2: QueueAccessType.NONEXCLUSIVE
                };
                const ACCESS_TYPE_ENUM_TO_BITS = {
                    [QueueAccessType.EXCLUSIVE]: 1,
                    [QueueAccessType.NONEXCLUSIVE]: 2
                };
                const DISCARD_ENUM_TO_VALUE = {
                    [QueueDiscardBehavior.NOTIFY_SENDER_OFF]: 1,
                    [QueueDiscardBehavior.NOTIFY_SENDER_ON]: 2
                };
                function addQueueProperties(message, queueProperties, skipAccessType = false) {
                    if (!queueProperties) {
                        return;
                    }
                    const {
                        accessType,
                        discardBehavior,
                        maxMessageRedelivery,
                        maxMessageSize,
                        permissions,
                        quotaMB,
                        respectsTTL
                    } = queueProperties;
                    // [AssuredCtrl AllOthersPermissions Parameter]
                    if (permissions && QUEUE_PERMISSIONS_TO_BITS[permissions] !== undefined) {
                        message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.EP_ALLOTHER_PERMISSION, QUEUE_PERMISSIONS_TO_BITS[permissions]));
                    }
                    //AccessType
                    if (!skipAccessType && accessType !== undefined && ACCESS_TYPE_ENUM_TO_BITS[accessType] !== undefined) {
                        message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.ACCESSTYPE, ACCESS_TYPE_ENUM_TO_BITS[accessType]));
                    }
                    // [AssuredCtrl EndpointQuotaMB Parameter]
                    if (quotaMB !== null && quotaMB !== undefined) {
                        message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.EP_QUOTA, quotaMB));
                    }
                    // [AssuredCtrl EndpointMaxMessageSize Parameter]
                    if (maxMessageSize !== undefined && maxMessageSize !== null) {
                        message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.EP_MAX_MSGSIZE, maxMessageSize));
                    }
                    let flags = 0;
                    if (discardBehavior !== null && discardBehavior !== undefined) {
                        const discardBehaviorValue = DISCARD_ENUM_TO_VALUE[discardBehavior];
                        flags |= discardBehaviorValue << 12;
                        // Omit cutThrough, << 14
                    }
                    if (flags /* is nonzero */) {
                        message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.EP_BEHAVIOUR, flags));
                    }
                    if (maxMessageRedelivery !== undefined && maxMessageRedelivery !== null) {
                        message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.MAX_REDELIVERY, maxMessageRedelivery));
                    }
                    if (respectsTTL !== undefined && respectsTTL !== null) {
                        message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.EP_RESPECTS_TTL, respectsTTL ? 1 : 0));
                    }
                }
                /**
 * @internal
 */
                class AdProtocolMessage extends BaseMessage {
                    /**
   * @constructor
   * @param {SMFAdProtocolMessageType} [messageType=SMFAdProtocolMessageType.OPENPUBFLOW]
   *  The type of message
   * @param {Number} [version=3] The AD protocol version for the message
   * @extends {BaseMessage}
   * @memberof solace
   * @internal
   */
                    constructor(messageType = 0, version = 3) {
                        super(new SMFHeader(SMFProtocol.ADCTRL, 1));
                        // Field: msgtype
                        this.msgType = messageType;
                        // Field: version
                        this.version = version;
                    }
                    _readParameter(paramtype, decoder = null, bufMethod = null) {
                        const param = this.getParameter(paramtype);
                        if (param === undefined) return undefined;
                        if (bufMethod && param.getBuffer()) {
                            return bufMethod.call(param.getBuffer(), param.getBegin());
                        }
                        const value = param.getValue();
                        return decoder ? decoder(value) : value;
                    }
                    /**
   * @returns {?QueueAccessType} The access type, if present
   */
                    getAccessType() {
                        const param = this._readParameter(SMFAdProtocolParam.ACCESSTYPE, strToInt8, bUInt8);
                        return ACCESS_TYPE_INT_TO_ENUM[param];
                    }
                    /**
   * @returns {?Boolean} The active flow indication, if present
   */
                    getActiveFlow() {
                        return this._readParameter(SMFAdProtocolParam.ACTIVE_FLOW_INDICATION, strToInt8, bUInt8);
                    }
                    /**
   * @returns {?QueueDiscardBehavior} The discard behavior for the endpoint, if present
   */
                    getQueueDiscardBehavior() {
                        const param = this._readParameter(SMFAdProtocolParam.EP_BEHAVIOUR, strToInt16, bUInt16BE);
                        if (param === undefined) {
                            return undefined;
                        }
                        // Get NotifySender flag
                        const masked = (param & 12288) >> 12;
                        if (masked === DISCARD_ENUM_TO_VALUE[QueueDiscardBehavior.NOTIFY_SENDER_OFF]) {
                            return QueueDiscardBehavior.NOTIFY_SENDER_OFF;
                        } else if (masked === DISCARD_ENUM_TO_VALUE[QueueDiscardBehavior.NOTIFY_SENDER_ON]) {
                            return QueueDiscardBehavior.NOTIFY_SENDER_ON;
                        }
                        return undefined;
                    }
                    /**
   * @returns {?Boolean} The Delivery Count setting of the endpoint, if present
   */
                    getEndpointDeliveryCountSent() {
                        const param = this._readParameter(SMFAdProtocolParam.EP_BEHAVIOUR, strToInt16, bUInt16BE);
                        // Get NotifySender flag
                        const masked = (param & 3072) >> 10;
                        switch (masked) {
                          case 0:
                            return undefined;

                          case 1:
                            return false;

                          case 2:
                            return true;

                          default:
                            //TODO: log: invalid flag value.
                            return undefined;
                        }
                    }
                    /**
   * @returns {?Number} The endpoint ID, if present
   */
                    getEndpointId() {
                        return this._readParameter(SMFAdProtocolParam.ENDPOINT_ID, strToUInt32, bUInt32BE);
                    }
                    /**
   * @returns {?Boolean} Whether endpoint respects TTL
   */
                    getRespectsTTL() {
                        const value = this._readParameter(SMFAdProtocolParam.EP_RESPECTS_TTL, strToInt8, bUInt8);
                        if (value === undefined) {
                            LOG_TRACE("respectsTTL missing from response.");
                            return undefined;
                        }
                        LOG_TRACE(`respectsTTL present in response: ${value}`);
                        return !!value;
                    }
                    /**
   * @returns {?String} The router-assigned flow name, if present
   */
                    getFlowName() {
                        return this._readParameter(SMFAdProtocolParam.FLOWNAME, stripNullTerminate);
                    }
                    /**
   * @returns {?Number} The router-assigned flow ID, if present
   */
                    getFlowId() {
                        return this._readParameter(SMFAdProtocolParam.FLOWID, strToUInt32, bUInt32BE);
                    }
                    /**
   * @returns {?Number} The quota on the endpoint, if present
   */
                    getQuota() {
                        return this._readParameter(SMFAdProtocolParam.EP_QUOTA, strToUInt32, bUInt32BE);
                    }
                    /**
   * @returns {?Number} The maximum message size of the endpoint, if present
   */
                    getMaxMsgSize() {
                        return this._readParameter(SMFAdProtocolParam.EP_MAX_MSGSIZE, strToUInt32, bUInt32BE);
                    }
                    /**
   * @returns {?String} The UTF-8 encoded, null terminated endpoint name
   */
                    getTopicEndpointBytes() {
                        return this._readParameter(SMFAdProtocolParam.DTENAME);
                    }
                    /**
   * @returns {?QueuePermissions} The granted permissions for the flow, if present
   */
                    getGrantedPermissions() {
                        const permissions = this._readParameter(SMFAdProtocolParam.GRANTED_PERMISSIONS, strToUInt32, bUInt32BE);
                        let result;
                        Object.keys(QUEUE_PERMISSIONS_TO_BITS).forEach(key => {
                            if (QUEUE_PERMISSIONS_TO_BITS[key] === permissions) {
                                result = key;
                            }
                        });
                        return result;
                    }
                    /**
   * @returns {?QueuePermissions} The permissions for other users for the endpoint, if present
   */
                    getAllOthersPermissions() {
                        const permissions = this._readParameter(SMFAdProtocolParam.EP_ALLOTHER_PERMISSION, strToUInt32, bUInt32BE);
                        let result;
                        Object.keys(QUEUE_PERMISSIONS_TO_BITS).forEach(key => {
                            if (QUEUE_PERMISSIONS_TO_BITS[key] === permissions) {
                                result = key;
                            }
                        });
                        return result;
                    }
                    /**
   * @returns {?Long} The last message ID acked, if present
   */
                    getLastMsgIdAcked() {
                        return this._readParameter(SMFAdProtocolParam.LASTMSGIDACKED, strToUInt64, bUInt64BE);
                    }
                    /**
   * @returns {?Long} The last message ID received, if present
   */
                    getLastMsgIdReceived() {
                        return this._readParameter(SMFAdProtocolParam.LASTMSGIDRECEIVED, strToUInt64, bUInt64BE);
                    }
                    /**
   * @returns {?Number} The publisher ID, if present
   */
                    getPublisherId() {
                        return this._readParameter(SMFAdProtocolParam.PUBLISHER_ID, strToUInt32, bUInt32BE);
                    }
                    /**
   * @returns {?Number} Whether we want flow change notifications, if present
   */
                    getWantFlowChangeNotify() {
                        return !!this._readParameter(SMFAdProtocolParam.WANT_FLOW_CHANGE_NOTIFY, strToInt8, bUInt8);
                    }
                    /**
   * @returns {?Number} The Window parameter, if present
   */
                    getWindow() {
                        return this._readParameter(SMFAdProtocolParam.WINDOW, strToInt8, bUInt8);
                    }
                    /**
   * @returns {?Number} The max redelivery parameter, if present
   */
                    getMaxRedelivery() {
                        return this._readParameter(SMFAdProtocolParam.MAX_REDELIVERY, strToInt8, bUInt8);
                    }
                    /**
   * @returns {?Number} The max unacked messages parameter, if present
   */
                    getMaxUnackedMessages() {
                        return this._readParameter(SMFAdProtocolParam.MAX_DELIVERED_UNACKED_MESSAGES_PER_FLOW, strToUInt32, bUInt32BE);
                    }
                    /**
   * @returns {?Long} The endpointErrorId, if present
   */
                    getEndpointErrorId() {
                        return this._readParameter(SMFAdProtocolParam.ENDPOINT_ERROR_ID, strToUInt64, bUInt64BE);
                    }
                    /**
   * @returns {?Long} The spoolerUniqueId, if present
   */
                    getSpoolerUniqueId() {
                        return this._readParameter(SMFAdProtocolParam.SPOOLER_UNIQUE_ID, strToUInt64, bUInt64BE);
                    }
                    /**
   * Creates a CLOSEPUBFLOW message
   * @param {Number} flowId The publisher flow to close
   * @param {Number} correlationTag The correlation tag for the request
   * @returns {AdProtocolMessage} The newly created message
   * @internal
   * @static
   */
                    static getCloseMessagePublisher(flowId, correlationTag) {
                        const message = new AdProtocolMessage(SMFAdProtocolMessageType.CLOSEPUBFLOW);
                        const header = message.smfHeader;
                        header.pm_corrtag = correlationTag;
                        message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.FLOWID, flowId));
                        return message;
                    }
                    /**
   * Creates a CREATE message
   * @param {solace.QueueDescriptor} queueDescriptor The endpoint descriptor for the create request
   * @param {?solace.QueueProperties} queueProperties The properties for the create request
   * @param {Number} correlationTag The correlation tag for the request
   * @returns {AdProtocolMessage} The newly created message
   * @internal
   * @static
   */
                    static getCreate(queueDescriptor, queueProperties, correlationTag) {
                        const message = new AdProtocolMessage(SMFAdProtocolMessageType.CREATE);
                        const header = message.smfHeader;
                        header.pm_corrtag = correlationTag;
                        /*
      {AssuredCtrl QueueName|TopicEndpointName Parameter}
      {AssuredCtrl Durability Parameter}
      [AssuredCtrl AllOthersPermission Parameter]
      [AssuredCtrl AccessType Parameter]
    [AssuredCtrl EndpointQuotaMB Parameter]
    [AssuredCtrl EndpointMaxMessageSize Parameter]
    [AssuredCtrl qEndpointBehaviourFlags Parameter]
    [AssuredCtrl MaxRedelivery Parameter]
    */
                        // QueueName/TopicEndpointName : different param type for TE vs queue
                        const endpointTypeParam = QueueDescriptorTypeToParam[queueDescriptor.type];
                        if (endpointTypeParam === undefined) throw new OperationError("Unknown destination type");
                        message.addParameter(new SMFParameter(SMFUH.REJECT, endpointTypeParam, nullTerminate(queueDescriptor.name)));
                        // [AssuredCtrl Durability Parameter]
                        message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.EP_DURABLE, queueDescriptor.durable));
                        addQueueProperties(message, queueProperties);
                        return message;
                    }
                    /**
   * Returns an AdProtocolMessage that describes a publisher open-flow request.
   * @static
   * @param {?Long} lastMsgIdAcked Last message ID acked, if re-opening
   * @param {?Long} lastMsgIdSent Last message ID sent, if re-opening
   * @param {Number} windowSize Desired window size
   * @param {String} flowName Last flow name in use, if re-opening
   * @param {Number} correlationTag Correlation tag for the request
   * @returns {solace.AdProtocolMessage} The OPENPUBFLOW message
   * @internal
   */
                    static getOpenMessagePublisher(lastMsgIdAcked, lastMsgIdSent, windowSize, flowName, correlationTag) {
                        const adMsg = new AdProtocolMessage(SMFAdProtocolMessageType.OPENPUBFLOW);
                        const smfHeader = adMsg.smfHeader;
                        smfHeader.pm_corrtag = correlationTag;
                        if (lastMsgIdAcked !== undefined) {
                            adMsg.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.LASTMSGIDACKED, lastMsgIdAcked));
                        }
                        if (lastMsgIdSent !== undefined) {
                            adMsg.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.LASTMSGIDSENT, lastMsgIdSent));
                        }
                        adMsg.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.WINDOW, windowSize));
                        adMsg.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.FLOWNAME, flowName || ""));
                        LOG_TRACE(`Create open publisher: lastMsgIdAcked=${lastMsgIdAcked} lastMsgIdSent=${lastMsgIdSent} window=${windowSize} flowName=${flowName || "(null)"}`);
                        return adMsg;
                    }
                    /**
   * Returns an AdProtocolMessage that describes a subscriber (MessageConsumer) bind request.
   * @static
   * @param {solace.QueueDescriptor} queueDescriptor The endpoint descriptor for the bind request
   * @param {?solace.QueueProperties} queueProperties The properties for the bind request
   * @param {solace.Destination} endpoint The endpoint for the bind request
   * @param {?solace.Topic} topicSubscription The topic endpoint
   * @param {String} correlationTag The correlation tag for the request
   * @param {Number} windowSize The desired window size
   * @param {Boolean} [noLocal=false] If true, local publisher messages are not delivered
   * @param {Boolean} [wantFlowChangeUpdate] default is true if destination is a {solace.Queue}
   * @param {Long} [lastMsgIdAcked=Long.UZERO] Last message ID acked, if re-binding
   * @param {Long} [lastMsgIdReceived=Long.UZERO] Last message ID received, if re-binding
   * @param {Boolean} [browser=false] If true, flow is a queue browser
   * @param {ReplayStartLocation} [replayStartLocation=undefined] If set messages
   *         are first retrieved from the replay log before live messages are received.
   * @param {Long} [endpointErrorId=undefined] Endpoint Error ID identifying the flow
   *         when rebinding.
   * @returns {solace.AdProtocolMessage} The BIND message
   * @internal
   */
                    static getOpenMessageConsumer(queueDescriptor, queueProperties, endpoint, topicSubscription, correlationTag, windowSize, noLocal, wantFlowChangeUpdate, lastMsgIdAcked = Long.UZERO, lastMsgIdReceived = Long.UZERO, browser = false, replayStartLocation = undefined, endpointErrorId = undefined) {
                        /*
    QUEUE FLOW                                      TE FLOW

    {SMF Header, protocol=AssuredCtrl ttl=1}        {SMF Header, protocol=AssuredCtrl ttl=1}
    [Correlation Tag Parameter]                     [Correlation Tag Parameter]
    {AssuredCtrl Message Header, msgType=Bind}      {AssuredCtrl Message Header, msgType=Bind}

    {AssuredCtrl QueueName Parameter}               {AssuredCtrl TopicEndpointName Parameter}
    ***                                             {AssuredCtrl TopicName Parameter}
    [AssuredCtrl Last Message Id Acked Parameter]   ***
    [AssuredCtrl Last Message Id Recv'd Parameter]  ***
    {AssuredCtrl Transport Window Size Parameter}   {AssuredCtrl Transport Window Size Parameter}
    [AssuredCtrl Durability Parameter]              [AssuredCtrl Durability Parameter]
    [AssuredCtrl Message Selector Parameter]        [AssuredCtrl Message Selector Parameter]
    [AssuredCtrl FlowType Parameter]                [AssuredCtrl FlowType Parameter]
    [AssuredCtrl Selector Parameter]                [AssuredCtrl Selector Parameter]
    [AssuredCtrl AllOthersPermissions Parameter]    [AssuredCtrl AllOthersPermissions Parameter]
    [AssuredCtrl EndpointQuotaMB Parameter]         [AssuredCtrl EndpointQuotaMB Parameter]
    [AssuredCtrl EndpointMaxMessageSize Parameter]  [AssuredCtrl EndpointMaxMessageSize Parameter]
    [AssuredCtrl TransactedSessionId Parameter]     [AssuredCtrl TransactedSessionId Parameter]
    [AssuredCtrl NoLocal Parameter]                 [AssuredCtrl NoLocal Parameter]
    [AssuredCtrl wantFlowChangeUpdate Parameter]    ***
    [AssuredCtrl qEndpointBehaviourFlags Parameter] [AssuredCtrl qEndpointBehaviourFlags Parameter]
    [AssuredCtrl MaxRedelivery Parameter]           [AssuredCtrl MaxRedelivery Parameter]
    [AssuredCtrl browser Parameter]                 ***
    */
                        const durable = queueDescriptor.durable;
                        const endpointBytes = endpoint.bytes;
                        const endpointType = endpoint.type;
                        // {SMF Header, protocol=AssuredCtrl ttl=1}        {SMF Header, protocol=AssuredCtrl ttl=1}
                        // [Correlation Tag Parameter]                     [Correlation Tag Parameter]
                        // {AssuredCtrl Message Header, msgType=Bind}      {AssuredCtrl Message Header, msgType=Bind}
                        const message = new AdProtocolMessage(SMFAdProtocolMessageType.BIND);
                        const header = message.smfHeader;
                        header.pm_corrtag = correlationTag;
                        // {AssuredCtrl QueueName Parameter}               {AssuredCtrl TopicEndpointName Parameter}
                        const endpointTypeParam = EndpointTypeToParam[endpointType];
                        if (endpointTypeParam === undefined) throw new OperationError("Unknown destination type");
                        message.addParameter(new SMFParameter(SMFUH.REJECT, endpointTypeParam, endpointBytes));
                        // ***                                             {AssuredCtrl TopicName Parameter}
                        if (topicSubscription) {
                            message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.TOPICNAME, topicSubscription.bytes));
                        }
                        if (endpointType === DestinationType.QUEUE) {
                            //     [AssuredCtrl Last Message Id Acked Parameter]   ***
                            message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.LASTMSGIDACKED, lastMsgIdAcked));
                            //     [AssuredCtrl Last Message Id Recv'd Parameter]  ***
                            message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.LASTMSGIDRECEIVED, lastMsgIdReceived));
                        }
                        // {AssuredCtrl Transport Window Size Parameter}
                        message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.WINDOW, windowSize));
                        // [AssuredCtrl Durability Parameter]
                        message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.EP_DURABLE, durable));
                        // Omit Message Selector
                        // Omit FlowType, CONSUMER assumed (not BROWSER currently)
                        // Omit TransactedSessionId
                        addQueueProperties(message, queueProperties, true);
                        if (noLocal /* is true */) {
                            // [AssuredCtrl NoLocal Parameter]
                            message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.NOLOCAL, 1));
                        }
                        if (wantFlowChangeUpdate /* is true */) {
                            // [AssuredCtrl wantFlowChangeUpdate Parameter]    ***
                            message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.WANT_FLOW_CHANGE_NOTIFY, 1));
                        }
                        if (browser /* is true */) {
                            // [AssuredCtrl browser Parameter]    ***
                            message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.FLOWTYPE, 2));
                        }
                        if (replayStartLocation !== undefined) {
                            // [AssuredCtrl replay start location Parameter]
                            let rsValue = replayStartLocation._replayStartValue;
                            if (replayStartLocation._type === ReplayStartType.DATE) {
                                const replayStartTimeMs = Long.fromNumber(replayStartLocation._replayStartValue, true);
                                const replayStartTimeNs = replayStartTimeMs.multiply(1e6);
                                rsValue = replayStartTimeNs;
                            }
                            message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.REPLAY_START_LOCATION, {
                                type: replayStartLocation._type,
                                value: rsValue
                            }));
                        }
                        if (endpointErrorId !== undefined) {
                            // [AssuredCtrl EndpointErrorId Parameter]    ***
                            LOG_TRACE(`Adding endpointErrorId to message: ${endpointErrorId}`);
                            message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.ENDPOINT_ERROR_ID, endpointErrorId));
                        }
                        return message;
                    }
                    /**
   * Creates an UNBIND request
   * @param {Number} flowId The flow ID to unbind
   * @param {Number} correlationTag The correlation tag for the request
   * @param {?Long} lastMessageIdAcked The last message ID marked as locally acked
   * @returns {AdProtocolMessage} The new UNBIND request
   * @static
   * @internal
   */
                    static getCloseMessageConsumer(flowId, correlationTag) {
                        const message = new AdProtocolMessage(SMFAdProtocolMessageType.UNBIND);
                        const header = message.smfHeader;
                        header.pm_corrtag = correlationTag;
                        message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.FLOWID, flowId));
                        // linger: assume no
                        return message;
                    }
                    static getDTEUnsubscribeMessage(correlationTag, topic) {
                        const message = new AdProtocolMessage(SMFAdProtocolMessageType.UNSUBSCRIBE);
                        const header = message.smfHeader;
                        header.pm_corrtag = correlationTag;
                        message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.DTENAME, topic.getBytes()));
                        return message;
                    }
                    /**
   * @param {Number} flowId The flow on which to acknowledge messages.
   * @param {?Long} [lastMessageIdAcked=undefined] The transport acknowledges receipt of all
   *  messages up to and including this ID.
   * @param {?Long} [windowSize=undefined] The size to which the flow window should be set.
   * @param {?Array.<Array.<Long>>} [applicationAckRanges=undefined] Low-high ID pairs of
   *  message IDs to acknowledge at the application level. To application ack a single message,
   *  pass `[ [singleMessageId, singleMessageId] ]`.
   * @returns {solace.AdProtocolMessage} A message containing the given parameters.
   * @internal
   * @static
   */
                    static getAck(flowId, lastMessageIdAcked = undefined, windowSize = undefined, applicationAckRanges = undefined) {
                        const message = new AdProtocolMessage(SMFAdProtocolMessageType.CLIENTACK);
                        message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.FLOWID, flowId));
                        if (lastMessageIdAcked) {
                            message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.LASTMSGIDACKED, lastMessageIdAcked));
                        }
                        if (windowSize !== undefined && windowSize !== null) {
                            // There are two windowSize options; we'll use the legacy one for smaller
                            // window sizes
                            message.addParameter(new SMFParameter(SMFUH.REJECT, windowSize <= 255 ? SMFAdProtocolParam.WINDOW : SMFAdProtocolParam.TRANSPORT_WINDOW, windowSize));
                        }
                        if (applicationAckRanges && applicationAckRanges.length) {
                            if (applicationAckRanges.length > AdProtocolMessage.MAX_CLIENT_ACK_RANGES) {
                                throw new OperationError("Application ack range count exceeds limit of 64");
                            }
                            message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.APPLICATION_ACK, applicationAckRanges));
                        }
                        return message;
                    }
                    /**
   * @param {Number} flowId The flow on which to acknowledge messages.
   * @param {?Long} [endpointErrorId=undefined] endpoint error id
   * @param {?Long} [lastMessageIdAcked=undefined] The transport acknowledges receipt of all
   *  messages up to and including this ID.
   * @returns {solace.AdProtocolMessage} A message containing the given parameters.
   * @internal
   * @static
   */
                    static getUnbindAck(flowId, endpointErrorId = undefined, lastMessageIdAcked = undefined) {
                        const message = new AdProtocolMessage(SMFAdProtocolMessageType.UNBIND);
                        message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.FLOWID, flowId));
                        if (endpointErrorId) {
                            LOG_TRACE(`Adding endpointErrorId to unbind ack: ${endpointErrorId}`);
                            message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.ENDPOINT_ERROR_ID, endpointErrorId));
                        }
                        LOG_TRACE(`Not adding lastMessageIdAcked to unbind ack: ${lastMessageIdAcked}`);
                        //if (lastMessageIdAcked) {
                        //  LOG_TRACE(`Adding lastMessageIdAcked to unbind ack: ${lastMessageIdAcked}`);
                        //  message.addParameter(new SMFParameter(
                        //    SMFUH.REJECT,
                        //    SMFAdProtocolParam.LASTMSGIDACKED,
                        //    lastMessageIdAcked
                        //  ));
                        //}
                        return message;
                    }
                }
                AdProtocolMessage.MAX_CLIENT_ACK_RANGES = 64;
                module.exports.AdProtocolMessage = AdProtocolMessage;
                /***/
            },
            /***/ "./modules/solclient-smf/lib/message-objects/api.js": 
            /*!**********************************************************!*\
  !*** ./modules/solclient-smf/lib/message-objects/api.js ***!
  \**********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    AdProtocolMessage
                } = __webpack_require__(/*! ./adprotocol-message */ "./modules/solclient-smf/lib/message-objects/adprotocol-message.js");
                const {
                    BinaryMetaBlock
                } = __webpack_require__(/*! ./binary-meta-block */ "./modules/solclient-smf/lib/message-objects/binary-meta-block.js");
                const {
                    ClientCtrlMessage
                } = __webpack_require__(/*! ./client-ctrl-message */ "./modules/solclient-smf/lib/message-objects/client-ctrl-message.js");
                const {
                    KeepAliveMessage
                } = __webpack_require__(/*! ./keep-alive-message */ "./modules/solclient-smf/lib/message-objects/keep-alive-message.js");
                const {
                    SMFHeader
                } = __webpack_require__(/*! ./smf-header */ "./modules/solclient-smf/lib/message-objects/smf-header.js");
                const {
                    SMFParameter
                } = __webpack_require__(/*! ./smf-parameter */ "./modules/solclient-smf/lib/message-objects/smf-parameter.js");
                const {
                    SMFUH
                } = __webpack_require__(/*! ./smf-uh */ "./modules/solclient-smf/lib/message-objects/smf-uh.js");
                const {
                    SMPMessage
                } = __webpack_require__(/*! ./smp-message */ "./modules/solclient-smf/lib/message-objects/smp-message.js");
                const {
                    TransportSMFMessage
                } = __webpack_require__(/*! ./transport-smf-message */ "./modules/solclient-smf/lib/message-objects/transport-smf-message.js");
                module.exports.AdProtocolMessage = AdProtocolMessage;
                module.exports.BinaryMetaBlock = BinaryMetaBlock;
                module.exports.ClientCtrlMessage = ClientCtrlMessage;
                module.exports.KeepAliveMessage = KeepAliveMessage;
                module.exports.SMFHeader = SMFHeader;
                module.exports.SMFParameter = SMFParameter;
                module.exports.SMFUH = SMFUH;
                module.exports.SMPMessage = SMPMessage;
                module.exports.TransportSMFMessage = TransportSMFMessage;
                /***/
            },
            /***/ "./modules/solclient-smf/lib/message-objects/base-message.js": 
            /*!*******************************************************************!*\
  !*** ./modules/solclient-smf/lib/message-objects/base-message.js ***!
  \*******************************************************************/
            /***/ module => {
                /**
 * @constructor BaseMessage
 * @private
 */
                class BaseMessage {
                    constructor(header = null, params = []) {
                        this._smfHeader = header;
                        this._parameters = params;
                    }
                    addParameter(param) {
                        this._parameters[param.getType()] = param;
                    }
                    getParameter(paramType) {
                        return this._parameters[paramType];
                    }
                    getParameterArray() {
                        return this._parameters;
                    }
                    get smfHeader() {
                        return this._smfHeader;
                    }
                    set smfHeader(val) {
                        this._smfHeader = val;
                    }
                    getResponse() {
                        const smf = this.smfHeader;
                        if (!(smf && smf.pm_respcode && smf.pm_respstr)) {
                            return null;
                        }
                        return {
                            responseCode: smf.pm_respcode,
                            responseString: smf.pm_respstr
                        };
                    }
                }
                module.exports.BaseMessage = BaseMessage;
                /***/
            },
            /***/ "./modules/solclient-smf/lib/message-objects/binary-meta-block.js": 
            /*!************************************************************************!*\
  !*** ./modules/solclient-smf/lib/message-objects/binary-meta-block.js ***!
  \************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Bits,
                    Convert
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    get: bits
                } = Bits;
                const {
                    int8ToStr,
                    int24ToStr
                } = Convert;
                /**
 * @classdesc
 *
 * BinaryMetaBlock represents a binary metadata block in a TrMsg
 *
 * @private
 */
                class BinaryMetaBlock {
                    constructor(type, payload) {
                        this.type = type;
                        this.payload = payload;
                    }
                    asEncodedSmf() {
                        const smf = [];
                        smf.push(int8ToStr(1));
                        smf.push(int8ToStr(this.type));
                        smf.push(int24ToStr(this.payload.length));
                        smf.push(this.payload.toString("latin1"));
                        return smf.join("");
                    }
                    static fromEncodedSmf(bufSmf, offset = 0) {
                        if (bufSmf.length - offset < 6) {
                            return null; // not enough data
                        }
                        const chunkCount = bufSmf.readUInt8(offset);
                        const fourbyte = bufSmf.readInt32BE(offset + 1);
                        const type = bits(fourbyte, 24, 8);
                        const payloadLen = bits(fourbyte, 0, 24);
                        const payloadOffset = chunkCount * 4 + 1;
                        const payload = bufSmf.slice(offset + payloadOffset, offset + payloadOffset + payloadLen);
                        return new BinaryMetaBlock(type, payload);
                    }
                }
                module.exports.BinaryMetaBlock = BinaryMetaBlock;
                /***/
            },
            /***/ "./modules/solclient-smf/lib/message-objects/client-ctrl-message.js": 
            /*!**************************************************************************!*\
  !*** ./modules/solclient-smf/lib/message-objects/client-ctrl-message.js ***!
  \**************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    AuthenticationScheme,
                    CapabilityType,
                    ClientCapabilityType,
                    MutableSessionProperty,
                    SessionProperties
                } = __webpack_require__(/*! solclient-session */ "./modules/solclient-session/api.js");
                const {
                    BaseMessage
                } = __webpack_require__(/*! ./base-message */ "./modules/solclient-smf/lib/message-objects/base-message.js");
                const {
                    Bits,
                    Convert
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    DestinationType,
                    DestinationUtil
                } = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    Process,
                    StringUtils,
                    Version
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const {
                    SMFClientCtrlMessageType
                } = __webpack_require__(/*! ../smf-client-ctrl-message-types */ "./modules/solclient-smf/lib/smf-client-ctrl-message-types.js");
                const {
                    SMFClientCtrlParam,
                    SMFClientCtrlAuthType
                } = __webpack_require__(/*! ../smf-client-ctrl-params */ "./modules/solclient-smf/lib/smf-client-ctrl-params.js");
                const {
                    SMFHeader
                } = __webpack_require__(/*! ./smf-header */ "./modules/solclient-smf/lib/message-objects/smf-header.js");
                const {
                    SMFParameter
                } = __webpack_require__(/*! ./smf-parameter */ "./modules/solclient-smf/lib/message-objects/smf-parameter.js");
                const {
                    SMFProtocol
                } = __webpack_require__(/*! ../smf-protocols */ "./modules/solclient-smf/lib/smf-protocols.js");
                const {
                    LOG_TRACE
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    get: bits,
                    set: setBits
                } = Bits;
                const {
                    int8ToStr,
                    strToInt8,
                    int16ToStr,
                    int32ToStr,
                    strToInt16,
                    strToInt32
                } = Convert;
                const {
                    nullTerminate,
                    stripNullTerminate
                } = StringUtils;
                const {
                    validateAndEncode
                } = DestinationUtil;
                const BOOLEAN_CAPS_BITS = [ CapabilityType.JNDI, CapabilityType.COMPRESSION, CapabilityType.GUARANTEED_MESSAGE_CONSUME, CapabilityType.TEMPORARY_ENDPOINT, CapabilityType.GUARANTEED_MESSAGE_PUBLISH, CapabilityType.GUARANTEED_MESSAGE_BROWSE, CapabilityType.ENDPOINT_MGMT, CapabilityType.SELECTOR, CapabilityType.ENDPOINT_MESSAGE_TTL, CapabilityType.QUEUE_SUBSCRIPTIONS, null, // skip obsolete FLOW_RECOVER
                CapabilityType.SUBSCRIPTION_MANAGER, CapabilityType.MESSAGE_ELIDING, CapabilityType.TRANSACTED_SESSION, CapabilityType.NO_LOCAL, CapabilityType.ACTIVE_CONSUMER_INDICATION, CapabilityType.PER_TOPIC_SEQUENCE_NUMBERING, CapabilityType.ENDPOINT_DISCARD_BEHAVIOR, CapabilityType.CUT_THROUGH, null, // skip OPENMAMA
                CapabilityType.MESSAGE_REPLAY, CapabilityType.COMPRESSED_SSL, null, // skipping LONG_SELECTORS
                CapabilityType.SHARED_SUBSCRIPTIONS, CapabilityType.BR_REPLAY_ERRORID ];
                const CLIENT_CAPS_VALUES = new Map([ [ ClientCapabilityType.UNBIND_ACK, 128 ], [ ClientCapabilityType.BR_ERRORID, 64 ] ]);
                /**
 * @classdesc ClientCtrlMessage
 * Represents a ClientCtrl request or reply message
 * @private
 */
                class ClientCtrlMessage extends BaseMessage {
                    constructor(messageType = 0) {
                        super(new SMFHeader(SMFProtocol.CLIENTCTRL, 1));
                        // Field: msgtype
                        this.msgType = messageType;
                        // Field: version
                        this.version = 1;
                    }
                    getP2PTopicValue() {
                        const p2pParam = this.getParameter(SMFClientCtrlParam.P2PTOPIC);
                        if (!p2pParam) {
                            return null;
                        }
                        return stripNullTerminate(p2pParam.getValue());
                    }
                    getVpnNameInUseValue() {
                        const vpnParam = this.getParameter(SMFClientCtrlParam.MSGVPNNAME);
                        if (!vpnParam) {
                            return null;
                        }
                        return stripNullTerminate(vpnParam.getValue());
                    }
                    getVridInUseValue() {
                        const vridParam = this.getParameter(SMFClientCtrlParam.VRIDNAME);
                        if (!vridParam) {
                            return null;
                        }
                        return stripNullTerminate(vridParam.getValue());
                    }
                    getUserIdValue() {
                        const userIdParam = this.getParameter(SMFClientCtrlParam.USERID);
                        if (!userIdParam) {
                            return null;
                        }
                        return stripNullTerminate(userIdParam.getValue());
                    }
                    getRouterCapabilities() {
                        let caps = [];
                        // Parse the composite capabilities parameter
                        let capParam = this.getParameter(SMFClientCtrlParam.ROUTER_CAPABILITIES);
                        if (capParam) {
                            caps = ClientCtrlMessage.prmParseCapabilitiesValue(capParam.getValue(), caps);
                        }
                        // Parse out the router status strings
                        capParam = this.getParameter(SMFClientCtrlParam.SOFTWAREVERSION);
                        if (capParam) {
                            caps[CapabilityType.PEER_SOFTWARE_VERSION] = stripNullTerminate(capParam.getValue());
                        }
                        capParam = this.getParameter(SMFClientCtrlParam.SOFTWAREDATE);
                        if (capParam) {
                            caps[CapabilityType.PEER_SOFTWARE_DATE] = stripNullTerminate(capParam.getValue());
                        }
                        capParam = this.getParameter(SMFClientCtrlParam.PLATFORM);
                        if (capParam) {
                            caps[CapabilityType.PEER_PLATFORM] = stripNullTerminate(capParam.getValue());
                        }
                        capParam = this.getParameter(SMFClientCtrlParam.PHYSICALROUTERNAME);
                        if (capParam) {
                            caps[CapabilityType.PEER_ROUTER_NAME] = stripNullTerminate(capParam.getValue());
                        }
                        return caps;
                    }
                    static prmGetDtoPriorityValue(dto) {
                        if (dto.local === undefined || dto.network === undefined) {
                            return false;
                        }
                        let twobyte = 0;
                        twobyte = setBits(twobyte, dto.local, 8, 8);
                        twobyte = setBits(twobyte, dto.network, 0, 8);
                        return int16ToStr(twobyte);
                    }
                    static prmParseDtoPriorityValue(strDtoPriority) {
                        const dto = {};
                        const twobyte = strToInt16(strDtoPriority.substr(0, 2));
                        dto.local = bits(twobyte, 8, 8);
                        dto.network = bits(twobyte, 0, 8);
                        return dto;
                    }
                    /*
  strCapabilities: parameter value
  caps: an already existing hash array of CapabilityType
   */
                    static prmParseCapabilitiesValue(strCapabilities, capsIn) {
                        const caps = capsIn;
                        if (!(strCapabilities && caps)) {
                            return false;
                        }
                        const CT = CapabilityType;
                        let pos = 0;
                        // parse boolean capabilities
                        const boolCapCount = strToInt8(strCapabilities[pos]);
                        ++pos;
                        // The boolean caps are listed in order as in the documentation,
                        // that is from MSB to LSB for each caps byte.
                        let capsByte;
                        for (let bitIndex = 0; bitIndex < boolCapCount; ++bitIndex) {
                            const msbIndex = bitIndex & 7;
                            if (msbIndex === 0) {
                                // Consume a byte
                                capsByte = strToInt8(strCapabilities[pos]);
                                ++pos;
                            }
                            const capsKey = BOOLEAN_CAPS_BITS[bitIndex];
                            if (!capsKey) continue; // We don't know about this cap
                            // so set caps bits from MSB (bit 7) to LSB (bit 0)
                            caps[capsKey] = !!bits(capsByte, 7 - msbIndex, 1);
                        }
                        // parse non-boolean capabilities
                        const sanityLoop = 500;
                        for (let i = 0; pos < strCapabilities.length && i < sanityLoop; ++i) {
                            const onebyte = strToInt8(strCapabilities[pos]); // type
                            pos++;
                            const capLen = strToInt32(strCapabilities.substr(pos, 4)) - 5;
                            pos += 4;
                            const strValue = strCapabilities.substr(pos, capLen);
                            pos += capLen;
                            switch (onebyte) {
                              case 0:
                                caps[CT.PEER_PORT_SPEED] = strValue.length === 4 ? strToInt32(strValue) : 0;
                                break;

                              case 1:
                                caps[CT.PEER_PORT_TYPE] = strValue.length === 1 ? strToInt8(strValue) : 0;
                                break;

                              case 2:
                                caps[CT.MAX_GUARANTEED_MSG_SIZE] = strValue.length === 4 ? strToInt32(strValue) : 0;
                                break;

                              case 3:
                                caps[CT.MAX_DIRECT_MSG_SIZE] = strValue.length === 4 ? strToInt32(strValue) : 0;
                                break;

                              default:
                                // NOOP (unknown cap)
                                break;
                            }
                        }
                        return caps;
                    }
                    static getLogin(sprop, compressedTLS, plaintextTLS, correlationTag) {
                        function clientCapsToStr(clientCapList) {
                            const highestCap = Math.max.apply(null, clientCapList) + 1;
                            let capBits = 0;
                            clientCapList.forEach(cap => {
                                capBits += CLIENT_CAPS_VALUES.get(cap);
                            });
                            return int8ToStr(highestCap) + int8ToStr(capBits);
                        }
                        if (!(sprop instanceof SessionProperties)) {
                            return false;
                        }
                        const cc = new ClientCtrlMessage(SMFClientCtrlMessageType.LOGIN);
                        const smfHeader = cc._smfHeader;
                        const isClientCert = sprop.authenticationScheme === AuthenticationScheme.CLIENT_CERTIFICATE;
                        smfHeader.pm_corrtag = correlationTag;
                        if (sprop.password && !isClientCert) {
                            smfHeader.pm_password = sprop.password;
                        }
                        if (sprop.userName) {
                            smfHeader.pm_username = sprop.userName;
                        }
                        if (sprop.subscriberLocalPriority && sprop.subscriberNetworkPriority) {
                            cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.DELIVERTOONEPRIORITY, ClientCtrlMessage.prmGetDtoPriorityValue({
                                local: sprop.subscriberLocalPriority,
                                network: sprop.subscriberNetworkPriority
                            })));
                        }
                        if (sprop.vpnName && sprop.vpnName.length > 0) {
                            cc.addParameter(new SMFParameter(1, SMFClientCtrlParam.MSGVPNNAME, nullTerminate(sprop.vpnName)));
                        }
                        if (sprop.applicationDescription && sprop.applicationDescription.length > 0) {
                            cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.CLIENTDESC, nullTerminate(sprop.applicationDescription)));
                        }
                        if (sprop.userIdentification && sprop.userIdentification.length > 0) {
                            cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.USERID, nullTerminate(sprop.userIdentification)));
                        }
                        if (sprop.authenticationScheme === AuthenticationScheme.OAUTH2) {
                            cc.addParameter(new SMFParameter(1, SMFClientCtrlParam.AUTHENTICATION_SCHEME, SMFClientCtrlAuthType.OAUTH2));
                            if (sprop.idToken) {
                                smfHeader.pm_oidc_id_token = nullTerminate(sprop.idToken);
                            }
                            if (sprop.accessToken) {
                                smfHeader.pm_oauth2_access_token = nullTerminate(sprop.accessToken);
                            }
                            if (sprop.issuerIdentifier) {
                                smfHeader.pm_oauth2_issuer_identifier = nullTerminate(sprop.issuerIdentifier);
                            }
                        }
                        cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.CLIENTNAME, nullTerminate(sprop.clientName)));
                        cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.PLATFORM, nullTerminate(`${Process.platform} - JS API (${Version.mode})`)));
                        if (sprop.noLocal) {
                            cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.NO_LOCAL, ""));
                        }
                        if (isClientCert) {
                            cc.addParameter(new SMFParameter(1, SMFClientCtrlParam.AUTHENTICATION_SCHEME, SMFClientCtrlAuthType.CLIENT_CERTIFICATE));
                        }
                        cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.SOFTWAREDATE, nullTerminate(Version.formattedDate)));
                        cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.SOFTWAREVERSION, nullTerminate(Version.version)));
                        if (compressedTLS && plaintextTLS) {
                            LOG_TRACE("Adding SslDowngrade=1 to login.");
                            cc.addParameter(new SMFParameter(1, SMFClientCtrlParam.SSL_DOWNGRADE, ""));
                        } else if (compressedTLS) {
                            LOG_TRACE("Adding SslDowngrade=2 to login.");
                            cc.addParameter(new SMFParameter(1, SMFClientCtrlParam.SSL_DOWNGRADE, ""));
                        } else if (plaintextTLS) {
                            LOG_TRACE("Adding SslDowngrade=0 to login.");
                            cc.addParameter(new SMFParameter(1, SMFClientCtrlParam.SSL_DOWNGRADE, "\0"));
                        }
                        const clientCaps = clientCapsToStr([ ClientCapabilityType.UNBIND_ACK, ClientCapabilityType.BR_ERRORID ]);
                        cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.CLIENT_CAPABILITIES, clientCaps));
                        //'\x02\xc0'));
                        //'\x01\x80'));
                        const keepaliveVal = int32ToStr(sprop.keepAliveIntervalInMsecs / 1e3);
                        cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.KEEP_ALIVE_INTERVAL, keepaliveVal));
                        return cc;
                    }
                    /**
   * Get a CC update message.
   *
   * @param {MutableSessionProperty} mutableSessionProperty The property to update
   * @param {String} newValue The new value for the property
   * @param {String} correlationTag The correlation tag for the request
   * @returns {ClientCtrlMessage} The new UPDATE message
   *
   * @private
   */
                    static getUpdate(mutableSessionProperty, newValue, correlationTag) {
                        const cc = new ClientCtrlMessage(SMFClientCtrlMessageType.UPDATE);
                        const smfHeader = cc.smfHeader;
                        smfHeader.pm_corrtag = correlationTag;
                        if (mutableSessionProperty === MutableSessionProperty.CLIENT_DESCRIPTION) {
                            const appdesc = (newValue || "").toString().substr(0, 250);
                            cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.CLIENTDESC, nullTerminate(appdesc)));
                        } else if (mutableSessionProperty === MutableSessionProperty.CLIENT_NAME) {
                            const error = ClientCtrlMessage.validateClientName(newValue, errorMessage => new OperationError(`Invalid clientName: ${errorMessage}`, ErrorSubcode.PARAMETER_OUT_OF_RANGE));
                            if (error) {
                                throw error;
                            }
                            cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.CLIENTNAME, nullTerminate(newValue)));
                        }
                        return cc;
                    }
                    static validateClientName(strName, exceptionCreator) {
                        const encodeResult = validateAndEncode(DestinationType.TOPIC, strName, exceptionCreator);
                        if (encodeResult.error) {
                            return encodeResult.error;
                        }
                        // Add 1: bytes includes terminator, 160 excludes terminator
                        if (encodeResult.bytes.length > 161) {
                            return exceptionCreator("Client Name too long (max length: 160).");
                        }
                        return null;
                    }
                }
                module.exports.ClientCtrlMessage = ClientCtrlMessage;
                /***/
            },
            /***/ "./modules/solclient-smf/lib/message-objects/keep-alive-message.js": 
            /*!*************************************************************************!*\
  !*** ./modules/solclient-smf/lib/message-objects/keep-alive-message.js ***!
  \*************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    BaseMessage
                } = __webpack_require__(/*! ./base-message */ "./modules/solclient-smf/lib/message-objects/base-message.js");
                const {
                    SMFHeader
                } = __webpack_require__(/*! ./smf-header */ "./modules/solclient-smf/lib/message-objects/smf-header.js");
                const {
                    SMFProtocol
                } = __webpack_require__(/*! ../smf-protocols */ "./modules/solclient-smf/lib/smf-protocols.js");
                class KeepAliveMessage extends BaseMessage {
                    constructor() {
                        super(new SMFHeader(SMFProtocol.KEEPALIVEV2, 2));
                        this._smfHeader.smf_uh = 2;
                    }
                }
                module.exports.KeepAliveMessage = KeepAliveMessage;
                /***/
            },
            /***/ "./modules/solclient-smf/lib/message-objects/smf-header.js": 
            /*!*****************************************************************!*\
  !*** ./modules/solclient-smf/lib/message-objects/smf-header.js ***!
  \*****************************************************************/
            /***/ module => {
                /**
 * @classdesc
 * Control messages wrap an SMFHeader instance
 * @private
 */
                class SMFHeader {
                    constructor(protocol = 0, ttl = 0) {
                        // header properties
                        // header block
                        // SMF parameters
                        // payload
                        this._parameters = [];
                        // Common SMF header field values
                        this.smf_version = 3;
                        this.smf_uh = 0;
                        this.smf_protocol = protocol;
                        this.smf_priority = 0;
                        this.smf_ttl = ttl;
                        this.smf_msgLen = 0;
                        this.smf_di = 0;
                        this.smf_tqd = 0;
                        this.smf_elidingEligible = 0;
                        this.smf_dto = 0;
                        this.smf_adf = 0; // AD
                        this.smf_deadMessageQueueEligible = 0; //DMQ Eligible
                        // Common SMF protocol parameters
                        this.pm_userdata = null;
                        this.pm_respcode = 0;
                        this.pm_respstr = null;
                        this.pm_username = null;
                        this.pm_password = null;
                        this.pm_tr_topicname_bytes = null;
                        this.pm_deliverymode = null;
                        this.pm_ad_msgid = undefined; // AD
                        this.pm_ad_prevmsgid = undefined; // AD
                        this.pm_ad_redelflag = 0; // AD
                        this.pm_ad_flowredelflag = 0; // AD
                        this.pm_ad_ttl = undefined; // AD
                        this.pm_ad_ackimm = undefined; // AD
                        this.pm_ad_flowid = 0; // AD
                        this.pm_ad_publisherid = 0;
                        this.pm_ad_publishermsgid = 0;
                        this.pm_content_summary = null;
                        this.pm_corrtag = null;
                        this.pm_topic_offset = 0;
                        this.pm_topic_len = 0;
                        this.pm_queue_offset = 0;
                        this.pm_queue_len = 0;
                        this.pm_msg_priority = null; // {number}
                        // extended optional parameters
                        // these fields are header but may not be present
                        // see ../codec/parse-smf.js for details
                        // this.pm_ad_redeliveryCount;
                        // this.pm_ad_spooler_unique_id;
                        // this.pm_ad_local_spooler_message_id;
                        // this.pm_ad_replication_mate_ack_message_id;
                        this.pm_oauth2_access_token = null;
                        this.pm_oidc_id_token = null;
                        this.pm_oauth2_issuer_identifier = null;
                        // housekeeping
                        this.unknownProtoFlag = false;
                        this.messageLength = 0;
                        this.payloadLength = 0;
                        this.headerLength = 0;
                        this.payload = null;
                        // This message is invalid, but the framing (messageLength) is fine.
                        // set by the parser when UH==2 on an unknown parameter.
                        // The SMF fsm can then discard and increment the stats.
                        this.discardMessage = false;
                    }
                    setMessageSizes(headerLength, payloadLength) {
                        this.headerLength = headerLength;
                        this.payloadLength = payloadLength;
                        this.messageLength = headerLength + payloadLength;
                    }
                    setPayloadSize(payloadLength) {
                        this.payloadLength = payloadLength;
                    }
                }
                module.exports.SMFHeader = SMFHeader;
                /***/
            },
            /***/ "./modules/solclient-smf/lib/message-objects/smf-parameter.js": 
            /*!********************************************************************!*\
  !*** ./modules/solclient-smf/lib/message-objects/smf-parameter.js ***!
  \********************************************************************/
            /***/ module => {
                /**
 * @classdesc
 * A representation of an SMF parameter
 *
 * @private
 */
                class SMFParameter {
                    /**
 * @constructor
 * @param {Number} uh The UH value [0..2]
 * @param {SMFParameterType} type The type of SMF parameter
 * @param {*} value The value for this parameter
 * @param {Buffer} buffer instead of value, a buffer, with indexes (begin and end)
 * @param {Number} begin start index in buffer
 * @param {Number} end end index in buffer.
 */
                    constructor(uh, type, value, buffer, begin, end) {
                        this._type = type;
                        this._value = value;
                        this._uh = uh;
                        this._buffer = buffer;
                        this._begin = begin;
                        this._end = end;
                    }
                    getType() {
                        return this._type;
                    }
                    getValue() {
                        if (this._buffer && !this._value) {
                            return this._buffer.toString("latin1", this._begin, this._end);
                        }
                        return this._value;
                    }
                    getUh() {
                        return this._uh;
                    }
                    getBuffer() {
                        return this._buffer;
                    }
                    getBegin() {
                        return this._begin;
                    }
                    getEnd() {
                        return this._end;
                    }
                    toString() {
                        return `${this._uh}:0x${this._type.toString(16)} = ${this.getValue()}`;
                    }
                }
                module.exports.SMFParameter = SMFParameter;
                /***/
            },
            /***/ "./modules/solclient-smf/lib/message-objects/smf-uh.js": 
            /*!*************************************************************!*\
  !*** ./modules/solclient-smf/lib/message-objects/smf-uh.js ***!
  \*************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                const SMFUH = {
                    IGNORE: 0,
                    REJECT: 2
                };
                module.exports.SMFUH = Enum.new(SMFUH);
                /***/
            },
            /***/ "./modules/solclient-smf/lib/message-objects/smp-message.js": 
            /*!******************************************************************!*\
  !*** ./modules/solclient-smf/lib/message-objects/smp-message.js ***!
  \******************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    assert
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                const {
                    BaseMessage
                } = __webpack_require__(/*! ./base-message */ "./modules/solclient-smf/lib/message-objects/base-message.js");
                const {
                    Destination,
                    DestinationUtil
                } = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                const {
                    SMFHeader
                } = __webpack_require__(/*! ./smf-header */ "./modules/solclient-smf/lib/message-objects/smf-header.js");
                const {
                    SMFProtocol
                } = __webpack_require__(/*! ../smf-protocols */ "./modules/solclient-smf/lib/smf-protocols.js");
                const {
                    SMFSMPMessageType
                } = __webpack_require__(/*! ../smf-smp-message-types */ "./modules/solclient-smf/lib/smf-smp-message-types.js");
                const {
                    SMFSMPMessageTypeFlags
                } = __webpack_require__(/*! ../smf-smp-message-type-flags */ "./modules/solclient-smf/lib/smf-smp-message-type-flags.js");
                /**
 * Represents an SMP request or reply message
 * @memberof solace
 * @private
 */
                class SMPMessage extends BaseMessage {
                    /**
   * Creates an instance of SMPMessage.
   *
   * @memberOf SMPMessage
   */
                    constructor() {
                        super(new SMFHeader(SMFProtocol.SMP, 1));
                        // Field: msgtype
                        this.msgType = 0;
                        // Field: subscription string
                        this.encodedUtf8Subscription = null;
                        this.encodedUtf8QueueName = null;
                        this.smpFlags = 0 | SMFSMPMessageTypeFlags.SMF_SMP_FLAG_TOPIC; // default flags
                        this._encodedQueueName = null; // unused in solclientjs
                        this._encodedClientName = null; // unused in solclientjs
                    }
                    isFlag(flagMask) {
                        return this.smpFlags & flagMask;
                    }
                    setFlag(flagMask, value) {
                        if (value) {
                            this.smpFlags |= flagMask;
                        } else {
                            this.smpFlags &= ~flagMask;
                        }
                    }
                    static getSubscriptionMessage(correlationTag, topic, add, requestConfirm) {
                        assert(topic instanceof Destination, "Topics are not UCS-2 strings. Pass a Topic object.");
                        const smp = new SMPMessage();
                        smp.msgType = add ? SMFSMPMessageType.ADDSUBSCRIPTION : SMFSMPMessageType.REMSUBSCRIPTION;
                        smp.encodedUtf8Subscription = topic.getBytes();
                        assert(smp.encodedUtf8Subscription, "Topic had no encoding");
                        smp.setFlag(SMFSMPMessageTypeFlags.SMF_SMP_FLAG_TOPIC, true);
                        if (requestConfirm) {
                            smp.setFlag(SMFSMPMessageTypeFlags.SMF_SMP_FLAG_RESPREQUIRED, true);
                        }
                        // Always put a correlation tag
                        smp._smfHeader.pm_corrtag = correlationTag;
                        return smp;
                    }
                    static getQueueSubscriptionMessage(correlationTag, topic, queue, add) {
                        assert(topic instanceof Destination, "Topics are not UCS-2 strings. Pass a Topic object.");
                        const smp = new SMPMessage();
                        smp.msgType = add ? SMFSMPMessageType.ADDQUEUESUBSCRIPTION : SMFSMPMessageType.REMQUEUESUBSCRIPTION;
                        smp.encodedUtf8QueueName = DestinationUtil.encodeBytes(queue.getName());
                        smp.encodedUtf8Subscription = topic.getBytes();
                        assert(smp.encodedUtf8Subscription, "Topic had no encoding");
                        assert(smp.encodedUtf8QueueName, "Queue had no encoding");
                        smp.setFlag(SMFSMPMessageTypeFlags.SMF_SMP_FLAG_TOPIC, true);
                        smp.setFlag(SMFSMPMessageTypeFlags.SMF_SMP_FLAG_RESPREQUIRED, true);
                        // TODO: true for remove, false for add? Typo in the spec?
                        smp.setFlag(SMFSMPMessageTypeFlags.SMF_SMP_FLAG_PERSIST, true);
                        // Always put a correlation tag
                        smp._smfHeader.pm_corrtag = correlationTag;
                        return smp;
                    }
                }
                module.exports.SMPMessage = SMPMessage;
                /***/
            },
            /***/ "./modules/solclient-smf/lib/message-objects/transport-smf-message.js": 
            /*!****************************************************************************!*\
  !*** ./modules/solclient-smf/lib/message-objects/transport-smf-message.js ***!
  \****************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    BaseMessage
                } = __webpack_require__(/*! ./base-message */ "./modules/solclient-smf/lib/message-objects/base-message.js");
                /**
 * @classdesc
 * Transport SMF Message
 * @memberof solace
 * @private
 */
                class TransportSMFMessage extends BaseMessage {
                    /**
   * @constructor
   */
                    constructor() {
                        super(null, null);
                        this.uh = 0;
                        this.messageType = null;
                        this.sessionId = null;
                        this.routerTag = null;
                        this.payload = null;
                        this.payloadLength = 0;
                        this.tsHeaderLength = 0;
                    }
                }
                module.exports.TransportSMFMessage = TransportSMFMessage;
                /***/
            },
            /***/ "./modules/solclient-smf/lib/smf-adprotocol-message-types.js": 
            /*!*******************************************************************!*\
  !*** ./modules/solclient-smf/lib/smf-adprotocol-message-types.js ***!
  \*******************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * @private
 * @enum {number}
 */
                const SMFAdProtocolMessageType = {
                    OPENPUBFLOW: 0,
                    // INTERROUTERACK:          0x01,
                    // INTERROUTERHANDSHAKEACK: 0x02,
                    CLIENTACK: 3,
                    BIND: 4,
                    UNBIND: 5,
                    UNSUBSCRIBE: 6,
                    CLOSEPUBFLOW: 7,
                    CREATE: 8,
                    DELETE: 9,
                    // FLOWRECOVER:  0x0a,
                    TRANSACTIONCTRL: 11,
                    FLOWCHANGEUPDATE: 12,
                    // EXTERNALACK:      0x0d,
                    XACTRL: 14,
                    CLIENTNACK: 15
                };
                module.exports.SMFAdProtocolMessageType = Enum.new(SMFAdProtocolMessageType);
                /***/
            },
            /***/ "./modules/solclient-smf/lib/smf-adprotocol-params.js": 
            /*!************************************************************!*\
  !*** ./modules/solclient-smf/lib/smf-adprotocol-params.js ***!
  \************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * @private
 * @enum {number}
 */
                const SMFAdProtocolParam = {
                    LASTMSGIDSENT: 1,
                    LASTMSGIDACKED: 2,
                    WINDOW: 3,
                    TRANSPORT_PRIORITY: 4,
                    APPLICATION_ACK: 5,
                    FLOWID: 6,
                    QUEUENAME: 7,
                    DTENAME: 8,
                    TOPICNAME: 9,
                    FLOWNAME: 10,
                    EP_DURABLE: 11,
                    ACCESSTYPE: 12,
                    SELECTOR: 13,
                    TRANSPORT_WINDOW: 14,
                    LINGER_OPTION: 15,
                    LASTMSGIDRECEIVED: 16,
                    EP_ALLOTHER_PERMISSION: 17,
                    FLOWTYPE: 18,
                    EP_QUOTA: 19,
                    EP_MAX_MSGSIZE: 20,
                    GRANTED_PERMISSIONS: 21,
                    EP_RESPECTS_TTL: 22,
                    TRANSACTION_CTRL_MESSAGE_TYPE: 23,
                    TRANSACTED_SESSION_ID: 24,
                    TRANSACTED_SESSION_NAME: 25,
                    TRANSACTION_ID: 26,
                    TRANSACTED_SESSION_STATE: 27,
                    TRANSACTION_FLOW_DESCRIPTOR_PUB_NOTIFY: 28,
                    TRANSACTION_FLOW_DESCRIPTOR_PUB_ACK: 29,
                    TRANSACTION_FLOW_DESCRIPTOR_SUB_ACK: 30,
                    NOLOCAL: 31,
                    ACTIVE_FLOW_INDICATION: 32,
                    WANT_FLOW_CHANGE_NOTIFY: 33,
                    EP_BEHAVIOUR: 34,
                    PUBLISHER_ID: 35,
                    APPLICATION_PUB_ACK: 36,
                    NUM_MESSAGES_SPOOLED: 37,
                    CUT_THROUGH: 38,
                    PUBLISHER_FLAGS: 39,
                    APP_MSG_ID_TYPE: 40,
                    QUEUE_ENDPOINT_HASH: 41,
                    MAX_REDELIVERY: 42,
                    PAYLOAD: 43,
                    ENDPOINT_ID: 44,
                    ACK_SEQUENCE_NUMBER: 45,
                    ACK_RECONCILE_REQUEST: 46,
                    START_OF_ACK_RECONCILE: 47,
                    TIMESTAMP: 48,
                    MAX_DELIVERED_UNACKED_MESSAGES_PER_FLOW: 49,
                    REPLAY_START_LOCATION: 51,
                    ENDPOINT_ERROR_ID: 52,
                    SPOOLER_UNIQUE_ID: 54
                };
                module.exports.SMFAdProtocolParam = Enum.new(SMFAdProtocolParam);
                /***/
            },
            /***/ "./modules/solclient-smf/lib/smf-client-ctrl-message-types.js": 
            /*!********************************************************************!*\
  !*** ./modules/solclient-smf/lib/smf-client-ctrl-message-types.js ***!
  \********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * @private
 * @enum {number}
 */
                const SMFClientCtrlMessageType = {
                    LOGIN: 0,
                    UPDATE: 1
                };
                module.exports.SMFClientCtrlMessageType = Enum.new(SMFClientCtrlMessageType);
                /***/
            },
            /***/ "./modules/solclient-smf/lib/smf-client-ctrl-params.js": 
            /*!*************************************************************!*\
  !*** ./modules/solclient-smf/lib/smf-client-ctrl-params.js ***!
  \*************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * @private
 * @enum {number}
 */
                const SMFClientCtrlParam = {
                    SOFTWAREVERSION: 0,
                    SOFTWAREDATE: 1,
                    PLATFORM: 2,
                    USERID: 3,
                    CLIENTDESC: 4,
                    CLIENTNAME: 5,
                    MSGVPNNAME: 6,
                    DELIVERTOONEPRIORITY: 7,
                    P2PTOPIC: 8,
                    ROUTER_CAPABILITIES: 9,
                    VRIDNAME: 10,
                    PHYSICALROUTERNAME: 12,
                    BRIDGE_MSG_VPN_NAME: 13,
                    BRIDGE_ROUTER_NAME: 14,
                    NO_LOCAL: 15,
                    BRIDGE_VERSION: 16,
                    AUTHENTICATION_SCHEME: 17,
                    CONNECTION_TYPE: 18,
                    ROUTER_CAPABILITIES_EXTENDED: 19,
                    REQUIRES_RELEASE_7: 20,
                    // not supported.
                    SSL_DOWNGRADE: 21,
                    CLIENT_CAPABILITIES: 23,
                    KEEP_ALIVE_INTERVAL: 24
                };
                // Internal use only
                const SMFClientCtrlAuthType = {
                    CLIENT_CERTIFICATE: "",
                    OAUTH2: "\n"
                };
                module.exports.SMFClientCtrlAuthType = Enum.new(SMFClientCtrlAuthType);
                module.exports.SMFClientCtrlParam = Enum.new(SMFClientCtrlParam);
                /***/
            },
            /***/ "./modules/solclient-smf/lib/smf-parameter-types.js": 
            /*!**********************************************************!*\
  !*** ./modules/solclient-smf/lib/smf-parameter-types.js ***!
  \**********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * @private
 * @enum {number}
 */
                const SMFParameterType = {
                    // SMF parameter types 5 bit types
                    PADDING: 0,
                    PUBLISHER_ID: 1,
                    PUBLISHER_MSGID: 2,
                    MESSAGEPRIORITY: 3,
                    USERDATA: 4,
                    USERNAME: 6,
                    PASSWORD: 7,
                    RESPONSE: 8,
                    SUB_ID_LIST: 10,
                    GENERIC_ATTACHMENT: 11,
                    BINARY_ATTACHMENT: 12,
                    DELIVERY_MODE: 16,
                    ASSURED_MESSAGE_ID: 17,
                    ASSURED_PREVMESSAGE_ID: 18,
                    ASSURED_REDELIVERED_FLAG: 19,
                    MESSAGE_CONTENT_SUMMARY: 22,
                    ASSURED_FLOWID: 23,
                    TR_TOPICNAME: 24,
                    AD_FLOWREDELIVERED_FLAG: 25,
                    AD_TIMETOLIVE: 28,
                    AD_TOPICSEQUENCE_NUMBER: 30,
                    EXTENDED_TYPE_STREAM: 31,
                    /* extended parameters 12 bit types */
                    AD_ACK_MESSAGE_ID: 41,
                    AD_SPOOLER_UNIQUE_ID: 44,
                    AD_REPL_MATE_ACK_MSGID: 45,
                    AD_REDELIVERY_COUNT: 46,
                    /* light wieght parameters */
                    LIGHT_CORRELATION: 0,
                    LIGHT_TOPIC_NAME_OFFSET: 1,
                    LIGHT_QUEUE_NAME_OFFSET: 2,
                    LIGHT_ACK_IMMEDIATELY: 3
                };
                const SMFExtendedParameterType = {
                    // SMFv3 Extended parameters inside the Extended Type Stream
                    //Not supported yet
                    //  GSS_API_TOKEN:        0x28,
                    //  AD_ACK_MESSAGE_ID:    0x29,
                    //  AD_TRANSACTION_ID:    0x2a,
                    //  AD_TRANSACTION_FLAGS: 0x2b,
                    OAUTH2_ISSUER_IDENTIFIER: 47,
                    OIDC_ID_TOKEN: 48,
                    OAUTH2_ACCESS_TOKEN: 49
                };
                module.exports.SMFParameterType = Enum.new(SMFParameterType);
                module.exports.SMFExtendedParameterType = Enum.new(SMFExtendedParameterType);
                /***/
            },
            /***/ "./modules/solclient-smf/lib/smf-protocols.js": 
            /*!****************************************************!*\
  !*** ./modules/solclient-smf/lib/smf-protocols.js ***!
  \****************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * SMFProtocol
 * @private
 * @enum {number}
 */
                const SMFProtocol = {
                    CSPF: 1,
                    CSMP: 2,
                    PUBMSG: 3,
                    XMLLINK: 4,
                    WSE: 5,
                    SEMP: 6,
                    SUBCTRL: 7,
                    PUBCTRL: 8,
                    ADCTRL: 9,
                    KEEPALIVE: 10,
                    KEEPALIVEV2: 11,
                    CLIENTCTRL: 12,
                    TRMSG: 13,
                    JNDI: 14,
                    SMP: 15,
                    SMRP: 16,
                    SMF_IN_SMF: 17,
                    SMF_IN_RV: 18,
                    ADCTRL_PASSTHROUGH: 19,
                    TSESSION: 20
                };
                module.exports.SMFProtocol = Enum.new(SMFProtocol);
                /***/
            },
            /***/ "./modules/solclient-smf/lib/smf-smp-message-type-flags.js": 
            /*!*****************************************************************!*\
  !*** ./modules/solclient-smf/lib/smf-smp-message-type-flags.js ***!
  \*****************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * @private
 * @enum {number}
 */
                const SMFSMPMessageTypeFlags = {
                    FLAG_FILTER: 1,
                    FLAG_PERSIST: 2,
                    SMF_SMP_FLAG_TOPIC: 4,
                    SMF_SMP_FLAG_RESPREQUIRED: 8,
                    SMF_SMP_FLAG_DELIVERALWAYS: 16
                };
                module.exports.SMFSMPMessageTypeFlags = Enum.new(SMFSMPMessageTypeFlags);
                /***/
            },
            /***/ "./modules/solclient-smf/lib/smf-smp-message-types.js": 
            /*!************************************************************!*\
  !*** ./modules/solclient-smf/lib/smf-smp-message-types.js ***!
  \************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * @private
 * @enum {number}
 */
                const SMFSMPMessageType = {
                    ADDSUBSCRIPTION: 0,
                    REMSUBSCRIPTION: 1,
                    ADDQUEUESUBSCRIPTION: 2,
                    REMQUEUESUBSCRIPTION: 3,
                    ADDSUBSCRIPTIONFORCLIENTNAME: 4,
                    REMSUBSCRIPTIONFORCLIENTNAME: 5
                };
                module.exports.SMFSMPMessageType = Enum.new(SMFSMPMessageType);
                /***/
            },
            /***/ "./modules/solclient-smf/lib/smf-transport-session-message-types.js": 
            /*!**************************************************************************!*\
  !*** ./modules/solclient-smf/lib/smf-transport-session-message-types.js ***!
  \**************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * @private
 * @enum {number}
 */
                const SMFTransportSessionMessageType = {
                    CREATE: 0,
                    CREATE_RESP: 1,
                    DESTROY: 2,
                    DESTROY_RESP: 3,
                    DATA: 4,
                    DATA_TOKEN: 5,
                    DATA_STREAM_TOKEN: 6
                };
                module.exports.SMFTransportSessionMessageType = Enum.new(SMFTransportSessionMessageType);
                /***/
            },
            /***/ "./modules/solclient-solcache-session/api.js": 
            /*!***************************************************!*\
  !*** ./modules/solclient-solcache-session/api.js ***!
  \***************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    CacheCBInfo
                } = __webpack_require__(/*! ./lib/cache-cb-info */ "./modules/solclient-solcache-session/lib/cache-cb-info.js");
                const {
                    CacheContext
                } = __webpack_require__(/*! ./lib/cache-context */ "./modules/solclient-solcache-session/lib/cache-context.js");
                const {
                    CacheLiveDataAction
                } = __webpack_require__(/*! ./lib/cache-live-data-actions */ "./modules/solclient-solcache-session/lib/cache-live-data-actions.js");
                const {
                    CacheRequest
                } = __webpack_require__(/*! ./lib/cache-request */ "./modules/solclient-solcache-session/lib/cache-request.js");
                const {
                    CacheRequestResult
                } = __webpack_require__(/*! ./lib/cache-request-result */ "./modules/solclient-solcache-session/lib/cache-request-result.js");
                const {
                    CacheReturnCode
                } = __webpack_require__(/*! ./lib/cache-return-codes */ "./modules/solclient-solcache-session/lib/cache-return-codes.js");
                const {
                    CacheReturnSubcode
                } = __webpack_require__(/*! ./lib/cache-return-subcodes */ "./modules/solclient-solcache-session/lib/cache-return-subcodes.js");
                const {
                    CacheSession
                } = __webpack_require__(/*! ./lib/cache-session */ "./modules/solclient-solcache-session/lib/cache-session.js");
                const {
                    CacheSessionProperties
                } = __webpack_require__(/*! ./lib/cache-session-properties */ "./modules/solclient-solcache-session/lib/cache-session-properties.js");
                module.exports.CacheCBInfo = CacheCBInfo;
                module.exports.CACHE_REQUEST_PREFIX = CacheContext.CACHE_REQUEST_PREFIX;
                module.exports.CacheLiveDataAction = CacheLiveDataAction;
                module.exports.CacheRequestResult = CacheRequestResult;
                module.exports.CacheReturnCode = CacheReturnCode;
                module.exports.CacheReturnSubcode = CacheReturnSubcode;
                module.exports.CacheRequest = CacheRequest;
                module.exports.CacheSession = CacheSession;
                module.exports.CacheSessionProperties = CacheSessionProperties;
                /***/
            },
            /***/ "./modules/solclient-solcache-session/lib/cache-cb-info.js": 
            /*!*****************************************************************!*\
  !*** ./modules/solclient-solcache-session/lib/cache-cb-info.js ***!
  \*****************************************************************/
            /***/ module => {
                /**
 * This callback is called by a cache session when a cache request
 * completes.
 *
 * @callback solace.CacheCBInfo.cacheRequestCallback
 * @function
 * @param {Number} requestID The ID of the request on which the event is notified.
 * @param {solace.CacheRequestResult} result The result of the cache request.
 * @param {Object} userObject The user object provided.
 */
                /**
 * @classdesc
 * Encapsulates a {@link solace.CacheSession}'s request listener callback function and
 * optional application-specified context object.
 *
 * Instances of this class are required as a parameter to
 * {@link solace.CacheSession#sendCacheRequest} when creating a CacheSession request.
 *
 * @memberof solace
 */
                class CacheCBInfo {
                    /**
   * Creates an instance of CacheCBInfo using the provided callback and user context object.
   * @param {solace.CacheCBInfo.cacheRequestCallback} cacheCBFunction The callback to be invoked.
   * @param {Object} userObject A context object to be returned with the callback.
   */
                    constructor(cacheCBFunction, userObject) {
                        /**
     * The function that will be called by the cache session when a request
     * completes.
     * @type {solace.CacheCBInfo.cacheRequestCallback}
     */
                        this.cacheCBFunction = cacheCBFunction;
                        /**
     * The user context object that will be supplied to the callback function
     * when the cache request completes.
     * @type {object}
     */
                        this.userObject = userObject;
                    }
                    /**
   * @returns {solace.CacheCBInfo.cacheRequestCallback} The callback function
   * @private
   */
                    getCallback() {
                        return this.cacheCBFunction;
                    }
                    /**
   * @returns {*} The user context object, if any
   * @private
   */
                    getUserObject() {
                        return this.userObject;
                    }
                }
                module.exports.CacheCBInfo = CacheCBInfo;
                /***/
            },
            /***/ "./modules/solclient-solcache-session/lib/cache-context.js": 
            /*!*****************************************************************!*\
  !*** ./modules/solclient-solcache-session/lib/cache-context.js ***!
  \*****************************************************************/
            /***/ module => {
                /**
 * @private
 * @static
 */
                const CacheContext = {
                    /**
   * A prefix appearing on the request IDs of all requests associated with a Solcache session.
   * @type {String}
   * @private
   */
                    CACHE_REQUEST_PREFIX: "#CRQ",
                    /**
   * A global counter generating unique correlation IDs for cache requests.
   * @private
   */
                    cacheRequestCorrelationId: 0
                };
                module.exports.CacheContext = CacheContext;
                /***/
            },
            /***/ "./modules/solclient-solcache-session/lib/cache-get-result-codes.js": 
            /*!**************************************************************************!*\
  !*** ./modules/solclient-solcache-session/lib/cache-get-result-codes.js ***!
  \**************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * @private
 * @enum {number}
 */
                const CacheGetResultCode = {
                    INVALID: 0,
                    OK: 1
                };
                module.exports.CacheGetResultCode = Enum.new(CacheGetResultCode);
                /***/
            },
            /***/ "./modules/solclient-solcache-session/lib/cache-get-result.js": 
            /*!********************************************************************!*\
  !*** ./modules/solclient-solcache-session/lib/cache-get-result.js ***!
  \********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    CacheGetResultCode
                } = __webpack_require__(/*! ./cache-get-result-codes */ "./modules/solclient-solcache-session/lib/cache-get-result-codes.js");
                const DEFAULTS = {
                    messageID: null,
                    version: 0,
                    responseCode: CacheGetResultCode.INVALID,
                    responseString: "",
                    matchTopic: "",
                    sessionID: null,
                    isSuspect: null,
                    hasMore: null,
                    hasTimestamps: null,
                    replyTo: null,
                    messageStream: null,
                    clusterNameStream: null
                };
                /**
 * @classdesc CacheGetResult encapsulates the result of a cache get request
 * @private
 */
                class CacheGetResult {
                    /*
   * @constructor
   */
                    constructor(options = DEFAULTS) {
                        Object.assign(this, options);
                    }
                    readFromStream(stream) {
                        this.messageID = stream.getNext().getValue();
                        this.version = stream.getNext().getValue();
                        this.responseCode = stream.getNext().getValue();
                        this.responseString = stream.getNext().getValue();
                        // SD claims instanceName is present here but empirically, it's not
                        this.matchTopic = stream.getNext().getValue();
                        this.sessionID = stream.getNext().getValue();
                        this.isSuspect = stream.getNext().getValue();
                        this.hasMore = stream.getNext().getValue();
                        this.hasTimestamps = stream.getNext().getValue();
                        if (stream.hasNext()) {
                            // first stream
                            this.messageStream = stream.getNext().getValue();
                        }
                        if (stream.hasNext()) {
                            // if two streams, first was cluster name stream
                            this.clusterNameStream = this.messageStream;
                            this.messageStream = stream.getNext().getValue();
                        }
                    }
                }
                module.exports.CacheGetResult = CacheGetResult;
                /***/
            },
            /***/ "./modules/solclient-solcache-session/lib/cache-live-data-actions.js": 
            /*!***************************************************************************!*\
  !*** ./modules/solclient-solcache-session/lib/cache-live-data-actions.js ***!
  \***************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * solace.CacheLiveDataAction
 * Enumeration of CacheLiveDataAction values, specifying how the CacheSession should handle
 * live data associated with a cache request in progress.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
                const CacheLiveDataAction = {
                    /**
   * @type {Number}
   * @description End the cache request when live data arrives that matches the topic.
   * Note that wildcard cache requests must always be {@link CacheLiveDataAction.FLOW_THRU}.
   */
                    FULFILL: 1,
                    /**
   * @type {Number}
   * @description Queue arriving live data that matches the topic, until the cache request
   * completes. Note that wildcard cache requests must always be {@link
   * solace.CacheLiveDataAction.FLOW_THRU}.
   */
                    QUEUE: 2,
                    /**
   * @type {Number}
   * @description Continue the outstanding cache request while allowing live data to flow through to
   * the application.
   * Note that wildcard cache requests must always be {@link CacheLiveDataAction.FLOW_THRU}.
   */
                    FLOW_THRU: 3
                };
                module.exports.CacheLiveDataAction = Enum.new(CacheLiveDataAction);
                /***/
            },
            /***/ "./modules/solclient-solcache-session/lib/cache-request-result.js": 
            /*!************************************************************************!*\
  !*** ./modules/solclient-solcache-session/lib/cache-request-result.js ***!
  \************************************************************************/
            /***/ module => {
                /**
 * @classdesc
 * <b>This class is not exposed for construction by API users. A CacheRequestResult object is
 * provided on the callback (see {@link solace.CacheCBInfo.cacheRequestCallback} when a cache
 * request completes.</b>
 *
 * An object that indicates the termination of a cache request, and provides details how it
 * concluded.
 * @memberof solace
 * @hideconstructor
 */
                class CacheRequestResult {
                    /*
   * @param {solace.CacheReturnCode} rc The result of the request.
   *   * When returnCode === CacheReturnCode.OK, the applicable subcodes are:
   *     * {@link CacheReturnSubcode.REQUEST_COMPLETE}
   *     * {@link CacheReturnSubcode.LIVE_DATA_FULFILL}
   *   * When returnCode === CacheReturnCode.FAIL, applicable subcodes are:
   *     * {@link CacheReturnSubcode.ERROR_RESPONSE}
   *     * {@link CacheReturnSubcode.INVALID_SESSION}
   *     * {@link CacheReturnSubcode.REQUEST_ALREADY_IN_PROGRESS}
   *   * When returnCode === CacheReturnCode.INCOMPLETE, applicable subcodes are:
   *     * {@link CacheReturnSubcode.NO_DATA}
   *     * {@link CacheReturnSubcode.REQUEST_TIMEOUT}
   *     * {@link CacheReturnSubcode.SUSPECT_DATA}
   *
   * @param {solace.CacheReturnSubcode} subcode The subcode result of the request. Provides
   *    details on the condition that caused the result.
   * @param {solace.Destination} topic The topic destination on which the request was made.
   * @param {String} error The error, if any, that caused the current result.
   */
                    constructor(rc, subcode, topic, error) {
                        this._returnCode = rc;
                        this._subcode = subcode;
                        this._topic = topic;
                        this._error = error;
                    }
                    /**
   * Gets the return code from the cache request result.
   *
   * @returns {solace.CacheReturnCode} The return code associated with the result of
   * the request.
   */
                    getReturnCode() {
                        return this._returnCode;
                    }
                    /**
   * Gets the return subcode from the cache request result.
   *
   * @returns {solace.CacheReturnSubcode} A subcode that gives more detail than
   * {@link CacheRequestResult#getReturnCode} about the result of the request.
   */
                    getReturnSubcode() {
                        return this._subcode;
                    }
                    /**
   * Gets the topic object associated with the cache request.
   *
   * @returns {solace.Destination} The topic destination supplied for the cache request.
   */
                    getTopic() {
                        return this._topic;
                    }
                    /**
   * Gets the error, if any, associated with the returned result.
   *
   * @returns {String} The error associated with the returned result.
   */
                    getError() {
                        return this._error;
                    }
                }
                module.exports.CacheRequestResult = CacheRequestResult;
                /***/
            },
            /***/ "./modules/solclient-solcache-session/lib/cache-request-types.js": 
            /*!***********************************************************************!*\
  !*** ./modules/solclient-solcache-session/lib/cache-request-types.js ***!
  \***********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * @private
 * @enum {number}
 */
                const CacheRequestType = {
                    INVALID: 0,
                    BULK_MSG: 1,
                    REGISTER_REQUEST: 2,
                    REGISTER_RESPONSE: 3,
                    HEARTBEAT_REQUEST: 4,
                    HEARTBEAT_RESPONSE: 5,
                    EVENT_NOTIFY: 6,
                    EVENT_ACK: 7,
                    ACTION_REQUEST: 8,
                    ACTION_RESPONSE: 9,
                    GET_REQUEST: 10,
                    GET_RESPONSE: 11,
                    GET_NEXT_REQUEST: 12,
                    GET_NEXT_RESPONSE: 13,
                    SET_REQUEST: 14,
                    SET_RESPONSE: 15,
                    GET_MSG_REQUEST: 16,
                    GET_MSG_RESPONSE: 17,
                    GET_NEXT_MSG_REQUEST: 18,
                    GET_NEXT_MSG_RESPONSE: 19,
                    UNREGISTER_IND: 20,
                    BULK_SET_REQUEST: 21,
                    BULK_SET_RESPONSE: 22,
                    PURGE_MSG_SEQUENCE_REQUEST: 23,
                    PURGE_MSG_SEQUENCE_RESPONSE: 24,
                    GET_MSG_SEQUENCE_REQUEST: 25,
                    GET_NEXT_MSG_SEQUENCE_REQUEST: 26,
                    GET_TOPIC_INFO_REQUEST: 27,
                    GET_TOPIC_INFO_RESPONSE: 28,
                    READY_MARKER: 29,
                    GET_TOPIC_INFO_REQUEST_RANGE: 30,
                    SYNC_READY_MARKER: 31,
                    VACUUM_REQUEST: 32,
                    VACUUM_RESPONSE: 33
                };
                module.exports.CacheRequestType = Enum.new(CacheRequestType);
                /***/
            },
            /***/ "./modules/solclient-solcache-session/lib/cache-request.js": 
            /*!*****************************************************************!*\
  !*** ./modules/solclient-solcache-session/lib/cache-request.js ***!
  \*****************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    CacheContext
                } = __webpack_require__(/*! ./cache-context */ "./modules/solclient-solcache-session/lib/cache-context.js");
                const {
                    LOG_DEBUG
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    CACHE_REQUEST_PREFIX
                } = CacheContext;
                /**
 * @private
 */
                class CacheRequest {
                    /**
   * @constructor
   * @param {CacheSession} cacheSession The owning session
   * @param {CacheRequestType} cacheMessageType The type of request
   * @param {Number} requestID The ID for the request
   * @param {CacheCBInfo} cbInfo Callback target
   * @param {CacheLiveDataAction} liveDataAction Action on live data received
   * @param {Topic} topic Associated topic
   * @param {String} cacheName Associated remote cache name
   * @private
   */
                    constructor(cacheSession, cacheMessageType, requestID, cbInfo, liveDataAction, topic, cacheName) {
                        this.cacheSession = cacheSession;
                        this.cacheMessageType = cacheMessageType;
                        this.requestID = requestID;
                        this.cbInfo = cbInfo;
                        this.liveDataAction = liveDataAction;
                        this.topic = topic;
                        this.cacheName = cacheName;
                        this.subscriptionWaiting = null;
                        this.replyReceived = false;
                        this.dataReceived = false;
                        this.isSuspect = false;
                        this.correlationID = `${CACHE_REQUEST_PREFIX}${CacheContext.cacheRequestCorrelationId++}`;
                        this.childRequests = [];
                        this.parentRequest = null;
                        this.queuedLiveData = [];
                        this.liveDataFulfilled = false;
                        this.timeoutHandle = null;
                    }
                    /**
   * @returns {CacheRequest} The root cache request in the current request tree
   * @private
   */
                    getRootRequest() {
                        if (!this.parentRequest) {
                            return this;
                        }
                        return this.parentRequest.getRootRequest();
                    }
                    /**
   * @param {CacheRequest} childIn A request to make a descendant of this node in the request tree
   * @private
   */
                    addChild(childIn) {
                        if (!(childIn instanceof CacheRequest)) {
                            throw new Error(`Invalid child ${childIn}`);
                        }
                        if (childIn === this) {
                            throw new Error("Constructing circular child reference");
                        }
                        const child = childIn;
                        child.parentRequest = this;
                        this.childRequests.push(child);
                    }
                    /**
   * @param {CacheRequest} childIn A request to remove as a descendant of this node
   * @private
   */
                    removeChild(childIn) {
                        if (childIn === this) {
                            throw new Error("Attempting to deconstruct invalid circular child reference");
                        }
                        const child = childIn;
                        const childIndex = this.childRequests.indexOf(child);
                        if (childIndex === -1) {
                            LOG_DEBUG(`Child ${child} not found in ${this}`);
                        }
                        this.childRequests.splice(childIndex, 1);
                        child.parentRequest = null;
                    }
                    /**
   * @private
   */
                    collapse() {
                        const parentRequest = this.parentRequest;
                        parentRequest.isSuspect = parentRequest.isSuspect || this.isSuspect;
                        parentRequest.dataReceived = parentRequest.dataReceived || this.dataReceived;
                        parentRequest.removeChild(this);
                    }
                    /**
   * @private
   */
                    cancel() {
                        if (this.parentRequest) {
                            this.collapse();
                        }
                        while (this.childRequests.length) {
                            const child = this.childRequests.shift();
                            if (child.childRequests) {
                                child.cancel();
                            }
                            this.removeChild(child);
                        }
                        this.clearRequestTimeout();
                    }
                    /**
   * @returns {Number} The ID of this request
   * @private
   */
                    getRequestID() {
                        return this.requestID;
                    }
                    /**
   * @returns {CacheCBInfo} The callback object for this request
   * @private
   */
                    getCBInfo() {
                        return this.cbInfo;
                    }
                    /**
   * @returns {Topic} The topic for this request
   * @private
   */
                    getTopic() {
                        return this.topic;
                    }
                    /**
   * @returns {CacheLiveDataAction} The live data action for this request
   * @private
   */
                    getLiveDataAction() {
                        return this.liveDataAction;
                    }
                    /**
   * @param {function({solace.CacheRequest})} cacheSessionTimeoutCB Callback to notify on timeout
   * @param {Number} timeoutMsec Timeout in milliseconds
   * @private
   */
                    startRequestTimeout(cacheSessionTimeoutCB, timeoutMsec) {
                        this.timeoutHandle = setTimeout(() => {
                            cacheSessionTimeoutCB(this);
                        }, timeoutMsec);
                    }
                    /**
   * @private
   */
                    clearRequestTimeout() {
                        if (this.timeoutHandle === null || this.timeoutHandle === undefined) {
                            return;
                        }
                        LOG_DEBUG(`Clearing timeout for ${this}`);
                        clearTimeout(this.timeoutHandle);
                        this.timeoutHandle = null;
                    }
                    /**
   * Returns a string representing the request.
   * @returns {String} A brief description of this object
   */
                    toString() {
                        return `CacheRequest[correlationID=${this.correlationID},requestID=${this.requestID},cacheName=${this.cacheName},topic=${this.topic.getName()}]`;
                    }
                }
                /**
 * @private
 */
                CacheRequest.VERSION = 1;
                /**
 * @private
 */
                CacheRequest.DEFAULT_REPLY_SIZE_LIMIT = 1e6;
                /**
 * @private
 */
                CacheRequest.REPLY_SIZE_LIMIT = CacheRequest.DEFAULT_REPLY_SIZE_LIMIT;
                module.exports.CacheRequest = CacheRequest;
                /***/
            },
            /***/ "./modules/solclient-solcache-session/lib/cache-return-codes.js": 
            /*!**********************************************************************!*\
  !*** ./modules/solclient-solcache-session/lib/cache-return-codes.js ***!
  \**********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Enumeration of CacheReturnCode types.  The method {@link solace.CacheRequestResult#getReturnCode}
 * returns on of these basic results of a cache request.  More details are available in the
 * associated {@link solace.CacheReturnSubcode}, retrieved by
 * {@link solace.CacheRequestResult#getReturnSubcode}.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
                const CacheReturnCode = {
                    /**
   * @type {Number}
   * @description The cache request succeeded.  See the subcode for more information.
   */
                    OK: 1,
                    /**
   * @type {Number}
   * @description The cache request was not processed.  See the subcode for more information.
   */
                    FAIL: 2,
                    /**
   * @type {Number}
   * @description The cache request was processed but could not be completed.  See the subcode for
   * more information.
   */
                    INCOMPLETE: 3
                };
                module.exports.CacheReturnCode = Enum.new(CacheReturnCode);
                /***/
            },
            /***/ "./modules/solclient-solcache-session/lib/cache-return-subcodes.js": 
            /*!*************************************************************************!*\
  !*** ./modules/solclient-solcache-session/lib/cache-return-subcodes.js ***!
  \*************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Enumeration of CacheReturnSubcode types.
 * @enum {number}
 * @namespace
 * @memberof solace
 */
                const CacheReturnSubcode = {
                    /**
   * @type {Number}
   * @description
   * The cache request completed successfully.
   */
                    REQUEST_COMPLETE: 0,
                    /**
   * @type {Number}
   * @description
   * The cache request completed when live data arrived on the topic requested.
   */
                    LIVE_DATA_FULFILL: 1,
                    /**
   * @type {Number}
   * @description
   * The cache instance or session returned an error response to the cache request.
   */
                    ERROR_RESPONSE: 2,
                    /**
   * @type {Number}
   * @description
   * The cache request failed because the {@link Session} used to construct it has been
   * disposed.
   */
                    INVALID_SESSION: 3,
                    /**
   * @type {Number}
   * @description
   * The cache request failed because the request timeout expired.
   */
                    REQUEST_TIMEOUT: 4,
                    /**
   * @type {Number}
   * @description
   * The cache request was made on the same topic as an existing request, and
   * {@link CacheLiveDataAction.FLOW_THRU} was not set.
   */
                    REQUEST_ALREADY_IN_PROGRESS: 5,
                    /**
   * @type {Number}
   * @description
   * The cache reply returned no data.
   */
                    NO_DATA: 6,
                    /**
   * @type {Number}
   * @description
   * The cache reply returned suspect data.
   */
                    SUSPECT_DATA: 7,
                    /**
   * @type {Number}
   * @description
   * The request was terminated because the cache session was disposed.
   */
                    CACHE_SESSION_DISPOSED: 8,
                    /**
   * @type {Number}
   * @description
   * The request was terminated because the subscription request for the specified topic failed.
   */
                    SUBSCRIPTION_ERROR: 9
                };
                module.exports.CacheReturnSubcode = Enum.new(CacheReturnSubcode);
                /***/
            },
            /***/ "./modules/solclient-solcache-session/lib/cache-session-properties.js": 
            /*!****************************************************************************!*\
  !*** ./modules/solclient-solcache-session/lib/cache-session-properties.js ***!
  \****************************************************************************/
            /***/ module => {
                /**
 * @classdesc
 *
 * Encapsulates the properties of a cache session.
 *
 * @memberof solace
 *
 */
                class CacheSessionProperties {
                    /**
    * @constructor
    *
    * @param {String} cacheName A property that specifies the cache name to which CacheSession
    *   operations should be sent.
    * @param {Number} [maxAgeSec=0] The maximum allowable message age in seconds to deliver in
    *   response to a cache request. 0 means no restriction on age.
    * @param {Number} [maxMessages=1] The maximum number of messages per Topic to deliver in
    *   response to cache requests. 0 means no restriction on the number of messages.
    * @param {Number} [timeoutMsec=10000] The timeout period (in milliseconds) to wait for a
    *   response from the cache. This is a protocol timer used internally by the API on each
    *   message exchange with SolCache. A single call to
    *   {@link solace.CacheSession#sendCacheRequest} may lead to many request-reply exchanges
    *   with SolCache and so is not bounded by this timer as long as each internal request is
    *   satisfied in time.
    *   * The valid range for this property is >= 3000.
    */
                    constructor(cacheName, maxAgeSec, maxMessages, timeoutMsec) {
                        /**
     * @type {String}
     *
     * @description A property that specifies the cache name to which CacheSession operations should
     * be sent.
     */
                        this.cacheName = cacheName;
                        /**
     * @type {Number}
     *
     * @description The maximum allowable message age in seconds to deliver in response to cache
     * requests.  0 means no restriction on age.
     *
     * @default 0
     */
                        this.maxAgeSec = maxAgeSec || 0;
                        /**
     * @type {Number}
     *
     * @description The maximum number of messages per Topic to deliver in response to cache
     * requests.  0 means no restriction on the number of messages.
     *
     * @default 1
     */
                        this.maxMessages = maxMessages === null || maxMessages === undefined ? 1 : maxMessages;
                        /**
     * @type {Number}
     *
     * @description The timeout for a cache request, in milliseconds.  The valid range for this
     * property is >= 3000.
     *
     * @default 10000
     */
                        this.timeoutMsec = timeoutMsec || 1e4;
                        /**
     * @private
     * @type {Boolean}
     * @description Whether to include other clusters in the request.
     * @default true
     */
                        this.includeOtherClusters = true;
                        /**
     * @private
     */
                        this.cachePrefix = "#P2P/CACHEINST/";
                    }
                    /**
   * Gets the cache name to which {@link solace.CacheSession} requests should be sent, for
   * sessions constructed using these properties.
   *
   * @returns {String} The cache name.
   */
                    getCacheName() {
                        return this.cacheName;
                    }
                    /**
   * Sets the cache name to which requests should be sent. Cannot be null or blank.
   * @param {String} value The cache name to which requests should be sent.
   */
                    setCacheName(value) {
                        this.cacheName = value;
                    }
                    /**
   * Gets the maximum allowable message age for messages to be delivered in response to a request
   * made on a {@link solace.CacheSession} that was constructed using these properties.  0 means no
   * restriction on age.
   *
   * @returns {Number} The maximum allowable message age to be returned by an associated
   * {@link solace.CacheSession}, or 0 for no restriction.
   */
                    getMaxMessageAgeSec() {
                        return this.maxAgeSec;
                    }
                    /**
   * Sets the maximum allowable message age. 0 means no restriction on age.
   *
   * @param {Number} value The maximum allowable message age, or 0 for no restriction.
   */
                    setMaxMessageAgeSec(value) {
                        this.maxAgeSec = value;
                    }
                    /**
   * Gets the maximum count of messages to be delivered, per {@link solace.Destination}, in
   * response to a request issued on a {@link solace.CacheSession} constructed using these
   * properties.  0 means no restriction on the number of messages.
   *
   * @returns {Number} The maximum number of messages per Topic to deliver, or 0 for no restriction.
   */
                    getMaxMessages() {
                        return this.maxMessages;
                    }
                    /**
   * Sets the maximum count of messages to be delivered per {@link solace.Destination} in response
   * to a cache request. 0 means no restriction.
   *
   * @param {Number} value The maximum count of messages to deliver, or 0 for no restriction.
   */
                    setMaxMessages(value) {
                        this.maxMessages = value;
                    }
                    /**
   * Gets the timeout for requests issued on a {@link solace.CacheSession} constructed
   * using these properties.
   *  * The valid range is >= 3000.
   *
   * @returns {Number} The timeout, in milliseconds, for cache session requests.
   */
                    getTimeoutMsec() {
                        return this.timeoutMsec;
                    }
                    /**
   * Sets the timeout for requests.
   *  * The valid range is >= 3000.
   * @param {Number} value The timeout for requests.
   */
                    setTimeoutMsec(value) {
                        this.timeoutMsec = value;
                    }
                }
                module.exports.CacheSessionProperties = CacheSessionProperties;
                /***/
            },
            /***/ "./modules/solclient-solcache-session/lib/cache-session-subscribe-info.js": 
            /*!********************************************************************************!*\
  !*** ./modules/solclient-solcache-session/lib/cache-session-subscribe-info.js ***!
  \********************************************************************************/
            /***/ module => {
                /**
 * A tuple associating subscriptions, correlation IDs and cache sessions.
 * @param {String} correlationID The correlation ID for this tuple
 * @param {Topic} topic The topic for this tuple
 * @param {CacheSession} cacheSession The cache session for this tuple
 * @private
 */
                class CacheSessionSubscribeInfo {
                    constructor(correlationID, topic, cacheSession) {
                        Object.assign(this, {
                            correlationID: correlationID,
                            topic: topic,
                            cacheSession: cacheSession
                        });
                    }
                }
                module.exports.CacheSessionSubscribeInfo = CacheSessionSubscribeInfo;
                /***/
            },
            /***/ "./modules/solclient-solcache-session/lib/cache-session.js": 
            /*!*****************************************************************!*\
  !*** ./modules/solclient-solcache-session/lib/cache-session.js ***!
  \*****************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const MessageLib = __webpack_require__(/*! solclient-message */ "./modules/solclient-message/api.js");
                const SessionLib = __webpack_require__(/*! solclient-session */ "./modules/solclient-session/api.js");
                const SMFLib = __webpack_require__(/*! solclient-smf */ "./modules/solclient-smf/api.js");
                const StatType = __webpack_require__(/*! solclient-stats */ "./modules/solclient-stats/api.js");
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    LOG_TRACE,
                    LOG_DEBUG,
                    LOG_INFO,
                    LOG_WARN
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    SDTField,
                    SDTFieldType,
                    SDTStreamContainer
                } = __webpack_require__(/*! solclient-sdt */ "./modules/solclient-sdt/api.js");
                const {
                    CacheCBInfo
                } = __webpack_require__(/*! ./cache-cb-info */ "./modules/solclient-solcache-session/lib/cache-cb-info.js");
                const {
                    CacheContext
                } = __webpack_require__(/*! ./cache-context */ "./modules/solclient-solcache-session/lib/cache-context.js");
                const {
                    CacheGetResult
                } = __webpack_require__(/*! ./cache-get-result */ "./modules/solclient-solcache-session/lib/cache-get-result.js");
                const {
                    CacheLiveDataAction
                } = __webpack_require__(/*! ./cache-live-data-actions */ "./modules/solclient-solcache-session/lib/cache-live-data-actions.js");
                const {
                    CacheRequest
                } = __webpack_require__(/*! ./cache-request */ "./modules/solclient-solcache-session/lib/cache-request.js");
                const {
                    CacheRequestResult
                } = __webpack_require__(/*! ./cache-request-result */ "./modules/solclient-solcache-session/lib/cache-request-result.js");
                const {
                    CacheRequestType
                } = __webpack_require__(/*! ./cache-request-types */ "./modules/solclient-solcache-session/lib/cache-request-types.js");
                const {
                    CacheReturnCode
                } = __webpack_require__(/*! ./cache-return-codes */ "./modules/solclient-solcache-session/lib/cache-return-codes.js");
                const {
                    CacheReturnSubcode
                } = __webpack_require__(/*! ./cache-return-subcodes */ "./modules/solclient-solcache-session/lib/cache-return-subcodes.js");
                const {
                    CacheSessionProperties
                } = __webpack_require__(/*! ./cache-session-properties */ "./modules/solclient-solcache-session/lib/cache-session-properties.js");
                const {
                    CacheSessionSubscribeInfo
                } = __webpack_require__(/*! ./cache-session-subscribe-info */ "./modules/solclient-solcache-session/lib/cache-session-subscribe-info.js");
                const {
                    Destination,
                    Topic
                } = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                const {
                    CACHE_REQUEST_PREFIX
                } = CacheContext;
                const noOp = () => undefined;
                /**
 * @classdesc
 * <b>This class is not exposed for construction by API users. Users should obtain an instance from
 * {@link solace.Session#createCacheSession}</b>
 * <p>
 * A session for performing cache requests.
 *
 * Applications must use {@link solace.Session#createCacheSession} to construct this class.
 *
 * The supplied {@link solace.CacheSessionProperties} will be copied. Subsequent modifications
 * to the passed properties will not modify the session. The properties may be reused.
 *
 * @hideconstructor
 * @memberof solace
 */
                class CacheSession {
                    /*
   * @constructor
   * @private
   *
   * @param {solace.CacheSessionProperties} props The properties for the cache session.
   * @param {solace.Session} session The Session on which the CacheSession will issue
   *  cache requests.
   * @param {Object} privateInterface Private methods exposed to this CacheSession.
   *
   * @throws {solace.OperationError}
   *  * if the parameters have an invalid type or value;
   *    subcode {@link ErrorSubcode.PARAMETER_INVALID_TYPE}.
   */
                    constructor(props, session, privateInterface) {
                        CacheSession._validateProps(props);
                        const properties = new CacheSessionProperties(props.cacheName, props.maxAgeSec, props.maxMessages, props.timeoutMsec);
                        Object.assign(this, {
                            _outstandingRequests: {},
                            _outstandingIDs: {},
                            _disposed: false,
                            _nextMessageCallbackInfo: null,
                            _nextSessionEventCallbackInfo: null,
                            _properties: properties,
                            _session: session,
                            _sessionIF: privateInterface
                        });
                        this._connectToSession(session);
                    }
                    /**
   * @param {solace.Session} session The session to connect
   * @private
   */
                    _connectToSession(session) {
                        this._nextSessionEventCallbackInfo = session.getEventCBInfo();
                        this._nextMessageCallbackInfo = session.getMessageCBInfo();
                        session.setMessageCBInfo(new SessionLib.MessageRxCBInfo((_, message) => {
                            this._handleMessage(message);
                        }, this));
                        session.setEventCBInfo(this._createCompoundEventCB(this._nextSessionEventCallbackInfo));
                    }
                    /**
   * Takes the session's existing event callback and sets it as the next delegate in a
   * chain of responsibility. The next delegate could be the client application, or another
   * cache session.
   * @param {SessionEventCBInfo} nextDelegate The next event receiver in the chain
   * @returns {SessionEventCBInfo} An event receiver that delegates to the supplied receiver
   * @private
   */
                    _createCompoundEventCB(nextDelegate) {
                        return new SessionLib.SessionEventCBInfo((session, sessionEvent, userObject, rfuObject) => {
                            this._handleSessionEvent(nextDelegate, session, sessionEvent, userObject, rfuObject);
                        }, null);
                    }
                    /**
   * Modified chain of responsibility. Handles the event, then passes the event to the next
   * delegate.
   * @param {SessionEventCBInfo} nextDelegate The next delegate to notify
   * @param {solace.Session} session The associated session
   * @param {SessionEvent} sessionEvent The session event to dispatch
   * @private
   */
                    _handleSessionEvent(nextDelegate, session, sessionEvent /*, userObject, rfuObject */) {
                        const passEvent = this._processSessionEvent(session, sessionEvent);
                        if (!passEvent) {
                            return;
                        }
                        const cbUserObject = nextDelegate.userObject;
                        if (!cbUserObject) {
                            nextDelegate.sessionEventCBFunction(session, sessionEvent);
                        } else {
                            nextDelegate.sessionEventCBFunction(session, sessionEvent, cbUserObject);
                        }
                    }
                    /**
   * @param {Message} message The message to forward
   * @private
   */
                    _sendToNextDelegate(message) {
                        const cbUserObject = this._nextMessageCallbackInfo.userObject;
                        if (!cbUserObject) {
                            this._nextMessageCallbackInfo.messageRxCBFunction(this._session, message);
                        } else {
                            this._nextMessageCallbackInfo.messageRxCBFunction(this._session, message, cbUserObject);
                        }
                    }
                    /**
   * @param {solace.Session} session The associated session
   * @param {SessionEvent} event The event to process
   * @returns {Boolean} true if event should pass to next delegate
   * @private
   */
                    _processSessionEvent(session, event) {
                        switch (event.sessionEventCode) {
                          case SessionLib.SessionEventCode.SUBSCRIPTION_ERROR:
                          case SessionLib.SessionEventCode.SUBSCRIPTION_OK:
                            return this._checkSubscriptionStatus(event);

                          case SessionLib.SessionEventCode.DOWN_ERROR:
                            this.dispose();
                            return true;

                          default:
                            LOG_TRACE(`Unhandled session event: ${event.sessionEventCode}`);
                            return true;
                        }
                    }
                    /**
   * @param {SessionEvent} event The event to check
   * @returns {Boolean} `true` if event should pass to next delegate
   * @private
   */
                    _checkSubscriptionStatus(event) {
                        // Incremental checks for whether this is our subscription.
                        if (event.correlationKey === null || event.correlationKey === undefined || !(event.correlationKey instanceof CacheSessionSubscribeInfo) || event.correlationKey.cacheSession !== this) {
                            return true;
                        }
                        const request = this._getOutstandingRequest(event.correlationKey.correlationID);
                        if (!request) {
                            LOG_WARN(`No request found for subscription success on ${event.correlationKey.topic}`);
                            return true;
                        }
                        if (event.sessionEventCode === SessionLib.SessionEventCode.SUBSCRIPTION_OK) {
                            this._handleSubscriptionSuccess(request, event.correlationKey.topic);
                            return false;
                        }
                        this._handleSubscriptionError(request, event);
                        return false;
                    }
                    /**
   * @param {CacheRequest} requestIn The cache on which to register success
   * @param {Topic} topic The topic on which to issue the request.
   * @private
   */
                    _handleSubscriptionSuccess(requestIn /*, topic */) {
                        // Null out this field and check completion status.
                        const request = requestIn;
                        request.subscriptionWaiting = null;
                        this._startCacheRequest(request);
                    }
                    /**
   * @param {CacheRequest} request The cache request on which to register failure
   * @private
   */
                    _handleSubscriptionError(request /*, event */) {
                        this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.SUBSCRIPTION_ERROR);
                    }
                    /**
   * @param {CacheRequest} request The cache request on which to check completion
   * @private
   */
                    _checkRequestCompletion(request) {
                        if (request.childRequests.length) {
                            // Not finished with spawned child requests.
                            LOG_DEBUG(`Awaiting termination of ${request.childRequests.length} children`);
                            return;
                        }
                        if (request.subscriptionWaiting) {
                            // Waiting for confirmation of subscription to a topic.
                            LOG_DEBUG("Awaiting subscription");
                            return;
                        }
                        if (request.timeoutHandle !== null && !request.replyReceived) {
                            LOG_DEBUG("Awaiting timeout");
                            return;
                        }
                        if (request.parentRequest) {
                            // We're no longer waiting for a child to complete.
                            const parent = request.parentRequest;
                            request.cancel();
                            this._unregisterRequest(request);
                            this._checkRequestCompletion(parent);
                            return;
                        }
                        // This is a parent request and it is done.
                        let code;
                        let subcode;
                        if (request.isSuspect) {
                            code = CacheReturnCode.INCOMPLETE;
                            subcode = CacheReturnSubcode.SUSPECT_DATA;
                        } else if (request.dataReceived) {
                            code = CacheReturnCode.OK;
                            if (request.liveDataFulfilled) {
                                subcode = CacheReturnSubcode.LIVE_DATA_FULFILL;
                            } else {
                                subcode = CacheReturnSubcode.REQUEST_COMPLETE;
                            }
                        } else if (request.replyReceived) {
                            code = CacheReturnCode.INCOMPLETE;
                            subcode = CacheReturnSubcode.NO_DATA;
                        } else {
                            throw new Error("Sanity: should never happen");
                        }
                        this._terminateRequest(request, code, subcode);
                    }
                    /**
   * @param {CacheRequest} parentRequest The parent node for the new request
   * @param {CacheGetResult} cacheGetResult The result of this request
   * @private
   */
                    _sendSeeOther(parentRequest, cacheGetResult) {
                        const clusterName = cacheGetResult.clusterNameStream.getNext().getValue();
                        // var root = parentRequest.getRootRequest();
                        LOG_DEBUG(`See Other for ${clusterName}. Sending child request`);
                        const childRequest = new CacheRequest(this, CacheRequestType.GET_MSG_REQUEST, parentRequest.requestID, new CacheCBInfo(noOp, null), parentRequest.liveDataAction, parentRequest.topic, clusterName);
                        // Add this request to its parent
                        parentRequest.addChild(childRequest);
                        // Start the request
                        this._registerRequest(childRequest);
                        childRequest.startRequestTimeout(CacheSession._handleCacheRequestTimeout, this._properties.timeoutMsec);
                        this._startCacheRequest(childRequest, // request to send
                        null, // no session ID
                        null, // no specific instance target
                        true); // don't return other clusters
                    }
                    /**
   * @param {CacheRequest} parentRequest The parent node for the new request
   * @param {CacheGetResult} cacheGetResult The result of this request
   * @private
   */
                    _sendGetNext(parentRequest, cacheGetResult) {
                        LOG_DEBUG("Cache result has more, sending GET_NEXT_MSG_REQUEST as child");
                        // This is how to trigger "Invalid Session":
                        //require("child_process").execSync('sleep 11');
                        const nextRequest = new CacheRequest(this, CacheRequestType.GET_NEXT_MSG_REQUEST, parentRequest.requestID, new CacheCBInfo(noOp, null), parentRequest.liveDataAction, parentRequest.topic, parentRequest.cacheName);
                        // Set up parent-child relationship
                        parentRequest.addChild(nextRequest);
                        // Start the request
                        this._registerRequest(nextRequest);
                        nextRequest.startRequestTimeout(CacheSession._handleCacheRequestTimeout, this._properties.timeoutMsec);
                        this._startCacheRequest(nextRequest, // request to send
                        cacheGetResult.sessionID, // supplied session ID
                        cacheGetResult.replyTo); // supplied cache instance target
                    }
                    /**
   * @param {Message} message The message to inspect and handle
   * @private
   */
                    _handleMessage(message) {
                        // Determine if the message is associated with one of this session's requests
                        const correlationID = message.getCorrelationId();
                        const request = correlationID === null || correlationID === undefined ? null : this._outstandingRequests[correlationID];
                        // This could be live data on a relevant topic.  Check that.
                        if (!request) {
                            if (this._relevantLiveData(message)) {
                                this._sendToNextDelegate(message);
                            }
                            return;
                        }
                        // It's ours!
                        LOG_DEBUG(`Processing reply to ${request}`);
                        // bug 36404: We have a response. Cancel the timeout for this request.
                        request.clearRequestTimeout();
                        const streamField = message.getSdtContainer();
                        const stream = streamField && streamField.getValue();
                        if (!stream) {
                            LOG_INFO(`Invalid message format for cache response: no SDT container (${streamField}) or stream (${stream})`);
                            this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.ERROR_RESPONSE);
                        }
                        // The session will never see this reply, so we need to update the stats
                        // from here.
                        this._incStat(StatType.RX_REPLY_MSG_RECVED);
                        request.replyReceived = true;
                        // If the request was fulfilled by live data, discard the reply and stop processing
                        // the response.
                        if (request.getRootRequest().liveDataFulfilled) {
                            this._incStat(StatType.CACHE_REQUEST_FULFILL_DISCARD_RESPONSE);
                            this._checkRequestCompletion(request);
                            return;
                        }
                        if (!stream) {
                            LOG_INFO("Invalid cache response did not fulfill request. Skipping response processing");
                            return;
                        }
                        try {
                            // Fill the result object with values from the result stream.
                            const result = new CacheGetResult();
                            result.readFromStream(stream);
                            result.replyTo = message.getReplyTo();
                            if (result.responseString) {
                                LOG_DEBUG(`Cluster response: ${result.responseString}`);
                            }
                            if (result.responseCode === 7 || result.responseString == "Invalid Session") {
                                LOG_INFO(`Cluster response indicates invalid session: ${result.responseString} code: ${result.responseCode}`);
                                this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.INVALID_SESSION);
                            }
                            // Apply the isSuspect flag. Don't clear it if the result is already suspect.
                            request.isSuspect = request.isSuspect || result.isSuspect;
                            // Get any inner messages.
                            const messages = CacheSession._decodeMessageStream(request, result);
                            // Update statistics.
                            this._incStat(StatType.RX_CACHE_MSG, messages.length);
                            // If we have more results to come, send a get next request.
                            if (result.hasMore) {
                                this._sendGetNext(request, result);
                            }
                            // If we have more clusters to visit, send requests to those clusters.
                            if (result.clusterNameStream) {
                                LOG_DEBUG("Receiving cluster stream");
                                while (result.clusterNameStream.hasNext()) {
                                    this._sendSeeOther(request, result);
                                }
                            }
                            // Forward any retrieved messages.
                            if (messages) {
                                messages.forEach(m => {
                                    this._sendToNextDelegate(m);
                                });
                            }
                            this._checkRequestCompletion(request);
                        } catch (exception) {
                            LOG_INFO(`Invalid message format for cache response: ${exception.stack}`);
                            this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.ERROR_RESPONSE);
                        }
                    }
                    /**
   * @param {Message} message The message to inspect and handle
   * @returns {Boolean} `true` if the next delegate should handle this message
   * @private
   */
                    _relevantLiveData(message) {
                        // If the next message processor does not belong to a cache
                        // session, and this is a CRQ message, suppress it.
                        if (message.getCorrelationId() && message.getCorrelationId().startsWith(CACHE_REQUEST_PREFIX) && !(this._nextMessageCallbackInfo.userObject instanceof CacheSession)) {
                            LOG_WARN("DROP: Dropping CRQ reply due to no remaining Cache Session processors on message " + "callback chain");
                            this._incStat(StatType.RX_REPLY_MSG_DISCARD);
                            return false;
                        }
                        // Otherwise, assume the message should flow through.
                        // If all _performLiveDataAction calls return true, we return true;
                        return Object.keys(this._outstandingRequests).every(checkCID => this._performLiveDataAction(this._outstandingRequests[checkCID], message));
                    }
                    /**
   * @param {CacheRequest} requestIn The cache request for which to perform the action
   * @param {Message} message The message to process on the request
   * @returns {Boolean} true if message should flow through after action.
   * @private
   */
                    _performLiveDataAction(requestIn, message) {
                        const request = requestIn;
                        request.dataReceived = true;
                        switch (request.liveDataAction) {
                          case CacheLiveDataAction.QUEUE:
                            request.queuedLiveData.push(message);
                            return false;

                          case CacheLiveDataAction.FULFILL:
                            if (!request.liveDataFulfilled) {
                                this._fulfillRequest(request);
                            }
                            return true;

                          default:
                            return true;
                        }
                    }
                    /**
   * @param {CacheRequest} requestIn The request to fulfill
   * @private
   */
                    _fulfillRequest(requestIn) {
                        const request = requestIn;
                        request.liveDataFulfilled = true;
                        this._trackCompletionStats(CacheReturnCode.OK, CacheReturnSubcode.LIVE_DATA_FULFILL);
                        // We have more work to do here -- we need to return the live data first.
                        // Schedule the notification for later.
                        setTimeout(() => {
                            CacheSession._notifyCallback(request, CacheReturnCode.OK, CacheReturnSubcode.LIVE_DATA_FULFILL, request.getTopic(), null);
                        }, 0);
                    }
                    /**
   * Disposes the session.  No cache requests will be sent by this CacheSession after it is
   * _disposed.
   *
   * Any subsequent operations on the session will throw {OperationError}.
   *
   * Any pending operations will immediately terminate, returning
   *   * {@link solace.CacheRequestResult}
   *     * #returnCode === {@link solace.CacheReturnCode.INCOMPLETE}
   *     * #subcode === {@link solace.CacheReturnSubcode.CACHE_SESSION_DISPOSED}
   * @throws {solace.OperationError} if the CacheSession is already _disposed.
   */
                    dispose() {
                        const toTerminate = Object.keys(this._outstandingRequests).map(correlationID => this._outstandingRequests[correlationID]).filter(request => request instanceof CacheRequest);
                        toTerminate.forEach(request => {
                            this._terminateRequest(request, CacheReturnCode.INCOMPLETE, CacheReturnSubcode.CACHE_SESSION_DISPOSED);
                        });
                        this._outstandingRequests = [];
                        // Restore original listeners
                        this._session.setEventCBInfo(this._nextSessionEventCallbackInfo);
                        this._session.setMessageCBInfo(this._nextMessageCallbackInfo);
                        // Set _disposed
                        this._disposed = true;
                    }
                    /**
   * Gets the cache session properties.
   *
   * @returns {solace.CacheSessionProperties} The properties for the session.
   * @throws {solace.OperationError} if the CacheSession is disposed.
   */
                    getProperties() {
                        return this._properties;
                    }
                    /**
   * Issues an asynchronous cache request. The result of the request will be returned via the
   * listener. Messages returned as a result of issuing the request will be returned to the
   * application via the {@link solace.MessageRxCBInfo} associated with this
   * {@link solace.CacheSession}'s {@link solace.Session}
   *
   * @param {Number} requestID The application-assigned ID number for the request.
   * @param {solace.Destination} topic The topic destination for which the cache request will be
   *    made.
   * @param {Boolean} subscribe If true, the session will subscribe to the given {Topic}, if it is
   * not already subscribed, before performing the cache request.
   * @param {solace.CacheLiveDataAction} liveDataAction The action to perform when the
   *    {@link solace.CacheSession} receives live data on the given topic.
   * @param {solace.CacheCBInfo} cbInfo Callback info for the cache request.
   *
   * @throws {solace.OperationError} In the following cases:
   * * If the CacheSession is disposed.
   *    Subcode: {@link solace.ErrorSubcode.INVALID_OPERATION}
   * * If one or more parameters were invalid.
   *    Subcode: {@link solace.ErrorSubcode.PARAMETER_INVALID_TYPE}
   * * If the supplied topic and live data action cannot be combined.
   *    Subcode: {@link solace.ErrorSubcode.PARAMETER_CONFLICT}
   * * If the supplied topic or live data action cannot be used given the current outstanding
   *    requests.
   *    Subcode: {@link solace.ErrorSubcode.PARAMETER_CONFLICT}
   */
                    sendCacheRequest(requestID, topic, subscribe, liveDataAction, cbInfo) {
                        if (arguments.length !== 5) {
                            throw new OperationError(`sendCacheRequest() invoked with an illegal argument count of ${arguments.length}`);
                        }
                        if (typeof subscribe !== "boolean") {
                            throw new OperationError(`Invalid subscribe flag argument, should be a boolean but was ${typeof subscribe}`);
                        }
                        if (typeof requestID !== "number" || Number.isNaN(requestID)) {
                            throw new OperationError("Invalid requestID", ErrorSubcode.PARAMETER_INVALID_TYPE, null);
                        }
                        if (this._outstandingIDs[requestID]) {
                            throw new OperationError("Request already in progress with this requestID");
                        }
                        if (!(topic instanceof Destination)) {
                            throw new OperationError("Invalid topic", ErrorSubcode.PARAMETER_INVALID_TYPE, typeof topic);
                        }
                        topic.validate();
                        if (!(liveDataAction === CacheLiveDataAction.FLOW_THRU || liveDataAction === CacheLiveDataAction.FULFILL || liveDataAction === CacheLiveDataAction.QUEUE)) {
                            throw new OperationError("Invalid live data action", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                        if (topic.isWildcarded() && liveDataAction !== CacheLiveDataAction.FLOW_THRU) {
                            throw new OperationError("Wildcarded topic not supported for this live data action", ErrorSubcode.PARAMETER_CONFLICT);
                        }
                        if (!(cbInfo instanceof CacheCBInfo)) {
                            throw new OperationError("Callback info was not an instance of CacheCBInfo");
                        }
                        if (this._disposed) {
                            CacheSession._notifyCallbackError(cbInfo, requestID, CacheReturnCode.FAIL, CacheReturnSubcode.CACHE_SESSION_DISPOSED, topic, "Cache request failed: the cache session is disposed.");
                            return;
                        }
                        if (this._session._disposed) {
                            CacheSession._notifyCallbackError(cbInfo, requestID, CacheReturnCode.FAIL, CacheReturnSubcode.INVALID_SESSION, topic, "Cache request failed: the session is disposed.");
                            return;
                        }
                        const request = new CacheRequest(this, CacheRequestType.GET_MSG_REQUEST, requestID, cbInfo, liveDataAction, topic, this._properties.cacheName);
                        const matchingRequestKeys = Object.keys(this._outstandingRequests).filter(key => this._outstandingRequests[key].topic.getName() === topic.getName());
                        if (matchingRequestKeys.length) {
                            // Topic name matches mean a conflict unless both requests are FLOW_THRU
                            const conflictKeys = liveDataAction !== CacheLiveDataAction.FLOW_THRU ? matchingRequestKeys : matchingRequestKeys.filter(k => this._outstandingRequests[k].liveDataAction !== CacheLiveDataAction.FLOW_THRU);
                            if (conflictKeys.length) {
                                const conflictRequest = this._outstandingRequests[conflictKeys[0]];
                                LOG_WARN(`Existing request ${conflictRequest} conflicts. Rejecting request ${request}`);
                                // Register this request so that it is not dismissed as an orphan.
                                this._registerRequest(request);
                                this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.REQUEST_ALREADY_IN_PROGRESS);
                                return;
                            }
                        }
                        this._registerRequest(request);
                        request.startRequestTimeout(CacheSession._handleCacheRequestTimeout, this._properties.timeoutMsec);
                        if (subscribe) {
                            const waitingForSubscribeInfo = new CacheSessionSubscribeInfo(request.correlationID, topic, this);
                            request._subscriptionWaiting = waitingForSubscribeInfo;
                            this._session.subscribe(topic, true, waitingForSubscribeInfo);
                            return;
                        }
                        this._startCacheRequest(request);
                    }
                    /**
   * @param {solace.Session} session The session associated with the request
   * @param {SessionEvent} sessionEvent The session event
   * @param {CacheRequest} userObject The user-specified context object
   * @private
   */
                    _handleCacheRequestFailed(session, sessionEvent, userObject /*, rfuObject */) {
                        this._terminateRequest(userObject.getRequestID(), CacheReturnCode.FAIL, CacheReturnSubcode.ERROR_RESPONSE);
                    }
                    /**
   * @param {CacheRequest} request The new request to register
   * @private
   */
                    _registerRequest(request) {
                        this._outstandingRequests[request.correlationID] = request;
                        if (!request.parentRequest) {
                            this._outstandingIDs[request.requestID] = request;
                        }
                    }
                    /**
   * @param {Number} correlationID The ID of an existing request
   * @returns {CacheRequest} The existing request with the given ID
   * @private
   */
                    _getOutstandingRequest(correlationID) {
                        return this._outstandingRequests[correlationID];
                    }
                    /**
   *
   * @param {CacheRequest} request The request to start
   * @param {?Number} sessionID Only when returned from a cache instance as part of a
   * previous message
   * @param {?Topic} destination Only when required by a cache reply
   * @param {?Boolean} suppressClusters True when other clusters should be excluded from
   * the response, as in a request resulting from a "see other"
   * @private
   */
                    _startCacheRequest(request, sessionID, destination, suppressClusters) {
                        const message = new MessageLib.Message();
                        // Prepare message
                        message.setCorrelationId(request.correlationID);
                        if (destination) {
                            message.setDestination(destination);
                        } else {
                            message.setDestination(Topic.createFromName(this._properties.cachePrefix + request.cacheName));
                        }
                        message.setReplyTo(Topic.createFromName(this._session.getSessionProperties().p2pInboxInUse));
                        message.setDeliverToOne(request.cacheMessageType === CacheRequestType.GET_MSG_REQUEST);
                        // Prepare stream container
                        const stream = new SDTStreamContainer();
                        stream.addField(SDTFieldType.UINT32, request.cacheMessageType);
                        stream.addField(SDTFieldType.UINT32, CacheRequest.VERSION);
                        stream.addField(SDTFieldType.STRING, request.topic.getName());
                        stream.addField(SDTFieldType.UINT32, CacheRequest.REPLY_SIZE_LIMIT);
                        if (typeof sessionID === "number") {
                            LOG_DEBUG(`Including session ID: ${sessionID}`);
                            stream.addField(SDTFieldType.UINT32, sessionID);
                        }
                        stream.addField(SDTFieldType.UINT32, this._properties.maxMessages);
                        stream.addField(SDTFieldType.UINT32, this._properties.maxAgeSec);
                        if (request.cacheMessageType === CacheRequestType.GET_MSG_REQUEST) {
                            stream.addField(SDTFieldType.BOOL, this._properties.includeOtherClusters && !suppressClusters);
                        }
                        stream.addField(SDTFieldType.BOOL, false); // includeTimestamps, 6.17.1
                        if (request.cacheMessageType === CacheRequestType.GET_MSG_REQUEST) {
                            stream.addField(SDTFieldType.UINT32, Math.round(this._properties.timeoutMsec / 1e3));
                        }
                        // Load stream container
                        message.setSdtContainer(SDTField.create(SDTFieldType.STREAM, stream));
                        try {
                            LOG_DEBUG(`Sending ${request}`);
                            this._session.send(message);
                            if (!request.parentRequest) {
                                // Don't count child requests in CACHE_REQUEST_SENT total
                                this._incStat(StatType.CACHE_REQUEST_SENT);
                            }
                        } catch (e) {
                            LOG_INFO(`Failed to send request: ${e.message}`);
                            this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.ERROR_RESPONSE, e);
                        }
                    }
                    /**
   * Increments a stat.
   * @param  {String} statType The stat to increment
   * @param  {Number} value    The amount by which to increment the state
   * @private
   */
                    _incStat(statType, value) {
                        if (!this._session) {
                            LOG_DEBUG("Can't log stat: session is disposed");
                            return;
                        }
                        if (!this._sessionIF) {
                            LOG_INFO("Can't log stat: session statistics not available");
                            return;
                        }
                        this._sessionIF.incStat(statType, value);
                    }
                    /**
   * Unregisters the given request.
   * @param  {CacheRequest} request The request to unreguster
   * @private
   */
                    _unregisterRequest(request) {
                        delete this._outstandingRequests[request.correlationID];
                        delete this._outstandingIDs[request.requestID];
                    }
                    /**
   * @param {CacheReturnCode} returnCode The return code for this completion
   * @param {CacheReturnSubcode} subcode The subcode for this completion
   * @private
   */
                    _trackCompletionStats(returnCode, subcode) {
                        switch (returnCode) {
                          case CacheReturnCode.OK:
                            this._incStat(StatType.CACHE_REQUEST_OK_RESPONSE);
                            if (subcode === CacheReturnSubcode.LIVE_DATA_FULFILL) {
                                this._incStat(StatType.CACHE_REQUEST_LIVE_DATA_FULFILL);
                            }
                            break;

                          case CacheReturnCode.INCOMPLETE:
                            this._incStat(StatType.CACHE_REQUEST_INCOMPLETE_RESPONSE);
                            break;

                          case CacheReturnCode.FAIL:
                            this._incStat(StatType.CACHE_REQUEST_FAIL_RESPONSE);
                            break;

                          default:
                            throw new Error("Sanity: no return code supplied");
                        }
                    }
                    /**
   * @param {CacheRequest} requestIn The request to terminate
   * @param {CacheReturnCode} returnCode The return code for this operation
   * @param {CacheReturnSubcode} subcode The subcode for this operation
   * @param {Error} error Any error associated with this operation
   * @private
   */
                    _terminateRequest(requestIn, returnCode, subcode, error) {
                        const request = requestIn.getRootRequest();
                        if (!this._outstandingRequests[request.correlationID]) {
                            // Request is unknown or was previously terminated
                            return;
                        }
                        const cbInfo = request.cbInfo;
                        if (!cbInfo) {
                            LOG_WARN(`No callback info provided for ${request}. Cannot notify`);
                            return; // Cannot continue
                        }
                        const callback = cbInfo.getCallback();
                        if (!callback) {
                            LOG_WARN(`No callback provided for ${request}. Cannot notify`);
                            return; // Cannot continue
                        }
                        const topic = request.getTopic();
                        if (!topic) {
                            LOG_WARN(`No topic provided for ${request}`);
                        }
                        request.queuedLiveData.forEach(data => this._sendToNextDelegate(data));
                        // Unregister before callback so that the client application can treat the request ID
                        // as "freed" and reuse it
                        request.cancel();
                        this._unregisterRequest(request);
                        if (!request.liveDataFulfilled) {
                            // All of this has already been done on fulfill.
                            this._trackCompletionStats(returnCode, subcode);
                            CacheSession._notifyCallback(request, returnCode, subcode, topic, error);
                        }
                    }
                    /**
   * @param {CacheRequest} requestIn The request with a result to decode
   * @param {CacheGetResult} result The result to decode
   * @returns {Array.<Message>} The messages contained in the result
   * @private
   */
                    static _decodeMessageStream(requestIn, result) {
                        if (!result.messageStream) {
                            return [];
                        }
                        LOG_DEBUG("Receiving messages");
                        const messages = [];
                        const request = requestIn;
                        while (result.messageStream.hasNext()) {
                            request.dataReceived = true;
                            const data = result.messageStream.getNext().getValue();
                            const innerMessage = SMFLib.Codec.Decode.decodeCompoundMessage(data, 0);
                            if (!innerMessage) {
                                continue;
                            }
                            const cacheStatus = result.isSuspect ? MessageLib.MessageCacheStatus.SUSPECT : MessageLib.MessageCacheStatus.CACHED;
                            innerMessage._setCacheStatus(cacheStatus);
                            innerMessage._setCacheRequestID(request.requestID);
                            messages.push(innerMessage);
                        }
                        LOG_DEBUG(`${messages.length} cached messages received`);
                        return messages;
                    }
                    /**
   * Closure call context; `this` will be redefined
   * @param {CacheRequest} cacheRequest The request that timed out
   * @private
   */
                    static _handleCacheRequestTimeout(cacheRequest) {
                        const context = cacheRequest.cacheSession;
                        if (!context._getOutstandingRequest(cacheRequest.correlationID)) {
                            LOG_INFO(`Timeout for ${cacheRequest} was not unregistered. Ignoring`);
                            // already completed
                            return;
                        }
                        // bug 36404: Cache request timeout is to be interpreted as timeout per session request-reply,
                        // not timeout per cache request-reply.
                        // Implementation: Timeouts on parent requests are cancelled when a child request is spawned.
                        // Timeouts on child requests cause the root request to fail.
                        LOG_INFO(`Request ${cacheRequest} timed out`);
                        context._terminateRequest(cacheRequest.getRootRequest(), CacheReturnCode.INCOMPLETE, CacheReturnSubcode.REQUEST_TIMEOUT);
                    }
                    /**
   * @param {CacheRequest} request The request that is notifying
   * @param {CacheReturnCode} returnCode The return code for the notification
   * @param {CacheReturnSubcode} subcode The subcode for the notification
   * @param {Destination} topic The topic associated with the notification
   * @param {Error} error Any error associated with the notification
   * @private
   */
                    static _notifyCallback(request, returnCode, subcode, topic, error) {
                        const cbInfo = request.cbInfo;
                        const callback = cbInfo.getCallback();
                        callback(request.requestID, new CacheRequestResult(returnCode, subcode, topic, error), cbInfo.getUserObject());
                    }
                    /**
   * @param {solace.CacheCBInfo} cbInfo Callback info for the cache request.
   * @param {Number} requestID The application-assigned ID number for the request
   * @param {CacheReturnCode} returnCode The return code for the notification
   * @param {CacheReturnSubcode} subcode The subcode for the notification
   * @param {Destination} topic The topic associated with the notification
   * @param {Error} error Any error associated with the notification
   * @private
   */
                    static _notifyCallbackError(cbInfo, requestID, returnCode, subcode, topic, error) {
                        const callback = cbInfo.getCallback();
                        callback(requestID, new CacheRequestResult(returnCode, subcode, topic, error), cbInfo.getUserObject());
                    }
                    /**
   * Validates the cache session properties.
   * @param {solace.CacheSessionProperties} props The properties to validate
   * @private
   */
                    static _validateProps(props) {
                        if (typeof props.cacheName !== "string") {
                            throw new OperationError("Invalid parameter type for cacheName", ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                        // Create from name will throw if the cacheName is invalid.  This performs more checking than
                        // the legacy API did, but I think it is all justified as we shouldn't be able to use anything
                        // that would be rejected here as a cacheName.
                        if (Topic.createFromName(props.cacheName).isWildcarded()) {
                            throw new OperationError(`Invalid cacheName '${props.cacheName}'. The cacheName cannot be wildcarded`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                        if (typeof props.maxAgeSec !== "number") {
                            throw new OperationError("Invalid parameter type for maxAgeSec", ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                        if (props.maxAgeSec < 0) {
                            throw new OperationError("Invalid value for maxAgeSec; must be >= 0", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                        if (typeof props.maxMessages !== "number") {
                            throw new OperationError("Invalid parameter type for maxMessages", ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                        if (props.maxMessages < 0) {
                            throw new OperationError("Invalid value for maxMessages; must be >= 0", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                        if (typeof props.timeoutMsec !== "number") {
                            throw new OperationError("Invalid parameter type for timeoutMsec", ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                        if (props.timeoutMsec < 3e3) {
                            throw new OperationError("Invalid value for timeoutMsec; must be >= 3000", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                    }
                }
                module.exports.CacheSession = CacheSession;
                /***/
            },
            /***/ "./modules/solclient-stats/api.js": 
            /*!****************************************!*\
  !*** ./modules/solclient-stats/api.js ***!
  \****************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Stats
                } = __webpack_require__(/*! ./lib/stats.js */ "./modules/solclient-stats/lib/stats.js");
                const {
                    StatsByMode
                } = __webpack_require__(/*! ./lib/stat-bymode */ "./modules/solclient-stats/lib/stat-bymode.js");
                const {
                    StatType
                } = __webpack_require__(/*! ./lib/stat-types */ "./modules/solclient-stats/lib/stat-types.js");
                module.exports = {
                    Stats: Stats,
                    StatType: StatType,
                    StatsByMode: StatsByMode
                };
                /***/
            },
            /***/ "./modules/solclient-stats/lib/stat-bymode.js": 
            /*!****************************************************!*\
  !*** ./modules/solclient-stats/lib/stat-bymode.js ***!
  \****************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    StatType
                } = __webpack_require__(/*! ./stat-types */ "./modules/solclient-stats/lib/stat-types.js");
                module.exports = {
                    StatsByMode: {
                        STAT_TX_BYMODE_MSGS: [ StatType.TX_DIRECT_MSGS, StatType.TX_PERSISTENT_MSGS, StatType.TX_NONPERSISTENT_MSGS ],
                        STAT_TX_BYMODE_BYTES: [ StatType.TX_DIRECT_BYTES, StatType.TX_PERSISTENT_BYTES, StatType.TX_NONPERSISTENT_BYTES ],
                        STAT_TX_BYMODE_REDELIVERED: [ StatType.TX_DIRECT_MSGS, // unused placeholder, direct messsages are not redelivered
                        StatType.TX_PERSISTENT_REDELIVERED, StatType.TX_NONPERSISTENT_REDELIVERED ],
                        STAT_TX_BYMODE_BYTES_REDELIVERED: [ StatType.TX_DIRECT_BYTES, // unused placeholder, direct messsages are not redelivered
                        StatType.TX_PERSISTENT_BYTES_REDELIVERED, StatType.TX_NONPERSISTENT_BYTES_REDELIVERED ],
                        STAT_RX_BYMODE_MSGS: [ StatType.RX_DIRECT_MSGS, StatType.RX_PERSISTENT_MSGS, StatType.RX_NONPERSISTENT_MSGS ],
                        STAT_RX_BYMODE_BYTES: [ StatType.RX_DIRECT_BYTES, StatType.RX_PERSISTENT_BYTES, StatType.RX_NONPERSISTENT_BYTES ]
                    }
                };
                /***/
            },
            /***/ "./modules/solclient-stats/lib/stat-types.js": 
            /*!***************************************************!*\
  !*** ./modules/solclient-stats/lib/stat-types.js ***!
  \***************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Statistics for sent/received messages and control operations.
 *
 * @enum {number}
 * @namespace
 * @memberof solace
 */
                const StatType = {
                    // ------- SMF and Direct Messaging
                    /**
   * Count of bytes sent as part of data messages.
   */
                    TX_TOTAL_DATA_BYTES: 0,
                    /**
   * Count of data messages sent.
   */
                    TX_TOTAL_DATA_MSGS: 1,
                    /**
   * Count of bytes sent as part of direct data messages.
   */
                    TX_DIRECT_BYTES: 2,
                    /**
   * Count of direct data messages sent.
   */
                    TX_DIRECT_MSGS: 3,
                    /**
   * Count of bytes sent as part of control messages.
   */
                    TX_CONTROL_BYTES: 4,
                    /**
   * Count of control messages sent.
   */
                    TX_CONTROL_MSGS: 5,
                    /**
   * Count of request messages sent.
   */
                    TX_REQUEST_SENT: 6,
                    /**
   * Count of request timeouts that occurred.
   */
                    TX_REQUEST_TIMEOUT: 7,
                    /**
   * Count of bytes received as part of data messages.
   */
                    RX_TOTAL_DATA_BYTES: 8,
                    /**
   * Count of data messages received.
   */
                    RX_TOTAL_DATA_MSGS: 9,
                    /**
   * Count of bytes received as part of direct data messages.
   */
                    RX_DIRECT_BYTES: 10,
                    /**
   * Count of direct data messages received.
   */
                    RX_DIRECT_MSGS: 11,
                    /**
   * Count of bytes received as part of control messages.
   */
                    RX_CONTROL_BYTES: 12,
                    /**
   * Count of control messages received.
   */
                    RX_CONTROL_MSGS: 13,
                    /**
   * Count discard message indications received on incoming messages.
   */
                    RX_DISCARD_MSG_INDICATION: 14,
                    /**
   * Count of reply messaged received.
   */
                    RX_REPLY_MSG_RECVED: 15,
                    /**
   * Count of received reply messages that were discarded.
   */
                    RX_REPLY_MSG_DISCARD: 16,
                    /**
   * @description
   * Count of messages discarded due to the presence of an unknown element or
   * unknown protocol in the SMF header.
   */
                    RX_DISCARD_SMF_UNKNOWN_ELEMENT: 17,
                    // ------- SolCache Session
                    /**
   * @description
   * Count of cache requests sent. One conceptual request (i.e. one API call)
   * may involve many requests and replies.
   */
                    CACHE_REQUEST_SENT: 18,
                    /**
   * @description
   * Count of OK responses to cache requests.
   */
                    CACHE_REQUEST_OK_RESPONSE: 19,
                    /**
   * @description
   * Count of cache requests that returned a failure response.
   */
                    CACHE_REQUEST_FAIL_RESPONSE: 20,
                    /**
   * @description
   * Count of cache replies discarded because a request has been fulfilled.
   */
                    CACHE_REQUEST_FULFILL_DISCARD_RESPONSE: 21,
                    /**
   * @description
   * Count of cached messages delivered to the application.
   */
                    RX_CACHE_MSG: 22,
                    /**
   * @description
   * Count of cache requests that were incomplete.
   */
                    CACHE_REQUEST_INCOMPLETE_RESPONSE: 23,
                    /**
   * @description
   * The cache session operation completed when live data arrived on the requested topic.
   */
                    CACHE_REQUEST_LIVE_DATA_FULFILL: 24,
                    // ------ Guaranteed Messaging
                    /**
   * Count of bytes sent as part of persistent data messages.
   */
                    TX_PERSISTENT_BYTES: 25,
                    /**
   * Count of persistent data messages sent.
   */
                    TX_PERSISTENT_MSGS: 26,
                    /**
   * Count of non-persistent data bytes sent.
   */
                    TX_NONPERSISTENT_BYTES: 27,
                    /**
   * Count of non-persistent data messages sent.
   */
                    TX_NONPERSISTENT_MSGS: 28,
                    /**
   * The number of bytes redelivered in Persistent messages.
   */
                    TX_PERSISTENT_BYTES_REDELIVERED: 29,
                    /**
   * The number of Persistent messages redelivered.
   */
                    TX_PERSISTENT_REDELIVERED: 30,
                    /**
   * The number of bytes redelivered in Non-Persistent messages.
   */
                    TX_NONPERSISTENT_BYTES_REDELIVERED: 31,
                    /**
   * The number of Non-Persistent messages redelivered.
   */
                    TX_NONPERSISTENT_REDELIVERED: 32,
                    /**
   * The number of acknowledgments received.
   */
                    TX_ACKS_RXED: 33,
                    /**
   * The number of times the transmit window closed.
   */
                    TX_WINDOW_CLOSE: 34,
                    /**
   * The number of times the acknowledgment timer expired.
   */
                    TX_ACK_TIMEOUT: 35,
                    /**
   * Count of bytes received as part of persistent data messages.
   */
                    RX_PERSISTENT_BYTES: 36,
                    /**
   * Count of persistent data messages received.
   */
                    RX_PERSISTENT_MSGS: 37,
                    /**
   * Count of bytes received as part of non-persistent data messages.
   */
                    RX_NONPERSISTENT_BYTES: 38,
                    /**
   * Count of non-persistent data messages received.
   */
                    RX_NONPERSISTENT_MSGS: 39,
                    /**
   * Count of acknowledgements sent to the Solace Message Router
   * for guaranteed messages received by the API.
   */
                    RX_ACKED: 40,
                    /**
   * Count of guaranteed messages discarded for being duplicates.
   */
                    RX_DISCARD_DUPLICATE: 41,
                    /**
   * Count of guaranteed messages discarded due to no match message consumer for the message.
   */
                    RX_DISCARD_NO_MATCHING_CONSUMER: 42,
                    /**
   * Count of guaranteed messages discarded for being received out of order.
   */
                    RX_DISCARD_OUT_OF_ORDER: 43
                };
                module.exports.StatType = Enum.new(StatType);
                /***/
            },
            /***/ "./modules/solclient-stats/lib/stats.js": 
            /*!**********************************************!*\
  !*** ./modules/solclient-stats/lib/stats.js ***!
  \**********************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    EventEmitter
                } = __webpack_require__(/*! solclient-events */ "./modules/solclient-events/api.js");
                const {
                    StatType
                } = __webpack_require__(/*! ./stat-types */ "./modules/solclient-stats/lib/stat-types.js");
                /**
 * @private
 */
                class Stats extends EventEmitter {
                    constructor(parent) {
                        super();
                        this._parent = parent;
                        this._statsMap = [];
                        StatType.values.forEach(value => {
                            this._statsMap[value] = 0;
                        });
                    }
                    resetStats() {
                        this.emit("reset");
                        // The stat types are sequential, so .fill(0) would work, but the API design
                        // doesn't really guarantee this so overwriting every existing index is safer.
                        this._statsMap = this._statsMap.map(() => 0);
                    }
                    incStat(statType, value = 1) {
                        // should we validate statType?
                        this._statsMap[statType] += value;
                        if (this._parent) {
                            this._parent.incStat(statType, value);
                        }
                    }
                    getStat(statType) {
                        return this._statsMap[statType];
                    }
                }
                module.exports.Stats = Stats;
                /***/
            },
            /***/ "./modules/solclient-transport/api.js": 
            /*!********************************************!*\
  !*** ./modules/solclient-transport/api.js ***!
  \********************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    SMFClient
                } = __webpack_require__(/*! ./lib/smf-client */ "./modules/solclient-transport/lib/smf-client.js");
                const {
                    TransportCapabilities
                } = __webpack_require__(/*! ./lib/transport-capabilities */ "./modules/solclient-transport/lib/transport-capabilities.js");
                const {
                    TransportError
                } = __webpack_require__(/*! ./lib/transport-error */ "./modules/solclient-transport/lib/transport-error.js");
                const {
                    TransportFactory
                } = __webpack_require__(/*! ./lib/transport-factory */ "./modules/solclient-transport/lib/transport-factory.js");
                const {
                    TransportProtocol
                } = __webpack_require__(/*! ./lib/transport-protocols */ "./modules/solclient-transport/lib/transport-protocols.js");
                const {
                    TransportReturnCode
                } = __webpack_require__(/*! ./lib/transport-return-codes */ "./modules/solclient-transport/lib/transport-return-codes.js");
                const {
                    TransportSessionEventCode
                } = __webpack_require__(/*! ./lib/transport-session-event-codes */ "./modules/solclient-transport/lib/transport-session-event-codes.js");
                const {
                    TransportSessionStates
                } = __webpack_require__(/*! ./lib/transport-session-states */ "./modules/solclient-transport/lib/transport-session-states.js");
                module.exports.SMFClient = SMFClient;
                module.exports.TransportCapabilities = TransportCapabilities;
                module.exports.TransportError = TransportError;
                module.exports.TransportFactory = TransportFactory;
                module.exports.TransportProtocol = TransportProtocol;
                module.exports.TransportReturnCode = TransportReturnCode;
                module.exports.TransportSessionEventCode = TransportSessionEventCode;
                module.exports.TransportSessionStates = TransportSessionStates;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/base-smf-client.js": 
            /*!************************************************************!*\
  !*** ./modules/solclient-transport/lib/base-smf-client.js ***!
  \************************************************************/
            /***/ module => {
                class BaseSMFClient {
                    constructor(rxSmfCB, rxMessageErrorCB, session) {
                        this.reset();
                        this._rxSmfCB = rxSmfCB; // callback for parsed msg
                        this._rxMessageErrorCB = rxMessageErrorCB; // invalid UH, etc.
                        this._session = session;
                    }
                    reset() {
                        this._correlationCounter = 0;
                    }
                    nextCorrelationTag() {
                        // Login uses the max value as a sentinel, so wrap around early
                        if (++this._correlationCounter >= BaseSMFClient.SMF_MAX_CORRELATION) {
                            this._correlationCounter = 1;
                        }
                        return this._correlationCounter;
                    }
                }
                BaseSMFClient.SMF_MAX_CORRELATION = 16777215;
                module.exports.BaseSMFClient = BaseSMFClient;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/buffer-queue.js": 
            /*!*********************************************************!*\
  !*** ./modules/solclient-transport/lib/buffer-queue.js ***!
  \*********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                // eslint-disable-next-line global-require
                const BufferImpl = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;
                function concatFrom(list, from, length) {
                    const buffer = BufferImpl.allocUnsafe(length);
                    let pos = 0;
                    let i;
                    const buf0 = list[0];
                    pos += buf0.copy(buffer, 0, from, buf0.length);
                    for (i = 1; i < list.length && pos < length; i++) {
                        const buf = list[i];
                        pos += buf.copy(buffer, pos, 0, buf.length);
                    }
                    return buffer;
                }
                function readUInt32BEFrag(bufList, listOffsetParam, byteIndexParam) {
                    let listOffset = listOffsetParam;
                    let byteIndex = byteIndexParam;
                    const bytes = []; // the 4 bytes
                    let i = 0;
                    for (i = 0; i < 4; i++) {
                        while (bufList[listOffset].length <= byteIndex) {
                            byteIndex -= bufList[listOffset].length;
                            listOffset++;
                            if (listOffset >= bufList.length) {
                                return null;
                            } // should not happen.
                        }
                        bytes[i] = bufList[listOffset].readUInt8(byteIndex);
                        byteIndex++;
                    }
                    // shift the bytes into a 32 bit number, BE.
                    return (bytes[0] << 24) + (bytes[1] << 16) + (bytes[2] << 8) + bytes[3];
                }
                /**
 * Simplified FIFO of buffers.
 * Holds transport buffers without copying, allows 12 byte peeks for header and length detection.
 * For pops either a slice is returned if possible,
 * or a copy if the message spans transport buffers.
 * Pushes are refused when over capacity.
 * @internal
 */
                class BufferQueue {
                    constructor(maxSize) {
                        let _queue = [];
                        const _maxSize = maxSize;
                        let _size = 0;
                        let _offset = 0;
                        /**
     * Creates a slice (view) of the buffer with the given size. Conceptually.
     * Since slicing is expensive, it just retruns the raw transport buffer with the offset.
     * Buffer - offset pair if possible, copy (with zero offset) if beyond first buffer boundary.
     *
     *
     * @param {Number} size Bytes to view
     * @returns {?Array} Buffer - offset pair if there was enough data to peek, or `null`
     */
                        this.peekView = function peekView(size) {
                            const result = [];
                            if (_queue.length < 1 || size > _size) {
                                return null;
                            }
                            if (_queue[0].length >= size + _offset) {
                                result[0] = _queue[0];
                                result[1] = _offset;
                            } else {
                                //over buffer boundary, must copy.
                                result[0] = concatFrom(_queue, _offset, size);
                                result[1] = 0;
                            }
                            return result;
                        };
                        this.readUInt8 = function readUInt8(index) {
                            if (index >= _size) {
                                return null;
                            }
                            const oIndex = index + _offset;
                            if (oIndex < _queue[0].length) {
                                return _queue[0].readUInt8(oIndex);
                            } // else
                            let pos = _queue[0].length;
                            let i = 1;
                            while (pos + _queue[i].length <= oIndex) {
                                pos += _queue[i].length;
                                i++;
                            }
                            return _queue[i].readUInt8(oIndex - pos);
                        };
                        this.readUInt32BE = function readUInt32BE(index) {
                            if (index + 3 >= _size) {
                                return null;
                            }
                            const oIndex = index + _offset;
                            if (oIndex + 3 < _queue[0].length) {
                                return _queue[0].readUInt32BE(oIndex);
                            } // else
                            if (oIndex < _queue[0].length) {
                                return readUInt32BEFrag(_queue, 0, oIndex);
                            }
                            let pos = _queue[0].length;
                            let i = 1;
                            while (pos + _queue[i].length <= oIndex) {
                                pos += _queue[i].length;
                                i++;
                            }
                            if (oIndex - pos + 3 < _queue[i].length) {
                                return _queue[i].readUInt32BE(oIndex - pos);
                            } // else
                            return readUInt32BEFrag(_queue, i, oIndex - pos);
                        };
                        /**
     * Adds a buffer to the queue.
     * Fails if maxsize is exeeded.
     *
     * @param {Buffer} dataIn Source data
     * @returns {Boolean} `true` if the data fits.
     */
                        this.put = function put(dataIn) {
                            const buffer = BufferQueue.adaptData(dataIn);
                            const size = buffer.length;
                            if (size === 0) {
                                return true;
                            }
                            if (_size + size >= _maxSize) return false;
                            _queue.push(buffer);
                            _size += size;
                            return true;
                        };
                        this.advance = function advance(size) {
                            if (size < 1) {
                                return;
                            }
                            if (size >= _size) {
                                this.reset();
                                return;
                            }
                            let done = 0;
                            while (done < size) {
                                if (_queue[0].length - _offset <= size - done) {
                                    // drop first buffer entirely
                                    const chunk = _queue[0].length - _offset;
                                    _queue.shift();
                                    done += chunk;
                                    _size -= chunk; // invariants are good.
                                    _offset = 0;
                                } else {
                                    // cut into first buffer, virtually, with _offset
                                    _offset += size - done;
                                    _size -= size - done;
                                    break;
                                }
                            }
                        };
                        this.reset = function reset() {
                            _queue = [];
                            _size = 0;
                            _offset = 0;
                        };
                        this.remaining = function remaining() {
                            return _size;
                        };
                        this.isEmpty = function isEmpty() {
                            return _size === 0;
                        };
                    }
                    /**
   * Adapt incoming data to the format expected by this.put().
   * @param {*} data The data to adapt.
   * @returns {Buffer} The adapted data.
   */
                    static adaptData(data) {
                        if (data instanceof BufferImpl) return data;
                        return BufferImpl.from(data);
                    }
                }
                module.exports.BufferQueue = BufferQueue;
                module.exports.concatFrom = concatFrom;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/buffer-smf-client.js": 
            /*!**************************************************************!*\
  !*** ./modules/solclient-transport/lib/buffer-smf-client.js ***!
  \**************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const DebugLib = __webpack_require__(/*! solclient-debug */ "./modules/solclient-debug/api.js");
                const SMFLib = __webpack_require__(/*! solclient-smf */ "./modules/solclient-smf/api.js");
                const {
                    BaseSMFClient
                } = __webpack_require__(/*! ./base-smf-client */ "./modules/solclient-transport/lib/base-smf-client.js");
                const {
                    BufferQueue
                } = __webpack_require__(/*! ./buffer-queue */ "./modules/solclient-transport/lib/buffer-queue.js");
                const {
                    Convert,
                    Hex
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    LogFormatter
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const BufferImpl = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;
                const {
                    stringToUint8Array
                } = Convert;
                const {
                    formatHexString
                } = Hex;
                const SMF_LOST_FRAMING_THRESHOLD = 8e7;
                const {
                    LOG_ERROR
                } = new LogFormatter("[buffer-smf-client]");
                function logPeekBuffer(buffer) {
                    const bufPair = buffer.peekView(Math.min(buffer.remaining(), 64));
                    LOG_ERROR(`First 64 bytes (or fewer) of incoming buffer: \n${DebugLib.Debug.formatDumpBytes(bufPair[0].toString("latin1", bufPair[1]), true, 0)}`);
                }
                /**
 * Interact with underlying transport to send and receive SMF messages
 * @private
 */
                class BufferSMFClient extends BaseSMFClient {
                    /**
   * @constructor
   * @param {Function} rxSmfCB The callback to notify on SMF binary data received
   * @param {Function} rxMessageErrorCB The callback to notify on message errors
   * @param {Session} session The session owning this client
   */
                    constructor(rxSmfCB, rxMessageErrorCB, session) {
                        super(rxSmfCB, rxMessageErrorCB, session);
                        this._incomingBuffer = new BufferQueue(SMF_LOST_FRAMING_THRESHOLD);
                    }
                    reset() {
                        super.reset();
                        // Called from super constructor, so guard this
                        if (this._incomingBuffer) this._incomingBuffer.reset();
                    }
                    /**
   * @param {String} data Incoming data as binary string
   */
                    rxDataString(data) {
                        this._rxDataCB(BufferImpl.from(stringToUint8Array(data)));
                    }
                    /**
   * @param {ArrayBuffer} data Incoming data
   */
                    rxDataArrayBuffer(data) {
                        this._rxDataCB(BufferImpl.from(data));
                    }
                    /**
   * @param {Buffer} data Incoming data
   */
                    rxDataBuffer(data) {
                        this._rxDataCB(data);
                    }
                    /**
   * Invoked by transport session. Handles multiple SMF messages in input, as well as defragmenting
   * partial SMF messages. The state we keep is in this._incomingBuffer.
   * @param {Buffer} data The binary data to decode
   */
                    _rxDataCB(data) {
                        if (this._session) {
                            // each incoming data chunk resets KA counter
                            this._session.resetKeepAliveCounter();
                        }
                        const buffer = this._incomingBuffer;
                        const putSuccess = buffer.put(data);
                        let remaining = buffer.remaining();
                        if (!putSuccess) {
                            // 80 megabytes - lost SMF framing: may never complete
                            logPeekBuffer(buffer);
                            this._rxMessageErrorCB(`Buffer overflow (length: ${remaining})`);
                            this._incomingBuffer.reset();
                        }
                        while (remaining > 12) {
                            const version = buffer.readUInt8(0) & 7;
                            if (version !== 3) {
                                LOG_ERROR(`Invalid smf version in smf header, version=${version}`);
                                // Throw away the buffer and bail out
                                LOG_ERROR("BufferSMFClient._rxDataCB(): couldn't decode message due to invalid smf header");
                                logPeekBuffer(buffer);
                                this._incomingBuffer.reset();
                                this._rxMessageErrorCB("Error parsing incoming SMF - invalid SMF header detected");
                                return;
                            }
                            const messageLen = buffer.readUInt32BE(8);
                            if (messageLen > buffer.remaining()) {
                                break; // no full message
                            }
                            const msgBuffer = buffer.peekView(messageLen);
                            //const binaryString = messageBuffer.toString('binary');
                            const incomingMsg = SMFLib.Codec.Decode.decodeCompoundMessage(msgBuffer[0], msgBuffer[1]);
                            if (incomingMsg && incomingMsg.smfHeader) {
                                buffer.advance(incomingMsg.smfHeader.messageLength);
                                this._rxSmfCB(incomingMsg); // hand over to core API callback
                            } else {
                                // couldn't decode! Lost SMF framing.
                                // throw away the buffer and bail out
                                const sessionId = this._session ? this._session._sessionId : null;
                                const sessionIdHex = sessionId ? formatHexString(sessionId) : "N/A";
                                LOG_ERROR(`BufferSMFClient._rxDataCB(): couldn't decode message (sessionId=${sessionIdHex})`);
                                logPeekBuffer(buffer);
                                this._incomingBuffer.reset();
                                this._rxMessageErrorCB("Error parsing incoming SMF");
                                return;
                            }
                            remaining = buffer.remaining();
                        }
                        if (remaining) {
                            // We have a partial header, or a valid header and a partial message.
                            // partial message remaining: keep it in incoming buffer
                        } else {
                            // clear incoming buffer
                            this._incomingBuffer.reset();
                        }
                    }
                }
                module.exports.BufferSMFClient = BufferSMFClient;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/smf-client.js": 
            /*!*******************************************************!*\
  !*** ./modules/solclient-transport/lib/smf-client.js ***!
  \*******************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /* eslint-disable global-require */
                const {
                    BaseSMFClient
                } = __webpack_require__(/*! ./base-smf-client */ "./modules/solclient-transport/lib/base-smf-client.js");
                // Got rid of anonymous function that checked browser and set smf-client
                // Now ignoring string-smf-client and setting it straight to buffer-smf-client
                // const SMFClient = require('./buffer-smf-client').BufferSMFClient;
                const SMFClient = (() => {
                    if (typeof navigator !== "undefined") {
                        /* eslint-env browser */
                        if (navigator.appVersion.indexOf("MSIE 9.") !== -1 || navigator.appVersion.indexOf("Trident/") !== -1) {
                            // Avoid the buffer-based version for IE9, 10, and 11, but not Edge.
                            return __webpack_require__(/*! ./buffer-smf-client */ "./modules/solclient-transport/lib/buffer-smf-client.js").BufferSMFClient;
                        }
                    }
                    /* eslint-env shared-browser-node */
                    return __webpack_require__(/*! ./buffer-smf-client */ "./modules/solclient-transport/lib/buffer-smf-client.js").BufferSMFClient;
                })();
                SMFClient.SMF_CLIENTCTRL_LOGIN_FAKE_CORRELATIONTAG = BaseSMFClient.SMF_MAX_CORRELATION;
                module.exports.SMFClient = SMFClient;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/transport-base.js": 
            /*!***********************************************************!*\
  !*** ./modules/solclient-transport/lib/transport-base.js ***!
  \***********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    TransportReturnCode
                } = __webpack_require__(/*! ./transport-return-codes */ "./modules/solclient-transport/lib/transport-return-codes.js");
                // Stubs don't use this
                /* eslint-disable class-methods-use-this */
                // Stubs declare all params
                /* eslint-disable no-unused-vars */
                /**
 *
 * Base class for various transports
 * @private
 */
                class TransportBase {
                    /**
   * @constructor
   * @param {URL} url The URL to connect to
   * @param {function} eventCB The callback to notify on events
   * @param {SMFClient} client The SMF client to notify on data
   * @param {Object} transportProps Additional properties to assign to the transport
   * @param {?Object} [interceptor] The transport interceptor to install
   */
                    constructor(url, eventCB, client, transportProps, interceptor = null) {
                        this._url = url;
                        this._ssl = TransportBase.useSsl(url);
                        this._client = client;
                        this._eventCB = eventCB;
                        this._props = transportProps;
                        this.setInterceptor(interceptor);
                    }
                    /**
   * Establish underlying transport.
   * Returns transport return code, to be overridden in subclass
   * @returns {TransportReturnCode} The result of this operation
   */
                    connect() {
                        return TransportReturnCode.OK;
                    }
                    /**
   * Destroy the underlying transport.
   * Returns transport return code, to be overridden in subclass
   * @param {Boolean} immediate Destroy gracefully if false.
   * @param {?String} msg The message associated with this operation, if any.
   * @param {?ErrorSubcode} subcode The subcode associated with this operation, if any.
   * @returns {TransportReturnCode} The result of this operation
   */
                    destroy(immediate, msg, subcode) {
                        return TransportReturnCode.OK;
                    }
                    flush(callback) {
                        callback();
                        return TransportReturnCode.OK;
                    }
                    /**
   * Send encoded SMF message
   * Returns transport return code, to be overridden in subclass
   * @param {String} message The encoded SMF message to send
   * @param {?Boolean} [forceAllowEnqueue=false] If true, do not fail due to transport buffer full
   * @returns {TransportReturnCode} The result of this operation
   */
                    send(message, forceAllowEnqueue = false) {
                        return TransportReturnCode.OK;
                    }
                    /**
   * @returns {TransportProtocol} Return transport protocol in use
   */
                    getTransportProtocol() {
                        return this._props.transportProtocol;
                    }
                    /**
   * @returns {?String} Return transport session information such as sessionId
   */
                    getInfoStr() {
                        return null;
                    }
                    /**
   * @returns {TransportClientStats} transport statistics
   */
                    getClientStats() {
                        return null;
                    }
                    /**
   * Check whether or not the transport can be downgraded to the next protocol.
   * It is possible to downgrade the transport, the existing transport is destroyed and
   * the new transport connection initiated.
   * @param {String} msg The message associated with this operation
   * @param {ErrorSubcode} subcode The subcode associated with this operation
   * @returns {Boolean} Return true if downgrade is allowed and has been initiated; false otherwise
   */
                    beginDowngrade(msg, subcode) {
                        return false;
                    }
                    /**
   * Sets the interceptor for this transport. This object has the chance
   * to intervene before bytes are sent or received.
   * @param {Object} [interceptor] If set, the interceptor is inserted into the
   *
   * @private
   */
                    setInterceptor(interceptor) {
                        if (this._interceptor) {
                            // Reset original callbacks
                            if (this._interceptor.removed) this._interceptor.removed(this);
                        }
                        this._interceptor = interceptor;
                        if (interceptor) {
                            if (interceptor.installed) interceptor.installed(this);
                        }
                    }
                    toString() {
                        return `${this.getTransportProtocol()}${this._ssl ? " (SSL)" : ""}`;
                    }
                    /**
   * @param {String} url The URL to check
   * @returns {Boolean} `true` if the URL requires SSL; `false` otherwise
   * @static
   */
                    static useSsl(url) {
                        const urlParts = (url || "").split("://");
                        if (urlParts.length === 0 || TransportBase.validSchemes.indexOf(urlParts[0]) < 0) {
                            throw new OperationError(`Invalid url "${url}": Only [${TransportBase.validSchemes.join(", ")}] URL schemes are supported`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                        const useSSL = urlParts[0] === "https" || urlParts[0] === "wss" || urlParts[0] === "tcps";
                        return useSSL;
                    }
                }
                /**
 * @type {Array.<String>}
 */
                TransportBase.validSchemes = [ "http", "https", "ws", "wss", "tcp", "tcps" ];
                module.exports.TransportBase = TransportBase;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/transport-capabilities.js": 
            /*!*******************************************************************!*\
  !*** ./modules/solclient-transport/lib/transport-capabilities.js ***!
  \*******************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    WebTransportCapabilities
                } = __webpack_require__(/*! ./web */ "./modules/solclient-transport/lib/web/api.js");
                const TransportCapabilities = {
                    web: WebTransportCapabilities
                };
                module.exports.TransportCapabilities = TransportCapabilities;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/transport-client-stats.js": 
            /*!*******************************************************************!*\
  !*** ./modules/solclient-transport/lib/transport-client-stats.js ***!
  \*******************************************************************/
            /***/ module => {
                /**
 * @private
 * @constructor
 */
                class TransportClientStats {
                    constructor() {
                        this.bytesWritten = 0;
                        this.msgWritten = 0;
                    }
                }
                module.exports.TransportClientStats = TransportClientStats;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/transport-error.js": 
            /*!************************************************************!*\
  !*** ./modules/solclient-transport/lib/transport-error.js ***!
  \************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    SolaceError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                /**
 * @classdesc
 * An error thrown when an error occurs on the transport session.
 * <p>
 * Applications are not expected to instantiate this type.
 *
 * @memberof solace
 * @private
 */
                class TransportError extends SolaceError {
                    /**
   * Creates an instance of TransportError.
   * @constructor
   * @param {String} message The message associated with this error
   * @param {ErrorSubcode} subcode The subcode for this error
   * @private
   */
                    constructor(message, subcode) {
                        super("TransportError", message);
                        this.subcode = subcode;
                    }
                    toString() {
                        return `${super.toString()}, subcode=${this.subcode}`;
                    }
                }
                module.exports.TransportError = TransportError;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/transport-factory.js": 
            /*!**************************************************************!*\
  !*** ./modules/solclient-transport/lib/transport-factory.js ***!
  \**************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    LOG_TRACE
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    TcpRawTransport,
                    CompressedTransport,
                    TlsOnlyTransport,
                    TcpTlsTransport
                } = false ? 0 : {};
                const {
                    WebTransport
                } = __webpack_require__(/*! ./web */ "./modules/solclient-transport/lib/web/api.js");
                const TransportFactory = {
                    createTransport(host, eventCB, client, props, getId) {
                        const url = host;
                        Object.assign(props, {
                            connectTimeoutInMsecs: 1e5
                        });
                        // TCP transport is dictated by the URL (tcp:// or tcps://)
                        // It is unaffected by the transportProtocol config parameter.
                        if (TcpRawTransport && url.trim().startsWith("tcp")) {
                            if (!url.trim().startsWith("tcps")) {
                                if (props.compressionLevel === 0) {
                                    LOG_TRACE("createTransport raw tcp");
                                    return new TcpRawTransport(url, eventCB, client, props);
                                } // else { //compressed plaintext right off the bat.
                                LOG_TRACE("createTransport compressed plaintex.");
                                const compressingLayer = new CompressedTransport(eventCB, client, props);
                                const plaintextTransport = new TcpRawTransport(url, compressingLayer.eventCB.bind(compressingLayer), compressingLayer, props);
                                compressingLayer.setClientStats(plaintextTransport.getClientStats());
                                plaintextTransport.setClientStats(null);
                                compressingLayer.setUnderlyingTransport(plaintextTransport);
                                return compressingLayer;
                            } //else { //tcps
                            if (props.sslConnectionDowngradeTo !== "PLAIN_TEXT") {
                                //no downgrade
                                LOG_TRACE("createTransport monolithic tls");
                                return new TcpTlsTransport(url, eventCB, client, props);
                            } //else { // Composite TLS transport anticipating downgrade.
                            LOG_TRACE("createTransport composite tls (anticipating downgrade)");
                            // passing URL for SNI.
                            const tlsLayer = new TlsOnlyTransport(url, eventCB, client, props);
                            const plaintextTransport = new TcpRawTransport(url, tlsLayer.eventCB.bind(tlsLayer), tlsLayer, props);
                            tlsLayer.setClientStats(plaintextTransport.getClientStats());
                            plaintextTransport.setClientStats(null);
                            tlsLayer.setUnderlyingTransport(plaintextTransport);
                            return tlsLayer;
                        }
                        LOG_TRACE("createTransport WebTransport");
                        return new WebTransport(url, eventCB, client, props, getId);
                    },
                    startCompression(uncompressedTransport) {
                        const eventCB = uncompressedTransport._eventCB;
                        const client = uncompressedTransport._client;
                        const props = uncompressedTransport._props;
                        const compressingLayer = new CompressedTransport(eventCB, client, props);
                        uncompressedTransport.rehome(compressingLayer.eventCB.bind(compressingLayer), compressingLayer);
                        compressingLayer.setClientStats(uncompressedTransport.getClientStats());
                        uncompressedTransport.setClientStats(null);
                        compressingLayer.setUnderlyingTransport(uncompressedTransport);
                        compressingLayer.connect();
                        return compressingLayer;
                    },
                    severTls(encryptedTransport, compress, callback) {
                        if (!compress) {
                            encryptedTransport.tlsShutdown(callback);
                        } else {
                            const precallback = plaintextTransport => callback(this.startCompression(plaintextTransport));
                            //encryptedTransport.tlsShutdown(precallback.bind(this));
                            encryptedTransport.tlsShutdown(precallback);
                        }
                    }
                };
                module.exports.TransportFactory = TransportFactory;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/transport-protocol-handler.js": 
            /*!***********************************************************************!*\
  !*** ./modules/solclient-transport/lib/transport-protocol-handler.js ***!
  \***********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const WebTransportsLib = __webpack_require__(/*! ./web */ "./modules/solclient-transport/lib/web/api.js");
                const {
                    Lazy
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                const {
                    LOG_TRACE
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    TransportBase
                } = __webpack_require__(/*! ./transport-base */ "./modules/solclient-transport/lib/transport-base.js");
                const {
                    TransportProtocol
                } = __webpack_require__(/*! ./transport-protocols */ "./modules/solclient-transport/lib/transport-protocols.js");
                const {
                    lazyValue
                } = Lazy;
                // Define transportProtocol to transport mapping
                const lutTransportProtocols = lazyValue(() => {
                    const protocols = {
                        [TransportProtocol.HTTP_BASE64]: WebTransportsLib.StateBase64,
                        [TransportProtocol.HTTP_BINARY]: WebTransportsLib.StateBinary,
                        [TransportProtocol.HTTP_BINARY_STREAMING]: WebTransportsLib.StateStreamingAndBinary,
                        [TransportProtocol.WS_BINARY]: WebTransportsLib.StateWebSocketBinary
                    };
                    return protocols;
                });
                /**
 * @classdesc
 * Handles web transport selection and downgrade without creating the actual transport
 * session object
 * @memberof solace
 * @private
 */
                class TransportProtocolHandler {
                    constructor(url, webTransportProtocolList) {
                        const useSSL = TransportBase.useSsl(url);
                        let transport = null;
                        let downgradeTransport = null;
                        webTransportProtocolList.slice().reverse().forEach(el => {
                            const TransportConstructor = lutTransportProtocols.value[el];
                            transport = new TransportConstructor(useSSL, this.switchState.bind(this), downgradeTransport);
                            downgradeTransport = transport;
                        });
                        this._transport = transport;
                        this._transport.onEnter();
                    }
                    getTransportProtocol() {
                        return this._transport.getTransportProtocol();
                    }
                    completeDowngrade(err) {
                        return this._transport.completeDowngrade(err);
                    }
                    canCompleteDowngrade() {
                        return this._transport.getNextState() !== null;
                    }
                    toString() {
                        return this._transport.toString();
                    }
                    switchState(newState, reason) {
                        LOG_TRACE(`Switching ${this._transport} => ${newState} (${reason})`);
                        this._transport = newState;
                        newState.onEnter();
                    }
                }
                module.exports.TransportProtocolHandler = TransportProtocolHandler;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/transport-protocols.js": 
            /*!****************************************************************!*\
  !*** ./modules/solclient-transport/lib/transport-protocols.js ***!
  \****************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Connection scheme types referenced by {@link solace.SessionProperties#transportProtocol},
 * {@link solace.SessionProperties#webTransportProtocolList} (browser only), and
 * {@link solace.SessionProperties#transportProtocolInUse}.
 *
 * @target browser
 * @enum {string}
 * @namespace
 * @memberof solace
 */
                const TransportProtocol = {
                    /**
   * A COMET model that uses base64 payload encoding. HTTP responses have a defined Content-Length.
   *
   * Guaranteed Messaging is incompatbile with HTTP_ transports.
   *  * {@link solace.MessagePublisherProperties#enabled} must be `false` for a session that may
   *    use this transport protocol.
   *  * {@link solace.Session#createMessageConsumer} will throw on a session that may use this
   *    transport protocol if {@link solace.MessagePublisherProperties#enabled} is `true`.
   *
   * @target browser
   */
                    HTTP_BASE64: "HTTP_BASE64",
                    /**
   * A COMET model that uses binary payload encoding. HTTP responses have a defined Content-Length.
   *
   * Guaranteed Messaging is incompatbile with HTTP_ transports.
   *  * {@link solace.MessagePublisherProperties#enabled} must be `false` for a session that may
   *    use this transport protocol.
   *  * {@link solace.Session#createMessageConsumer} will throw on a session that may use this
   *    transport protocol if {@link solace.MessagePublisherProperties#enabled} is `true`.
   *
   * @target browser
   */
                    HTTP_BINARY: "HTTP_BINARY",
                    /**
   * A COMET model that uses binary payload encoding. HTTP responses use Chunked Transfer-Encoding
   * to stream data from the Solace Message Router to the client without needing to terminate the
   * HTTP response.
   *
   * Guaranteed Messaging is incompatbile with HTTP_ transports.
   *  * {@link solace.MessagePublisherProperties#enabled} must be `false` for a session that may
   *    use this transport protocol.
   *  * {@link solace.Session#createMessageConsumer} will throw on a session that may use this
   *    transport protocol if {@link solace.MessagePublisherProperties#enabled} is `true`.
   *
   * @target browser
   */
                    HTTP_BINARY_STREAMING: "HTTP_BINARY_STREAMING",
                    /**
   * A WebSocket communication channel uses binary payload encoding and provides full-duplex
   * communication between the client and the Solace Message Router over a single TCP connection.
   *
   * This is the preferred protocol to use if all networking infrastructure betweed the application
   * and the Solace Message router support WebSockets. If this is not the case, it may be necessary
   * to use one of the HTTP protocols that use the COMET model of messaging.
   *
   * This transport protocol supports Guaranteed Messaging.
   */
                    WS_BINARY: "WS_BINARY"
                };
                module.exports.TransportProtocol = Enum.new(TransportProtocol);
                /***/
            },
            /***/ "./modules/solclient-transport/lib/transport-return-codes.js": 
            /*!*******************************************************************!*\
  !*** ./modules/solclient-transport/lib/transport-return-codes.js ***!
  \*******************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * @private
 * @enum {number}
 */
                const TransportReturnCode = {
                    OK: 0,
                    FAIL: 1,
                    NO_SPACE: 2,
                    DATA_DECODE_ERROR: 3,
                    INVALID_STATE_FOR_OPERATION: 4,
                    CONNECTION_ERROR: 5
                };
                module.exports.TransportReturnCode = Enum.new(TransportReturnCode);
                /* eslint-disable */
                // Manually demangle these names; bug 70031
                module.exports.TransportReturnCode._setCanonical({
                    OK: TransportReturnCode.OK,
                    FAIL: TransportReturnCode.FAIL,
                    NO_SPACE: TransportReturnCode.NO_SPACE,
                    DATA_DECODE_ERROR: TransportReturnCode.DATA_DECODE_ERROR,
                    INVALID_STATE_FOR_OPERATION: TransportReturnCode.INVALID_STATE_FOR_OPERATION,
                    CONNECTION_ERROR: TransportReturnCode.CONNECTION_ERROR
                });
                /* eslint-enable */
                /***/
            },
            /***/ "./modules/solclient-transport/lib/transport-session-event-codes.js": 
            /*!**************************************************************************!*\
  !*** ./modules/solclient-transport/lib/transport-session-event-codes.js ***!
  \**************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Defines the possible TransportSessionEvent codes.
 * @private
 * @enum {number}
 */
                const TransportSessionEventCode = {
                    // Raised when TransportSession is up and ready to send/receive data
                    UP_NOTICE: 1,
                    // Raised if the session is destroyed
                    DESTROYED_NOTICE: 2,
                    // Raised when the send queue had reached its maximum, but now has space again
                    CAN_ACCEPT_DATA: 4,
                    // Raised when there is a decode error on received data.  The app should destroy the session
                    DATA_DECODE_ERROR: 5,
                    // Raised when there is a decode error on received data.  The app should destroy the session
                    PARSE_FAILURE: 6,
                    // Raised when the connection times out. The app should attempt downgrade if available.
                    CONNECT_TIMEOUT: 7,
                    // There was an error sending a message on an etablished transport
                    SEND_ERROR: 8,
                    // The requested downgrade was rejected.
                    DOWNGRADE_FAILED: 10,
                    // The requested downgrade completed.
                    DOWNGRADE_SUCCEEDED: 11
                };
                module.exports.TransportSessionEventCode = Enum.new(TransportSessionEventCode);
                /***/
            },
            /***/ "./modules/solclient-transport/lib/transport-session-event.js": 
            /*!********************************************************************!*\
  !*** ./modules/solclient-transport/lib/transport-session-event.js ***!
  \********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /* provided dependency */ var util_inspect = __webpack_require__(/*! browser-util-inspect */ "./node_modules/browser-util-inspect/index.js");
                const {
                    ErrorSubcode
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    Hex
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    TransportSessionEventCode
                } = __webpack_require__(/*! ./transport-session-event-codes */ "./modules/solclient-transport/lib/transport-session-event-codes.js");
                const {
                    formatHexString
                } = Hex;
                /**
 * @classdesc
 * Defines a Transport Session Event
 *
 * @private
 */
                class TransportSessionEvent {
                    /**
   * @constructor
   * @param {Object} tsEventCode The {@link TransportSessionEventCode} associated with this event
   * @param {String} infoStr An informational string
   * @param {?Number} responseCode The response code from the router, if any
   * @param {ErrorSubcode} subcode The {@link ErrorSubcode} associated with this event
   * @param {Number} sessionId The session ID associated with this event
   *
   */
                    constructor(tsEventCode, infoStr, responseCode, subcode, sessionId) {
                        this._transportEventCode = tsEventCode;
                        this._infoStr = infoStr;
                        this._responseCode = responseCode;
                        this._errorSubcode = subcode;
                        this._sid = sessionId;
                    }
                    // TransportSessionEvent functions
                    getTransportEventCode() {
                        return this._transportEventCode;
                    }
                    get transportEventCode() {
                        return this._transportEventCode;
                    }
                    getInfoStr() {
                        return this.infoStr;
                    }
                    get infoStr() {
                        return this._infoStr;
                    }
                    getResponseCode() {
                        return this.responseCode;
                    }
                    get responseCode() {
                        return this._responseCode;
                    }
                    getSubcode() {
                        return this.errorSubcode;
                    }
                    get errorSubcode() {
                        return this._errorSubcode;
                    }
                    getSessionId() {
                        return this.sessionId;
                    }
                    get sessionId() {
                        return this._sid;
                    }
                    ["inspect"]() {
                        return {
                            transportEventCode: TransportSessionEventCode.describe(this.transportEventCode),
                            infoStr: this.infoStr,
                            responseCode: this.responseCode,
                            errorSubcode: ErrorSubcode.describe(this.errorSubcode),
                            sid: this.sid && formatHexString(this.sid) || "N/A"
                        };
                    }
                    toString() {
                        return util_inspect(this);
                    }
                }
                module.exports.TransportSessionEvent = TransportSessionEvent;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/transport-session-states.js": 
            /*!*********************************************************************!*\
  !*** ./modules/solclient-transport/lib/transport-session-states.js ***!
  \*********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Transport session states, used by WebSocketTransportSession and HTTPTransportSession
 * @enum {number}
 * @private
 */
                const TransportSessionState = {
                    DOWN: 0,
                    WAITING_FOR_CREATE: 1,
                    SESSION_UP: 2,
                    WAITING_FOR_DESTROY: 4,
                    CONNECTION_FAILED: 5
                };
                module.exports.TransportSessionState = Enum.new(TransportSessionState);
                /***/
            },
            /***/ "./modules/solclient-transport/lib/tsh-state.js": 
            /*!******************************************************!*\
  !*** ./modules/solclient-transport/lib/tsh-state.js ***!
  \******************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    LOG_INFO,
                    LOG_WARN
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    Process
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                /**
 * @classdesc
 * Base class for transports
 * @memberof solace
 * @private
 */
                class TSHState {
                    /**
   * @constructor
   * @param {Boolean} useSsl True if SSL should be used
   * @param {TransportProtocol} tpProtocol The protocol to use for this state
   * @param {Function} exitCallback The callback to notify on exit
   * @param {?TSHState} nextState The TSH state to use on downgrade
   */
                    constructor(useSsl, tpProtocol, exitCallback, nextState) {
                        this._ssl = !!useSsl;
                        this._transportProtocol = tpProtocol;
                        this._exitCallback = exitCallback;
                        this._nextState = nextState;
                        this._unsupportedRuntimeMessage = `${this._transportProtocol} not supported by this runtime: ${Process.userAgent}`;
                    }
                    getNextState() {
                        return this._nextState;
                    }
                    setNextState(nextState) {
                        this._nextState = nextState;
                    }
                    getTransportProtocol() {
                        return this._transportProtocol;
                    }
                    getUseSsl() {
                        return this._ssl;
                    }
                    // Override me
                    validateLegal() {
                        // eslint-disable-line class-methods-use-this
                        return true;
                    }
                    onEnter() {
                        if (!this.validateLegal()) {
                            if (this._nextState && this._exitCallback) {
                                this._exitCallback(this._nextState, this._unsupportedRuntimeMessage);
                            } else {
                                LOG_WARN(`${this._unsupportedRuntimeMessage}, no next state.`);
                            }
                        }
                    }
                    completeDowngrade(err) {
                        if (this._nextState && this._exitCallback) {
                            LOG_INFO(`Connect failed (${err}), try next state.`);
                            this._exitCallback(this._nextState, "Connect failed");
                            return true;
                        }
                        LOG_WARN(`Connect failed (${err}), no next state.`);
                        return false;
                    }
                    toString() {
                        return this._transportProtocol + (this._ssl ? " (SSL)" : "");
                    }
                }
                module.exports.TSHState = TSHState;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/web/api.js": 
            /*!****************************************************!*\
  !*** ./modules/solclient-transport/lib/web/api.js ***!
  \****************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const HTTPLib = __webpack_require__(/*! ./http */ "./modules/solclient-transport/lib/web/http/api.js");
                const {
                    StateBase64
                } = __webpack_require__(/*! ./state-base64 */ "./modules/solclient-transport/lib/web/state-base64.js");
                const {
                    StateBinary
                } = __webpack_require__(/*! ./state-binary */ "./modules/solclient-transport/lib/web/state-binary.js");
                const {
                    StateStreamingAndBinary
                } = __webpack_require__(/*! ./state-streaming-and-binary */ "./modules/solclient-transport/lib/web/state-streaming-and-binary.js");
                const {
                    StateWebSocketBinary
                } = __webpack_require__(/*! ./state-websocket-binary */ "./modules/solclient-transport/lib/web/state-websocket-binary.js");
                const {
                    WebTransport
                } = __webpack_require__(/*! ./web-transport */ "./modules/solclient-transport/lib/web/web-transport.js");
                const {
                    WebTransportCapabilities
                } = __webpack_require__(/*! ./web-transport-capabilities */ "./modules/solclient-transport/lib/web/web-transport-capabilities.js");
                const {
                    HTTPConnection,
                    HTTPTransportSession
                } = HTTPLib;
                module.exports.HTTPConnection = HTTPConnection;
                module.exports.HTTPTransportSession = HTTPTransportSession;
                module.exports.StateBase64 = StateBase64;
                module.exports.StateBinary = StateBinary;
                module.exports.StateStreamingAndBinary = StateStreamingAndBinary;
                module.exports.StateWebSocketBinary = StateWebSocketBinary;
                module.exports.WebTransport = WebTransport;
                module.exports.WebTransportCapabilities = WebTransportCapabilities;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/web/http/api.js": 
            /*!*********************************************************!*\
  !*** ./modules/solclient-transport/lib/web/http/api.js ***!
  \*********************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    HTTPConnection
                } = __webpack_require__(/*! ./http-connection */ "./modules/solclient-transport/lib/web/http/http-connection.js");
                const {
                    HTTPTransportSession
                } = __webpack_require__(/*! ./http-transport-session */ "./modules/solclient-transport/lib/web/http/http-transport-session.js");
                if (true) {
                    module.exports.HTTPConnection = HTTPConnection;
                    module.exports.HTTPTransportSession = HTTPTransportSession;
                }
                /***/
            },
            /***/ "./modules/solclient-transport/lib/web/http/http-connection.js": 
            /*!*********************************************************************!*\
  !*** ./modules/solclient-transport/lib/web/http/http-connection.js ***!
  \*********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const DebugLib = __webpack_require__(/*! solclient-debug */ "./modules/solclient-debug/api.js");
                const {
                    Convert,
                    Base64
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    LOG_DEBUG,
                    LOG_INFO,
                    LOG_WARN,
                    LOG_ERROR
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    sendXhrBinary,
                    sendXhrText
                } = __webpack_require__(/*! ./send-xhr */ "./modules/solclient-transport/lib/web/http/send-xhr.js");
                const {
                    StringBuffer,
                    TimingBucket
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const {
                    TransportReturnCode
                } = __webpack_require__(/*! ../../transport-return-codes */ "./modules/solclient-transport/lib/transport-return-codes.js");
                const {
                    XHRFactory
                } = __webpack_require__(/*! ./xhr-factory */ "./modules/solclient-transport/lib/web/http/xhr-factory.js");
                const {
                    arrayBufferToString
                } = Convert;
                const SOL_CONNECTION_DEBUG = false;
                /**
 * A URI starting with a "/" is a "path-absolute" URI, and those aren't
 * allowed to have a query component (starting with "?").
 *
 * If an origin isn't defined in the url, tack on the one from the page.
 *
 * @param {URL} url The URL to connect to
 * @returns {URL} Adjusted URL if incoming URL was relative
 * @private
 */
                function prependOrigin(url) {
                    if (!url.match(/^(http|ws)(s?):/i) && window.location && window.location.origin) {
                        return window.location.origin + (url.charAt(0) !== "/" ? "/" : "") + url;
                    }
                    return url;
                }
                function getTs() {
                    return new Date().getTime();
                }
                class Stats {
                    constructor() {
                        this.WaitedToken = new TimingBucket("WaitedToken", 100);
                        this.HadToken = new TimingBucket("HadToken", 100);
                        this.ReturnedToken = new TimingBucket("ReturnedToken", 100);
                    }
                    toString() {
                        let s = "";
                        [ this.WaitedToken, this.HadToken, this.ReturnedToken ].forEach(b => {
                            if (b && b.bucketCount() > 0) {
                                s += `${b.name} >> ${b}\n`;
                            }
                        });
                        return s;
                    }
                }
                /**
 * @classdesc
 * This class contains all state for a single HTTP connection (XHR).
 *
 * @private
 */
                class HTTPConnection {
                    constructor(url, base64Enc, streamProgressEvents, rxDataCb, connectionErrorCb, contentType, connectionClose) {
                        this.Options = {
                            url: prependOrigin(url),
                            contentType: contentType,
                            base64Enc: base64Enc,
                            streamProgressEvents: streamProgressEvents,
                            connectionClose: connectionClose
                        };
                        this._streamProgressBytes = 0;
                        this._xhr = null;
                        this._rxDataCb = rxDataCb;
                        this._connErrorCb = connectionErrorCb;
                        this._reqActive = false;
                        this._REQCOUNTER = 0;
                        this._REQBASE = Math.floor(Math.random() * 1e3);
                        this._xhr = XHRFactory.create();
                        // older browser ie9
                        this._handleAbortedReq = !HTTPConnection.browserSupportsXhrBinary();
                        this.stats = new Stats();
                    }
                    recStat(s) {
                        if (!SOL_CONNECTION_DEBUG) {
                            return;
                        }
                        const stats = this.stats;
                        if (s === "GotToken") {
                            stats.LastGotToken = getTs();
                            if (stats.LastSendMsg) {
                                const waitedTok = stats.LastGotToken - stats.LastSendMsg;
                                stats.WaitedToken.log(waitedTok);
                                if (waitedTok > 100) {
                                    LOG_WARN(`Abnormally long waitToken, last request: ${this._REQBASE}_${this._REQCOUNTER}`);
                                }
                            }
                        }
                        if (s === "SendMsg") {
                            stats.LastSendMsg = getTs();
                            const hadToken = stats.LastSendMsg - stats.LastGotToken;
                            stats.HadToken.log(hadToken);
                        }
                        if (s === "GotData") {
                            stats.LastGotData = getTs();
                        }
                        if (s === "ReturnToken") {
                            stats.LastReturnToken = getTs();
                            if (stats.LastGotData) {
                                const returnedToken = stats.LastReturnToken - stats.LastGotData;
                                stats.ReturnedToken.log(returnedToken);
                            }
                        }
                    }
                    /*
   * Send data over the connection - this requires a send token
   */
                    send(data, attempt = 0, maxRetry = 1) {
                        if (attempt > 0) {
                            this._xhr.abort();
                            this._xhr = XHRFactory.create();
                        }
                        this._xhr.open("POST", this.Options.url, true);
                        this._streamProgressBytes = 0;
                        // We pass the write data to the CB so we can retry when it mysteriously fails.
                        this._xhr.onreadystatechange = () => this.xhrStateChange(data, attempt, maxRetry);
                        this._reqActive = true;
                        if (SOL_CONNECTION_DEBUG) {
                            this._REQCOUNTER++;
                            this._xhr.setRequestHeader("sol-request-track", `${this._REQBASE}_${this._REQCOUNTER}`);
                        }
                        if (this.Options.base64Enc) {
                            sendXhrText(this._xhr, data, this.Options.contentType, this.Options.connectionClose);
                        } else {
                            sendXhrBinary(this._xhr, data, this.Options.contentType, this.Options.connectionClose);
                        }
                        this.recStat("SendMsg");
                    }
                    // XmlHTTPRequest Callback
                    xhrStateChange(sentdata, attempt, maxRetry) {
                        const readyState = this._xhr.readyState;
                        const RS_LOADING = this._xhr.LOADING;
                        const RS_DONE = this._xhr.DONE;
                        if (!(this.Options.streamProgressEvents && readyState === RS_LOADING || readyState === RS_DONE)) {
                            // we proceed with notifications if we're LOADING and we requested streaming events,
                            // or we're DONE.
                            return;
                        }
                        if (!this._reqActive) {
                            // request aborted, DO NOT propagate event
                            return;
                        }
                        let status = null;
                        if (this._handleAbortedReq) {
                            // To avoid the following IE9 error when request is aborted by server or client and
                            // application tries to access any property in the XHR other than readyState whose value is
                            // 4 (XMLHTTPRequest.DONE):
                            // - The data necessary to complete this operation is not yet available
                            // See https://groups.google.com/forum/#!topic/websync/ysBEvtvMyb0 for details
                            // _requestActive is used to handle client initiated abort, but it does not handle
                            // the case when the request is aborted on the server side or proxy server
                            try {
                                status = this._xhr.status;
                            } catch (e) {
                                LOG_INFO(`Error trying to access status in XHR due to request aborted: ${e.message}`);
                                return;
                            }
                        } else {
                            status = this._xhr.status;
                        }
                        if (status === 200 || status === 304) {
                            // Success status code
                            let data = null;
                            if (this._xhr.responseType && this._xhr.responseType === "arraybuffer") {
                                data = arrayBufferToString(this._xhr.response);
                            } else {
                                data = this._xhr.responseText;
                            }
                            data = data.substring(this._streamProgressBytes, data.length);
                            this._streamProgressBytes += data.length;
                            if (data.length === 0 && readyState === RS_LOADING) {
                                // we are streaming LOADING events but have no data
                                return;
                            }
                            if (this.Options.base64Enc) {
                                try {
                                    data = Base64.decode(data);
                                } catch (e) {
                                    // Failed the decode - call the error callback
                                    LOG_ERROR(`Data decode error on: ${data}`);
                                    LOG_ERROR(`Data decode error is: ${e.message}`);
                                    this._rxDataCb(TransportReturnCode.DATA_DECODE_ERROR, data);
                                    return;
                                }
                            } else {
                                // take lower-8 bits
                                const decodedData = [];
                                const dataLength = data.length;
                                for (let i = 0; i < dataLength; i++) {
                                    decodedData.push(String.fromCharCode(data.charCodeAt(i) & 255));
                                }
                                data = decodedData.join("");
                            }
                            if (readyState === RS_DONE) {
                                // MUST do this BEFORE the callback invocation, because the callback can trigger a new send.
                                this._reqActive = false;
                            }
                            this._rxDataCb(TransportReturnCode.OK, data);
                            if (readyState === RS_DONE && data.length > 0) {
                                this._rxDataCb(TransportReturnCode.OK, ""); // indicate end of stream
                            }
                            return;
                        }
                        // Failure status code.
                        const statusText = this._xhr.statusText;
                        let responseText = "";
                        if (this._xhr.responseType && this._xhr.responseType === "arraybuffer") {
                            responseText = arrayBufferToString(this._xhr.response);
                        } else {
                            responseText = this._xhr.responseText || "";
                        }
                        const responseTextLen = responseText.length;
                        const requestUrl = this.Options.url;
                        const sentdataLen = sentdata ? sentdata.length : 0;
                        const {
                            formatDumpBytes
                        } = DebugLib.Debug;
                        const responseTextDump = formatDumpBytes(responseText.substr(0, Math.min(responseTextLen, 64)), true, 0);
                        const sentTextDump = formatDumpBytes((sentdata || "").substr(0, Math.min(sentdataLen, 256)), true, 0);
                        if (true) {
                            const stmt = new StringBuffer(`Http request failed.  url=${requestUrl}, status=${status}, statusText=${statusText}, `, `responseText length=${responseTextLen}, `, "responseText (first 64 bytes or fewer)=\n", `${responseTextDump}, `, `XHR errorCode=${this._xhr._error ? this._xhr._error.code : ""}, `, `attempt=${attempt}, reqActive=${this._reqActive}, readyState=${readyState}, `, `sent data length=${sentdataLen}, `, "sent data (first 256 bytes or fewer)=\n", `${sentTextDump}`).toString();
                            LOG_DEBUG(stmt);
                        }
                        const nextMaxRetry = maxRetry;
                        if (this._reqActive && status !== 400 && responseText.length === 0 && (attempt === 0 || attempt < nextMaxRetry)) {
                            LOG_INFO(`XHR failed while request active, will retry send, retry=${attempt + 1}`);
                            // RETRY (could be a transient browser connection problem)
                            this.send(sentdata, attempt + 1, nextMaxRetry);
                        } else {
                            this._reqActive = false;
                            this._connErrorCb(status, new StringBuffer(`HTTP request failed(status=${status} statusText=${statusText}, `, `responseText length=${responseTextLen}, responseText[0..64]=\n`, responseTextDump, `XHR errorCode=${this._xhr._error ? this._xhr._error.code : ""})`).toString());
                        }
                    }
                    isUsingBase64() {
                        return this.Options.base64Enc;
                    }
                    // This function will abort the current xhr request if it is active
                    abort() {
                        // mark request as inactive, so we won't process statechange events
                        this._reqActive = false;
                        if (this._xhr && this._xhr.abort) {
                            this._xhr.abort();
                        }
                    }
                    /**
   * Check if we can try binary XHR on this browser.
   * @returns {Boolean} `true` if XHR binary should work; `false` otherwise
   * @static
   */
                    static browserSupportsXhrBinary() {
                        return sendXhrBinary !== sendXhrText;
                    }
                    /**
   * Check if browser supports streaming responses (progressive reading of XHR).
   * @returns {Boolean} `true` if feature was detected, `false` otherwise
   * @static
   */
                    static browserSupportsStreamingResponse() {
                        const xhr = XHRFactory.create();
                        // A conforming XHR2 implementation must include progress events.
                        // Can we assume that the event property will be null instead of undefined?
                        // A conforming XHR2 implementation must also include withCredentials.
                        const check = xhr && xhr.onprogress === null; // xhr.withCredentials === false;
                        LOG_INFO(`http browserStreamingCheck - if XMLHTTPRequest supported and XMLHTTPRequest support onprogress: ${check}`);
                        return check;
                    }
                }
                module.exports.HTTPConnection = HTTPConnection;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/web/http/http-transport-session.js": 
            /*!****************************************************************************!*\
  !*** ./modules/solclient-transport/lib/web/http/http-transport-session.js ***!
  \****************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const DebugLib = __webpack_require__(/*! solclient-debug */ "./modules/solclient-debug/api.js");
                const SMFLib = __webpack_require__(/*! solclient-smf */ "./modules/solclient-smf/api.js");
                const {
                    Check
                } = __webpack_require__(/*! solclient-validate */ "./modules/solclient-validate/api.js");
                const {
                    Convert,
                    Hex
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    HTTPConnection
                } = __webpack_require__(/*! ./http-connection */ "./modules/solclient-transport/lib/web/http/http-connection.js");
                const {
                    LogFormatter
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    SMFClient
                } = __webpack_require__(/*! ../../smf-client */ "./modules/solclient-transport/lib/smf-client.js");
                const {
                    TransportError
                } = __webpack_require__(/*! ../../transport-error */ "./modules/solclient-transport/lib/transport-error.js");
                const {
                    TransportProtocol
                } = __webpack_require__(/*! ../../transport-protocols */ "./modules/solclient-transport/lib/transport-protocols.js");
                const {
                    TransportReturnCode
                } = __webpack_require__(/*! ../../transport-return-codes */ "./modules/solclient-transport/lib/transport-return-codes.js");
                const {
                    TransportSessionEvent
                } = __webpack_require__(/*! ../../transport-session-event */ "./modules/solclient-transport/lib/transport-session-event.js");
                const {
                    TransportSessionEventCode
                } = __webpack_require__(/*! ../../transport-session-event-codes */ "./modules/solclient-transport/lib/transport-session-event-codes.js");
                const {
                    TransportSessionState
                } = __webpack_require__(/*! ../../transport-session-states */ "./modules/solclient-transport/lib/transport-session-states.js");
                const {
                    WebTransportSessionBase
                } = __webpack_require__(/*! ../web-transport-session-base */ "./modules/solclient-transport/lib/web/web-transport-session-base.js");
                const {
                    int32ToStr,
                    strToByteArray,
                    strToHexArray
                } = Convert;
                const {
                    formatHexString
                } = Hex;
                const {
                    LOG_TRACE,
                    LOG_DEBUG,
                    LOG_ERROR,
                    LOG_INFO
                } = new LogFormatter("[http-transport-session]");
                /**
 * @private
 * @namespace Values for tracking current state of incoming streaming data
 */
                const PacketReadState = {
                    READING_HEADER: 0,
                    STREAMING: 1
                };
                // eslint-disable-next-line global-require
                const BufferImpl = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer;
                /**
 * @private
 */
                const MSIE_TRANSPORT_PADDING = 257;
                function adaptURL(url) {
                    const v = url.match(/(ws|http)(s?:\/\/.+)/);
                    return `http${v[2]}`;
                }
                /** ===========================================================================
 * HTTPTransportSession :
 *
 * This contains all data and code required to maintain HTTP transport sessions
 * with Solace routers
 * ============================================================================
 * @extends WebTransportSessionBase
 * @private
 */
                class HTTPTransportSession extends WebTransportSessionBase {
                    constructor(baseUrl, eventCB, client, props) {
                        // Our internal data format (for now) is binary string, so we wrap the callback
                        // in a function that does the required conversion to ArrayBuffer.
                        super(baseUrl, eventCB, client, props);
                        // const self = this;
                        // logger.formatter = function formatter(...args) {
                        //   return [self.sessionIdHex, ...args];
                        // };
                        // Set to true if we have the data token that we need for sending data to the router
                        this._haveToken = true;
                        // Maximum payload chunk size in web transport
                        this._confMaxWebPayload = props.maxWebPayload;
                        this._maxPayloadBytes = 0;
                        // Timer that will keep track of the destroy time
                        this._destroyTimer = null;
                        this._destroyTimeout = props.connectTimeoutInMsecs;
                        // The URL used for create messages
                        this._createUrl = adaptURL(baseUrl);
                        // The URL used for all other messages - it will have the router tag appended
                        // after the session has been created
                        this._routerUrl = this._createUrl;
                        // SMF client (instantiated after session is created)
                        this._rxChannelClient = null;
                        // Send data connection (instantiated after session is created)
                        this._httpSendConn = null;
                        // Receive data connection (instantiated after session is created)
                        this._httpReceiveConn = null;
                        // Data Token SMF header - this is preformatted for performance
                        // It will be set after session is created
                        this._smfDataTokenTSHeader = null;
                        // Router Tag - a string that will be added to HTTP request URLs
                        this._routerTag = "";
                        // Session ID - 8-byte identifier that will associate this client
                        // with client resources on the router
                        this._sid = null;
                        if (props.transportProtocol === null || props.transportProtocol === undefined) {
                            throw new OperationError("transportProtocol is not set", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                        this._transportProtocol = props.transportProtocol;
                        this._useBinaryTransport = false;
                        this._useStreamingTransport = false;
                        this._streamingTransportPadding = 0;
                        this._useBinaryTransport = props.transportProtocol !== TransportProtocol.HTTP_BASE64;
                        this._useStreamingTransport = props.transportProtocol === TransportProtocol.HTTP_BINARY_STREAMING;
                        // extra state for STREAMING transport
                        this._incomingBuffer = "";
                        this._packetReadState = PacketReadState.READING_HEADER;
                        const agent = navigator.userAgent || "";
                        if (agent.match(/trident/i) || agent.match(/msie/i)) {
                            this._streamingTransportPadding = MSIE_TRANSPORT_PADDING;
                        }
                        if (props.transportContentType === null || props.transportContentType === undefined) {
                            throw new OperationError("transportContentType is not set", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                        this._contentType = props.transportContentType;
                    }
                    /**
   * @override
   */
                    connectTimerExpiry() {
                        LOG_INFO("HTTP transport connect timeout");
                        this.destroyCleanup("HTTP transport connect timeout", ErrorSubcode.TIMEOUT);
                    }
                    get sessionIdHex() {
                        return this._sid ? formatHexString(this._sid) : "";
                    }
                    updateMaxWebPayload() {
                        // 22 Bytes of TransportSMF wrapping overhead
                        const trLessEncapSMF = this._confMaxWebPayload - 22;
                        // Base64 has a 4:3 expansion
                        this._maxPayloadBytes = this._useBinaryTransport ? trLessEncapSMF : Math.floor(trLessEncapSMF * .75);
                    }
                    /**
   * Connect transport session to router
   * @returns {TransportReturnCode} The result of the operation
   */
                    connect() {
                        // Check that we we are in an acceptable state for connection
                        if (this._state !== TransportSessionState.DOWN) {
                            return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                        }
                        return this.connectInternal();
                    }
                    connectInternal() {
                        // Create the XHR to talk to the router
                        this._connError = null;
                        try {
                            this._createConn = new HTTPConnection(this._createUrl, !this._useBinaryTransport, false, (rc, data) => this.handleCreateResponse(rc, data), (rc, data) => this.handleCreateConnFailure(rc, data), this._contentType);
                        } catch (e) {
                            LOG_INFO(`Failed to create connection to router: ${e.message}`);
                            this._connError = e;
                            return TransportReturnCode.CONNECTION_ERROR;
                        }
                        if (Check.nothing(this._createConn)) {
                            LOG_INFO("Failed to create connection to router");
                            return TransportReturnCode.CONNECTION_ERROR;
                        }
                        // Get an SMF transport session create message
                        const createMsg = SMFLib.Codec.Transport.genTsCreateHeader();
                        if (this._state === TransportSessionState.WAITING_FOR_CREATE) {
                            // already connecting (this is likely a retry with Base64 encoding)
                            LOG_DEBUG("Connect attempt while in WAITING_FOR_CREATE (retry)");
                        } else {
                            this.createConnectTimeout();
                            // Set the current state
                            this._state = TransportSessionState.WAITING_FOR_CREATE;
                        }
                        // Send the create message to the router.  When the response is received, the
                        // handleCreateResponse method will be called
                        try {
                            this._createConn.send(createMsg);
                        } catch (connError) {
                            LOG_INFO(`Error connecting: ${connError.message}`);
                            LOG_TRACE("Error details:", connError.stack || connError);
                            this._state = TransportSessionState.CONNECTION_FAILED;
                            this.cancelConnectTimeout();
                            if (connError instanceof TransportError) {
                                this._connError = connError;
                            } else {
                                this._connError = new TransportError(`Could not create HTTP transport session: ${connError.message}`, connError.subcode || ErrorSubcode.CONNECTION_ERROR);
                            }
                            return TransportReturnCode.CONNECTION_ERROR;
                        }
                        return TransportReturnCode.OK;
                    }
                    /**
   * Destroy transport session to router
   * @param {String} msg The message associated with the operation
   * @param {ErrorSubcode} subcode The subcode associated with the operation
   * @returns {TransportReturnCode} The result of the operation
   */
                    destroy(msg, subcode) {
                        LOG_TRACE(`Destroy transport session when in state ${this._state}`);
                        if (this._state === TransportSessionState.WAITING_FOR_DESTROY || this._state === TransportSessionState.DOWN) {
                            // Nothing to do
                            return TransportReturnCode.OK;
                        }
                        if (this._state === TransportSessionState.CONNECTION_FAILED || this._state === TransportSessionState.WAITING_FOR_CREATE) {
                            // The connections are in an unreliable state - we will just
                            // kill our local object and let the router clean itself up with its inactivity timer
                            LOG_INFO("The connection is in unreliable state, close transport");
                            this.destroyCleanup(msg, subcode, true);
                            return TransportReturnCode.OK;
                        }
                        LOG_INFO("Destroy transport session immediately");
                        // Set the current state
                        this._state = TransportSessionState.WAITING_FOR_DESTROY;
                        // Abort any current requests for this session
                        if (this._httpSendConn !== null) {
                            LOG_INFO("Destroy transport session: abort sendConn");
                            this._httpSendConn.abort();
                        }
                        if (this._httpReceiveConn !== null) {
                            LOG_INFO("Destroy transport session: abort receiveConn");
                            this._httpReceiveConn.abort();
                        }
                        // Start a timer
                        this._destroyTimer = setTimeout(() => {
                            this.destroyTimerExpiry();
                        }, this._destroyTimeout);
                        // Send the destroy message over new HTTPConnection to the router so that the async abort
                        // can properly finish in the old _httpSendConn.
                        // When the response is received, the handleDestroyResponse method will be called.
                        this._httpSendConn = new HTTPConnection(this._routerUrl, !this._useBinaryTransport, false, (rc, data) => this.handleRxDataToken(rc, data), // RxData callback
                        (rc, data) => this.handleSendFailure(rc, data), // connection close or error callback
                        this._contentType, true);
                        // Get an SMF transport session destroy message
                        const destroyMsg = SMFLib.Codec.Transport.genTsDestroyHeader(this._sid);
                        LOG_TRACE(`destroy message: ${strToHexArray(destroyMsg)}`);
                        this._httpSendConn.send(destroyMsg);
                        return TransportReturnCode.OK;
                    }
                    /**
   * Send data over the connection - this requires a send token
   * @param {String} dataIn The data to send
   * @param {Boolean} [forceAllowEnqueue=false] If `true`, do not fail due to out of space
   * @returns {TransportReturnCode} The result of the operation
   */
                    send(dataIn, forceAllowEnqueue = false) {
                        let data = dataIn;
                        // LOG_TRACE(`HTTPTransportSession:send ${data.length}, tx_queued:${this._queuedDataSize}`);
                        if (this._state !== TransportSessionState.SESSION_UP) {
                            return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                        }
                        // Check to see if we already have queued data
                        if (this._queuedData.length > 0 || !this._haveToken) {
                            return this.enqueueData(data, forceAllowEnqueue);
                        }
                        // Check if we need to chop up the payload
                        let remainder = null;
                        if (data.length > this._maxPayloadBytes) {
                            remainder = data.substr(this._maxPayloadBytes);
                            data = data.substr(0, this._maxPayloadBytes);
                            // If no space for remainder, return FAIL without sending anything.
                            if (!this.allowEnqueue(remainder.length)) {
                                return this.enqueueFailNoSpace();
                            }
                            // LOG_DEBUG("$$ send dataChunk:" + data.length + ", remainderChunk:" + remainder.length);
                        }
                        // We have the token, so send the data
                        this._haveToken = false;
                        const transportPacketLen = this._smfDataTSHeaderParts[0].length + 4 + this._smfDataTSHeaderParts[1].length + data.length;
                        this._httpSendConn.send(this._smfDataTSHeaderParts[0] + int32ToStr(transportPacketLen) + this._smfDataTSHeaderParts[1] + data);
                        this._clientstats.bytesWritten += data.length;
                        if (remainder) {
                            // The message was partially sent. The message written count will be incremented
                            // when its last bytes go out.
                            return this.enqueueData(remainder, null);
                        }
                        // The whole message was sent.
                        this._clientstats.msgWritten++;
                        return TransportReturnCode.OK;
                    }
                    /**
   * Push data onto the pending send queue as long as it doesn't violate
   * the max stored message size
   * @param {String} data The data to enqueue
   * @param {Boolean} [forceAllowEnqueue=false] If `true`, don't fail due to no space.
   * @returns {TransportReturnCode} The result of the operation.
   */
                    enqueueData(data, forceAllowEnqueue = false) {
                        const dataLen = data.length;
                        // LOG_DEBUG("enqueueing data: " + data.length + ", queue depth: " + this._queuedDataSize);
                        if (forceAllowEnqueue || this.allowEnqueue(dataLen)) {
                            this._queuedDataSize += dataLen;
                            this._queuedData.push(data);
                        } else {
                            return this.enqueueFailNoSpace();
                        }
                        return TransportReturnCode.OK;
                    }
                    /**
   * Set the data in the preformatted headers.  The headers are set up this way
   * for performance reasons
   * @param {String} sid The session ID to incorporate into the headers
   */
                    initPreformattedHeaders(sid) {
                        // _smfDataTSHeaderParts is a two entry array - one part before the total length
                        // and the other after.  The total length is not known until actual data is sent
                        this._smfDataTSHeaderParts = SMFLib.Codec.Transport.genTsDataMsgHeaderParts(sid);
                        // _smfDataTokenTSHeader is a single header that all data-token messages require
                        if (this._useStreamingTransport) {
                            this._smfDataTokenTSHeader = SMFLib.Codec.Transport.genTsDataStreamTokenMsg(sid, this._streamingTransportPadding);
                        } else {
                            this._smfDataTokenTSHeader = SMFLib.Codec.Transport.genTsDataTokenMsg(sid);
                        }
                    }
                    /**
   * @override
   */
                    flush(callback) {
                        if (this._queuedDataSize) {
                            this._flushCallback = callback;
                        } else {
                            callback();
                        }
                    }
                    /**
   * Check if there is any data waiting to be sent to the router.
   * If there is, send it.
   */
                    sendQueuedData() {
                        if (this._queuedDataSize === 0) {
                            return;
                        }
                        this._haveToken = false;
                        const data = this.getQueuedDataToSend();
                        const transportPacketLen = this._smfDataTSHeaderParts[0].length + 4 + this._smfDataTSHeaderParts[1].length + data.length;
                        this._httpSendConn.send(this._smfDataTSHeaderParts[0] + int32ToStr(transportPacketLen) + this._smfDataTSHeaderParts[1] + data);
                        this._clientstats.bytesWritten += data.length;
                        if (this._canSendNeeded) {
                            this._canSendNeeded = false;
                            this._eventCB(new TransportSessionEvent(TransportSessionEventCode.CAN_ACCEPT_DATA, "", null, 0, this._sid));
                        }
                        if (this._flushCallback) {
                            const cb = this._flushCallback;
                            this._flushCallback = null;
                            cb();
                        }
                    }
                    // Internal Callbacks
                    // Called when a create response message has been received
                    handleCreateResponse(tsRc, response) {
                        if (this._state === TransportSessionState.WAITING_FOR_DESTROY || this._state === TransportSessionState.DOWN) {
                            LOG_DEBUG("Received create response on a destroyed transport session, ignore");
                            return;
                        }
                        // Was: stop the connect timer. We don't do that in this transport now.
                        // We wait for the login response.
                        // We know whether we're using Base64 or not, so update our max payload size.
                        this.updateMaxWebPayload();
                        if (tsRc !== TransportReturnCode.OK) {
                            LOG_INFO(`Received create response with return code ${TransportReturnCode.describe(tsRc)}`);
                            if (tsRc === TransportReturnCode.DATA_DECODE_ERROR) {
                                this.destroyCleanup("Received data decode error on create session response", ErrorSubcode.DATA_DECODE_ERROR);
                            } else {
                                this.destroyCleanup("Failed to handle create session response", ErrorSubcode.CONNECTION_ERROR);
                            }
                            return;
                        }
                        if (response.length === 0) {
                            return; // null read indicating end of stream
                        }
                        // Parse the Transport Session SMF
                        const parsedResponse = SMFLib.Codec.Decode.decodeCompoundMessage(BufferImpl.from(response, "latin1"), 0);
                        if (!parsedResponse) {
                            LOG_ERROR("Could not parse create response as SMF. Destroying transport");
                            this.destroyCleanup("Failed to parse create response message", ErrorSubcode.CONNECTION_ERROR);
                            return;
                        }
                        const smfresponse = parsedResponse.getResponse();
                        if (smfresponse.responseCode !== 200) {
                            this.destroyCleanup(`Transport create request failed (${smfresponse.responseCode}, ${smfresponse.responseString})`, ErrorSubcode.CONNECTION_ERROR);
                            return;
                        }
                        this.cancelConnectTimeout();
                        this._createConn.abort();
                        this._createConn = null;
                        this._state = TransportSessionState.SESSION_UP;
                        this._sid = parsedResponse.sessionId;
                        this._routerTag = parsedResponse.routerTag;
                        // Trim any parameters off the create url before using it for the routerUrl
                        this._routerUrl = this._createUrl.replace(/\?.*/, "");
                        if (this._routerTag !== "") {
                            this._routerUrl = this._routerUrl + this._routerTag;
                        }
                        this.initPreformattedHeaders(this._sid);
                        const useBase64 = !this._useBinaryTransport;
                        const useStreaming = this._useStreamingTransport;
                        // Create the two connections to the router
                        // By now, getXhrObj() should not throw any exception inside HTTPConnection constructor
                        this._httpSendConn = new HTTPConnection(this._routerUrl, useBase64, false, (rc, data) => this.handleRxDataToken(rc, data), // RxData callback
                        (rc, data) => this.handleSendFailure(rc, data), // connection close or error callback
                        this._contentType);
                        if (this._useStreamingTransport) {
                            // When the transport is HTTP_BINARY_STREAMING the SMF encapsulation
                            // is complete, the SMF header indicates a message length of 0xFFFFFFFF
                            // and after decoding just the header alone the data is passed through
                            // to the session layer, so we must use a simplified SMF parser and a
                            // stateful data callback in that case.
                            this._httpReceiveConn = new HTTPConnection(this._routerUrl, useBase64, useStreaming, (rc, data) => this.handleRxStreaming(rc, data), // RxData Callback
                            (rc, data) => this.handleSendFailure(rc, data), // connection close or error callback
                            this._contentType, true);
                        } else {
                            // Create a SMF client for the Receive Data channel, when http is used.
                            // SMF messages are encapsualated in a solace http-transport which is itself
                            // encapsulated in SMF.  So create an SMF client that will callback with
                            // an smfMessage construct to the HTTPTransportSession.
                            this._rxChannelClient = new SMFClient(rxData => this.handleSmfMessage(rxData), rxError => this.handleSmfParseError(rxError), null); // we don't have a 'session' for this client. It's just a parser.
                            this._httpReceiveConn = new HTTPConnection(this._routerUrl, useBase64, useStreaming, (rc, data) => this.handleRxData(rc, data), // RxData Callback
                            (rc, data) => this.handleSendFailure(rc, data), // connection close or error callback
                            this._contentType);
                        }
                        // Give the router the data token so that it will be able to send data
                        this._httpReceiveConn.send(this._smfDataTokenTSHeader);
                        // Send the event to the application letting it know that the session is up
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.UP_NOTICE, smfresponse.responseString, smfresponse.responseCode, 0, parsedResponse.sessionId));
                    }
                    // Called when receiving a destroy response
                    handleDestroyResponse(response) {
                        LOG_DEBUG("Handle destroy response");
                        // Stop the timer
                        this.cancelDestroyTimeout();
                        const innerResponse = response.getResponse();
                        const responseString = innerResponse ? innerResponse.responseString : "";
                        this.destroyCleanup(`${responseString} handled Destroy Response addressed to session ${formatHexString(response.sessionId)}, on session ${formatHexString(this._sid)}`, 0);
                    }
                    handleSmfMessage(tsmsg) {
                        const smfHeader = tsmsg.smfHeader;
                        if (smfHeader.smf_protocol !== SMFLib.SMFProtocol.TSESSION) {
                            this.handleSmfParseError(`Unexpected Message Prototcol (${smfHeader.smf_protocol}) on ReceiveData connection`);
                            return;
                        }
                        // we have found a transport SMF, can we now read the Transport SMF chunk
                        const data = tsmsg.payload;
                        const TotalPayloadToRead = tsmsg.payloadLength;
                        switch (tsmsg.messageType) {
                          case SMFLib.SMFTransportSessionMessageType.DESTROY_RESP:
                            this.handleDestroyResponse(tsmsg);
                            return;

                          case SMFLib.SMFTransportSessionMessageType.DATA:
                            if (tsmsg.sessionId !== this._sid) {
                                // The router may have given us an error code; if so, include in the error message.
                                const smfErrResponse = tsmsg.getResponse();
                                const responseErrStr = smfErrResponse ? ` (${smfErrResponse.responseCode} ${smfErrResponse.responseString})` : "";
                                const responseCode = smfErrResponse ? smfErrResponse.responseCode : null;
                                LOG_DEBUG(`HandleRxData Bad Session ID received in message. Expected: ${strToByteArray(this._sid)}, Received: ${strToByteArray(tsmsg.sessionId)}${responseErrStr}`);
                                this._state = TransportSessionState.CONNECTION_FAILED;
                                this._eventCB(new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE, `Session ID mismatch in data message, expected: ${formatHexString(this._sid)}, got: ${formatHexString(tsmsg.sessionId)}, ${responseErrStr}`, responseCode, ErrorSubcode.PROTOCOL_ERROR, this._sid));
                                return;
                            }
                            // pass-through encapsulated data to parent
                            if (TotalPayloadToRead > 0) {
                                this._client.rxDataBuffer(data);
                            }
                            break;

                          default:
                            // Unexpected message type
                            this.handleSmfParseError(`Unexpected message type (${tsmsg.messageType}) on ReceiveData connection`);
                        }
                    }
                    handleSmfParseError() {
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DATA_DECODE_ERROR, "Received data decode error", null, ErrorSubcode.DATA_DECODE_ERROR, this._sid));
                    }
                    // Called when data is received on the connection
                    handleRxData(tsRc, data) {
                        if (this._httpReceiveConn === null || this._rxChannelClient === null) {
                            if (this._state === TransportSessionState.DOWN) {
                                LOG_INFO("Transport session is down, ignore data from receive connection");
                            } else {
                                LOG_ERROR(`Transport session is not in working state, state: ${this._state}`);
                            }
                            return;
                        }
                        if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                            LOG_DEBUG("Transport session is being destroyed, ignore data from receive connection, " + `dump first 64 bytes (or fewer) of data:\n${DebugLib.Debug.formatDumpBytes(data.substring(0, 64), true, 0)}`);
                            return;
                        }
                        this._httpReceiveConn.recStat("GotData");
                        if (tsRc !== TransportReturnCode.OK) {
                            this.handleRxError(tsRc, data);
                            return;
                        }
                        if (data.length === 0) {
                            LOG_DEBUG("Send write token to router");
                            this._httpReceiveConn.send(this._smfDataTokenTSHeader);
                        } else {
                            this._rxChannelClient.rxDataString(data);
                        } // end have data to process
                    }
                    // Called when data is received on a HTTP_BINARY_STREAMING connection
                    handleRxStreaming(tsRc, data) {
                        if (this._httpReceiveConn === null) {
                            if (this._state === TransportSessionState.DOWN) {
                                LOG_DEBUG("Transport session is down, ignore data from receive connection");
                            } else {
                                LOG_ERROR(`Transport session is not in working state, state: ${this._state}`);
                            }
                            return;
                        }
                        if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                            LOG_DEBUG("Transport session is being destroyed, ignore data from streaming receive " + `connection, dump first 64 bytes (or fewer) of data:\n${DebugLib.Debug.formatDumpBytes(data.substring(0, 64), true, 0)}`);
                            return;
                        }
                        this._httpReceiveConn.recStat("GotData");
                        if (tsRc !== TransportReturnCode.OK) {
                            this.handleRxError(tsRc, data);
                            return;
                        }
                        if (data.length === 0) {
                            LOG_TRACE("Send write token to router");
                            this._packetReadState = PacketReadState.READING_HEADER;
                            this._httpReceiveConn.send(this._smfDataTokenTSHeader);
                            return;
                        }
                        // pass-through encapsulated data to parent
                        if (this._packetReadState === PacketReadState.STREAMING) {
                            this._client.rxDataString(data);
                            return;
                        }
                        this._incomingBuffer += data;
                        const smfheader = SMFLib.Codec.ParseSMF.parseSMFAt(BufferImpl.from(this._incomingBuffer, "latin1"), 0, true);
                        if (smfheader) {
                            // we have a valid smf header, see if there is a transport header and session-id
                            const tsmsg = SMFLib.Codec.Transport.parseTsSmfHdrAt(BufferImpl.from(this._incomingBuffer, "latin1"), smfheader.headerLength, smfheader);
                            if (!tsmsg) {
                                // Not tsMsg but there is an smf header, just return until more data arrives
                                return;
                            }
                            // We have the transport message header too, if it is a DATA message enter
                            // STREAMING state
                            switch (tsmsg.messageType) {
                              case SMFLib.SMFTransportSessionMessageType.DESTROY_RESP:
                                this.handleDestroyResponse(tsmsg);
                                return;

                              case SMFLib.SMFTransportSessionMessageType.DATA:
                                if (tsmsg.sessionId !== this._sid) {
                                    // The router may have given us an error code, if so, include in the error message.
                                    const smfErrResponse = tsmsg.getResponse();
                                    const responseErrStr = smfErrResponse ? ` (${smfErrResponse.responseCode} ${smfErrResponse.responseString})` : "";
                                    const responseCode = smfErrResponse ? smfErrResponse.responseCode : null;
                                    LOG_DEBUG(`HandleRxData Bad Session ID received in message.  Expected: ${strToByteArray(this._sid)}, Received: ${strToByteArray(tsmsg.sessionId)}${responseErrStr}`);
                                    LOG_DEBUG(`First 64 bytes (or fewer) of message: ${strToByteArray(data.substr(0, 64))}`);
                                    this._state = TransportSessionState.CONNECTION_FAILED;
                                    this._eventCB(new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE, `Session ID mismatch in data message, expected: ${formatHexString(this._sid)}, got: ${formatHexString(tsmsg.sessionId)}, ${responseErrStr}`, responseCode, ErrorSubcode.PROTOCOL_ERROR, this._sid));
                                    return;
                                }
                                // all is good. We can now STREAM the rest of the data until a empty message is received.
                                this._packetReadState = PacketReadState.STREAMING;
                                // pass-through any remaining data
                                if (this._incomingBuffer.length > smfheader.headerLength + tsmsg.tsHeaderLength) {
                                    this._client.rxDataString(this._incomingBuffer.substr(smfheader.headerLength + tsmsg.tsHeaderLength));
                                }
                                this._incomingBuffer = "";
                                return;

                              default:
                                // Unexpected message type
                                throw new TransportError(`Unexpected message type (${tsmsg.messageType}) on ReceiveData connection`, 0);
                            }
                        } else if (SMFLib.Codec.ParseSMF.isSMFHeaderAvailable(BufferImpl.from(this._incomingBuffer, "latin1"), 0) && !SMFLib.Codec.ParseSMF.isSMFHeaderValid(BufferImpl.from(this._incomingBuffer, "latin1"), 0)) {
                            // Probably lost framing
                            LOG_ERROR(`Couldn't decode message due to invalid smf header, dump first 64 bytes (or fewer) of buffer content:\n${DebugLib.Debug.formatDumpBytes(this._incomingBuffer.substring(0, 64), true, 0)}`);
                            const errorInfo = "Error parsing incoming message - invalid SMF header detected";
                            this._state = TransportSessionState.CONNECTION_FAILED;
                            this._eventCB(new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE, errorInfo, null, ErrorSubcode.PROTOCOL_ERROR, null));
                        }
                    }
                    // Called when data is received on the httpDataSend
                    handleRxDataToken(tsRc, data) {
                        if (tsRc !== TransportReturnCode.OK) {
                            this.handleRxError(tsRc, data);
                            return;
                        }
                        if (data.length === 0) {
                            return; // handle End of Stream
                        }
                        const parsedResponse = SMFLib.Codec.Decode.decodeCompoundMessage(BufferImpl.from(data, "latin1"), 0);
                        if (!parsedResponse) {
                            if (this._state !== TransportSessionState.WAITING_FOR_DESTROY) {
                                this._state = TransportSessionState.CONNECTION_FAILED;
                                this._eventCB(new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE, "Failed to parse received data message", null, ErrorSubcode.PROTOCOL_ERROR, this._sid));
                            } else {
                                this.destroyCleanup("Failed to parse received data message", ErrorSubcode.PROTOCOL_ERROR);
                            }
                            return;
                        }
                        if (parsedResponse.messageType === SMFLib.SMFTransportSessionMessageType.DESTROY_RESP) {
                            this.handleDestroyResponse(parsedResponse);
                            return;
                        }
                        if (parsedResponse.sessionId !== this._sid) {
                            // The router may have given us an error code, if so, include in the error message.
                            const smfErrResponse = parsedResponse.getResponse();
                            const responseErrStr = smfErrResponse ? ` (${smfErrResponse.responseCode} ${smfErrResponse.responseString})` : "";
                            const responseCode = smfErrResponse ? smfErrResponse.responseCode : null;
                            LOG_DEBUG(`HandleRxDataToken Bad SID received in message.  Expected: ${strToByteArray(this._sid)}, Received: ${strToByteArray(parsedResponse.sessionId)}${responseErrStr}`);
                            LOG_DEBUG(`First 64 bytes (or fewer) of message: ${strToByteArray(data.substr(0, 64))}`);
                            if (this._state !== TransportSessionState.WAITING_FOR_DESTROY) {
                                this._state = TransportSessionState.CONNECTION_FAILED;
                                this._eventCB(new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE, `Session ID mismatch in response message, expected: ${formatHexString(this._sid)}, got: ${formatHexString(parsedResponse.sessionId)}, ${responseErrStr}`, responseCode, ErrorSubcode.PROTOCOL_ERROR, this._sid));
                            } else {
                                this.destroyCleanup("Session ID mismatch in response message", ErrorSubcode.PROTOCOL_ERROR);
                            }
                            return;
                        }
                        if (parsedResponse.messageType === SMFLib.SMFTransportSessionMessageType.DATA_TOKEN || parsedResponse.messageType === SMFLib.SMFTransportSessionMessageType.DATA_STREAM_TOKEN) {
                            this._haveToken = true;
                            this._httpSendConn.recStat("GotToken");
                            // this._eventCB(
                            //    new TransportSessionEvent(TransportSessionEventCode.NOTIFY_GOT_TOKEN, "", null, null));
                            this.sendQueuedData();
                        } else {
                            // Unexpected message type
                            throw new TransportError(`Unexpected message type (${parsedResponse.messageType}) on SendData connection`, 0);
                        }
                    }
                    handleRxError(tsRc) {
                        LOG_INFO(`handleRxError, transport return code ${TransportReturnCode.name(tsRc)}`);
                        this._state = TransportSessionState.CONNECTION_FAILED;
                        if (tsRc === TransportReturnCode.DATA_DECODE_ERROR) {
                            this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DATA_DECODE_ERROR, "Received data decode error", null, ErrorSubcode.DATA_DECODE_ERROR, this._sid));
                        } else {
                            this._eventCB(new TransportSessionEvent(TransportSessionEventCode.SEND_ERROR, "Connection error", ErrorSubcode.CONNECTION_ERROR, this._sid));
                        }
                    }
                    // Called when there is an error on a connection or the connection is aborted
                    handleSendFailure(status, msg) {
                        // failed to send message, if it is a destroy message, just complete the destroy process\
                        if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                            LOG_INFO(`Connection destroy failure (${msg}) while in state ${this._state}`);
                            this.destroyCleanup(`Connection destroy failure: ${msg}`, ErrorSubcode.CONNECTION_ERROR);
                        } else {
                            // Failed to send message, return error to upper layer which may  tear the session down
                            LOG_INFO(`Connection failure (${msg}) while in state ${this._state}`);
                            this._eventCB(new TransportSessionEvent(TransportSessionEventCode.SEND_ERROR, `Connection error: ${msg}`, status, ErrorSubcode.CONNECTION_ERROR, this._sid));
                        }
                    }
                    // Called when there is an error on a connection for a session create request
                    handleCreateConnFailure(status, msg) {
                        if (this._state === TransportSessionState.DOWN) {
                            return;
                        }
                        LOG_INFO(`Connection create failure (${msg}) while in state ${this._state}`);
                        this.destroyCleanup(`Connection create failure: ${msg}`, ErrorSubcode.CONNECTION_ERROR);
                    }
                    // Called when the destroy timer expires
                    destroyTimerExpiry() {
                        this.destroyCleanup("Destroy request timeout", ErrorSubcode.CONNECTION_ERROR);
                    }
                    cancelDestroyTimeout() {
                        if (this._destroyTimer) {
                            clearTimeout(this._destroyTimer);
                            this._destroyTimer = null;
                        }
                    }
                    /**
   * Called after receiving ts destroy response from router
   * @param {String} infoStr The informational string to pass along
   * @param {ErrorSubcode} subcode The subcode associated with the event
   * @param {Boolean} asyncSendEvent If true, always send the event asynchronously.
   */
                    destroyCleanup(infoStr, subcode, asyncSendEvent) {
                        LOG_DEBUG(`Destroy cleanup: ${infoStr}`);
                        // Abort any current requests for this session
                        if (this._createConn) {
                            LOG_DEBUG("Destroy cleanup: Abort createConn");
                            this._createConn.abort();
                        }
                        if (this._httpSendConn) {
                            LOG_DEBUG("Destroy cleanup: Abort sendConn");
                            this._httpSendConn.abort();
                        }
                        if (this._httpReceiveConn) {
                            LOG_DEBUG("Destroy cleanup: Abort receiveConn");
                            this._httpReceiveConn.abort();
                        }
                        // Clear most internal state
                        this._createUrl = null;
                        this._routerUrl = null;
                        this._createConn = null;
                        this._httpSendConn = null;
                        this._httpReceiveConn = null;
                        this._smfDataTokenTSHeader = null;
                        this._rxChannelClient = null;
                        this._routerTag = "";
                        this._queuedData = [];
                        this._queuedDataSize = 0;
                        this._canSendNeeded = false;
                        // Clear timers.
                        this.cancelDestroyTimeout();
                        this.cancelConnectTimeout();
                        // Set final state
                        this._state = TransportSessionState.DOWN;
                        // Send the event to the application letting it know that the session is down
                        const finalize = () => {
                            // Check whether the callback was cleared before the timeout completes.
                            if (this._eventCB) {
                                this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DESTROYED_NOTICE, infoStr || "Session is destroyed", null, subcode || 0, this._sid));
                            }
                            // release reference to smf client object
                            this._client = null;
                            // release reference to session object
                            this._eventCB = null;
                        };
                        if (asyncSendEvent) {
                            setTimeout(finalize, 0); // opportunity to use setImmediate instead
                        } else {
                            finalize();
                        }
                    }
                    getInfoStr() {
                        const str = `HTTPTransportSession; sid=${formatHexString(this._sid)}; routerTag=${this._routerTag}`;
                        return str;
                    }
                }
                module.exports.HTTPTransportSession = HTTPTransportSession;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/web/http/send-xhr.js": 
            /*!**************************************************************!*\
  !*** ./modules/solclient-transport/lib/web/http/send-xhr.js ***!
  \**************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Base64,
                    Convert
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    XHRFactory
                } = __webpack_require__(/*! ./xhr-factory */ "./modules/solclient-transport/lib/web/http/xhr-factory.js");
                const {
                    encode: base64Encode
                } = Base64;
                const {
                    stringToUint8Array
                } = Convert;
                function sendXhrBinaryMSIE10(xhr, data, contentType) {
                    xhr.responseType = "arraybuffer";
                    xhr.overrideMimeType(`${contentType}; charset=x-user-defined`);
                    xhr.setRequestHeader("Content-Type", `${contentType}; charset=x-user-defined`);
                    xhr.send(stringToUint8Array(data));
                }
                function sendXhrBinaryXHR2(xhr, data, contentType) {
                    xhr.overrideMimeType(`${contentType}; charset=x-user-defined`);
                    xhr.setRequestHeader("Content-Type", `${contentType}; charset=x-user-defined`);
                    xhr.send(stringToUint8Array(data).buffer);
                }
                function sendXhrText(xhr, data, contentType, connClose) {
                    xhr.setRequestHeader("Content-Type", `${contentType}; charset=x-user-defined`);
                    xhr.send(data === null || data === undefined ? data : base64Encode(data), connClose);
                }
                const sendXhrBinary = (() => {
                    // Uint8Array is probably shimmed by core-js. We don't use window.Blob, but
                    // it is a Working Draft, not  part of ES6, and not shimmed by core-js.
                    // Therefore it makes a workable canary for IE10 detection.
                    if (typeof window !== "undefined" && window.Uint8Array && window.Blob /* !ie9 */) {
                        const xhr = XHRFactory.create(true);
                        if (xhr.responseType /* ie10 */) {
                            return sendXhrBinaryMSIE10;
                        }
                        return sendXhrBinaryXHR2;
                    }
                    return sendXhrText;
                })();
                module.exports.sendXhrBinary = sendXhrBinary;
                module.exports.sendXhrText = sendXhrText;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/web/http/xhr-factory.js": 
            /*!*****************************************************************!*\
  !*** ./modules/solclient-transport/lib/web/http/xhr-factory.js ***!
  \*****************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ErrorSubcode
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    TransportError
                } = __webpack_require__(/*! ../../transport-error */ "./modules/solclient-transport/lib/transport-error.js");
                /* eslint-env browser */
                const XHRFactory = {
                    /**
   * Creates an XHR object.
   *
   * @param {Boolean} [allowFail=false] If `true`, return null on failure; otherwise throw.
   * @throws {TransportError}
   * @returns {XMLHttpRequest} The new XHR object
   */
                    create(allowFail = false) {
                        const xhr = typeof XMLHttpRequest !== "undefined" ? new XMLHttpRequest() : null;
                        if (!allowFail && !xhr) {
                            throw new TransportError("Failed to create an XMLHTTPRequest", ErrorSubcode.CREATE_XHR_FAILED);
                        }
                        return xhr;
                    }
                };
                module.exports.XHRFactory = XHRFactory;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/web/state-base64.js": 
            /*!*************************************************************!*\
  !*** ./modules/solclient-transport/lib/web/state-base64.js ***!
  \*************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    TransportProtocol
                } = __webpack_require__(/*! ../transport-protocols */ "./modules/solclient-transport/lib/transport-protocols.js");
                const {
                    TSHState
                } = __webpack_require__(/*! ../tsh-state */ "./modules/solclient-transport/lib/tsh-state.js");
                /**
 * @classdesc
 * HTTP Base64 transport
 * @memberof solace
 * @private
 */
                class StateBase64 extends TSHState {
                    /**
   * @constructor
   * @extends TSHState
   * @param {Boolean} useSsl True if SSL should be used
   * @param {Function} exitCb Callback to notify on exit
   * @param {?TSHState} nextState Downgrade target
   */
                    constructor(useSsl, exitCb, nextState) {
                        super(useSsl, TransportProtocol.HTTP_BASE64, exitCb, nextState);
                    }
                }
                module.exports.StateBase64 = StateBase64;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/web/state-binary.js": 
            /*!*************************************************************!*\
  !*** ./modules/solclient-transport/lib/web/state-binary.js ***!
  \*************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    TransportProtocol
                } = __webpack_require__(/*! ../transport-protocols */ "./modules/solclient-transport/lib/transport-protocols.js");
                const {
                    TSHState
                } = __webpack_require__(/*! ../tsh-state */ "./modules/solclient-transport/lib/tsh-state.js");
                const {
                    WebTransportCapabilities
                } = __webpack_require__(/*! ./web-transport-capabilities */ "./modules/solclient-transport/lib/web/web-transport-capabilities.js");
                /**
 * @classdesc
 * HTTP Binary transport
 * @memberof solace
 * @private
 */
                class StateBinary extends TSHState {
                    /**
   * @constructor
   * @extends TSHState
   * @param {Boolean} useSsl True if SSL should be used
   * @param {Function} exitCb Callback to notify on exit
   * @param {?TSHState} nextState Downgrade target
   */
                    constructor(useSsl, exitCb, nextState) {
                        super(useSsl, TransportProtocol.HTTP_BINARY, exitCb, nextState);
                    }
                    validateLegal() {
                        // eslint-disable-line class-methods-use-this
                        return WebTransportCapabilities.xhrBinary();
                    }
                }
                module.exports.StateBinary = StateBinary;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/web/state-streaming-and-binary.js": 
            /*!***************************************************************************!*\
  !*** ./modules/solclient-transport/lib/web/state-streaming-and-binary.js ***!
  \***************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    TransportProtocol
                } = __webpack_require__(/*! ../transport-protocols */ "./modules/solclient-transport/lib/transport-protocols.js");
                const {
                    TSHState
                } = __webpack_require__(/*! ../tsh-state */ "./modules/solclient-transport/lib/tsh-state.js");
                const {
                    WebTransportCapabilities
                } = __webpack_require__(/*! ./web-transport-capabilities */ "./modules/solclient-transport/lib/web/web-transport-capabilities.js");
                /**
 * @classdesc
 * HTTP Binary Streaming transport
 * @memberof solace
 * @private
 */
                class StateStreamingAndBinary extends TSHState {
                    /**
   * @constructor
   * @extends TSHState
   * @param {Boolean} useSsl True if SSL should be used
   * @param {Function} exitCb Callback to notify on exit
   * @param {?TSHState} nextState Downgrade target
   */
                    constructor(useSsl, exitCb, nextState) {
                        super(useSsl, TransportProtocol.HTTP_BINARY_STREAMING, exitCb, nextState);
                    }
                    validateLegal() {
                        // eslint-disable-line class-methods-use-this
                        return WebTransportCapabilities.streaming() && WebTransportCapabilities.xhrBinary();
                    }
                }
                module.exports.StateStreamingAndBinary = StateStreamingAndBinary;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/web/state-websocket-binary.js": 
            /*!***********************************************************************!*\
  !*** ./modules/solclient-transport/lib/web/state-websocket-binary.js ***!
  \***********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    TransportProtocol
                } = __webpack_require__(/*! ../transport-protocols */ "./modules/solclient-transport/lib/transport-protocols.js");
                const {
                    TSHState
                } = __webpack_require__(/*! ../tsh-state */ "./modules/solclient-transport/lib/tsh-state.js");
                const {
                    WebTransportCapabilities
                } = __webpack_require__(/*! ./web-transport-capabilities */ "./modules/solclient-transport/lib/web/web-transport-capabilities.js");
                /**
 * @classdesc
 * WebSocket transport
 * @memberof solace
 * @private
 */
                class StateWebSocketBinary extends TSHState {
                    /**
   * @constructor
   * @extends TSHState
   * @param {Boolean} useSsl True if SSL should be used
   * @param {Function} exitCb Callback to notify on exit
   * @param {?TSHState} nextState Downgrade target
   */
                    constructor(useSsl, exitCb, nextState) {
                        super(useSsl, TransportProtocol.WS_BINARY, exitCb, nextState);
                    }
                    validateLegal() {
                        // eslint-disable-line class-methods-use-this
                        return WebTransportCapabilities.webSocket();
                    }
                }
                module.exports.StateWebSocketBinary = StateWebSocketBinary;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/web/web-transport-capabilities.js": 
            /*!***************************************************************************!*\
  !*** ./modules/solclient-transport/lib/web/web-transport-capabilities.js ***!
  \***************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const HTTPLib = __webpack_require__(/*! ./http */ "./modules/solclient-transport/lib/web/http/api.js");
                const {
                    WebSocketTransportSession
                } = __webpack_require__(/*! ./websocket-transport-session */ "./modules/solclient-transport/lib/web/websocket-transport-session.js");
                const {
                    HTTPConnection
                } = HTTPLib;
                const WebTransportCapabilities = {
                    webSocket() {
                        return WebSocketTransportSession.browserSupportsBinaryWebSockets();
                    },
                    xhrBinary() {
                        return HTTPConnection.browserSupportsXhrBinary();
                    },
                    streaming() {
                        return HTTPConnection.browserSupportsStreamingResponse();
                    }
                };
                module.exports.WebTransportCapabilities = WebTransportCapabilities;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/web/web-transport-events.js": 
            /*!*********************************************************************!*\
  !*** ./modules/solclient-transport/lib/web/web-transport-events.js ***!
  \*********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                /**
 * Enumeration of Web Transport events.
 * @enum {string}
 * @namespace
 * @memberof solace
 * @private
 */
                const WebTransportEvent = {
                    /**
   * The Session Layer has issued a connect request
   */
                    CONNECT: "Connect",
                    /**
   * The Session Layer has issued a destroy request
   */
                    DESTROY: "Destroy",
                    /**
   * A downgrade request has been received from an FSM.
   */
                    DOWNGRADE: "Downgrade",
                    /**
   * The underlying transport has been destroyed. Seen in
   * response to calling destroy() and in some cases when
   * the transport is destroyed by the peer.
   */
                    DESTROYED_NOTICE: "DestroyedNotice",
                    /**
   * The underlying transport timed out in its connection attempt.
   * The managing component should abort this connection attempt
   * and begin a downgrade if available.
   */
                    CONNECT_TIMEOUT: "ConnectTimeout",
                    /**
   * The underlying transport is active and ready for traffic.
   */
                    UP_NOTICE: "UpNotice",
                    /**
   * The transport encountered an error sending data.
   */
                    SEND_ERROR: "SendError"
                };
                module.exports.WebTransportEvent = Enum.new(WebTransportEvent);
                /***/
            },
            /***/ "./modules/solclient-transport/lib/web/web-transport-fsm.js": 
            /*!******************************************************************!*\
  !*** ./modules/solclient-transport/lib/web/web-transport-fsm.js ***!
  \******************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ErrorSubcode
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    FsmEvent,
                    State,
                    StateMachine
                } = __webpack_require__(/*! solclient-fsm */ "./modules/solclient-fsm/api.js");
                const {
                    LogFormatter
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    TransportReturnCode
                } = __webpack_require__(/*! ../transport-return-codes */ "./modules/solclient-transport/lib/transport-return-codes.js");
                const {
                    TransportSessionEvent
                } = __webpack_require__(/*! ../transport-session-event */ "./modules/solclient-transport/lib/transport-session-event.js");
                const {
                    TransportSessionEventCode
                } = __webpack_require__(/*! ../transport-session-event-codes */ "./modules/solclient-transport/lib/transport-session-event-codes.js");
                const {
                    WebTransportEvent
                } = __webpack_require__(/*! ./web-transport-events */ "./modules/solclient-transport/lib/web/web-transport-events.js");
                const {
                    WebTransportState
                } = __webpack_require__(/*! ./web-transport-states */ "./modules/solclient-transport/lib/web/web-transport-states.js");
                const {
                    LOG_TRACE,
                    LOG_INFO
                } = new LogFormatter();
                class WebTransportFSM extends StateMachine {
                    constructor(transportIn, getId) {
                        super({
                            name: "WebTransportFSM"
                        });
                        const transport = transportIn;
                        const fsm = this;
                        const logger = new LogFormatter();
                        logger.formatter = function logFormatter(...args) {
                            return [ `[web-transport-fsm=${getId()}]`, ...args ];
                        };
                        this.log = logger.wrap(this.log, this);
                        this.transport = transport;
                        this.initial(function onInitial() {
                            return this.transitionTo(this.WebTransportDown, context => {
                                LOG_TRACE(`Starting ${context.getStateMachine().getName()}`);
                            });
                        });
                        this.unhandledEventReaction(function onUnhandledEvent(wEvent) {
                            LOG_TRACE(`Ignoring event ${wEvent.getName()} in state ${this.getCurrentState().getName()}`);
                            return this;
                        });
                        this.WebTransportDown = new State({
                            name: WebTransportState.DOWN,
                            parentContext: this
                        }).reaction(WebTransportEvent.CONNECT, function onConnect() {
                            return this.transitionTo(fsm.WebTransportConnecting);
                        }).reaction(WebTransportEvent.DESTROY, function onDestroy(wEvent) {
                            transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
                            return this.transitionTo(fsm.WebTransportDestroying);
                        });
                        this.WebTransportConnecting = new State({
                            name: WebTransportState.CONNECTING,
                            parentContext: this
                        }).entry(() => {
                            try {
                                const rc = transport.connectInternal();
                                if (rc !== TransportReturnCode.OK) {
                                    const connError = transport.getConnError();
                                    const wEvent = new FsmEvent({
                                        name: WebTransportEvent.DESTROY
                                    });
                                    wEvent._destroyMsg = connError ? connError.message : "Error occurred while establishing transport";
                                    wEvent._subcode = connError ? connError.subcode : null;
                                    wEvent._eventReason = connError;
                                    return this.processEvent(wEvent);
                                }
                            } catch (e) {
                                LOG_INFO(`transport.connectInternal threw: ${e.message}`);
                                const wEvent = new FsmEvent({
                                    name: WebTransportEvent.DESTROY
                                });
                                wEvent._destroyMsg = e.message;
                                wEvent._subcode = e.subcode ? e.subcode : ErrorSubcode.CONNECTION_ERROR;
                                wEvent._eventReason = e;
                                return this.processEvent(wEvent);
                            }
                            return undefined;
                        }).reaction(WebTransportEvent.SEND_ERROR, wEvent => {
                            transport.notifyEvent(wEvent._transportEvent); // Give the session a chance to intervene
                            return fsm.attemptDowngrade(wEvent._transportEvent);
                        }).reaction(WebTransportEvent.CONNECT_TIMEOUT, e => fsm.attemptDowngrade(e._transportEvent)).reaction(WebTransportEvent.DESTROYED_NOTICE, wEvent => {
                            transport.notifyEvent(wEvent._transportEvent);
                            return this.transitionTo(fsm.WebTransportDown);
                        }).reaction(WebTransportEvent.UP_NOTICE, function onUpNotice(wEvent) {
                            transport.notifyEvent(wEvent._transportEvent);
                            return this.transitionTo(fsm.WebTransportUp);
                        }).reaction(WebTransportEvent.DESTROY, function onDestroy(wEvent) {
                            transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
                            return this.transitionTo(fsm.WebTransportDestroying);
                        });
                        this.WebTransportDowngrading = new State({
                            name: WebTransportState.DOWNGRADING,
                            parentContext: this
                        }).reaction(WebTransportEvent.DESTROYED_NOTICE, function onDestroyed(wEvent) {
                            LOG_INFO("Web transport: request downgrade");
                            if (!transport.completeDowngrade()) {
                                LOG_INFO("Web transport: connection error, no downgrade");
                                transport.notifyEvent(wEvent._transportEvent);
                                fsm.notifyDowngradeFailed();
                                return this.transitionTo(fsm.WebTransportDown);
                            }
                            return this.transitionTo(fsm.WebTransportConnecting);
                        }).reaction(WebTransportEvent.DESTROY, function onDestroy(wEvent) {
                            transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
                            return this.transitionTo(fsm.WebTransportDestroying);
                        });
                        this.WebTransportUp = new State({
                            name: WebTransportState.UP,
                            parentContext: this
                        }).reaction(WebTransportEvent.DOWNGRADE, wEvent => fsm.attemptDowngrade(new TransportSessionEvent(wEvent._downgradeMsg, wEvent._subcode))).reaction(WebTransportEvent.DESTROYED_NOTICE, function onDestroyed(wEvent) {
                            transport.notifyEvent(wEvent._transportEvent);
                            return this.transitionTo(fsm.WebTransportDown);
                        }).reaction(WebTransportEvent.DESTROY, function onDestroy(wEvent) {
                            transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
                            return this.transitionTo(fsm.WebTransportDestroying);
                        }).reaction(WebTransportEvent.SEND_ERROR, function onUpNotice(wEvent) {
                            transport.notifyEvent(wEvent._transportEvent);
                            transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
                            return this.transitionTo(fsm.WebTransportDestroying);
                        });
                        this.WebTransportDestroying = new State({
                            name: WebTransportState.DESTROYING,
                            parentContext: this
                        }).reaction(WebTransportEvent.DESTROYED_NOTICE, function onDestroyed(wEvent) {
                            transport.notifyEvent(wEvent._transportEvent);
                            return this.transitionTo(fsm.WebTransportDown);
                        });
                    }
                    /**
     * Attempt a downgrade. This is the procedure.
     * 1. Call this. If it returns true, wait for DESTROYED_NOTICE, then
     * 2. Call transport.completeDowngrade().
     * @param {TransportSessionEvent} tsEvent The event triggering the downgrade
     * @returns {Boolean} `true` if downgrade is starting (by destroying the transport)
     */
                    attemptDowngrade(tsEvent) {
                        const {
                            infoStr,
                            errorSubcode
                        } = tsEvent;
                        if (!this.transport.beginDowngrade(infoStr, errorSubcode)) {
                            LOG_TRACE("Downgrade unavailable");
                            this.transport.destroyInternal(infoStr, errorSubcode);
                            this.transport.notifyEvent(tsEvent);
                            return this.transitionTo(this.WebTransportDestroying);
                        }
                        LOG_TRACE("Downgrade available");
                        return this.transitionTo(this.WebTransportDowngrading);
                    }
                    notifyDowngradeFailed() {
                        LOG_TRACE("Notifying of downgrade failure");
                        this.transport.notifyEvent(new TransportSessionEvent(TransportSessionEventCode.DOWNGRADE_FAILED, "Downgrade failed"));
                    }
                }
                module.exports.WebTransportFSM = WebTransportFSM;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/web/web-transport-session-base.js": 
            /*!***************************************************************************!*\
  !*** ./modules/solclient-transport/lib/web/web-transport-session-base.js ***!
  \***************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    LOG_DEBUG,
                    LOG_TRACE
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    TransportBase
                } = __webpack_require__(/*! ../transport-base */ "./modules/solclient-transport/lib/transport-base.js");
                const {
                    TransportClientStats
                } = __webpack_require__(/*! ../transport-client-stats */ "./modules/solclient-transport/lib/transport-client-stats.js");
                const {
                    TransportReturnCode
                } = __webpack_require__(/*! ../transport-return-codes */ "./modules/solclient-transport/lib/transport-return-codes.js");
                const {
                    TransportSessionState
                } = __webpack_require__(/*! ../transport-session-states */ "./modules/solclient-transport/lib/transport-session-states.js");
                const MAX_BUFFERED_AMOUNT_QUERY_INTERVAL_MS = 4e3;
                /**
 * Base class for web related transports
 * @extends TransportBase
 * @private
 */
                class WebTransportSessionBase extends TransportBase {
                    /**
   * @constructor
   * @param {URL} url The URL to connect to
   * @param {function} eventCB The function to call on events
   * @param {SMFClient} client The function to call on data received.
   * @param {Object} props Additional object properties for this transport session
   */
                    constructor(url, eventCB, client, props) {
                        // instanitate instance properties defined in TransportBase
                        super(url, eventCB, client, props);
                        /**
     * @type {Number}
     */
                        this._connectTimeout = props.transportDowngradeTimeoutInMsecs;
                        /**
     * @type {?number}
     */
                        this._connectTimer = null;
                        /**
     * @type {TransportClientStats}
     */
                        this._clientstats = new TransportClientStats();
                        /**
     * Maximum amount of send data than can be queued
     * @type {Number}
     */
                        this._sendBufferMaxSize = props.sendBufferMaxSize;
                        /**
     * Maximum payload chunk size in web transport
     * @type {Number}
     */
                        this._maxPayloadBytes = props.maxWebPayload;
                        /**
     * Queue to hold data to be sent to the Solace Message Router when we get back a
     * data token
     * @type {array}
     */
                        this._queuedData = [];
                        /**
     * Number of bytes of queued data
     * @type {Number}
     */
                        this._queuedDataSize = 0;
                        /**
     * Remember if we have to send an event when there is room in the queue
     * @type {Boolean}
     */
                        this._canSendNeeded = false;
                        /**
     * @type {TransportSessionState}
     */
                        this._state = TransportSessionState.DOWN;
                        /**
     * Any connection error that needs to be propagated up
     * @type {?Error}
     */
                        this._connError = null;
                    }
                    // override
                    getClientStats() {
                        return this._clientstats;
                    }
                    createConnectTimeout() {
                        if (this._connectTimeout > 0) {
                            this._connectTimer = setTimeout(() => {
                                this.connectTimerExpiry();
                            }, this._connectTimeout);
                        }
                    }
                    cancelConnectTimeout() {
                        if (this._connectTimer) {
                            clearTimeout(this._connectTimer);
                            this._connectTimer = null;
                        }
                    }
                    /* override me */
                    connectTimerExpiry() {
                        // eslint-disable-line class-methods-use-this
                        return undefined;
                    }
                    allowEnqueue(datalen) {
                        // Bug 32006: if there's no queued data, we always accept at least one message, even if it
                        // exceeds the sendBufferMaxSize.
                        // If we reject enqueueing something too large because we already have queued data,
                        // that guarantees when the data is flushed we will emit the alertOnDequeue event.
                        return this._queuedDataSize === 0 || datalen + this._queuedDataSize <= this._sendBufferMaxSize;
                    }
                    enqueueFailNoSpace() {
                        this._canSendNeeded = true;
                        return TransportReturnCode.NO_SPACE;
                    }
                    /* override me */
                    flush(callback) {
                        // eslint-disable-line class-methods-use-this
                        callback();
                    }
                    getQueuedDataToSend() {
                        // Track messages dequeued.
                        let data = "";
                        // Start by trying to fill a complete payload.
                        let bytesAllowed = this._maxPayloadBytes;
                        LOG_TRACE(`getQueuedDataToSend: bytesAllowed=${bytesAllowed}, bufferedAmount=${this.getBufferedAmount ? this.getBufferedAmount() : "undefined"}`);
                        if (this.getBufferedAmount) {
                            bytesAllowed = this._maxPayloadBytes - this.getBufferedAmount();
                            if (bytesAllowed <= 0) {
                                LOG_DEBUG(`$$ bytesAllowed=${bytesAllowed}, maxPayloadBytes=${this._maxPayloadBytes}, bufferedAmount=${this.getBufferedAmount()}`);
                                if (true && this._bufferedAmountQueryIntervalInMsecs * this._bufferedAmountQueryIntervalDelayMultiplier <= MAX_BUFFERED_AMOUNT_QUERY_INTERVAL_MS) {
                                    this._bufferedAmountQueryIntervalDelayMultiplier *= 2;
                                }
                                return data;
                            }
                            if (true) {
                                this._bufferedAmountQueryIntervalDelayMultiplier = 1;
                            }
                        }
                        if (this._queuedDataSize > bytesAllowed) {
                            let payloadSize = bytesAllowed;
                            // Slow path: dequeue and append until we fill the payload.
                            while (payloadSize && this._queuedDataSize) {
                                // Is this element larger than the payload?
                                const elem = this._queuedData[0];
                                const elemLength = elem.length;
                                if (elemLength > payloadSize) {
                                    // This element is larger than the payload.
                                    data += elem.substr(0, payloadSize);
                                    this._queuedData[0] = elem.substr(payloadSize);
                                    // The rest of the payload space was consumed.
                                    this._queuedDataSize -= payloadSize;
                                    payloadSize = 0;
                                } else {
                                    data += this._queuedData.shift();
                                    payloadSize -= elemLength;
                                    this._queuedDataSize -= elemLength;
                                    this._clientstats.msgWritten++;
                                }
                            }
                        } else {
                            // Shortcut: use the whole buffer, increase the message sent count by the length of the size
                            // queue, and reset the buffer.
                            data = this._queuedData.join("");
                            this._clientstats.msgWritten += this._queuedData.length;
                            this._queuedData = [];
                            this._queuedDataSize = 0;
                        }
                        LOG_DEBUG(`Sending ${data.length} bytes from queued data`);
                        return data;
                    }
                }
                module.exports.WebTransportSessionBase = WebTransportSessionBase;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/web/web-transport-states.js": 
            /*!*********************************************************************!*\
  !*** ./modules/solclient-transport/lib/web/web-transport-states.js ***!
  \*********************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Enum
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                // WebTransport states, used by WebTransport
                const WebTransportState = {
                    DOWN: "WebTransportDown",
                    CONNECTING: "WebTransportConnecting",
                    DOWNGRADING: "WebTransportDowngrading",
                    DESTROYING: "WebTransportDestroying",
                    UP: "WebTransportUp"
                };
                module.exports.WebTransportState = Enum.new(WebTransportState);
                /***/
            },
            /***/ "./modules/solclient-transport/lib/web/web-transport.js": 
            /*!**************************************************************!*\
  !*** ./modules/solclient-transport/lib/web/web-transport.js ***!
  \**************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    HTTPTransportSession
                } = __webpack_require__(/*! ./http */ "./modules/solclient-transport/lib/web/http/api.js");
                const {
                    LOG_TRACE,
                    LOG_INFO,
                    LOG_ERROR
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    FsmEvent
                } = __webpack_require__(/*! solclient-fsm */ "./modules/solclient-fsm/api.js");
                const {
                    TransportBase
                } = __webpack_require__(/*! ../transport-base */ "./modules/solclient-transport/lib/transport-base.js");
                const {
                    TransportProtocol
                } = __webpack_require__(/*! ../transport-protocols */ "./modules/solclient-transport/lib/transport-protocols.js");
                const {
                    TransportProtocolHandler
                } = __webpack_require__(/*! ../transport-protocol-handler */ "./modules/solclient-transport/lib/transport-protocol-handler.js");
                const {
                    TransportReturnCode
                } = __webpack_require__(/*! ../transport-return-codes */ "./modules/solclient-transport/lib/transport-return-codes.js");
                const {
                    TransportSessionEventCode
                } = __webpack_require__(/*! ../transport-session-event-codes */ "./modules/solclient-transport/lib/transport-session-event-codes.js");
                const {
                    WebSocketTransportSession
                } = __webpack_require__(/*! ./websocket-transport-session */ "./modules/solclient-transport/lib/web/websocket-transport-session.js");
                const {
                    WebTransportEvent
                } = __webpack_require__(/*! ./web-transport-events */ "./modules/solclient-transport/lib/web/web-transport-events.js");
                const {
                    WebTransportFSM
                } = __webpack_require__(/*! ./web-transport-fsm */ "./modules/solclient-transport/lib/web/web-transport-fsm.js");
                /**
 * @classdesc
 * This class manages all the web based transport protocols.
 * <ul>
 *     <li>{@link TransportProtocol.HTTP_BASE64}
 *     <li>{@link TransportProtocol.HTTP_BINARY}
 *     <li>{@link TransportProtocol.HTTP_BINARY_STREAMING}
 *     <li>{@link TransportProtocol.WS_BINARY}
 * </ul>
 * @extends TransportBase
 * @private
 */
                class WebTransport extends TransportBase {
                    /**
   * @constructor
   * @param {URL} url The url to connect to
   * @param {Function} eventCB The callback for transport events
   * @param {BaseSMFClient} client An SMF client instance
   * @param {Object} props Additional transport properties
   * @param {Function} getId A function that returns this transport's unique ID
   */
                    constructor(url, eventCB, client, props, getId) {
                        super(url, eventCB, client, props);
                        LOG_TRACE(`webTransportProtocolList ${props.webTransportProtocolList}`);
                        this._transportHandler = new TransportProtocolHandler(url, props.webTransportProtocolList);
                        this._webTransportFsm = new WebTransportFSM(this, getId);
                        this._webTransportFsm.start();
                    }
                    notifyEvent(event) {
                        this._eventCB(event);
                    }
                    handleDestroyed() {
                        this._transportSession = null;
                    }
                    handleTransportEvent(transportEvent) {
                        LOG_INFO(`Web transport receive transport event: ${transportEvent}`);
                        let wEvent;
                        switch (transportEvent.getTransportEventCode()) {
                          case TransportSessionEventCode.UP_NOTICE:
                            wEvent = new FsmEvent({
                                name: WebTransportEvent.UP_NOTICE
                            });
                            wEvent._transportEvent = transportEvent;
                            this._webTransportFsm.processEvent(wEvent);
                            break;

                          case TransportSessionEventCode.DESTROYED_NOTICE:
                            this.handleDestroyed();
                            wEvent = new FsmEvent({
                                name: WebTransportEvent.DESTROYED_NOTICE
                            });
                            wEvent._transportEvent = transportEvent;
                            this._webTransportFsm.processEvent(wEvent);
                            break;

                          case TransportSessionEventCode.SEND_ERROR:
                            wEvent = new FsmEvent({
                                name: WebTransportEvent.SEND_ERROR
                            });
                            wEvent._transportEvent = transportEvent;
                            this._webTransportFsm.processEvent(wEvent);
                            break;

                          case TransportSessionEventCode.CONNECT_TIMEOUT:
                            wEvent = new FsmEvent({
                                name: WebTransportEvent.CONNECT_TIMEOUT
                            });
                            wEvent._transportEvent = transportEvent;
                            this._webTransportFsm.processEvent(wEvent);
                            break;

                          case TransportSessionEventCode.DOWNGRADE_FAILED:
                            this._lastDowngradeSucceeded = false;
                            break;

                          case TransportSessionEventCode.DOWNGRADE_SUCCEEDED:
                            this._lastDowngradeSucceeded = true;
                            break;

                          default:
                            // All other transport events have no effect on the web transport and are passed through
                            this._eventCB(transportEvent);
                        }
                    }
                    /**
   * @override
   */
                    connect() {
                        const wEvent = new FsmEvent({
                            name: WebTransportEvent.CONNECT
                        });
                        this._webTransportFsm.processEvent(wEvent);
                        return TransportReturnCode.OK;
                    }
                    connectInternal() {
                        this._transportSession = null;
                        const tpProtocol = this._transportHandler.getTransportProtocol();
                        this._props.transportProtocol = tpProtocol;
                        switch (tpProtocol) {
                          case TransportProtocol.HTTP_BASE64:
                          case TransportProtocol.HTTP_BINARY:
                          case TransportProtocol.HTTP_BINARY_STREAMING:
                            this._transportSession = new HTTPTransportSession(this._url, evt => this.handleTransportEvent(evt), this._client, this._props);
                            break;

                          case TransportProtocol.WS_BINARY:
                            this._transportSession = new WebSocketTransportSession(this._url, evt => this.handleTransportEvent(evt), this._client, this._props);
                            break;

                          default:
                            LOG_ERROR(`Web transport unrecognized TransportProtocol: ${tpProtocol}`);
                            throw new OperationError(`No transport session provider for scheme: ${tpProtocol}`, ErrorSubcode.CONNECTION_ERROR, tpProtocol);
                        }
                        LOG_INFO(`Connect Transport ${tpProtocol}`);
                        return this._transportSession.connect();
                    }
                    /**
   * @override
   */
                    destroy(msg, subcode) {
                        const wEvent = new FsmEvent({
                            name: WebTransportEvent.DESTROY
                        });
                        wEvent._destroyMsg = msg;
                        wEvent._subcode = subcode;
                        this._webTransportFsm.processEvent(wEvent);
                        return TransportReturnCode.OK;
                    }
                    /**
   * @param {String} msg The message associated with the downgrade
   * @param {ErrorSubcode} subcode The subcode associated with the downgrade
   * @returns {Boolean} `true` if there are downgrade options available. `false` otherwise.
   * @private
   */
                    beginDowngrade(msg, subcode) {
                        if (this._transportHandler.canCompleteDowngrade()) {
                            LOG_TRACE("Web transport downgrade");
                            // Destroy the underlying transport session
                            // This will asynchronously cause DESTROYED_NOTICE to be emitted.
                            // The receiver can then call completeDowngrade, which will complete the downgrade.
                            this.destroyInternal(msg, subcode);
                            return true;
                        }
                        LOG_TRACE("Web transport downgrade rejected");
                        return false;
                    }
                    completeDowngrade() {
                        if (!this._transportHandler.canCompleteDowngrade()) {
                            return false;
                        }
                        return this._transportHandler.completeDowngrade();
                    }
                    destroyInternal(msg, subcode) {
                        if (this._transportSession) {
                            this._transportSession.destroy(msg, subcode);
                        }
                    }
                    /**
   * @override
   */
                    flush(callback) {
                        return this._transportSession.flush(callback);
                    }
                    getConnError() {
                        if (this._transportSession) {
                            return this._transportSession._connError;
                        }
                        return null;
                    }
                    /**
   * @override
   */
                    getInfoStr() {
                        if (this._transportSession) {
                            return this._transportSession.getInfoStr();
                        }
                        return "Not connected.";
                    }
                    /**
   * @override
   */
                    getTransportProtocol() {
                        return this._transportHandler.getTransportProtocol();
                    }
                    /**
   * @override
   */
                    getClientStats() {
                        if (this._transportSession) {
                            return this._transportSession.getClientStats();
                        }
                        return null;
                    }
                    /**
   * @override
   */
                    requestDowngrade(msg, subcode) {
                        LOG_TRACE("Creating downgrade request event");
                        this._lastDowngradeSucceeded = undefined; // will be reset by handler for TS DOWNGRADE_ events
                        const wEvent = new FsmEvent({
                            name: WebTransportEvent.DOWNGRADE
                        });
                        wEvent._downgradeMsg = msg;
                        wEvent._subcode = subcode;
                        this._webTransportFsm.processEvent(wEvent);
                        return this._lastDowngradeSucceeded;
                    }
                    /**
   * @override
   */
                    send(message, forceAllowEnqueue) {
                        return this._transportSession.send(message, forceAllowEnqueue);
                    }
                }
                module.exports.WebTransport = WebTransport;
                /***/
            },
            /***/ "./modules/solclient-transport/lib/web/websocket-close-codes.js": 
            /*!**********************************************************************!*\
  !*** ./modules/solclient-transport/lib/web/websocket-close-codes.js ***!
  \**********************************************************************/
            /***/ module => {
                module.exports.WebSocketCloseCodes = {
                    0: {
                        name: "Unknown code",
                        description: "No status code was returned by the operation"
                    },
                    1e3: {
                        name: "Normal Closure",
                        description: "The connection closed normally"
                    },
                    1001: {
                        name: "Going Away",
                        description: "The endpoint is going away due to a server failure or client navigation"
                    },
                    1002: {
                        name: "Protocol Error",
                        description: "A WebSocket protocol error occurred"
                    },
                    1003: {
                        name: "Unsupported Data",
                        description: "The endpoint cannot handle the specified data type"
                    },
                    1004: {
                        name: "Reserved",
                        description: ""
                    },
                    1005: {
                        name: "No Status Recvd",
                        description: "Expected a status code but none was provided"
                    },
                    1006: {
                        name: "Abnormal Closure",
                        description: "No close frame was received before remote hangup"
                    },
                    1007: {
                        name: "Invalid Frame Payload Data",
                        description: "A message contained data inconsistent with its encoding"
                    },
                    1008: {
                        name: "Policy Violation",
                        description: "A message violated endpoint policy"
                    },
                    1009: {
                        name: "Message Too Big",
                        description: "A data frame was too large"
                    },
                    1010: {
                        name: "Missing Extension",
                        description: "The endpoint did not negotiate an expected extension"
                    },
                    1011: {
                        name: "Internal Error",
                        description: "The server encountered an unexpected condition that prevented it from fulfilling the request"
                    },
                    1012: {
                        name: "Service Restart",
                        description: "The server is restarting"
                    },
                    1013: {
                        name: "Try Again Later",
                        description: "The server is terminating the connection due to a temporary condition"
                    },
                    1014: {
                        name: "Bad Gateway",
                        description: "A gateway or proxy received an invalid response from the upstream server"
                    },
                    1015: {
                        name: "TLS Handshake",
                        description: "The connection was closed due to a failure to perform a TLS handshake"
                    }
                };
                /***/
            },
            /***/ "./modules/solclient-transport/lib/web/websocket-transport-session.js": 
            /*!****************************************************************************!*\
  !*** ./modules/solclient-transport/lib/web/websocket-transport-session.js ***!
  \****************************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    LOG_TRACE,
                    LOG_DEBUG,
                    LOG_INFO,
                    LOG_WARN,
                    LOG_ERROR
                } = __webpack_require__(/*! solclient-log */ "./modules/solclient-log/api.js");
                const {
                    ArrayUtils
                } = __webpack_require__(/*! solclient-util */ "./modules/solclient-util/api.js");
                const {
                    Convert,
                    Hex
                } = __webpack_require__(/*! solclient-convert */ "./modules/solclient-convert/api.js");
                const {
                    ErrorSubcode
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const {
                    mixin
                } = __webpack_require__(/*! solclient-eskit */ "./modules/solclient-eskit/api.js");
                const {
                    TransportError
                } = __webpack_require__(/*! ../transport-error */ "./modules/solclient-transport/lib/transport-error.js");
                const {
                    TransportReturnCode
                } = __webpack_require__(/*! ../transport-return-codes */ "./modules/solclient-transport/lib/transport-return-codes.js");
                const {
                    TransportSessionEvent
                } = __webpack_require__(/*! ../transport-session-event */ "./modules/solclient-transport/lib/transport-session-event.js");
                const {
                    TransportSessionEventCode
                } = __webpack_require__(/*! ../transport-session-event-codes */ "./modules/solclient-transport/lib/transport-session-event-codes.js");
                const {
                    TransportSessionState
                } = __webpack_require__(/*! ../transport-session-states */ "./modules/solclient-transport/lib/transport-session-states.js");
                const {
                    WebSocketCloseCodes
                } = __webpack_require__(/*! ./websocket-close-codes */ "./modules/solclient-transport/lib/web/websocket-close-codes.js");
                const {
                    WebTransportSessionBase
                } = __webpack_require__(/*! ./web-transport-session-base */ "./modules/solclient-transport/lib/web/web-transport-session-base.js");
                const http = __webpack_require__(/*! http */ "?77a7");
                const https = __webpack_require__(/*! https */ "?37c5");
                const {
                    stringToArrayBuffer
                } = Convert;
                const {
                    formatHexString
                } = Hex;
                const {
                    includes
                } = ArrayUtils;
                /* eslint-env browser */
                // closure mangles window.WebSocket
                const globalContext = typeof window === "undefined" ? __webpack_require__.g : window;
                let MyWebSocket = globalContext.WebSocket;
                if (false) {}
                /* eslint-env shared-browser-node */
                function adaptURL(url) {
                    const v = url.match(/(ws|http)(s?:\/\/.+)/);
                    return `ws${v[2]}`;
                }
                /**
 * @classdesc
 * @private
 * @memberof solace
 */
                class WebSocketTransportSession extends WebTransportSessionBase {
                    /**
   * @constructor
   * @param {String} url The url to connect to
   * @param {function} eventCB The callback for transport events
   * @param {SMFClient} client The SMF client for data events
   * @param {Object} props Properties for the transport session
   */
                    constructor(url, eventCB, client, props) {
                        super(url, eventCB, client, props);
                        /**
     * @type {String}
     */
                        this._url = adaptURL(url);
                        /**
     * @type {?WebSocket}
     */
                        this._socket = null;
                        /**
     * @type {?string}
     */
                        this._sessionId = new Date().getTime();
                        if (true) {
                            /**
       * @type {Number}
       */
                            this._bufferedAmountQueryIntervalInMsecs = props.bufferedAmountQueryIntervalInMsecs;
                            /**
       * @type {?number}
       */
                            this._bufferedAmountQueryTimer = null;
                            /**
       * @type {Number}
       */
                            this._bufferedAmountQueryIntervalDelayMultiplier = 1;
                        }
                    }
                    /**
   * @private
   */
                    onOpen() {
                        this.cancelConnectTimeout();
                        this._state = TransportSessionState.SESSION_UP;
                        // Send the event to the application letting it know that the session is up
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.UP_NOTICE, "Connected", 0, null, this._sessionId));
                    }
                    /**
   * @param {Socket} originalSocket bound at the time of callback registration,
   * safety against stray calls after socket is destroyed.
   * @param {Event} event The websocket event causing the close
   * @private
   */
                    onClose(originalSocket, event) {
                        if (originalSocket !== this._socket) {
                            LOG_DEBUG("Websocket Transport Session stray onClose for previous socket, ignoring.");
                            return;
                        }
                        if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                            LOG_TRACE("WebSocket transport is being destroyed, ignore error");
                            return;
                        }
                        const msgBuf = [];
                        const code = WebSocketCloseCodes[event.code] || WebSocketCloseCodes[0];
                        msgBuf.push(`${event.code} ${code.name} (${code.description})`);
                        if (event.wasClean !== undefined) {
                            msgBuf.push(`clean closure: ${event.wasClean}`);
                        }
                        if (event.reason) {
                            msgBuf.push(`reason: ${event.reason}`);
                        }
                        const msg = msgBuf.join(", ");
                        LOG_DEBUG(`WebSocket transport connection is closed ${msg}`);
                        LOG_TRACE(`Event { type: ${event.type} wasClean: ${event.wasClean} code: ${event.code} reason: ${event.reason} }`);
                        this._state = TransportSessionState.CONNECTION_FAILED;
                        this.destroy(`Connection closed: ${msg}`, ErrorSubcode.COMMUNICATION_ERROR);
                    }
                    onDrain() {
                        LOG_TRACE("Drained socket");
                        this.maybeEmitCanSend();
                        this.maybeEmitFlush();
                    }
                    onBufferedAmountPoll() {
                        if (this.getBufferedAmount() === 0) {
                            this.onDrain();
                        } else if (this.scheduleQuery) {
                            this.scheduleQuery();
                        }
                    }
                    /**
   * @param {Socket} originalSocket bound at callback registration.
   * @param {TransportSessionEvent} event The event causing the error
   * @private
   */
                    onError(originalSocket, event) {
                        LOG_INFO(`Websocket Transport Session onError for socket ${originalSocket} while socket is ${this._socket}`);
                        if (originalSocket !== this._socket) {
                            LOG_INFO("Websocket Transport Session stray onError for previous socket, ignoring.");
                            return;
                        }
                        if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                            LOG_INFO("WebSocket transport is being destroyed, ignore error");
                            return;
                        }
                        const msg = event.message ? `: ${event.message}` : "";
                        LOG_INFO(`WebSocket transport connection error ${msg} while in state ${this._state}`);
                        // There won't be an onClose call to clean up unless we are connected already.
                        if (this._state === TransportSessionState.WAITING_FOR_CONNECT) {
                            this.cancelConnectTimeout();
                            this._state = TransportSessionState.CONNECTION_FAILED;
                            this.destroy(`Connection failed: ${msg}`, ErrorSubcode.CONNECTION_ERROR);
                        } else {
                            // Sending error event only, onClose will clean up in due time.
                            this._eventCB(new TransportSessionEvent(TransportSessionEventCode.SEND_ERROR, `Connection error${msg}`, null, ErrorSubcode.CONNECTION_ERROR, null));
                        }
                    }
                    /**
   * @param {TransportSessionEvent} event The data event
   * @private
   */
                    onMessage(event) {
                        if (this._client) {
                            this._client.rxDataArrayBuffer(event.data);
                        }
                    }
                    /**
   * @override
   * @private
   */
                    connectTimerExpiry() {
                        LOG_INFO("WebSocket transport connect timeout");
                        this.state = TransportSessionState.CONNECTION_FAILED;
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.CONNECT_TIMEOUT, "Connection timed out", null, ErrorSubcode.TIMEOUT));
                    }
                    /**
   * @override
   * @private
   */
                    connect() {
                        if (this._state !== TransportSessionState.DOWN) {
                            LOG_ERROR(`Invalid state for operation: ${TransportSessionState.nameOf(this._state)}`);
                            return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                        }
                        if (!this._url) {
                            LOG_WARN("Cannot connect to null URL");
                            return TransportReturnCode.CONNECTION_ERROR;
                        }
                        if (this._socket) {
                            this.onError("Socket already connected");
                        }
                        LOG_INFO("Establishing WebSocket transport session");
                        try {
                            this.createConnectTimeout();
                            this._state = TransportSessionState.WAITING_FOR_CREATE;
                            if (false) {}
                            LOG_INFO("Constructing socket");
                            if (true) {
                                /**
         * @type {WebSocket}
         */
                                this._socket = new MyWebSocket(this._url, "smf.solacesystems.com");
                            } else {}
                            // Closure is generally faster than bind
                            LOG_TRACE("Assigning properties to socket");
                            // Closure using Browser profile to avoid mangling this
                            this._socket.binaryType = "arraybuffer";
                            this._socket.onopen = this.onOpen.bind(this);
                            this._socket.onmessage = this.onMessage.bind(this);
                            this._socket.onclose = this.onClose.bind(this, this._socket);
                            this._socket.onerror = this.onError.bind(this, this._socket);
                            LOG_TRACE("Prepared socket");
                        } catch (error) {
                            LOG_INFO(`Error connecting: ${error.message}`);
                            LOG_TRACE("Error details", error.stack || error);
                            this._state = TransportSessionState.CONNECTION_FAILED;
                            this.cancelConnectTimeout();
                            if (error instanceof TransportError) {
                                this._connError = error;
                            } else {
                                throw new TransportError(`Could not create WebSocket: ${error.message}`, error.subcode || ErrorSubcode.CONNECTION_ERROR);
                            }
                            return TransportReturnCode.CONNECTION_ERROR;
                        }
                        LOG_INFO("WebSocket is connecting");
                        return TransportReturnCode.OK;
                    }
                    /**
   * @override
   * @param {String} data The binary string data to send.
   * @param {Boolean} [force=false] If true, send even if buffer is full.
   */
                    send(data, force = false) {
                        if (this._state !== TransportSessionState.SESSION_UP) {
                            return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                        }
                        const dataLen = data.length;
                        const bufferAllow = this._sendBufferMaxSize - this.getBufferedAmount() >= 0;
                        // LOG_DEBUG('Websocket send:', dataLen, force, bufferAllow);
                        if (!(force || bufferAllow)) {
                            this._canSendNeeded = true;
                            if (this.scheduleQuery) this.scheduleQuery();
                            return TransportReturnCode.NO_SPACE;
                        }
                        // LOG_TRACE(`websocket.send: len=${data.length}`);
                        // Slice messages per maxPayloadBytes
                        const maxPayloadBytes = this._maxPayloadBytes;
                        const ab = stringToArrayBuffer(data);
                        if (dataLen > maxPayloadBytes) {
                            for (let i = 0; i < dataLen; i += maxPayloadBytes) {
                                this._socket.send(ab.slice(i, i + maxPayloadBytes));
                            }
                        } else {
                            this._socket.send(ab);
                        }
                        // LOG_TRACE(`websocket.send: after send getBufferedAmount=${this.getBufferedAmount()}`);
                        this._clientstats.bytesWritten += dataLen;
                        ++this._clientstats.msgWritten;
                        return TransportReturnCode.OK;
                    }
                    /**
   * @returns {Number} The number of already buffered bytes in this transport.
   * @private
   */
                    getBufferedAmount() {
                        // Access as string property because this is a defineProperty on node websocket,
                        // meaning it is not mangled by Closure Compiler
                        return this._socket ? this._socket["bufferedAmount"] : 0; // eslint-disable-line dot-notation
                    }
                    /**
   * @override
   */
                    flush(callback) {
                        this._flushCallback = callback;
                        this.maybeEmitFlush();
                    }
                    maybeEmitCanSend() {
                        if (this._canSendNeeded && this.getBufferedAmount() < this._sendBufferMaxSize) {
                            LOG_TRACE("Transport emitting CAN_ACCEPT_DATA");
                            this._canSendNeeded = false;
                            this._eventCB(new TransportSessionEvent(TransportSessionEventCode.CAN_ACCEPT_DATA, "", null, 0, this._sessionId));
                        }
                    }
                    maybeEmitFlush() {
                        if (!this._flushCallback) return;
                        if (true && this.getBufferedAmount() > 0) {
                            // Ensure we have a query scheduled, but don't interrupt a query in progress
                            if (!this._bufferedAmountQueryTimer) {
                                this.scheduleQuery();
                            }
                            return;
                        }
                        // Node is automatically flushed by socket.end(), which is called in non-error cases
                        LOG_DEBUG("Transport emitting FLUSH");
                        const cb = this._flushCallback;
                        this._flushCallback = null;
                        cb();
                    }
                    /**
   * @override
   */
                    destroy(message, subcode) {
                        // We can destroy (and get a notice) even if the socket is freshly created.
                        // But this will only work once.
                        if (this._state !== TransportSessionState.DOWN) {
                            LOG_INFO(`Destroy WebSocket transport: ${message}`);
                            // Set state for connection teardown.
                            this._state = TransportSessionState.WAITING_FOR_DESTROY;
                            if (this._socket) {
                                this._socket.close();
                                this._socket.onopen = null;
                                this._socket.onmessage = null;
                                this._socket.onclose = null;
                                this._socket.onerror = function onerrorStub() {}; // Prevent unhandled errors
                                this._socket = null;
                            }
                            if (this._connectTimer) {
                                clearTimeout(this._connectTimer);
                                this._connectTimer = undefined;
                            }
                            if (true) {
                                this.cancelQuery();
                                this._bufferedAmountQueryIntervalDelayMultiplier = 1;
                            }
                            this._canSendNeeded = false;
                            this._state = TransportSessionState.DOWN;
                            this._client = null; // Don't accept data.
                        }
                        // always send a DESTROYED_NOTICE in response to a destroy() even
                        // if we think the transport is already destroyed
                        if (this._eventCB) {
                            // Fire this *almost* instantly, but follow the HTTP
                            // transport pattern by guaranteeing an async callback.
                            this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DESTROYED_NOTICE, message || "Session is destroyed", null, subcode || 0, this._sessionId));
                            // Release references to other components
                            this._eventCB = null;
                        }
                        return TransportReturnCode.OK;
                    }
                    /**
   * @override
   * @returns {String} A description of this object.
   */
                    getInfoStr() {
                        const str = `WebSocketTransportSession; sid=${formatHexString(this._sessionId)}`;
                        return str;
                    }
                    static browserSupportsBinaryWebSockets() {
                        LOG_DEBUG("websocket browserSupportBinaryCheck - " + "if WebSocket, ArrayBuffer and Uint8Array are supported");
                        const exists = [ "function", "object" ];
                        if (!includes(exists, typeof MyWebSocket) || !includes(exists, typeof ArrayBuffer) || !includes(exists, typeof Uint8Array)) {
                            LOG_INFO("websocket browserSupportBinaryCheck: false - some required classes not supported");
                            return false;
                        }
                        LOG_DEBUG("websocket browserSupportBinaryCheck - if WebSocket supports binaryType");
                        if ("binaryType" in MyWebSocket.prototype) {
                            LOG_INFO("websocket browserSupportBinaryCheck: true - WebSocket supports binaryType");
                            return true;
                        }
                        LOG_INFO("websocket browserSupportBinaryCheck: false - WebSocket does not support binaryType");
                        return false;
                    }
                }
                if (true) {
                    mixin(WebSocketTransportSession, class WebSocketTransportSessionBrowser {
                        /**
     * @private
     */
                        scheduleQuery() {
                            const bufferedAmount = this.getBufferedAmount();
                            if (bufferedAmount > 0 && this._bufferedAmountQueryIntervalInMsecs > 0) {
                                this.cancelQuery();
                                if (this._bufferedAmountQueryIntervalDelayMultiplier > 1) {
                                    LOG_DEBUG(`$$ schedule bufferedAmount query timer in ${this._bufferedAmountQueryIntervalInMsecs * this._bufferedAmountQueryIntervalDelayMultiplier} ms`);
                                }
                                const timeout = this._bufferedAmountQueryIntervalInMsecs * this._bufferedAmountQueryIntervalDelayMultiplier;
                                this._bufferedAmountQueryTimer = setTimeout(() => {
                                    this.cancelQuery();
                                    try {
                                        this.onBufferedAmountPoll();
                                    } catch (e) {
                                        LOG_ERROR(`Error occurred in onBufferedAmountPoll: ${e.message}`);
                                        LOG_TRACE("Error details:", e.stack || e);
                                    }
                                }, timeout);
                            }
                        }
                        cancelQuery() {
                            if (this._bufferedAmountQueryTimer) {
                                clearTimeout(this._bufferedAmountQueryTimer);
                                this._bufferedAmountQueryTimer = null;
                            }
                        }
                    });
                } else {}
                module.exports.WebSocketTransportSession = WebSocketTransportSession;
                /***/
            },
            /***/ "./modules/solclient-util/api.js": 
            /*!***************************************!*\
  !*** ./modules/solclient-util/api.js ***!
  \***************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    APIProperties
                } = __webpack_require__(/*! ./lib/api-properties */ "./modules/solclient-util/lib/api-properties.js");
                const {
                    APIPropertiesValidators
                } = __webpack_require__(/*! ./lib/api-properties-validators */ "./modules/solclient-util/lib/api-properties-validators.js");
                const {
                    ArrayUtils
                } = __webpack_require__(/*! ./lib/array-utils */ "./modules/solclient-util/lib/array-utils.js");
                const {
                    parseURL
                } = __webpack_require__(/*! ./lib/url */ "./modules/solclient-util/lib/url.js");
                const {
                    Process
                } = __webpack_require__(/*! ./lib/process */ "./modules/solclient-util/lib/process.js");
                const {
                    StringBuffer
                } = __webpack_require__(/*! ./lib/string-buffer */ "./modules/solclient-util/lib/string-buffer.js");
                const {
                    StringUtils
                } = __webpack_require__(/*! ./lib/string-utils */ "./modules/solclient-util/lib/string-utils.js");
                const {
                    TimingBucket
                } = __webpack_require__(/*! ./lib/timing-bucket */ "./modules/solclient-util/lib/timing-bucket.js");
                const {
                    UUID
                } = __webpack_require__(/*! ./lib/uuid */ "./modules/solclient-util/lib/uuid.js");
                const {
                    Version
                } = __webpack_require__(/*! ./lib/version */ "./modules/solclient-util/lib/version.js");
                module.exports = {
                    parseURL: parseURL,
                    APIProperties: APIProperties,
                    APIPropertiesValidators: APIPropertiesValidators,
                    ArrayUtils: ArrayUtils,
                    Process: Process,
                    StringBuffer: StringBuffer,
                    StringUtils: StringUtils,
                    TimingBucket: TimingBucket,
                    UUID: UUID,
                    Version: Version
                };
                /***/
            },
            /***/ "./modules/solclient-util/lib/api-properties-validators.js": 
            /*!*****************************************************************!*\
  !*** ./modules/solclient-util/lib/api-properties-validators.js ***!
  \*****************************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Check
                } = __webpack_require__(/*! solclient-validate */ "./modules/solclient-validate/api.js");
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const APIPropertiesValidators = {
                    validateInstance(typeDesc, instance, name, ...args) {
                        args.forEach(check => {
                            const validator = check.shift();
                            const validatorArgs = [ typeDesc, instance, name, ...check ];
                            validator(...validatorArgs);
                        });
                    },
                    valInstance(typeDesc, instance, name, typeInstance, typeInstanceDesc) {
                        if (!Check.instanceOf(instance[name], typeInstance)) {
                            throw new OperationError(`${typeDesc} validation: Property '${name}' must be instance of ${typeInstanceDesc}`);
                        }
                    },
                    valNotEmpty(typeDesc, instance, name) {
                        if (Check.none(instance[name]) || instance[name] === "") {
                            throw new OperationError(`${typeDesc} validation: Property '${name}' cannot be empty.`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                    },
                    valLength(typeDesc, instance, name, max) {
                        if (Check.string(instance[name]) && instance[name].length > max) {
                            throw new OperationError(`${typeDesc} validation: Property '${name}' exceeded max length ${max}`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                    },
                    valRange(typeDesc, instance, name, min, max) {
                        if (Check.number(instance[name]) && (instance[name] < min || instance[name] > max)) {
                            throw new OperationError(`${typeDesc} validation: Property '${name}' out of range [${min}; ${max}].`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                    },
                    valString(typeDesc, instance, name) {
                        if (!Check.string(instance[name])) {
                            throw new OperationError(`${typeDesc} validation: Property '${name}' must be type string; was ${typeof instance[name]}`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                    },
                    valNumber(typeDesc, instance, name) {
                        if (!Check.number(instance[name])) {
                            throw new OperationError(`${typeDesc} validation: Property '${name}' must be type number; was ${typeof instance[name]}`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                    },
                    valBoolean(typeDesc, instance, name) {
                        const val = instance[name];
                        if (!Check.boolean(val)) {
                            throw new OperationError(`${typeDesc} validation: Property '${name}' must be type boolean; was ${typeof val}`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                    },
                    valIsMember(typeDesc, instance, key, enumInstance, enumName, allowNull = false) {
                        const val = instance[key];
                        if (allowNull && (val === null || val === undefined)) return;
                        if (enumInstance.values.indexOf(val) >= 0) return;
                        throw new OperationError(`${typeDesc} validation: Property '${key}'=${val} must be a member of ${enumName}`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                    },
                    valStringOrArray(typeDesc, instance, name) {
                        const val = instance[name];
                        if (typeof val !== "string" && !Array.isArray(val)) {
                            throw new OperationError(`${typeDesc} validation: Property '${name}' must be a string or array`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                    },
                    valArrayIsMember(typeDesc, instance, name, enumInstance, enumName, allowUndefined, allowEmpty, allowDuplicate) {
                        const val = instance[name];
                        if (val === undefined || val === null) {
                            if (allowUndefined) {
                                return;
                            }
                            throw new OperationError(`${typeDesc} validation: Property '${name}' must be type Array`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                        if (!Array.isArray(instance[name])) {
                            throw new OperationError(`${typeDesc} validation: Property '${name}' must be type Array`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                        if (!allowEmpty && instance[name].length === 0) {
                            throw new OperationError(`${typeDesc} validation: Property '${name}' cannot be empty`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                        instance[name].forEach((ele, index) => {
                            if (!enumInstance.values.includes(ele)) {
                                throw new OperationError(`${typeDesc} validation: Property '${name}' must be an array of ${enumName}`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                            }
                            if (!allowDuplicate) {
                                if (instance[name].indexOf(ele, index + 1) >= 0) {
                                    throw new OperationError(`${typeDesc} validation: Property '${name}' cannot have duplicate element value`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                                }
                            }
                        });
                    },
                    valArrayOfString(typeDesc, instance, name) {
                        const val = instance[name];
                        if (Check.something(val)) {
                            if (!Array.isArray(val)) {
                                throw new OperationError(`${typeDesc} validation: Property '${name}' must be type Array`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                            }
                            val.forEach(ele => {
                                if (typeof ele !== "string") {
                                    throw new OperationError(`${typeDesc} validation: Property '${name}' must be an array of string`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                                }
                            });
                        }
                    },
                    valTopicString(typedesc, instance, name) {
                        // Pardon this late import. I need to break a circular dependency.
                        // eslint-disable-next-line global-require
                        const {
                            DestinationUtil,
                            DestinationType
                        } = __webpack_require__(/*! solclient-destination */ "./modules/solclient-destination/api.js");
                        module.exports.APIPropertiesValidators.valString(typedesc, instance, name);
                        const val = instance[name];
                        const result = DestinationUtil.validateAndEncode(DestinationType.TOPIC, val);
                        if (result.error) {
                            throw new OperationError(`${typedesc} validation: Property '${name}' must be ` + `a valid topic string: ${result.error}`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                    },
                    valTopicStringOrEmpty(typedesc, instance, name) {
                        const val = instance[name];
                        if (val && val.length) {
                            module.exports.APIPropertiesValidators.valTopicString(typedesc, instance, name);
                        }
                    }
                };
                module.exports.APIPropertiesValidators = APIPropertiesValidators;
                /***/
            },
            /***/ "./modules/solclient-util/lib/api-properties.js": 
            /*!******************************************************!*\
  !*** ./modules/solclient-util/lib/api-properties.js ***!
  \******************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /* provided dependency */ var util_inspect = __webpack_require__(/*! browser-util-inspect */ "./node_modules/browser-util-inspect/index.js");
                const cloneObj = __webpack_require__(/*! clone */ "./node_modules/clone/clone.js");
                const CLONE_CIRCULAR = false; // If true, handles circular references safely.
                const CLONE_DEPTH = 1; // Don't deep-clone nested values.
                /**
 * @memberof solace
 * @private
 */
                class APIProperties {
                    /**
   * Base class for all API properties structures. Provides the clone() method to
   * make all properties cloneable.
   * Creates an instance of APIProperties. Assigns properties from one or more
   * objects in increasing priority order.
   *
   * @example
   * super({ foo: 'defaultFoo', bar: 42 }, { foo: 'quux' }); // .foo == quux, .bar = 42
   *
   * @param {...any} options The properties sources to assign.
   *
   * @since 10.0.0
   * @constructor
   */
                    constructor(...options) {
                        Object.assign(this, ...options);
                    }
                    /**
   * Can be overridden.  For instance sessionProperties
   * overrides this to suppress printing the password.
   * @returns {String} The string representation of this object
   * @private
   */
                    toString() {
                        return util_inspect(this);
                    }
                    clone() {
                        return cloneObj(this, CLONE_CIRCULAR, CLONE_DEPTH);
                    }
                }
                module.exports.APIProperties = APIProperties;
                /***/
            },
            /***/ "./modules/solclient-util/lib/array-utils.js": 
            /*!***************************************************!*\
  !*** ./modules/solclient-util/lib/array-utils.js ***!
  \***************************************************/
            /***/ module => {
                function flatten(array) {
                    return array.reduce((acc, el) => acc.concat(Array.isArray(el) ? flatten(el) : el), []);
                }
                function includes(array, el) {
                    return array.some(v => v === el);
                }
                module.exports.ArrayUtils = {
                    flatten: flatten,
                    includes: includes
                };
                /***/
            },
            /***/ "./modules/solclient-util/lib/browser-url-polyfill.js": 
            /*!************************************************************!*\
  !*** ./modules/solclient-util/lib/browser-url-polyfill.js ***!
  \************************************************************/
            /***/ module => {
                /* Any copyright is dedicated to the Public Domain.
 * http://creativecommons.org/publicdomain/zero/1.0/ */
                /* eslint-disable no-restricted-syntax */
                /* eslint-disable no-labels */
                /* eslint-env browser */
                module.exports = function(scope) {
                    // feature detect for URL constructor
                    let hasWorkingUrl = false;
                    if (!scope.forceJURL) {
                        try {
                            const u = new URL("b", "http://a");
                            u.pathname = "c%20d";
                            hasWorkingUrl = u.href === "http://a/c%20d";
                        } catch (e) {
                            // no problem
                        }
                    }
                    if (hasWorkingUrl) {
                        return;
                    }
                    // Otherwise the keys get minified.
                    /* eslint-disable dot-notation */
                    const relative = Object.create(null);
                    relative["ftp"] = 21;
                    relative["file"] = 0;
                    relative["gopher"] = 70;
                    relative["http"] = 80;
                    relative["https"] = 443;
                    relative["ws"] = 80;
                    relative["wss"] = 443;
                    /* eslint-enable dot-notation */
                    const relativePathDotMapping = Object.create(null);
                    relativePathDotMapping["%2e"] = ".";
                    relativePathDotMapping[".%2e"] = "..";
                    relativePathDotMapping["%2e."] = "..";
                    relativePathDotMapping["%2e%2e"] = "..";
                    function clear() {
                        this._scheme = "";
                        this._schemeData = "";
                        this._username = "";
                        this._password = null;
                        this._host = "";
                        this._port = "";
                        this._path = [];
                        this._query = "";
                        this._fragment = "";
                        this._isInvalid = false;
                        this._isRelative = false;
                    }
                    function isRelativeScheme(scheme) {
                        return relative[scheme] !== undefined;
                    }
                    function invalid() {
                        clear.call(this);
                        this._isInvalid = true;
                    }
                    function IDNAToASCII(h) {
                        if (h === "") {
                            invalid.call(this);
                        }
                        // TODO: more robust
                        return h.toLowerCase();
                    }
                    function percentEscape(c) {
                        const unicode = c.charCodeAt(0);
                        if (unicode > 32 && unicode < 127 && 
                        // " # < > ? `
                        [ 34, 35, 60, 62, 63, 96 ].indexOf(unicode) === -1) {
                            return c;
                        }
                        return encodeURIComponent(c);
                    }
                    function percentEscapeQuery(c) {
                        // TODO: This actually needs to encode c using encoding and then
                        // convert the bytes one-by-one.
                        const unicode = c.charCodeAt(0);
                        if (unicode > 32 && unicode < 127 && 
                        // " # < > ` (do not escape '?')
                        [ 34, 35, 60, 62, 96 ].indexOf(unicode) === -1) {
                            return c;
                        }
                        return encodeURIComponent(c);
                    }
                    let EOF;
                    const ALPHA = /[a-zA-Z]/;
                    const ALPHANUMERIC = /[a-zA-Z0-9+\-.]/;
                    function parse(input, stateOverride, base) {
                        const errors = [];
                        function err(message) {
                            errors.push(message);
                        }
                        let state = stateOverride || "scheme start";
                        let cursor = 0;
                        let buffer = "";
                        let seenAt = false;
                        let seenBracket = false;
                        loop: while ((input[cursor - 1] !== EOF || cursor === 0) && !this._isInvalid) {
                            const c = input[cursor];
                            switch (state) {
                              case "scheme start":
                                if (c && ALPHA.test(c)) {
                                    buffer += c.toLowerCase(); // ASCII-safe
                                    state = "scheme";
                                } else if (!stateOverride) {
                                    buffer = "";
                                    state = "no scheme";
                                    continue;
                                } else {
                                    err("Invalid scheme.");
                                    break loop;
                                }
                                break;

                              case "scheme":
                                if (c && ALPHANUMERIC.test(c)) {
                                    buffer += c.toLowerCase(); // ASCII-safe
                                } else if (c === ":") {
                                    this._scheme = buffer;
                                    buffer = "";
                                    if (stateOverride) {
                                        break loop;
                                    }
                                    if (isRelativeScheme(this._scheme)) {
                                        this._isRelative = true;
                                    }
                                    if (this._scheme === "file") {
                                        state = "relative";
                                    } else if (this._isRelative && base && base._scheme === this._scheme) {
                                        state = "relative or authority";
                                    } else if (this._isRelative) {
                                        state = "authority first slash";
                                    } else {
                                        state = "scheme data";
                                    }
                                } else if (!stateOverride) {
                                    buffer = "";
                                    cursor = 0;
                                    state = "no scheme";
                                    continue;
                                } else if (EOF === c) {
                                    break loop;
                                } else {
                                    err(`Code point not allowed in scheme: ${c}`);
                                    break loop;
                                }
                                break;

                              case "scheme data":
                                if (c === "?") {
                                    this._query = "?";
                                    state = "query";
                                } else if (c === "#") {
                                    this._fragment = "#";
                                    state = "fragment";
                                } else if (EOF !== c && c !== "\t" && c !== "\n" && c !== "\r") {
                                    // TODO: error handling
                                    this._schemeData += percentEscape(c);
                                }
                                break;

                              case "no scheme":
                                if (!base || !isRelativeScheme(base._scheme)) {
                                    err("Missing scheme.");
                                    invalid.call(this);
                                } else {
                                    state = "relative";
                                    continue;
                                }
                                break;

                              case "relative or authority":
                                if (c === "/" && input[cursor + 1] === "/") {
                                    state = "authority ignore slashes";
                                } else {
                                    err(`Expected /, got: ${c}`);
                                    state = "relative";
                                    continue;
                                }
                                break;

                              case "relative":
                                this._isRelative = true;
                                if (this._scheme !== "file") {
                                    this._scheme = base._scheme;
                                }
                                if (EOF === c) {
                                    this._host = base._host;
                                    this._port = base._port;
                                    this._path = base._path.slice();
                                    this._query = base._query;
                                    this._username = base._username;
                                    this._password = base._password;
                                    break loop;
                                } else if (c === "/" || c === "\\") {
                                    if (c === "\\") {
                                        err("\\ is an invalid code point.");
                                    }
                                    state = "relative slash";
                                } else if (c === "?") {
                                    this._host = base._host;
                                    this._port = base._port;
                                    this._path = base._path.slice();
                                    this._query = "?";
                                    this._username = base._username;
                                    this._password = base._password;
                                    state = "query";
                                } else if (c === "#") {
                                    this._host = base._host;
                                    this._port = base._port;
                                    this._path = base._path.slice();
                                    this._query = base._query;
                                    this._fragment = "#";
                                    this._username = base._username;
                                    this._password = base._password;
                                    state = "fragment";
                                } else {
                                    const nextC = input[cursor + 1];
                                    const nextNextC = input[cursor + 2];
                                    if (this._scheme !== "file" || !ALPHA.test(c) || nextC !== ":" && nextC !== "|" || EOF !== nextNextC && nextNextC !== "/" && nextNextC !== "\\" && nextNextC !== "?" && nextNextC !== "#") {
                                        this._host = base._host;
                                        this._port = base._port;
                                        this._username = base._username;
                                        this._password = base._password;
                                        this._path = base._path.slice();
                                        this._path.pop();
                                    }
                                    state = "relative path";
                                    continue;
                                }
                                break;

                              case "relative slash":
                                if (c === "/" || c === "\\") {
                                    if (c === "\\") {
                                        err("\\ is an invalid code point.");
                                    }
                                    if (this._scheme === "file") {
                                        state = "file host";
                                    } else {
                                        state = "authority ignore slashes";
                                    }
                                } else {
                                    if (this._scheme !== "file") {
                                        this._host = base._host;
                                        this._port = base._port;
                                        this._username = base._username;
                                        this._password = base._password;
                                    }
                                    state = "relative path";
                                    continue;
                                }
                                break;

                              case "authority first slash":
                                if (c === "/") {
                                    state = "authority second slash";
                                } else {
                                    err(`Expected '/', got: ${c}`);
                                    state = "authority ignore slashes";
                                    continue;
                                }
                                break;

                              case "authority second slash":
                                state = "authority ignore slashes";
                                if (c !== "/") {
                                    err(`Expected '/', got: ${c}`);
                                    continue;
                                }
                                break;

                              case "authority ignore slashes":
                                if (c !== "/" && c !== "\\") {
                                    state = "authority";
                                    continue;
                                } else {
                                    err(`Expected authority, got: ${c}`);
                                }
                                break;

                              case "authority":
                                if (c === "@") {
                                    if (seenAt) {
                                        err("@ already seen.");
                                        buffer += "%40";
                                    }
                                    seenAt = true;
                                    for (let i = 0; i < buffer.length; i++) {
                                        const cp = buffer[i];
                                        if (cp === "\t" || cp === "\n" || cp === "\r") {
                                            err("Invalid whitespace in authority.");
                                            continue;
                                        }
                                        // TODO: check URL code points
                                        if (cp === ":" && this._password === null) {
                                            this._password = "";
                                            continue;
                                        }
                                        const tempC = percentEscape(cp);
                                        if (this._password !== null) {
                                            this._password += tempC;
                                        } else {
                                            this._username += tempC;
                                        }
                                    }
                                    buffer = "";
                                } else if (EOF === c || c === "/" || c === "\\" || c === "?" || c === "#") {
                                    cursor -= buffer.length;
                                    buffer = "";
                                    state = "host";
                                    continue;
                                } else {
                                    buffer += c;
                                }
                                break;

                              case "file host":
                                if (EOF === c || c === "/" || c === "\\" || c === "?" || c === "#") {
                                    if (buffer.length === 2 && ALPHA.test(buffer[0]) && (buffer[1] === ":" || buffer[1] === "|")) {
                                        state = "relative path";
                                    } else if (buffer.length === 0) {
                                        state = "relative path start";
                                    } else {
                                        this._host = IDNAToASCII.call(this, buffer);
                                        buffer = "";
                                        state = "relative path start";
                                    }
                                    continue;
                                } else if (c === "\t" || c === "\n" || c === "\r") {
                                    err("Invalid whitespace in file host.");
                                } else {
                                    buffer += c;
                                }
                                break;

                              case "host":
                              case "hostname":
                                if (c === ":" && !seenBracket) {
                                    // TODO: host parsing
                                    this._host = IDNAToASCII.call(this, buffer);
                                    buffer = "";
                                    state = "port";
                                    if (stateOverride === "hostname") {
                                        break loop;
                                    }
                                } else if (EOF === c || c === "/" || c === "\\" || c === "?" || c === "#") {
                                    this._host = IDNAToASCII.call(this, buffer);
                                    buffer = "";
                                    state = "relative path start";
                                    if (stateOverride) {
                                        break loop;
                                    }
                                    continue;
                                } else if (c !== "\t" && c !== "\n" && c !== "\r") {
                                    if (c === "[") {
                                        seenBracket = true;
                                    } else if (c === "]") {
                                        seenBracket = false;
                                    }
                                    buffer += c;
                                } else {
                                    err(`Invalid code point in host/hostname: ${c}`);
                                }
                                break;

                              case "port":
                                if (/[0-9]/.test(c)) {
                                    buffer += c;
                                } else if (EOF === c || c === "/" || c === "\\" || c === "?" || c === "#" || stateOverride) {
                                    if (buffer !== "") {
                                        const temp = parseInt(buffer, 10);
                                        if (temp !== relative[this._scheme]) {
                                            this._port = `${temp}`;
                                        }
                                        buffer = "";
                                    }
                                    if (stateOverride) {
                                        break loop;
                                    }
                                    state = "relative path start";
                                    continue;
                                } else if (c === "\t" || c === "\n" || c === "\r") {
                                    err(`Invalid code point in port: ${c}`);
                                } else {
                                    invalid.call(this);
                                }
                                break;

                              case "relative path start":
                                if (c === "\\") {
                                    err("'\\' not allowed in path.");
                                }
                                state = "relative path";
                                if (c !== "/" && c !== "\\") {
                                    continue;
                                }
                                break;

                              case "relative path":
                                if (EOF === c || c === "/" || c === "\\" || !stateOverride && (c === "?" || c === "#")) {
                                    if (c === "\\") {
                                        err("\\ not allowed in relative path.");
                                    }
                                    const tmp = relativePathDotMapping[buffer.toLowerCase()];
                                    if (tmp) {
                                        buffer = tmp;
                                    }
                                    if (buffer === "..") {
                                        this._path.pop();
                                        if (c !== "/" && c !== "\\") {
                                            this._path.push("");
                                        }
                                    } else if (buffer === "." && c !== "/" && c !== "\\") {
                                        this._path.push("");
                                    } else if (buffer !== ".") {
                                        if (this._scheme === "file" && this._path.length === 0 && buffer.length === 2 && ALPHA.test(buffer[0]) && buffer[1] === "|") {
                                            buffer = `${buffer[0]}:`;
                                        }
                                        this._path.push(buffer);
                                    }
                                    buffer = "";
                                    if (c === "?") {
                                        this._query = "?";
                                        state = "query";
                                    } else if (c === "#") {
                                        this._fragment = "#";
                                        state = "fragment";
                                    }
                                } else if (c !== "\t" && c !== "\n" && c !== "\r") {
                                    buffer += percentEscape(c);
                                }
                                break;

                              case "query":
                                if (!stateOverride && c === "#") {
                                    this._fragment = "#";
                                    state = "fragment";
                                } else if (EOF !== c && c !== "\t" && c !== "\n" && c !== "\r") {
                                    this._query += percentEscapeQuery(c);
                                }
                                break;

                              case "fragment":
                                if (EOF !== c && c !== "\t" && c !== "\n" && c !== "\r") {
                                    this._fragment += c;
                                }
                                break;

                              default:
                            }
                            cursor++;
                        }
                    }
                    // Does not process domain names or IP addresses.
                    // Does not handle encoding for the query parameter.
                    /* eslint-disable no-param-reassign */
                    function PolyfillURL(url, base /* , encoding */) {
                        if (base !== undefined && !(base instanceof PolyfillURL)) {
                            base = new PolyfillURL(String(base));
                        }
                        url = String(url);
                        this._url = url;
                        clear.call(this);
                        const input = url.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, "");
                        // encoding = encoding || 'utf-8'
                        parse.call(this, input, null, base);
                    }
                    PolyfillURL.prototype = {
                        toString() {
                            return this.href;
                        },
                        get href() {
                            if (this._isInvalid) {
                                return this._url;
                            }
                            let authority = "";
                            if (this._username !== "" || this._password !== null) {
                                authority = `${this._username + (this._password !== null ? `:${this._password}` : "")}@`;
                            }
                            return this.protocol + (this._isRelative ? `//${authority}${this.host}` : "") + this.pathname + this._query + this._fragment;
                        },
                        set href(href) {
                            clear.call(this);
                            parse.call(this, href);
                        },
                        get protocol() {
                            return `${this._scheme}:`;
                        },
                        set protocol(protocol) {
                            if (this._isInvalid) {
                                return;
                            }
                            parse.call(this, `${protocol}:`, "scheme start");
                        },
                        get host() {
                            if (this._isInvalid) return "";
                            if (this._port) return `${this._host}:${this._port}`;
                            return this._host;
                        },
                        set host(host) {
                            if (this._isInvalid || !this._isRelative) {
                                return;
                            }
                            parse.call(this, host, "host");
                        },
                        get hostname() {
                            return this._host;
                        },
                        set hostname(hostname) {
                            if (this._isInvalid || !this._isRelative) {
                                return;
                            }
                            parse.call(this, hostname, "hostname");
                        },
                        get port() {
                            return this._port;
                        },
                        set port(port) {
                            if (this._isInvalid || !this._isRelative) {
                                return;
                            }
                            parse.call(this, port, "port");
                        },
                        get pathname() {
                            if (this._isInvalid) return "";
                            if (this._isRelative) return `/${this._path.join("/")}`;
                            return this._schemeData;
                        },
                        set pathname(pathname) {
                            if (this._isInvalid || !this._isRelative) {
                                return;
                            }
                            this._path = [];
                            parse.call(this, pathname, "relative path start");
                        },
                        get search() {
                            return this._isInvalid || !this._query || this._query === "?" ? "" : this._query;
                        },
                        set search(search) {
                            if (this._isInvalid || !this._isRelative) {
                                return;
                            }
                            this._query = "?";
                            if (search[0] === "?") {
                                search = search.slice(1);
                            }
                            parse.call(this, search, "query");
                        },
                        get hash() {
                            return this._isInvalid || !this._fragment || this._fragment === "#" ? "" : this._fragment;
                        },
                        set hash(hash) {
                            if (this._isInvalid) {
                                return;
                            }
                            this._fragment = "#";
                            if (hash[0] === "#") {
                                hash = hash.slice(1);
                            }
                            parse.call(this, hash, "fragment");
                        },
                        get origin() {
                            if (this._isInvalid || !this._scheme) {
                                return "";
                            }
                            // javascript: Gecko returns String(""), WebKit/Blink String("null")
                            // Gecko throws error for "data://"
                            // data: Gecko returns "", Blink returns "data://", WebKit returns "null"
                            // Gecko returns String("") for file: mailto:
                            // WebKit/Blink returns String("SCHEME://") for file: mailto:
                            switch (this._scheme) {
                              case "data":
                              case "file":
                              case "javascript":
                              case "mailto":
                                return "null";

                              default:
                            }
                            const host = this.host;
                            if (!host) {
                                return "";
                            }
                            return `${this._scheme}://${host}`;
                        }
                    };
                    // Copy over the static methods
                    const OriginalURL = scope.URL;
                    if (OriginalURL) {
                        PolyfillURL.createObjectURL = function createObjectURL(...args) {
                            // IE extension allows a second optional options argument.
                            // http://msdn.microsoft.com/en-us/library/ie/hh772302(v=vs.85).aspx
                            return OriginalURL.createObjectURL(...args);
                        };
                        PolyfillURL.revokeObjectURL = function revokeObjectURL(url) {
                            OriginalURL.revokeObjectURL(url);
                        };
                    }
                    scope.URL = PolyfillURL;
                };
                /***/
            },
            /***/ "./modules/solclient-util/lib/process.js": 
            /*!***********************************************!*\
  !*** ./modules/solclient-util/lib/process.js ***!
  \***********************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const WINDOWS_VERSION_MAP = {
                    6.4: "10.0",
                    6.3: "8.1",
                    6.2: "8",
                    6.1: "7",
                    "6.0": "Vista",
                    5.2: "Server 2003",
                    5.1: "XP",
                    5.01: "2000 SP1",
                    "5.0": "2000",
                    "4.0": "4.0"
                };
                const NODE_OS_TYPES = {
                    Darwin: "OSX",
                    Windows_NT: "Windows"
                };
                const context = typeof window !== "undefined" ? window : __webpack_require__.g;
                const DEFAULT = {};
                const NODE_PROCESS = {
                    product: "solclientjs",
                    platform: "node",
                    agent: "node",
                    process: context.process
                };
                // Worst case fallbacks
                const BROWSER_PROCESS = {
                    product: "solclientjs",
                    platform: "unknown",
                    agent: "Gecko"
                };
                function getBrowserAgentInfo() {
                    /* eslint-env browser */
                    const navObj = typeof navigator !== "undefined" ? navigator : null;
                    if (!navObj) return null;
                    const agentStr = navigator.userAgent;
                    // Execute these regex checks against the user agent string in this order.
                    // The earlier browsers have a lot of impersonation substrings in their user
                    // agent list so we positively test for them before considering the browsers
                    // that are frequently impersonated.
                    const browsers = [ [ "edge", /Edge\/([0-9._]+)/ ], [ "chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9.]+)(:?\s|$)/ ], [ "firefox", /Firefox\/([0-9.]+)(?:\s|$)/ ], [ "opera", /Opera\/([0-9.]+)(?:\s|$)/ ], [ "opera", /OPR\/([0-9.]+)(:?\s|$)$/ ], [ "ie", /Trident\/7\.0.*rv:([0-9.]+).*\).*Gecko$/ ], [ "ie", /MSIE\s([0-9.]+);.*Trident\/[4-8].0/ ], // Edit: IE11 in IE9 emu mode uses Trident 8
                    [ "ie", /MSIE\s(7\.0)/ ], [ "bb10", /BB10;\sTouch.*Version\/([0-9.]+)/ ], [ "android", /Android\s([0-9.]+)/ ], [ "ios", /Version\/([0-9._]+).*Mobile.*Safari.*/ ], [ "safari", /Version\/([0-9._]+).*Safari/ ] ];
                    const agentInfo = {
                        browser: {
                            name: "unknown",
                            version: "0.0.0"
                        },
                        platform: {
                            os: "unknown",
                            arch: "unknown",
                            version: "unknown"
                        }
                    };
                    const agentHas = (...strs) => strs.some(str => agentStr.indexOf(str) >= 0);
                    const firstValue = (...vals) => vals.filter(Boolean).shift();
                    Object.assign(agentInfo, // start with fallbacks above
                    // 1. Run the callback below for each browser name/regex-rule pair.
                    // 2. Decompose the pair into variables called `key` and `rule`.
                    browsers.map(([ key, rule ]) => {
                        // 3. Skip if the rule doesn't match the user agent string.
                        if (!rule.test(agentStr)) return false;
                        // 4. Get the matches for the rule.
                        const match = rule.exec(agentStr);
                        // 5. Extract the version from match group 1.
                        const versionStrs = match && match[1].split(/[._]/).slice(0, 3);
                        // 6. Convert the version strings to numbers.
                        const version = versionStrs.map(str => parseInt(str, 10));
                        // 7. Ensure our version tuple is length 3 by appending 0 elements.
                        while (version.length < 3) version.push(0);
                        // 8. Return an agentInfo object in the same form as above, consuming the version array.
                        return {
                            browser: {
                                name: key,
                                version: version.join(".")
                            }
                        };
                    }).filter(Boolean).shift()); // 9. Filter out anything that returned `false` (#3)...
                    // 10. ...and return the first element.
                    // Now try to extract platform info
                    const os = firstValue(agentHas("Windows Phone") && "WindowsPhone", agentHas("Windows") && "Windows", agentHas("Linux") && "Linux", agentHas("like Mac OS X") && "iOS", agentHas("OS X") && "OSX", agentHas("Android", "Adr") && "Android", agentHas("BB10", "RIM Tablet OS", "BlackBerry") && "BlackBerry");
                    const versionTests = {
                        Windows: () => firstValue(agentHas("Win16") && "3.1.1", agentHas("Windows CE") && "CE", agentHas("Windows 95") && "4.00.950", agentHas("Windows 98; Win 9x 4.90") && "4.90", agentHas("Windows 98") && "4.10", (() => {
                            // Look in the first set of parentheses for a version string key.
                            // This will fail when Windows 16 comes out
                            const parenParts = agentStr.match(/\(.+?\)/);
                            const versionPart = parenParts[0];
                            if (!versionPart) return false;
                            const versionMatch = str => versionPart.indexOf(str) >= 0;
                            return firstValue(...Object.keys(WINDOWS_VERSION_MAP).map(k => versionMatch(k) && WINDOWS_VERSION_MAP[k]));
                        })()),
                        OSX: () => agentStr.match(/OS X ((\d+[._])+\d+)\b/)[1],
                        Linux: () => "",
                        iOS: () => agentStr.match(/OS ((\d+[._])+\d+) like Mac OS X/)[1],
                        Android: () => agentStr.match(/(?:Android|Adr) ((\d+[._])+\d_)/)[1],
                        BlackBerry: () => agentStr.match(/(?:Version\/|RIM Tablet OS )((\d+\.)+\d+)/)[1]
                    };
                    const versionTest = versionTests[os];
                    agentInfo.platform.os = os || "Unknown";
                    agentInfo.platform.version = (versionTest && versionTest() || "0.0.0").replace(/_/g, ".");
                    return agentInfo;
                }
                /* eslint-env shared-browser-node */
                try {
                    if (true && context.navigator) {
                        // These are historical defaults
                        const safeEncode = str => str.replace(/[^a-zA-Z0-9_/.]/g, "-");
                        Object.assign(BROWSER_PROCESS, {
                            platform: context.navigator.platform,
                            agent: context.navigator.product,
                            description: safeEncode(context.navigator.userAgent),
                            navigator: context.navigator
                        });
                        const browserAgentInfo = getBrowserAgentInfo();
                        if (browserAgentInfo) {
                            BROWSER_PROCESS.agent = safeEncode(`${browserAgentInfo.browser.name}-${browserAgentInfo.browser.version}`);
                            BROWSER_PROCESS.platform = `${BROWSER_PROCESS.agent}-${safeEncode(`${browserAgentInfo.platform.os}-${browserAgentInfo.platform.version}`)}`;
                        }
                    }
                    if (false) {}
                } catch (ex) {
                    // Fall back to defaults
                }
                const Process = Object.assign({}, DEFAULT, true ? BROWSER_PROCESS : 0, false ? 0 : {});
                module.exports.Process = Process;
                /***/
            },
            /***/ "./modules/solclient-util/lib/string-buffer.js": 
            /*!*****************************************************!*\
  !*** ./modules/solclient-util/lib/string-buffer.js ***!
  \*****************************************************/
            /***/ module => {
                /**
 * This class is used to efficiently concatenate strings.
 * @private
 */
                class StringBuffer {
                    /**
   * @constructor
   * @param {...*} args Initial buffer contents
   * @private
   */
                    constructor(...args) {
                        this.clear();
                        this.append(...args);
                    }
                    /**
   * Appends the given strings to the buffer
   *
   * @param {...*} args Objects to add to the buffer. These are immediately
   *                    coerced to strings.
   * @returns {StringBuffer} this
   */
                    append(...args) {
                        [ ...args ].forEach(arg => {
                            this.buffer[this.index++] = String(arg);
                        });
                        return this;
                    }
                    /**
   * Resets the buffer.
   */
                    clear() {
                        this.buffer = [];
                        this.index = 0;
                    }
                    /**
   * Returns the buffer as a string. Additional concatenations and renderings
   * can be performed.
   * @returns {String} The buffer's contents concatenated to a string.
   */
                    toString() {
                        return this.buffer.join("");
                    }
                }
                module.exports.StringBuffer = StringBuffer;
                /***/
            },
            /***/ "./modules/solclient-util/lib/string-utils.js": 
            /*!****************************************************!*\
  !*** ./modules/solclient-util/lib/string-utils.js ***!
  \****************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    StringBuffer
                } = __webpack_require__(/*! ./string-buffer */ "./modules/solclient-util/lib/string-buffer.js");
                const PAD_LEFT = 0;
                const PAD_RIGHT = 1;
                const LUT_PRINTABLE = (() => {
                    const tmp = [];
                    for (let c = 0; c < 256; ++c) {
                        tmp[c] = c < 33 || c > 126 ? "." : String.fromCharCode(c);
                    }
                    return tmp;
                })();
                function padLeftRight(str, minLen, padSide, padChar = " ") {
                    if (typeof str !== "string") {
                        return str;
                    }
                    if (str.length >= minLen) {
                        return str;
                    }
                    const buf = new StringBuffer();
                    for (let i = 0; i < minLen - str.length; i++) {
                        buf.append(padChar.charAt(0));
                    }
                    switch (padSide) {
                      case PAD_LEFT:
                        return `${buf}${str}`;

                      case PAD_RIGHT:
                        return `${str}${buf}`;

                      default:
                        return str;
                    }
                }
                function leastSpaces(length, line) {
                    if (!line.length) return length;
                    const spaces = line.match(/^\s*/)[0].length;
                    return spaces < length ? spaces : length;
                }
                function capitalizeWord(str) {
                    return `${str.charAt(0).toUpperCase()}${str.substr(1)}`;
                }
                function isEmptyFun(str) {
                    return str === undefined || str === null || str.length === 0;
                }
                /**
 * @private
 * @type {StringUtils}
 */
                const StringUtils = {};
                StringUtils.capitalize = function capitalize(str) {
                    if (!(str && str.length)) {
                        return str;
                    }
                    return str.split(" ").map(capitalizeWord).join(" ");
                };
                StringUtils.isEmpty = isEmptyFun;
                StringUtils.notEmpty = function notEmpty(str) {
                    return !isEmptyFun(str);
                };
                StringUtils.toSafeChars = function toSafeChars(str) {
                    return str.replace(/[^a-zA-Z0-9_/.]/g, "");
                };
                StringUtils.padLeft = function padLeft(str, minLen, padChar) {
                    return padLeftRight(str, minLen, PAD_LEFT, padChar);
                };
                StringUtils.padRight = function padRight(str, minLen, padChar) {
                    return padLeftRight(str, minLen, PAD_RIGHT, padChar);
                };
                StringUtils.nullTerminate = function nullTerminate(str) {
                    if (str === null || str === undefined) {
                        throw new Error("non str in nullTerminate");
                    }
                    const lastChar = str.charCodeAt(str.length - 1);
                    if (lastChar === 0) {
                        return str;
                    }
                    return str + String.fromCharCode(0);
                };
                StringUtils.stripNullTerminate = function stripNullTerminate(str) {
                    if (str === null || str === undefined) {
                        throw new Error("null str in stripNullTerminate");
                    }
                    const lastChar = str.charCodeAt(str.length - 1);
                    if (lastChar === 0) {
                        return str.substr(0, str.length - 1);
                    }
                    return str;
                };
                StringUtils.hexdump = function hexdump(s) {
                    const output = new StringBuffer();
                    const printable = new StringBuffer();
                    const spacer = pos => pos === 8 || pos === 16 ? "  " : " ";
                    let linelen = 0;
                    for (let i = 0, sLength = s.length; i < sLength; i++) {
                        const ccode = s.charCodeAt(i);
                        output.append(padLeftRight(ccode.toString(16), 2, PAD_LEFT));
                        printable.append(LUT_PRINTABLE[ccode] || ".");
                        output.append(spacer(++linelen));
                        if (i === s.length - 1) {
                            // input finished: complete the line
                            while (linelen < 16) {
                                output.append(`  ${spacer(++linelen)}`);
                            }
                        }
                        if (linelen === 16) {
                            output.append(printable.join(""));
                            output.append("\n");
                            linelen = 0;
                            printable.clear();
                        }
                    }
                    return output.toString();
                };
                /**
 * Use heredoc`....` to create multi-line heredoc strings. Leading blank lines are removed, as are
 * leading spaces, up to the number of spaces on the least-indented line.
 * @param {String} literals The document template
 * @param {...String} substitutions The substitutions to make in the document
 * @returns {String} The interpolated representation of the document
 */
                StringUtils.heredoc = function heredoc(literals, ...substitutions) {
                    const subst = [ ...substitutions, "" ];
                    const lines = literals.map(k => k + subst.shift()).join("").split(/\r?\n/);
                    const spaces = lines.length === 1 ? 0 : lines.reduce(leastSpaces, Infinity);
                    while (lines[0] === "") {
                        lines.shift();
                    }
                    return lines.map(line => line.substring(spaces)).join("\n");
                };
                module.exports.StringUtils = StringUtils;
                /***/
            },
            /***/ "./modules/solclient-util/lib/timing-bucket.js": 
            /*!*****************************************************!*\
  !*** ./modules/solclient-util/lib/timing-bucket.js ***!
  \*****************************************************/
            /***/ module => {
                class TimingBucket {
                    constructor(name, interval) {
                        this.name = name;
                        this.interval = interval;
                        this.buckets = [];
                    }
                    get bucketCount() {
                        let c = 0;
                        for (let i = 0, n = this.buckets.length; i < n; ++i) {
                            c += this.buckets[i] || 0;
                        }
                        return c;
                    }
                    log(v) {
                        if (v === undefined || isNaN(v)) {
                            return;
                        }
                        const normalized = Math.floor(v / this.interval) * this.interval;
                        this.buckets[normalized] = this.buckets[normalized] || 0;
                        this.buckets[normalized]++;
                    }
                    toString() {
                        const cont = [];
                        this.buckets.forEach(i => {
                            cont.push(`${i}: ${this.buckets[i]}`);
                        });
                        return `{${cont.join(", ")}}`;
                    }
                }
                module.exports.TimingBucket = TimingBucket;
                /***/
            },
            /***/ "./modules/solclient-util/lib/url.js": 
            /*!*******************************************!*\
  !*** ./modules/solclient-util/lib/url.js ***!
  \*******************************************/
            /***/ function(module, __unused_webpack_exports, __webpack_require__) {
                /* eslint-disable global-require */
                let parseURL;
                if (false) {} else {
                    /* eslint-env browser */
                    const scope = typeof window !== "undefined" ? window : this;
                    __webpack_require__(/*! ./browser-url-polyfill */ "./modules/solclient-util/lib/browser-url-polyfill.js")(scope);
                    parseURL = function makeURL(...args) {
                        return new URL(...args);
                    };
                }
                module.exports.parseURL = parseURL;
                /***/
            },
            /***/ "./modules/solclient-util/lib/uuid.js": 
            /*!********************************************!*\
  !*** ./modules/solclient-util/lib/uuid.js ***!
  \********************************************/
            /***/ module => {
                function generateUUID() {
                    // Public Domain/MIT
                    let d = new Date().getTime();
                    // if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
                    //   d += performance.now(); //use high-precision timer if available
                    // }
                    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, c => {
                        const r = (d + Math.random() * 16) % 16 | 0;
                        d = Math.floor(d / 16);
                        return (c === "x" ? r : r & 3 | 8).toString(16);
                    });
                }
                module.exports.UUID = {
                    generateUUID: generateUUID
                };
                /***/
            },
            /***/ "./modules/solclient-util/lib/version.js": 
            /*!***********************************************!*\
  !*** ./modules/solclient-util/lib/version.js ***!
  \***********************************************/
            /***/ module => {
                // Coverity scanned is configured to run against the generated monolithic
                // solclient.js file (debug) version. On the loadbuild server BUILD_ENV.VERSION is
                // substituted and never null (it is null in developer workspace) so
                // coverity will complain that the " || '0.0.0-source' " is DEADCODE
                // coverity[dead_error_line]
                const VERSION = "10.11.0" || 0;
                // Parse the date if provided. Was seeing NaN formatted dates in source mode, so add fallback
                const DATE = true ? new Date(Date.parse("Thu Sep 15 2022 13:43:57 GMT-0400 (Eastern Daylight Time)")) : 0;
                const MODE = "DEBUG";
                // These property names are all for export, so make sure they're not mangled
                const TARGET = {
                    name: "browser",
                    node: false,
                    browser: true
                };
                const FORMATTED_DATE = (() => {
                    const pad = n => n < 10 ? `0${n}` : n;
                    const d = DATE;
                    const YYYY = d.getFullYear();
                    const MM = pad(d.getMonth() + 1);
                    const DD = pad(d.getDate());
                    const hh = pad(d.getHours());
                    const mm = pad(d.getMinutes());
                    return `${YYYY}/${MM}/${DD} ${hh}:${mm}`;
                })();
                const SUMMARY = [ "SolclientJS", "10.11.0", MODE, FORMATTED_DATE ].join(", ");
                /**
 * Returns the API version. Use version, date and mode properties for build details.
 * Use the summary property or the .toString() method to return a summary.
 * @static
 * @type {Object}
 * @namespace
 * @memberof solace
 */
                const Version = {
                    /**
   * The API version, as an informational string. The format of this string is subject to change.
   * @type {String}
   */
                    version: VERSION,
                    /**
   * The API build date.
   * @type {Date}
   */
                    date: DATE,
                    /**
   * The API build date, as a formatted string.
   * The format of this date is:
   * `YYYY-MM-DD hh:mm`
   * where
   *  * `YYYY` is the 4-digit year,
   *  * `MM` is the 2-digit month   (01-12),
   *  * `DD` is the 2-digit day     (01-31),
   *  * `hh` is the 2-digit hour    (00-23),
   *  * `mm` is the 2-digit minute  (00-59)
   *
   * @type {String}
   */
                    formattedDate: FORMATTED_DATE,
                    /**
   * Information about the build target. This object is informational; its type, structure and
   * content are subject to change.
   * @type {Object}
   */
                    target: TARGET,
                    /**
   * The build mode. This may be one of 'debug' or 'release'. Other build modes may be added
   * in the future.
   * @type {String}
   */
                    mode: MODE,
                    /**
   * If `true`, this is an unoptimized debug build.
   * @type {Boolean}
   */
                    debug: true,
                    /**
   * If `true`, this is an optimized release build. Note that there may be multiple release
   * builds in a distribution, with varying degrees of optimization.
   * @type {Boolean}
   */
                    release: false,
                    /**
   * An informational string summarizing the API name, version and build date.
   * @type {String}
   */
                    summary: SUMMARY,
                    toString() {
                        return SUMMARY;
                    }
                };
                module.exports.Version = Version;
                /***/
            },
            /***/ "./modules/solclient-validate/api.js": 
            /*!*******************************************!*\
  !*** ./modules/solclient-validate/api.js ***!
  \*******************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Check
                } = __webpack_require__(/*! ./lib/check */ "./modules/solclient-validate/lib/check.js");
                const {
                    Parameter
                } = __webpack_require__(/*! ./lib/parameter */ "./modules/solclient-validate/lib/parameter.js");
                module.exports.Check = Check;
                module.exports.Parameter = Parameter;
                /***/
            },
            /***/ "./modules/solclient-validate/lib/base-checks.js": 
            /*!*******************************************************!*\
  !*** ./modules/solclient-validate/lib/base-checks.js ***!
  \*******************************************************/
            /***/ module => {
                const EPSILON = 1e6;
                /**
 * @param {Array} arr The array to flatten
 * @returns {Array} A maximally flattened array. The original array is not modified.
 * @private
 */
                function flatten(arr) {
                    return arr.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);
                }
                /**
 * @private
 */
                const BaseChecks = (() => {
                    const result = {
                        /**
     * Checks whether a value is undefined or null.
     *
     * @param   {*} value The value to check.
     *
     * @returns {Boolean} True if the value is undefined or null.
     *
     * @private
     */
                        nothing(value) {
                            return value === undefined || value === null;
                        },
                        /**
     * Checks whether a value is anything, i.e. not undefined or null.
     *
     * @param   {*} value The value to check.
     *
     * @returns {Boolean} True unless the value is undefined or null.
     *
     * @private
     */
                        anything(value) {
                            return !BaseChecks.nothing(value);
                        },
                        /**
     * Checks whether a value is undefined. Uses the conservative
     * typeof check for compatibility with particularly ill-behaved
     * libraries that redefine <code>undefined</code>.
     *
     * @param   {*} value The value to check.
     *
     * @returns {Boolean} True if the value is undefined.
     *
     * @private
     */
                        undefined(value) {
                            return typeof value === "undefined";
                        },
                        /**
     * Checks whether a value is defined. This is true for any value with
     * a type that is not 'undefined'.
     *
     * @param {any} value The value to check
     * @returns {Boolean} True if the value is defined.
     *
     * @private
     */
                        defined(value) {
                            return !BaseChecks.undefined(value);
                        },
                        /**
     * Checks whether a value is an array.
     *
     * @param   {*} value The value to check.
     *
     * @returns {Boolean} True if the value is an array.
     *
     * @private
     */
                        array(value) {
                            return BaseChecks.anything(value) && Array.isArray(value);
                        },
                        /**
     * Checks whether a value is an object. If a value is an array, it is not an object.
     * If a value is null, it is not an object.
     *
     * @param   {*} value The value to check.
     *
     * @returns {Boolean} True if the value is an object (and not an array).
     *
     * @private
     */
                        object(value) {
                            return !BaseChecks.array(value) && value !== null && (typeof value === "object" || value instanceof Object);
                        },
                        /**
     * Checks whether a value is an instance of the given type.
     *
     * @param   {*} val The value to check.
     * @param   {Object} type The type to check.
     *
     * @returns {Boolean} True if type is in value's prototype chain.
     *
     * @private
     */
                        instanceOf(val, type) {
                            return BaseChecks.object(val) && val instanceof type;
                        },
                        /**
     * Checks whether a value's typeof is equal to the given type string.
     *
     * @param {*} val The value to check.
     * @param {String} type The type string for comparison.
     *
     * @returns {Boolean} True if typeof(val) == type
     *
     * @private
     */
                        type(val, type) {
                            return typeof val === type; /* dynamic */ // eslint-disable-line valid-typeof
                        },
                        /**
     * Checks whether a value is an instance of any of the given types.
     *
     * @param   {*} val The value to check.
     * @param   {Object} types The types to check.
     *
     * @returns {Boolean} True if any element of types is in val's prototype chain.
     *
     * @private
     */
                        instanceOfAny(val, ...types) {
                            return BaseChecks.array(types) && flatten(types).some(type => BaseChecks.instanceOf(val, type));
                        },
                        /**
     * Checks whether the given value is empty.
     *
     * Emptiness is determined using the following checks:
     *
     * <ol>
     *  <li>If an object is nothing, it is empty.</li>
     *  <li>If it is an object, and it has no keys of its own, it is empty.</li>
     *  <li>If it has a length property, it is empty if length === 0.</li>
     *  <li>If none of the above apply, the object is not empty.</li>
     * </ol>
     *
     * @param   {*} val The value to check.
     *
     * @returns {Boolean} True if the value is empty.
     *
     * @private
     */
                        empty(val) {
                            if (BaseChecks.nothing(val)) return true;
                            if (BaseChecks.object(val)) {
                                if (Object.keys(val).length === 0) {
                                    return true;
                                }
                            }
                            if (val.length === 0) {
                                return true;
                            }
                            return false;
                        },
                        /**
     * A user-defined check.
     *
     * @param   {*} val The value to check
     * @param   {Function} fn The function(val) to use.
     *
     * @returns {Boolean} The result of the function, coerced to a boolean.
     *
     * @private
     */
                        truthy(val, fn) {
                            return !!fn(val);
                        },
                        rangeGe(val, rangeMinInclusive) {
                            return val >= rangeMinInclusive;
                        },
                        rangeGt(val, rangeMin) {
                            return val > rangeMin;
                        },
                        rangeLe(val, rangeMaxInclusive) {
                            return val <= rangeMaxInclusive;
                        },
                        rangeLt(val, rangeMax) {
                            return val < rangeMax;
                        },
                        rangeCompare(val, operator, operand, ...args) {
                            switch (operator) {
                              case "=":
                              case "==":
                              case "===":
                                return val === operand;

                              case "~=":
                              case "=~":
                                {
                                    const epsilon = args[0] || EPSILON;
                                    return Math.abs(val - operand) < epsilon;
                                }

                              case "<":
                                return val < operand;

                              case "<=":
                                return val <= operand;

                              case ">":
                                return val > operand;

                              case ">=":
                                return val >= operand;

                              default:
                                throw new Error(`Illegal operator for rangeCompare: ${operator}`);
                            }
                        },
                        NaN(val) {
                            return Number.isNaN(val);
                        },
                        /**
     * Checks whether val is included in the object. If obj is an array, val is included if
     * val is an element of the array. Otherwise, if obj is an object, val is included if
     * val is one of the keys of obj.
     *
     * @param   {*} val The value to test
     * @param   {*} obj The object to test
     *
     * @returns {Boolean} True if the value is included in the object
     */
                        included(val, obj) {
                            if (BaseChecks.nothing(obj)) {
                                return false;
                            }
                            if (obj.includes) {
                                return obj.includes(val);
                            }
                            if (Array.isArray(obj)) {
                                // Not exactly Array.prototype.includes, which uses SameValueZero (+0 == -0)
                                return obj.indexOf(val) >= 0;
                            }
                            if (BaseChecks.object(obj)) {
                                const keys = Object.keys(obj);
                                return BaseChecks.included(val, keys);
                            }
                            return false;
                        },
                        /**
     * Checks whether val is equal to expected.
     *
     * @param {any} val The value to check.
     * @param {any} expected The expected value.
     * @returns {Boolean} True if the value was equal to the expected value.
     */
                        equal(val, expected) {
                            return val === expected;
                        },
                        /**
     * Checks whether the given value appears as an attribute value in the given attributes object,
     * e.g. whether an enumeration contains the given value. If the attributes object is an array,
     * the array membership check {@link #included} is used instead.
     *
     * @param   {*} val The value to check.
     * @param   {Object} obj The object with attributes to check.
     *
     * @returns {Boolean} True if attrs has any attribute equal to val.
     */
                        member(val, obj) {
                            return BaseChecks.anything(obj) && (BaseChecks.array(obj) ? BaseChecks.included(val, obj) : Object.keys(obj).some(k => obj[k] === val));
                        },
                        boolean(v) {
                            return BaseChecks.type(v, "boolean");
                        },
                        number(v) {
                            return BaseChecks.type(v, "number");
                        },
                        string(v) {
                            return BaseChecks.type(v, "string");
                        },
                        function(v) {
                            return BaseChecks.type(v, "function");
                        }
                    };
                    /**
   * Checks whether an object is none. This is the same check as <code>nothing</code>
   * @see {@link nothing}
   */
                    result.none = result.nothing;
                    /**
   * Checks whether an object is something. This is the same check as <code>anything</code>
   */
                    result.something = result.anything;
                    // Add check-loosening suffixes, (t | null), (t | undefined) and (t | null | undefined).
                    // Do the t check last, just in case it is not (null | undefined) safe.
                    Object.keys(result).forEach(key => {
                        /**
     * .orNull checks. These are equivalent to the similarly named check, but also pass if the value
     * supplied was equal to null.
     *
     * @param {*} val The value to check.
     * @param {*} args The arguments to forward to the base validator.
     *
     * @returns {Boolean} True if the value was null or passed the similarly named validator.
     */
                        result[key].orNull = function orNull(val, ...args) {
                            return val === null || result[key](val, ...args);
                        };
                        /**
     * .orUndefined checks. These are equivalent to the similarly named check, but also pass if the
     * value supplied was equal to null.
     *
     * @param {*} val The value to check.
     * @param {*} args The arguments to forward to the base validator.
     *
     * @returns {Boolean} True if the value was null or passed the similarly named validator.
     */
                        result[key].orUndefined = function orUndefined(val, ...args) {
                            return val === undefined || result[key](val, ...args);
                        };
                        /**
     * .orNothing checks. These are equivalent to the similarly named check, but also pass if the
     * value supplied was null or undefined.
     *
     * @param {*} val The value to check.
     * @param {*} args The arguments to forward to the base validator.
     *
     * @returns {Boolean} True if the value was null or passed the similarly named validator.
     */
                        result[key].orNothing = function orNothing(val, ...args) {
                            return result.nothing(val) || result[key](val, ...args);
                        };
                    });
                    return result;
                })();
                module.exports.BaseChecks = BaseChecks;
                /***/
            },
            /***/ "./modules/solclient-validate/lib/check.js": 
            /*!*************************************************!*\
  !*** ./modules/solclient-validate/lib/check.js ***!
  \*************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    BaseChecks
                } = __webpack_require__(/*! ./base-checks */ "./modules/solclient-validate/lib/base-checks.js");
                /**
 *
 * Generates a then closure.
 *
 * @param {Boolean} doOp Whether the returned then function should call its argument.
 * @returns {Object} An object { then(fn, elseFn=undefined) }. If doOp was true, then(fn) will
 *                      call fn. If not, elseFn will be called if supplied.
 * @private
 */
                function thenGen(doOp) {
                    return {
                        then: doOp ? f => f() : (_, elseFn) => elseFn()
                    };
                }
                /**
 *
 * none, anything, boolean, ... @returns {Boolean}
 * when(condition) @returns then(fn, elseFn) => if condition fn() else elseFn && elseFn()
 * unless(condition, else) @returns then(fn, elseFn) => if !condition fn() else elseFn && elseFn
 * whenNone, whenAnything, whenBoolean, ... @returns {function} then(fn, elseFn)
 * unlessNone, unlessAnything, unlessBoolean ... @returns {function} unless(fn, elseFn)
 * @private
 */
                const Check = (() => {
                    const result = Object.assign({}, BaseChecks);
                    result.when = condition => thenGen(condition);
                    result.unless = condition => thenGen(!condition);
                    return result;
                })();
                module.exports.Check = Check;
                /***/
            },
            /***/ "./modules/solclient-validate/lib/parameter.js": 
            /*!*****************************************************!*\
  !*** ./modules/solclient-validate/lib/parameter.js ***!
  \*****************************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                const {
                    Check
                } = __webpack_require__(/*! ./check */ "./modules/solclient-validate/lib/check.js");
                const {
                    ErrorSubcode,
                    OperationError
                } = __webpack_require__(/*! solclient-error */ "./modules/solclient-error/api.js");
                const NO_OBJ = {}; // anonymous object
                function objectValues(object) {
                    return Object.keys(object).map(k => object[k]);
                }
                function subcodeSummary(subcode, expected = null, got = NO_OBJ) {
                    const expectedStr = expected ? `; expected: ${expected}` : "";
                    const gotStr = got !== NO_OBJ ? `; got: ${got}` : "";
                    switch (subcode) {
                      case ErrorSubcode.PARAMETER_INVALID_TYPE:
                        return `Parameter type was invalid${expectedStr}${gotStr}`;

                      default:
                        return ErrorSubcode.nameOf(subcode).toLowerCase().replace(/_/, " ") + expectedStr;
                    }
                }
                function validateError(name, subcode, message) {
                    throw new OperationError(`Parameter ${name} failed validation`, subcode, message);
                }
                function validate(name, subcode, message, check, value, ...validatorArgs) {
                    if (!check(value, ...validatorArgs)) {
                        return validateError(name, subcode, message);
                    }
                    return value;
                }
                const typename = x => x && x.constructor && x.constructor.name || typeof x;
                /**
 * The Check object is a powerful validation API but it is partially built at runtime by composing
 * functions, and it requires significant boilerplate for parameter validation.
 *
 * The Parameter API expresses concrete validations using the Check API, returning values on success
 * and throwing the appropriate SDK exception on failure. It would be tempting to try to
 * automatically build a Parameter method for every Check method, but this would make Parameter
 * difficult to understand and use.
 *
 * @private
 */
                const Parameter = {};
                Parameter.isArray = function isArray(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "array", value)) {
                    return validate(name, subcode, message, Check.isArray, value);
                };
                Parameter.isBoolean = function isBoolean(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "boolean", value)) {
                    return validate(name, subcode, message, Check.boolean, value);
                };
                Parameter.isBooleanOrNothing = function isBooleanOrNothing(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "boolean or nothing", value)) {
                    return validate(name, subcode, message, Check.boolean.orNothing, value);
                };
                Parameter.isEnumMember = function isEnumMember(name, value, memberOfEnum, subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE, message = subcodeSummary(subcode, `one of [${memberOfEnum.names.join(", ")}]`, value)) {
                    return validate(name, subcode, message, Check.member, value, memberOfEnum);
                };
                Parameter.isEnumMemberOrNothing = function isEnumMemberOrNothing(name, value, memberOfEnum, subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE, message = subcodeSummary(subcode, `one of [${memberOfEnum.names.join(", ")}]`, value)) {
                    return validate(name, subcode, message, Check.member.orNothing, value, memberOfEnum);
                };
                Parameter.isFunction = function isFunction(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "function", value)) {
                    return validate(name, subcode, message, Check.function, value);
                };
                Parameter.isFunctionOrNothing = function isFunctionOrNothing(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "function or nothing", value)) {
                    return validate(name, subcode, message, Check.function.orNothing, value);
                };
                Parameter.isInstanceOf = function isInstanceOf(name, value, instanceOf, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, instanceOf.name, typename(value))) {
                    return validate(name, subcode, message, Check.instanceOf, value, instanceOf);
                };
                Parameter.isInstanceOfOrNothing = function isInstanceOfOrNothing(name, value, instanceOf, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, `${instanceOf.name} or nothing`, typename(value))) {
                    return validate(name, subcode, message, Check.instanceOf.orNothing, value, instanceOf);
                };
                Parameter.isInstanceOfOrNull = function isInstanceOfOrNull(name, value, instanceOf, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, `${instanceOf.name} or null`, typename(value))) {
                    return validate(name, subcode, message, Check.instanceOf.orNull, value, instanceOf);
                };
                Parameter.isInstanceOfOrUndefined = function isInstanceOfOrUndefined(name, value, instanceOf, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, `${instanceOf.name} or undefined`, typename(value))) {
                    return validate(name, subcode, message, Check.instanceOf.orUndefined, value, instanceOf);
                };
                Parameter.isMember = function isMember(name, value, memberOf, subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE, message = subcodeSummary(subcode, `one of ${memberOf.name}.[${objectValues(memberOf).join(", ")}]`, value)) {
                    return validate(name, subcode, message, Check.member, value, memberOf);
                };
                Parameter.isNumber = function isNumber(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "number", value)) {
                    return validate(name, subcode, message, Check.number, value);
                };
                Parameter.isNumberOrNothing = function isNumberOrNothing(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "number or nothing", value)) {
                    return validate(name, subcode, message, Check.number.orNothing, value);
                };
                Parameter.isNumberOrNull = function isNumberOrNull(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "number or null", value)) {
                    return validate(name, subcode, message, Check.number.orNull, value);
                };
                Parameter.isRangeCompare = function isRangeCompare(name, value, operator, operand, subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE, message = subcodeSummary(subcode, `${operator} ${operand}`, value)) {
                    return validate(name, subcode, message, Check.rangeCompare, value, operator, operand);
                };
                Parameter.isRangeCompareOrNothing = function isRangeCompareOrNothing(name, value, operator, operand, subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE, message = subcodeSummary(subcode, `${operator} ${operand} or nothing`, value)) {
                    return validate(name, subcode, message, Check.rangeCompare.orNothing, value, operator, operand);
                };
                Parameter.isStringOrNull = function isStringOrNull(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "string or null", value)) {
                    return validate(name, subcode, message, Check.string.orNull, value);
                };
                Parameter.isString = function isString(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "string", value)) {
                    return validate(name, subcode, message, Check.string, value);
                };
                Parameter.isStringOrNothing = function isStringOrNothing(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "string or nothing", value)) {
                    return validate(name, subcode, message, Check.string.orNothing, value);
                };
                Parameter.isValue = function isValue(name, value, expected, subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE, message = subcodeSummary(subcode, `must be ${value}`)) {
                    return validate(name, subcode, message, Check.equal, value, expected);
                };
                module.exports.Parameter = Parameter;
                /***/
            },
            /***/ "./node_modules/base64-js/index.js": 
            /*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
            /***/ (__unused_webpack_module, exports) => {
                "use strict";
                exports.byteLength = byteLength;
                exports.toByteArray = toByteArray;
                exports.fromByteArray = fromByteArray;
                var lookup = [];
                var revLookup = [];
                var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
                var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                for (var i = 0, len = code.length; i < len; ++i) {
                    lookup[i] = code[i];
                    revLookup[code.charCodeAt(i)] = i;
                }
                // Support decoding URL-safe base64 strings, as Node.js does.
                // See: https://en.wikipedia.org/wiki/Base64#URL_applications
                revLookup["-".charCodeAt(0)] = 62;
                revLookup["_".charCodeAt(0)] = 63;
                function getLens(b64) {
                    var len = b64.length;
                    if (len % 4 > 0) {
                        throw new Error("Invalid string. Length must be a multiple of 4");
                    }
                    // Trim off extra bytes after placeholder bytes are found
                    // See: https://github.com/beatgammit/base64-js/issues/42
                    var validLen = b64.indexOf("=");
                    if (validLen === -1) validLen = len;
                    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
                    return [ validLen, placeHoldersLen ];
                }
                // base64 is 4/3 + up to two characters of the original data
                function byteLength(b64) {
                    var lens = getLens(b64);
                    var validLen = lens[0];
                    var placeHoldersLen = lens[1];
                    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
                }
                function _byteLength(b64, validLen, placeHoldersLen) {
                    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
                }
                function toByteArray(b64) {
                    var tmp;
                    var lens = getLens(b64);
                    var validLen = lens[0];
                    var placeHoldersLen = lens[1];
                    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
                    var curByte = 0;
                    // if there are placeholders, only get up to the last complete 4 chars
                    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
                    var i;
                    for (i = 0; i < len; i += 4) {
                        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
                        arr[curByte++] = tmp >> 16 & 255;
                        arr[curByte++] = tmp >> 8 & 255;
                        arr[curByte++] = tmp & 255;
                    }
                    if (placeHoldersLen === 2) {
                        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
                        arr[curByte++] = tmp & 255;
                    }
                    if (placeHoldersLen === 1) {
                        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
                        arr[curByte++] = tmp >> 8 & 255;
                        arr[curByte++] = tmp & 255;
                    }
                    return arr;
                }
                function tripletToBase64(num) {
                    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
                }
                function encodeChunk(uint8, start, end) {
                    var tmp;
                    var output = [];
                    for (var i = start; i < end; i += 3) {
                        tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
                        output.push(tripletToBase64(tmp));
                    }
                    return output.join("");
                }
                function fromByteArray(uint8) {
                    var tmp;
                    var len = uint8.length;
                    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
                    var parts = [];
                    var maxChunkLength = 16383; // must be multiple of 3
                    // go through the array every three bytes, we'll deal with trailing stuff later
                    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
                    }
                    // pad the end with zeros, but make sure to not forget the extra bytes
                    if (extraBytes === 1) {
                        tmp = uint8[len - 1];
                        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
                    } else if (extraBytes === 2) {
                        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
                        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
                    }
                    return parts.join("");
                }
                /***/
            },
            /***/ "./node_modules/browser-util-inspect/index.js": 
            /*!****************************************************!*\
  !*** ./node_modules/browser-util-inspect/index.js ***!
  \****************************************************/
            /***/ module => {
                /**
 * Module exports.
 */
                module.exports = inspect;
                /**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 * @license MIT ( Joyent)
 */
                /* legacy: obj, showHidden, depth, colors*/
                function inspect(obj, opts) {
                    // default options
                    var ctx = {
                        seen: [],
                        stylize: stylizeNoColor
                    };
                    // legacy...
                    if (arguments.length >= 3) ctx.depth = arguments[2];
                    if (arguments.length >= 4) ctx.colors = arguments[3];
                    if (isBoolean(opts)) {
                        // legacy...
                        ctx.showHidden = opts;
                    } else if (opts) {
                        // got an "options" object
                        _extend(ctx, opts);
                    }
                    // set default options
                    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
                    if (isUndefined(ctx.depth)) ctx.depth = 2;
                    if (isUndefined(ctx.colors)) ctx.colors = false;
                    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
                    if (ctx.colors) ctx.stylize = stylizeWithColor;
                    return formatValue(ctx, obj, ctx.depth);
                }
                // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
                inspect.colors = {
                    bold: [ 1, 22 ],
                    italic: [ 3, 23 ],
                    underline: [ 4, 24 ],
                    inverse: [ 7, 27 ],
                    white: [ 37, 39 ],
                    grey: [ 90, 39 ],
                    black: [ 30, 39 ],
                    blue: [ 34, 39 ],
                    cyan: [ 36, 39 ],
                    green: [ 32, 39 ],
                    magenta: [ 35, 39 ],
                    red: [ 31, 39 ],
                    yellow: [ 33, 39 ]
                };
                // Don't use 'blue' not visible on cmd.exe
                inspect.styles = {
                    special: "cyan",
                    number: "yellow",
                    boolean: "yellow",
                    undefined: "grey",
                    null: "bold",
                    string: "green",
                    date: "magenta",
                    // "name": intentionally not styling
                    regexp: "red"
                };
                function stylizeNoColor(str, styleType) {
                    return str;
                }
                function isBoolean(arg) {
                    return typeof arg === "boolean";
                }
                function isUndefined(arg) {
                    return arg === void 0;
                }
                function stylizeWithColor(str, styleType) {
                    var style = inspect.styles[styleType];
                    if (style) {
                        return "[" + inspect.colors[style][0] + "m" + str + "[" + inspect.colors[style][1] + "m";
                    } else {
                        return str;
                    }
                }
                function isFunction(arg) {
                    return typeof arg === "function";
                }
                function isString(arg) {
                    return typeof arg === "string";
                }
                function isNumber(arg) {
                    return typeof arg === "number";
                }
                function isNull(arg) {
                    return arg === null;
                }
                function hasOwn(obj, prop) {
                    return Object.prototype.hasOwnProperty.call(obj, prop);
                }
                function isRegExp(re) {
                    return isObject(re) && objectToString(re) === "[object RegExp]";
                }
                function isObject(arg) {
                    return typeof arg === "object" && arg !== null;
                }
                function isError(e) {
                    return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
                }
                function isDate(d) {
                    return isObject(d) && objectToString(d) === "[object Date]";
                }
                function objectToString(o) {
                    return Object.prototype.toString.call(o);
                }
                function arrayToHash(array) {
                    var hash = {};
                    array.forEach(function(val, idx) {
                        hash[val] = true;
                    });
                    return hash;
                }
                function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                    var output = [];
                    for (var i = 0, l = value.length; i < l; ++i) {
                        if (hasOwn(value, String(i))) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
                        } else {
                            output.push("");
                        }
                    }
                    keys.forEach(function(key) {
                        if (!key.match(/^\d+$/)) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
                        }
                    });
                    return output;
                }
                function formatError(value) {
                    return "[" + Error.prototype.toString.call(value) + "]";
                }
                function formatValue(ctx, value, recurseTimes) {
                    // Provide a hook for user-specified inspect functions.
                    // Check that value is an object with an inspect function on it
                    if (ctx.customInspect && value && isFunction(value.inspect) && 
                    // Filter out the util module, it's inspect function is special
                    value.inspect !== inspect && 
                    // Also filter out any prototype objects using the circular check.
                    !(value.constructor && value.constructor.prototype === value)) {
                        var ret = value.inspect(recurseTimes, ctx);
                        if (!isString(ret)) {
                            ret = formatValue(ctx, ret, recurseTimes);
                        }
                        return ret;
                    }
                    // Primitive types cannot have properties
                    var primitive = formatPrimitive(ctx, value);
                    if (primitive) {
                        return primitive;
                    }
                    // Look up the keys of the object.
                    var keys = Object.keys(value);
                    var visibleKeys = arrayToHash(keys);
                    try {
                        if (ctx.showHidden && Object.getOwnPropertyNames) {
                            keys = Object.getOwnPropertyNames(value);
                        }
                    } catch (e) {
                        // ignore
                    }
                    // IE doesn't make error fields non-enumerable
                    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
                    if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
                        return formatError(value);
                    }
                    // Some type of object without properties can be shortcutted.
                    if (keys.length === 0) {
                        if (isFunction(value)) {
                            var name = value.name ? ": " + value.name : "";
                            return ctx.stylize("[Function" + name + "]", "special");
                        }
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                        }
                        if (isDate(value)) {
                            return ctx.stylize(Date.prototype.toString.call(value), "date");
                        }
                        if (isError(value)) {
                            return formatError(value);
                        }
                    }
                    var base = "", array = false, braces = [ "{", "}" ];
                    // Make Array say that they are Array
                    if (Array.isArray(value)) {
                        array = true;
                        braces = [ "[", "]" ];
                    }
                    // Make functions say that they are functions
                    if (isFunction(value)) {
                        var n = value.name ? ": " + value.name : "";
                        base = " [Function" + n + "]";
                    }
                    // Make RegExps say that they are RegExps
                    if (isRegExp(value)) {
                        base = " " + RegExp.prototype.toString.call(value);
                    }
                    // Make dates with properties first say the date
                    if (isDate(value)) {
                        base = " " + Date.prototype.toUTCString.call(value);
                    }
                    // Make error with message first say the error
                    if (isError(value)) {
                        base = " " + formatError(value);
                    }
                    if (keys.length === 0 && (!array || value.length == 0)) {
                        return braces[0] + base + braces[1];
                    }
                    if (recurseTimes < 0) {
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                        } else {
                            return ctx.stylize("[Object]", "special");
                        }
                    }
                    ctx.seen.push(value);
                    var output;
                    if (array) {
                        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                    } else {
                        output = keys.map(function(key) {
                            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                        });
                    }
                    ctx.seen.pop();
                    return reduceToSingleString(output, base, braces);
                }
                function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                    var name, str, desc;
                    desc = {
                        value: void 0
                    };
                    try {
                        // ie6  navigator.toString
                        // throws Error: Object doesn't support this property or method
                        desc.value = value[key];
                    } catch (e) {
                        // ignore
                    }
                    try {
                        // ie10  Object.getOwnPropertyDescriptor(window.location, 'hash')
                        // throws TypeError: Object doesn't support this action
                        if (Object.getOwnPropertyDescriptor) {
                            desc = Object.getOwnPropertyDescriptor(value, key) || desc;
                        }
                    } catch (e) {
                        // ignore
                    }
                    if (desc.get) {
                        if (desc.set) {
                            str = ctx.stylize("[Getter/Setter]", "special");
                        } else {
                            str = ctx.stylize("[Getter]", "special");
                        }
                    } else {
                        if (desc.set) {
                            str = ctx.stylize("[Setter]", "special");
                        }
                    }
                    if (!hasOwn(visibleKeys, key)) {
                        name = "[" + key + "]";
                    }
                    if (!str) {
                        if (ctx.seen.indexOf(desc.value) < 0) {
                            if (isNull(recurseTimes)) {
                                str = formatValue(ctx, desc.value, null);
                            } else {
                                str = formatValue(ctx, desc.value, recurseTimes - 1);
                            }
                            if (str.indexOf("\n") > -1) {
                                if (array) {
                                    str = str.split("\n").map(function(line) {
                                        return "  " + line;
                                    }).join("\n").substr(2);
                                } else {
                                    str = "\n" + str.split("\n").map(function(line) {
                                        return "   " + line;
                                    }).join("\n");
                                }
                            }
                        } else {
                            str = ctx.stylize("[Circular]", "special");
                        }
                    }
                    if (isUndefined(name)) {
                        if (array && key.match(/^\d+$/)) {
                            return str;
                        }
                        name = JSON.stringify("" + key);
                        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                            name = name.substr(1, name.length - 2);
                            name = ctx.stylize(name, "name");
                        } else {
                            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                            name = ctx.stylize(name, "string");
                        }
                    }
                    return name + ": " + str;
                }
                function formatPrimitive(ctx, value) {
                    if (isUndefined(value)) return ctx.stylize("undefined", "undefined");
                    if (isString(value)) {
                        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                        return ctx.stylize(simple, "string");
                    }
                    if (isNumber(value)) return ctx.stylize("" + value, "number");
                    if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
                    // For some reason typeof null is "object", so special case here.
                    if (isNull(value)) return ctx.stylize("null", "null");
                }
                function reduceToSingleString(output, base, braces) {
                    var numLinesEst = 0;
                    var length = output.reduce(function(prev, cur) {
                        numLinesEst++;
                        if (cur.indexOf("\n") >= 0) numLinesEst++;
                        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
                    }, 0);
                    if (length > 60) {
                        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
                    }
                    return braces[0] + base + " " + output.join(", ") + " " + braces[1];
                }
                function _extend(origin, add) {
                    // Don't do anything if add isn't an object
                    if (!add || !isObject(add)) return origin;
                    var keys = Object.keys(add);
                    var i = keys.length;
                    while (i--) {
                        origin[keys[i]] = add[keys[i]];
                    }
                    return origin;
                }
                /***/
            },
            /***/ "./node_modules/buffer/index.js": 
            /*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
            /***/ (__unused_webpack_module, exports, __webpack_require__) => {
                "use strict";
                /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
                /* eslint-disable no-proto */
                const base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js");
                const ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js");
                const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
                exports.Buffer = Buffer;
                exports.SlowBuffer = SlowBuffer;
                exports.INSPECT_MAX_BYTES = 50;
                const K_MAX_LENGTH = 2147483647;
                exports.kMaxLength = K_MAX_LENGTH
                /**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */;
                Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
                if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
                    console.error("This browser lacks typed array (Uint8Array) support which is required by " + "`buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
                }
                function typedArraySupport() {
                    // Can typed array instances can be augmented?
                    try {
                        const arr = new Uint8Array(1);
                        const proto = {
                            foo: function() {
                                return 42;
                            }
                        };
                        Object.setPrototypeOf(proto, Uint8Array.prototype);
                        Object.setPrototypeOf(arr, proto);
                        return arr.foo() === 42;
                    } catch (e) {
                        return false;
                    }
                }
                Object.defineProperty(Buffer.prototype, "parent", {
                    enumerable: true,
                    get: function() {
                        if (!Buffer.isBuffer(this)) return undefined;
                        return this.buffer;
                    }
                });
                Object.defineProperty(Buffer.prototype, "offset", {
                    enumerable: true,
                    get: function() {
                        if (!Buffer.isBuffer(this)) return undefined;
                        return this.byteOffset;
                    }
                });
                function createBuffer(length) {
                    if (length > K_MAX_LENGTH) {
                        throw new RangeError('The value "' + length + '" is invalid for option "size"');
                    }
                    // Return an augmented `Uint8Array` instance
                    const buf = new Uint8Array(length);
                    Object.setPrototypeOf(buf, Buffer.prototype);
                    return buf;
                }
                /**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */
                function Buffer(arg, encodingOrOffset, length) {
                    // Common case.
                    if (typeof arg === "number") {
                        if (typeof encodingOrOffset === "string") {
                            throw new TypeError('The "string" argument must be of type string. Received type number');
                        }
                        return allocUnsafe(arg);
                    }
                    return from(arg, encodingOrOffset, length);
                }
                Buffer.poolSize = 8192; // not used by this implementation
                function from(value, encodingOrOffset, length) {
                    if (typeof value === "string") {
                        return fromString(value, encodingOrOffset);
                    }
                    if (ArrayBuffer.isView(value)) {
                        return fromArrayView(value);
                    }
                    if (value == null) {
                        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof value);
                    }
                    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
                        return fromArrayBuffer(value, encodingOrOffset, length);
                    }
                    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
                        return fromArrayBuffer(value, encodingOrOffset, length);
                    }
                    if (typeof value === "number") {
                        throw new TypeError('The "value" argument must not be of type number. Received type number');
                    }
                    const valueOf = value.valueOf && value.valueOf();
                    if (valueOf != null && valueOf !== value) {
                        return Buffer.from(valueOf, encodingOrOffset, length);
                    }
                    const b = fromObject(value);
                    if (b) return b;
                    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
                        return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
                    }
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof value);
                }
                /**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
                Buffer.from = function(value, encodingOrOffset, length) {
                    return from(value, encodingOrOffset, length);
                }
                // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
                // https://github.com/feross/buffer/pull/148
                ;
                Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
                Object.setPrototypeOf(Buffer, Uint8Array);
                function assertSize(size) {
                    if (typeof size !== "number") {
                        throw new TypeError('"size" argument must be of type number');
                    } else if (size < 0) {
                        throw new RangeError('The value "' + size + '" is invalid for option "size"');
                    }
                }
                function alloc(size, fill, encoding) {
                    assertSize(size);
                    if (size <= 0) {
                        return createBuffer(size);
                    }
                    if (fill !== undefined) {
                        // Only pay attention to encoding if it's a string. This
                        // prevents accidentally sending in a number that would
                        // be interpreted as a start offset.
                        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
                    }
                    return createBuffer(size);
                }
                /**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
                Buffer.alloc = function(size, fill, encoding) {
                    return alloc(size, fill, encoding);
                };
                function allocUnsafe(size) {
                    assertSize(size);
                    return createBuffer(size < 0 ? 0 : checked(size) | 0);
                }
                /**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
                Buffer.allocUnsafe = function(size) {
                    return allocUnsafe(size);
                }
                /**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */;
                Buffer.allocUnsafeSlow = function(size) {
                    return allocUnsafe(size);
                };
                function fromString(string, encoding) {
                    if (typeof encoding !== "string" || encoding === "") {
                        encoding = "utf8";
                    }
                    if (!Buffer.isEncoding(encoding)) {
                        throw new TypeError("Unknown encoding: " + encoding);
                    }
                    const length = byteLength(string, encoding) | 0;
                    let buf = createBuffer(length);
                    const actual = buf.write(string, encoding);
                    if (actual !== length) {
                        // Writing a hex string, for example, that contains invalid characters will
                        // cause everything after the first invalid character to be ignored. (e.g.
                        // 'abxxcd' will be treated as 'ab')
                        buf = buf.slice(0, actual);
                    }
                    return buf;
                }
                function fromArrayLike(array) {
                    const length = array.length < 0 ? 0 : checked(array.length) | 0;
                    const buf = createBuffer(length);
                    for (let i = 0; i < length; i += 1) {
                        buf[i] = array[i] & 255;
                    }
                    return buf;
                }
                function fromArrayView(arrayView) {
                    if (isInstance(arrayView, Uint8Array)) {
                        const copy = new Uint8Array(arrayView);
                        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
                    }
                    return fromArrayLike(arrayView);
                }
                function fromArrayBuffer(array, byteOffset, length) {
                    if (byteOffset < 0 || array.byteLength < byteOffset) {
                        throw new RangeError('"offset" is outside of buffer bounds');
                    }
                    if (array.byteLength < byteOffset + (length || 0)) {
                        throw new RangeError('"length" is outside of buffer bounds');
                    }
                    let buf;
                    if (byteOffset === undefined && length === undefined) {
                        buf = new Uint8Array(array);
                    } else if (length === undefined) {
                        buf = new Uint8Array(array, byteOffset);
                    } else {
                        buf = new Uint8Array(array, byteOffset, length);
                    }
                    // Return an augmented `Uint8Array` instance
                    Object.setPrototypeOf(buf, Buffer.prototype);
                    return buf;
                }
                function fromObject(obj) {
                    if (Buffer.isBuffer(obj)) {
                        const len = checked(obj.length) | 0;
                        const buf = createBuffer(len);
                        if (buf.length === 0) {
                            return buf;
                        }
                        obj.copy(buf, 0, 0, len);
                        return buf;
                    }
                    if (obj.length !== undefined) {
                        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                            return createBuffer(0);
                        }
                        return fromArrayLike(obj);
                    }
                    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
                        return fromArrayLike(obj.data);
                    }
                }
                function checked(length) {
                    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
                    // length is NaN (which is otherwise coerced to zero.)
                    if (length >= K_MAX_LENGTH) {
                        throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
                    }
                    return length | 0;
                }
                function SlowBuffer(length) {
                    if (+length != length) {
                        // eslint-disable-line eqeqeq
                        length = 0;
                    }
                    return Buffer.alloc(+length);
                }
                Buffer.isBuffer = function isBuffer(b) {
                    return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
                };
                Buffer.compare = function compare(a, b) {
                    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
                    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
                    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                    }
                    if (a === b) return 0;
                    let x = a.length;
                    let y = b.length;
                    for (let i = 0, len = Math.min(x, y); i < len; ++i) {
                        if (a[i] !== b[i]) {
                            x = a[i];
                            y = b[i];
                            break;
                        }
                    }
                    if (x < y) return -1;
                    if (y < x) return 1;
                    return 0;
                };
                Buffer.isEncoding = function isEncoding(encoding) {
                    switch (String(encoding).toLowerCase()) {
                      case "hex":
                      case "utf8":
                      case "utf-8":
                      case "ascii":
                      case "latin1":
                      case "binary":
                      case "base64":
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return true;

                      default:
                        return false;
                    }
                };
                Buffer.concat = function concat(list, length) {
                    if (!Array.isArray(list)) {
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    }
                    if (list.length === 0) {
                        return Buffer.alloc(0);
                    }
                    let i;
                    if (length === undefined) {
                        length = 0;
                        for (i = 0; i < list.length; ++i) {
                            length += list[i].length;
                        }
                    }
                    const buffer = Buffer.allocUnsafe(length);
                    let pos = 0;
                    for (i = 0; i < list.length; ++i) {
                        let buf = list[i];
                        if (isInstance(buf, Uint8Array)) {
                            if (pos + buf.length > buffer.length) {
                                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                                buf.copy(buffer, pos);
                            } else {
                                Uint8Array.prototype.set.call(buffer, buf, pos);
                            }
                        } else if (!Buffer.isBuffer(buf)) {
                            throw new TypeError('"list" argument must be an Array of Buffers');
                        } else {
                            buf.copy(buffer, pos);
                        }
                        pos += buf.length;
                    }
                    return buffer;
                };
                function byteLength(string, encoding) {
                    if (Buffer.isBuffer(string)) {
                        return string.length;
                    }
                    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
                        return string.byteLength;
                    }
                    if (typeof string !== "string") {
                        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + "Received type " + typeof string);
                    }
                    const len = string.length;
                    const mustMatch = arguments.length > 2 && arguments[2] === true;
                    if (!mustMatch && len === 0) return 0;
                    // Use a for loop to avoid recursion
                    let loweredCase = false;
                    for (;;) {
                        switch (encoding) {
                          case "ascii":
                          case "latin1":
                          case "binary":
                            return len;

                          case "utf8":
                          case "utf-8":
                            return utf8ToBytes(string).length;

                          case "ucs2":
                          case "ucs-2":
                          case "utf16le":
                          case "utf-16le":
                            return len * 2;

                          case "hex":
                            return len >>> 1;

                          case "base64":
                            return base64ToBytes(string).length;

                          default:
                            if (loweredCase) {
                                return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
                            }
                            encoding = ("" + encoding).toLowerCase();
                            loweredCase = true;
                        }
                    }
                }
                Buffer.byteLength = byteLength;
                function slowToString(encoding, start, end) {
                    let loweredCase = false;
                    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
                    // property of a typed array.
                    // This behaves neither like String nor Uint8Array in that we set start/end
                    // to their upper/lower bounds if the value passed is out of range.
                    // undefined is handled specially as per ECMA-262 6th Edition,
                    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
                    if (start === undefined || start < 0) {
                        start = 0;
                    }
                    // Return early if start > this.length. Done here to prevent potential uint32
                    // coercion fail below.
                    if (start > this.length) {
                        return "";
                    }
                    if (end === undefined || end > this.length) {
                        end = this.length;
                    }
                    if (end <= 0) {
                        return "";
                    }
                    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
                    end >>>= 0;
                    start >>>= 0;
                    if (end <= start) {
                        return "";
                    }
                    if (!encoding) encoding = "utf8";
                    while (true) {
                        switch (encoding) {
                          case "hex":
                            return hexSlice(this, start, end);

                          case "utf8":
                          case "utf-8":
                            return utf8Slice(this, start, end);

                          case "ascii":
                            return asciiSlice(this, start, end);

                          case "latin1":
                          case "binary":
                            return latin1Slice(this, start, end);

                          case "base64":
                            return base64Slice(this, start, end);

                          case "ucs2":
                          case "ucs-2":
                          case "utf16le":
                          case "utf-16le":
                            return utf16leSlice(this, start, end);

                          default:
                            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                            encoding = (encoding + "").toLowerCase();
                            loweredCase = true;
                        }
                    }
                }
                // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
                // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
                // reliably in a browserify context because there could be multiple different
                // copies of the 'buffer' package in use. This method works even for Buffer
                // instances that were created from another copy of the `buffer` package.
                // See: https://github.com/feross/buffer/issues/154
                Buffer.prototype._isBuffer = true;
                function swap(b, n, m) {
                    const i = b[n];
                    b[n] = b[m];
                    b[m] = i;
                }
                Buffer.prototype.swap16 = function swap16() {
                    const len = this.length;
                    if (len % 2 !== 0) {
                        throw new RangeError("Buffer size must be a multiple of 16-bits");
                    }
                    for (let i = 0; i < len; i += 2) {
                        swap(this, i, i + 1);
                    }
                    return this;
                };
                Buffer.prototype.swap32 = function swap32() {
                    const len = this.length;
                    if (len % 4 !== 0) {
                        throw new RangeError("Buffer size must be a multiple of 32-bits");
                    }
                    for (let i = 0; i < len; i += 4) {
                        swap(this, i, i + 3);
                        swap(this, i + 1, i + 2);
                    }
                    return this;
                };
                Buffer.prototype.swap64 = function swap64() {
                    const len = this.length;
                    if (len % 8 !== 0) {
                        throw new RangeError("Buffer size must be a multiple of 64-bits");
                    }
                    for (let i = 0; i < len; i += 8) {
                        swap(this, i, i + 7);
                        swap(this, i + 1, i + 6);
                        swap(this, i + 2, i + 5);
                        swap(this, i + 3, i + 4);
                    }
                    return this;
                };
                Buffer.prototype.toString = function toString() {
                    const length = this.length;
                    if (length === 0) return "";
                    if (arguments.length === 0) return utf8Slice(this, 0, length);
                    return slowToString.apply(this, arguments);
                };
                Buffer.prototype.toLocaleString = Buffer.prototype.toString;
                Buffer.prototype.equals = function equals(b) {
                    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
                    if (this === b) return true;
                    return Buffer.compare(this, b) === 0;
                };
                Buffer.prototype.inspect = function inspect() {
                    let str = "";
                    const max = exports.INSPECT_MAX_BYTES;
                    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
                    if (this.length > max) str += " ... ";
                    return "<Buffer " + str + ">";
                };
                if (customInspectSymbol) {
                    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
                }
                Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
                    if (isInstance(target, Uint8Array)) {
                        target = Buffer.from(target, target.offset, target.byteLength);
                    }
                    if (!Buffer.isBuffer(target)) {
                        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + "Received type " + typeof target);
                    }
                    if (start === undefined) {
                        start = 0;
                    }
                    if (end === undefined) {
                        end = target ? target.length : 0;
                    }
                    if (thisStart === undefined) {
                        thisStart = 0;
                    }
                    if (thisEnd === undefined) {
                        thisEnd = this.length;
                    }
                    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                        throw new RangeError("out of range index");
                    }
                    if (thisStart >= thisEnd && start >= end) {
                        return 0;
                    }
                    if (thisStart >= thisEnd) {
                        return -1;
                    }
                    if (start >= end) {
                        return 1;
                    }
                    start >>>= 0;
                    end >>>= 0;
                    thisStart >>>= 0;
                    thisEnd >>>= 0;
                    if (this === target) return 0;
                    let x = thisEnd - thisStart;
                    let y = end - start;
                    const len = Math.min(x, y);
                    const thisCopy = this.slice(thisStart, thisEnd);
                    const targetCopy = target.slice(start, end);
                    for (let i = 0; i < len; ++i) {
                        if (thisCopy[i] !== targetCopy[i]) {
                            x = thisCopy[i];
                            y = targetCopy[i];
                            break;
                        }
                    }
                    if (x < y) return -1;
                    if (y < x) return 1;
                    return 0;
                }
                // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
                // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
                //
                // Arguments:
                // - buffer - a Buffer to search
                // - val - a string, Buffer, or number
                // - byteOffset - an index into `buffer`; will be clamped to an int32
                // - encoding - an optional encoding, relevant is val is a string
                // - dir - true for indexOf, false for lastIndexOf
                ;
                function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                    // Empty buffer means no match
                    if (buffer.length === 0) return -1;
                    // Normalize byteOffset
                    if (typeof byteOffset === "string") {
                        encoding = byteOffset;
                        byteOffset = 0;
                    } else if (byteOffset > 2147483647) {
                        byteOffset = 2147483647;
                    } else if (byteOffset < -2147483648) {
                        byteOffset = -2147483648;
                    }
                    byteOffset = +byteOffset; // Coerce to Number.
                    if (numberIsNaN(byteOffset)) {
                        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
                        byteOffset = dir ? 0 : buffer.length - 1;
                    }
                    // Normalize byteOffset: negative offsets start from the end of the buffer
                    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
                    if (byteOffset >= buffer.length) {
                        if (dir) return -1; else byteOffset = buffer.length - 1;
                    } else if (byteOffset < 0) {
                        if (dir) byteOffset = 0; else return -1;
                    }
                    // Normalize val
                    if (typeof val === "string") {
                        val = Buffer.from(val, encoding);
                    }
                    // Finally, search either indexOf (if dir is true) or lastIndexOf
                    if (Buffer.isBuffer(val)) {
                        // Special case: looking for empty string/buffer always fails
                        if (val.length === 0) {
                            return -1;
                        }
                        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                    } else if (typeof val === "number") {
                        val = val & 255; // Search for a byte value [0-255]
                        if (typeof Uint8Array.prototype.indexOf === "function") {
                            if (dir) {
                                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                            } else {
                                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                            }
                        }
                        return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir);
                    }
                    throw new TypeError("val must be string, number or Buffer");
                }
                function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                    let indexSize = 1;
                    let arrLength = arr.length;
                    let valLength = val.length;
                    if (encoding !== undefined) {
                        encoding = String(encoding).toLowerCase();
                        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                            if (arr.length < 2 || val.length < 2) {
                                return -1;
                            }
                            indexSize = 2;
                            arrLength /= 2;
                            valLength /= 2;
                            byteOffset /= 2;
                        }
                    }
                    function read(buf, i) {
                        if (indexSize === 1) {
                            return buf[i];
                        } else {
                            return buf.readUInt16BE(i * indexSize);
                        }
                    }
                    let i;
                    if (dir) {
                        let foundIndex = -1;
                        for (i = byteOffset; i < arrLength; i++) {
                            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                                if (foundIndex === -1) foundIndex = i;
                                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
                            } else {
                                if (foundIndex !== -1) i -= i - foundIndex;
                                foundIndex = -1;
                            }
                        }
                    } else {
                        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
                        for (i = byteOffset; i >= 0; i--) {
                            let found = true;
                            for (let j = 0; j < valLength; j++) {
                                if (read(arr, i + j) !== read(val, j)) {
                                    found = false;
                                    break;
                                }
                            }
                            if (found) return i;
                        }
                    }
                    return -1;
                }
                Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
                    return this.indexOf(val, byteOffset, encoding) !== -1;
                };
                Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
                    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
                };
                Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
                    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
                };
                function hexWrite(buf, string, offset, length) {
                    offset = Number(offset) || 0;
                    const remaining = buf.length - offset;
                    if (!length) {
                        length = remaining;
                    } else {
                        length = Number(length);
                        if (length > remaining) {
                            length = remaining;
                        }
                    }
                    const strLen = string.length;
                    if (length > strLen / 2) {
                        length = strLen / 2;
                    }
                    let i;
                    for (i = 0; i < length; ++i) {
                        const parsed = parseInt(string.substr(i * 2, 2), 16);
                        if (numberIsNaN(parsed)) return i;
                        buf[offset + i] = parsed;
                    }
                    return i;
                }
                function utf8Write(buf, string, offset, length) {
                    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
                }
                function asciiWrite(buf, string, offset, length) {
                    return blitBuffer(asciiToBytes(string), buf, offset, length);
                }
                function base64Write(buf, string, offset, length) {
                    return blitBuffer(base64ToBytes(string), buf, offset, length);
                }
                function ucs2Write(buf, string, offset, length) {
                    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
                }
                Buffer.prototype.write = function write(string, offset, length, encoding) {
                    // Buffer#write(string)
                    if (offset === undefined) {
                        encoding = "utf8";
                        length = this.length;
                        offset = 0;
                        // Buffer#write(string, encoding)
                    } else if (length === undefined && typeof offset === "string") {
                        encoding = offset;
                        length = this.length;
                        offset = 0;
                        // Buffer#write(string, offset[, length][, encoding])
                    } else if (isFinite(offset)) {
                        offset = offset >>> 0;
                        if (isFinite(length)) {
                            length = length >>> 0;
                            if (encoding === undefined) encoding = "utf8";
                        } else {
                            encoding = length;
                            length = undefined;
                        }
                    } else {
                        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                    }
                    const remaining = this.length - offset;
                    if (length === undefined || length > remaining) length = remaining;
                    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
                        throw new RangeError("Attempt to write outside buffer bounds");
                    }
                    if (!encoding) encoding = "utf8";
                    let loweredCase = false;
                    for (;;) {
                        switch (encoding) {
                          case "hex":
                            return hexWrite(this, string, offset, length);

                          case "utf8":
                          case "utf-8":
                            return utf8Write(this, string, offset, length);

                          case "ascii":
                          case "latin1":
                          case "binary":
                            return asciiWrite(this, string, offset, length);

                          case "base64":
                            // Warning: maxLength not taken into account in base64Write
                            return base64Write(this, string, offset, length);

                          case "ucs2":
                          case "ucs-2":
                          case "utf16le":
                          case "utf-16le":
                            return ucs2Write(this, string, offset, length);

                          default:
                            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                            encoding = ("" + encoding).toLowerCase();
                            loweredCase = true;
                        }
                    }
                };
                Buffer.prototype.toJSON = function toJSON() {
                    return {
                        type: "Buffer",
                        data: Array.prototype.slice.call(this._arr || this, 0)
                    };
                };
                function base64Slice(buf, start, end) {
                    if (start === 0 && end === buf.length) {
                        return base64.fromByteArray(buf);
                    } else {
                        return base64.fromByteArray(buf.slice(start, end));
                    }
                }
                function utf8Slice(buf, start, end) {
                    end = Math.min(buf.length, end);
                    const res = [];
                    let i = start;
                    while (i < end) {
                        const firstByte = buf[i];
                        let codePoint = null;
                        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                        if (i + bytesPerSequence <= end) {
                            let secondByte, thirdByte, fourthByte, tempCodePoint;
                            switch (bytesPerSequence) {
                              case 1:
                                if (firstByte < 128) {
                                    codePoint = firstByte;
                                }
                                break;

                              case 2:
                                secondByte = buf[i + 1];
                                if ((secondByte & 192) === 128) {
                                    tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                                    if (tempCodePoint > 127) {
                                        codePoint = tempCodePoint;
                                    }
                                }
                                break;

                              case 3:
                                secondByte = buf[i + 1];
                                thirdByte = buf[i + 2];
                                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                                    tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                                    if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                                        codePoint = tempCodePoint;
                                    }
                                }
                                break;

                              case 4:
                                secondByte = buf[i + 1];
                                thirdByte = buf[i + 2];
                                fourthByte = buf[i + 3];
                                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                                    tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                                    if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                                        codePoint = tempCodePoint;
                                    }
                                }
                            }
                        }
                        if (codePoint === null) {
                            // we did not generate a valid codePoint so insert a
                            // replacement char (U+FFFD) and advance only 1 byte
                            codePoint = 65533;
                            bytesPerSequence = 1;
                        } else if (codePoint > 65535) {
                            // encode to utf16 (surrogate pair dance)
                            codePoint -= 65536;
                            res.push(codePoint >>> 10 & 1023 | 55296);
                            codePoint = 56320 | codePoint & 1023;
                        }
                        res.push(codePoint);
                        i += bytesPerSequence;
                    }
                    return decodeCodePointsArray(res);
                }
                // Based on http://stackoverflow.com/a/22747272/680742, the browser with
                // the lowest limit is Chrome, with 0x10000 args.
                // We go 1 magnitude less, for safety
                const MAX_ARGUMENTS_LENGTH = 4096;
                function decodeCodePointsArray(codePoints) {
                    const len = codePoints.length;
                    if (len <= MAX_ARGUMENTS_LENGTH) {
                        return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
                    }
                    // Decode in chunks to avoid "call stack size exceeded".
                    let res = "";
                    let i = 0;
                    while (i < len) {
                        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
                    }
                    return res;
                }
                function asciiSlice(buf, start, end) {
                    let ret = "";
                    end = Math.min(buf.length, end);
                    for (let i = start; i < end; ++i) {
                        ret += String.fromCharCode(buf[i] & 127);
                    }
                    return ret;
                }
                function latin1Slice(buf, start, end) {
                    let ret = "";
                    end = Math.min(buf.length, end);
                    for (let i = start; i < end; ++i) {
                        ret += String.fromCharCode(buf[i]);
                    }
                    return ret;
                }
                function hexSlice(buf, start, end) {
                    const len = buf.length;
                    if (!start || start < 0) start = 0;
                    if (!end || end < 0 || end > len) end = len;
                    let out = "";
                    for (let i = start; i < end; ++i) {
                        out += hexSliceLookupTable[buf[i]];
                    }
                    return out;
                }
                function utf16leSlice(buf, start, end) {
                    const bytes = buf.slice(start, end);
                    let res = "";
                    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
                    for (let i = 0; i < bytes.length - 1; i += 2) {
                        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
                    }
                    return res;
                }
                Buffer.prototype.slice = function slice(start, end) {
                    const len = this.length;
                    start = ~~start;
                    end = end === undefined ? len : ~~end;
                    if (start < 0) {
                        start += len;
                        if (start < 0) start = 0;
                    } else if (start > len) {
                        start = len;
                    }
                    if (end < 0) {
                        end += len;
                        if (end < 0) end = 0;
                    } else if (end > len) {
                        end = len;
                    }
                    if (end < start) end = start;
                    const newBuf = this.subarray(start, end);
                    // Return an augmented `Uint8Array` instance
                    Object.setPrototypeOf(newBuf, Buffer.prototype);
                    return newBuf;
                }
                /*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */;
                function checkOffset(offset, ext, length) {
                    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
                    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
                }
                Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
                    offset = offset >>> 0;
                    byteLength = byteLength >>> 0;
                    if (!noAssert) checkOffset(offset, byteLength, this.length);
                    let val = this[offset];
                    let mul = 1;
                    let i = 0;
                    while (++i < byteLength && (mul *= 256)) {
                        val += this[offset + i] * mul;
                    }
                    return val;
                };
                Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
                    offset = offset >>> 0;
                    byteLength = byteLength >>> 0;
                    if (!noAssert) {
                        checkOffset(offset, byteLength, this.length);
                    }
                    let val = this[offset + --byteLength];
                    let mul = 1;
                    while (byteLength > 0 && (mul *= 256)) {
                        val += this[offset + --byteLength] * mul;
                    }
                    return val;
                };
                Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                    offset = offset >>> 0;
                    if (!noAssert) checkOffset(offset, 1, this.length);
                    return this[offset];
                };
                Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                    offset = offset >>> 0;
                    if (!noAssert) checkOffset(offset, 2, this.length);
                    return this[offset] | this[offset + 1] << 8;
                };
                Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                    offset = offset >>> 0;
                    if (!noAssert) checkOffset(offset, 2, this.length);
                    return this[offset] << 8 | this[offset + 1];
                };
                Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                    offset = offset >>> 0;
                    if (!noAssert) checkOffset(offset, 4, this.length);
                    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
                };
                Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                    offset = offset >>> 0;
                    if (!noAssert) checkOffset(offset, 4, this.length);
                    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
                };
                Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
                    offset = offset >>> 0;
                    validateNumber(offset, "offset");
                    const first = this[offset];
                    const last = this[offset + 7];
                    if (first === undefined || last === undefined) {
                        boundsError(offset, this.length - 8);
                    }
                    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
                    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
                    return BigInt(lo) + (BigInt(hi) << BigInt(32));
                });
                Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
                    offset = offset >>> 0;
                    validateNumber(offset, "offset");
                    const first = this[offset];
                    const last = this[offset + 7];
                    if (first === undefined || last === undefined) {
                        boundsError(offset, this.length - 8);
                    }
                    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
                    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
                    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
                });
                Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
                    offset = offset >>> 0;
                    byteLength = byteLength >>> 0;
                    if (!noAssert) checkOffset(offset, byteLength, this.length);
                    let val = this[offset];
                    let mul = 1;
                    let i = 0;
                    while (++i < byteLength && (mul *= 256)) {
                        val += this[offset + i] * mul;
                    }
                    mul *= 128;
                    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
                    return val;
                };
                Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
                    offset = offset >>> 0;
                    byteLength = byteLength >>> 0;
                    if (!noAssert) checkOffset(offset, byteLength, this.length);
                    let i = byteLength;
                    let mul = 1;
                    let val = this[offset + --i];
                    while (i > 0 && (mul *= 256)) {
                        val += this[offset + --i] * mul;
                    }
                    mul *= 128;
                    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
                    return val;
                };
                Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                    offset = offset >>> 0;
                    if (!noAssert) checkOffset(offset, 1, this.length);
                    if (!(this[offset] & 128)) return this[offset];
                    return (255 - this[offset] + 1) * -1;
                };
                Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                    offset = offset >>> 0;
                    if (!noAssert) checkOffset(offset, 2, this.length);
                    const val = this[offset] | this[offset + 1] << 8;
                    return val & 32768 ? val | 4294901760 : val;
                };
                Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                    offset = offset >>> 0;
                    if (!noAssert) checkOffset(offset, 2, this.length);
                    const val = this[offset + 1] | this[offset] << 8;
                    return val & 32768 ? val | 4294901760 : val;
                };
                Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                    offset = offset >>> 0;
                    if (!noAssert) checkOffset(offset, 4, this.length);
                    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
                };
                Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                    offset = offset >>> 0;
                    if (!noAssert) checkOffset(offset, 4, this.length);
                    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
                };
                Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
                    offset = offset >>> 0;
                    validateNumber(offset, "offset");
                    const first = this[offset];
                    const last = this[offset + 7];
                    if (first === undefined || last === undefined) {
                        boundsError(offset, this.length - 8);
                    }
                    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24); // Overflow
                    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
                });
                Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
                    offset = offset >>> 0;
                    validateNumber(offset, "offset");
                    const first = this[offset];
                    const last = this[offset + 7];
                    if (first === undefined || last === undefined) {
                        boundsError(offset, this.length - 8);
                    }
                    const val = (first << 24) + // Overflow
                    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
                    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
                });
                Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                    offset = offset >>> 0;
                    if (!noAssert) checkOffset(offset, 4, this.length);
                    return ieee754.read(this, offset, true, 23, 4);
                };
                Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                    offset = offset >>> 0;
                    if (!noAssert) checkOffset(offset, 4, this.length);
                    return ieee754.read(this, offset, false, 23, 4);
                };
                Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                    offset = offset >>> 0;
                    if (!noAssert) checkOffset(offset, 8, this.length);
                    return ieee754.read(this, offset, true, 52, 8);
                };
                Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                    offset = offset >>> 0;
                    if (!noAssert) checkOffset(offset, 8, this.length);
                    return ieee754.read(this, offset, false, 52, 8);
                };
                function checkInt(buf, value, offset, ext, max, min) {
                    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
                    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
                    if (offset + ext > buf.length) throw new RangeError("Index out of range");
                }
                Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset = offset >>> 0;
                    byteLength = byteLength >>> 0;
                    if (!noAssert) {
                        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
                        checkInt(this, value, offset, byteLength, maxBytes, 0);
                    }
                    let mul = 1;
                    let i = 0;
                    this[offset] = value & 255;
                    while (++i < byteLength && (mul *= 256)) {
                        this[offset + i] = value / mul & 255;
                    }
                    return offset + byteLength;
                };
                Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset = offset >>> 0;
                    byteLength = byteLength >>> 0;
                    if (!noAssert) {
                        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
                        checkInt(this, value, offset, byteLength, maxBytes, 0);
                    }
                    let i = byteLength - 1;
                    let mul = 1;
                    this[offset + i] = value & 255;
                    while (--i >= 0 && (mul *= 256)) {
                        this[offset + i] = value / mul & 255;
                    }
                    return offset + byteLength;
                };
                Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                    value = +value;
                    offset = offset >>> 0;
                    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
                    this[offset] = value & 255;
                    return offset + 1;
                };
                Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                    value = +value;
                    offset = offset >>> 0;
                    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
                    this[offset] = value & 255;
                    this[offset + 1] = value >>> 8;
                    return offset + 2;
                };
                Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                    value = +value;
                    offset = offset >>> 0;
                    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
                    this[offset] = value >>> 8;
                    this[offset + 1] = value & 255;
                    return offset + 2;
                };
                Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                    value = +value;
                    offset = offset >>> 0;
                    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
                    this[offset + 3] = value >>> 24;
                    this[offset + 2] = value >>> 16;
                    this[offset + 1] = value >>> 8;
                    this[offset] = value & 255;
                    return offset + 4;
                };
                Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                    value = +value;
                    offset = offset >>> 0;
                    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
                    this[offset] = value >>> 24;
                    this[offset + 1] = value >>> 16;
                    this[offset + 2] = value >>> 8;
                    this[offset + 3] = value & 255;
                    return offset + 4;
                };
                function wrtBigUInt64LE(buf, value, offset, min, max) {
                    checkIntBI(value, min, max, buf, offset, 7);
                    let lo = Number(value & BigInt(4294967295));
                    buf[offset++] = lo;
                    lo = lo >> 8;
                    buf[offset++] = lo;
                    lo = lo >> 8;
                    buf[offset++] = lo;
                    lo = lo >> 8;
                    buf[offset++] = lo;
                    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
                    buf[offset++] = hi;
                    hi = hi >> 8;
                    buf[offset++] = hi;
                    hi = hi >> 8;
                    buf[offset++] = hi;
                    hi = hi >> 8;
                    buf[offset++] = hi;
                    return offset;
                }
                function wrtBigUInt64BE(buf, value, offset, min, max) {
                    checkIntBI(value, min, max, buf, offset, 7);
                    let lo = Number(value & BigInt(4294967295));
                    buf[offset + 7] = lo;
                    lo = lo >> 8;
                    buf[offset + 6] = lo;
                    lo = lo >> 8;
                    buf[offset + 5] = lo;
                    lo = lo >> 8;
                    buf[offset + 4] = lo;
                    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
                    buf[offset + 3] = hi;
                    hi = hi >> 8;
                    buf[offset + 2] = hi;
                    hi = hi >> 8;
                    buf[offset + 1] = hi;
                    hi = hi >> 8;
                    buf[offset] = hi;
                    return offset + 8;
                }
                Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
                    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
                });
                Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
                    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
                });
                Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset = offset >>> 0;
                    if (!noAssert) {
                        const limit = Math.pow(2, 8 * byteLength - 1);
                        checkInt(this, value, offset, byteLength, limit - 1, -limit);
                    }
                    let i = 0;
                    let mul = 1;
                    let sub = 0;
                    this[offset] = value & 255;
                    while (++i < byteLength && (mul *= 256)) {
                        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                            sub = 1;
                        }
                        this[offset + i] = (value / mul >> 0) - sub & 255;
                    }
                    return offset + byteLength;
                };
                Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
                    value = +value;
                    offset = offset >>> 0;
                    if (!noAssert) {
                        const limit = Math.pow(2, 8 * byteLength - 1);
                        checkInt(this, value, offset, byteLength, limit - 1, -limit);
                    }
                    let i = byteLength - 1;
                    let mul = 1;
                    let sub = 0;
                    this[offset + i] = value & 255;
                    while (--i >= 0 && (mul *= 256)) {
                        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                            sub = 1;
                        }
                        this[offset + i] = (value / mul >> 0) - sub & 255;
                    }
                    return offset + byteLength;
                };
                Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                    value = +value;
                    offset = offset >>> 0;
                    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
                    if (value < 0) value = 255 + value + 1;
                    this[offset] = value & 255;
                    return offset + 1;
                };
                Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                    value = +value;
                    offset = offset >>> 0;
                    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
                    this[offset] = value & 255;
                    this[offset + 1] = value >>> 8;
                    return offset + 2;
                };
                Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                    value = +value;
                    offset = offset >>> 0;
                    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
                    this[offset] = value >>> 8;
                    this[offset + 1] = value & 255;
                    return offset + 2;
                };
                Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                    value = +value;
                    offset = offset >>> 0;
                    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
                    this[offset] = value & 255;
                    this[offset + 1] = value >>> 8;
                    this[offset + 2] = value >>> 16;
                    this[offset + 3] = value >>> 24;
                    return offset + 4;
                };
                Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                    value = +value;
                    offset = offset >>> 0;
                    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
                    if (value < 0) value = 4294967295 + value + 1;
                    this[offset] = value >>> 24;
                    this[offset + 1] = value >>> 16;
                    this[offset + 2] = value >>> 8;
                    this[offset + 3] = value & 255;
                    return offset + 4;
                };
                Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
                    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
                });
                Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
                    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
                });
                function checkIEEE754(buf, value, offset, ext, max, min) {
                    if (offset + ext > buf.length) throw new RangeError("Index out of range");
                    if (offset < 0) throw new RangeError("Index out of range");
                }
                function writeFloat(buf, value, offset, littleEndian, noAssert) {
                    value = +value;
                    offset = offset >>> 0;
                    if (!noAssert) {
                        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
                    }
                    ieee754.write(buf, value, offset, littleEndian, 23, 4);
                    return offset + 4;
                }
                Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                    return writeFloat(this, value, offset, true, noAssert);
                };
                Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                    return writeFloat(this, value, offset, false, noAssert);
                };
                function writeDouble(buf, value, offset, littleEndian, noAssert) {
                    value = +value;
                    offset = offset >>> 0;
                    if (!noAssert) {
                        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
                    }
                    ieee754.write(buf, value, offset, littleEndian, 52, 8);
                    return offset + 8;
                }
                Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                    return writeDouble(this, value, offset, true, noAssert);
                };
                Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                    return writeDouble(this, value, offset, false, noAssert);
                }
                // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
                ;
                Buffer.prototype.copy = function copy(target, targetStart, start, end) {
                    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
                    if (!start) start = 0;
                    if (!end && end !== 0) end = this.length;
                    if (targetStart >= target.length) targetStart = target.length;
                    if (!targetStart) targetStart = 0;
                    if (end > 0 && end < start) end = start;
                    // Copy 0 bytes; we're done
                    if (end === start) return 0;
                    if (target.length === 0 || this.length === 0) return 0;
                    // Fatal error conditions
                    if (targetStart < 0) {
                        throw new RangeError("targetStart out of bounds");
                    }
                    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
                    if (end < 0) throw new RangeError("sourceEnd out of bounds");
                    // Are we oob?
                    if (end > this.length) end = this.length;
                    if (target.length - targetStart < end - start) {
                        end = target.length - targetStart + start;
                    }
                    const len = end - start;
                    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
                        // Use built-in when available, missing from IE11
                        this.copyWithin(targetStart, start, end);
                    } else {
                        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
                    }
                    return len;
                }
                // Usage:
                //    buffer.fill(number[, offset[, end]])
                //    buffer.fill(buffer[, offset[, end]])
                //    buffer.fill(string[, offset[, end]][, encoding])
                ;
                Buffer.prototype.fill = function fill(val, start, end, encoding) {
                    // Handle string cases:
                    if (typeof val === "string") {
                        if (typeof start === "string") {
                            encoding = start;
                            start = 0;
                            end = this.length;
                        } else if (typeof end === "string") {
                            encoding = end;
                            end = this.length;
                        }
                        if (encoding !== undefined && typeof encoding !== "string") {
                            throw new TypeError("encoding must be a string");
                        }
                        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
                            throw new TypeError("Unknown encoding: " + encoding);
                        }
                        if (val.length === 1) {
                            const code = val.charCodeAt(0);
                            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                                // Fast path: If `val` fits into a single byte, use that numeric value.
                                val = code;
                            }
                        }
                    } else if (typeof val === "number") {
                        val = val & 255;
                    } else if (typeof val === "boolean") {
                        val = Number(val);
                    }
                    // Invalid ranges are not set to a default, so can range check early.
                    if (start < 0 || this.length < start || this.length < end) {
                        throw new RangeError("Out of range index");
                    }
                    if (end <= start) {
                        return this;
                    }
                    start = start >>> 0;
                    end = end === undefined ? this.length : end >>> 0;
                    if (!val) val = 0;
                    let i;
                    if (typeof val === "number") {
                        for (i = start; i < end; ++i) {
                            this[i] = val;
                        }
                    } else {
                        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
                        const len = bytes.length;
                        if (len === 0) {
                            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
                        }
                        for (i = 0; i < end - start; ++i) {
                            this[i + start] = bytes[i % len];
                        }
                    }
                    return this;
                }
                // CUSTOM ERRORS
                // =============
                // Simplified versions from Node, changed for Buffer-only usage
                ;
                const errors = {};
                function E(sym, getMessage, Base) {
                    errors[sym] = class NodeError extends Base {
                        constructor() {
                            super();
                            Object.defineProperty(this, "message", {
                                value: getMessage.apply(this, arguments),
                                writable: true,
                                configurable: true
                            });
                            // Add the error code to the name to include it in the stack trace.
                            this.name = `${this.name} [${sym}]`;
                            // Access the stack to generate the error message including the error code
                            // from the name.
                            this.stack; // eslint-disable-line no-unused-expressions
                            // Reset the name to the actual name.
                            delete this.name;
                        }
                        get code() {
                            return sym;
                        }
                        set code(value) {
                            Object.defineProperty(this, "code", {
                                configurable: true,
                                enumerable: true,
                                value: value,
                                writable: true
                            });
                        }
                        toString() {
                            return `${this.name} [${sym}]: ${this.message}`;
                        }
                    };
                }
                E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
                    if (name) {
                        return `${name} is outside of buffer bounds`;
                    }
                    return "Attempt to access memory outside buffer bounds";
                }, RangeError);
                E("ERR_INVALID_ARG_TYPE", function(name, actual) {
                    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
                }, TypeError);
                E("ERR_OUT_OF_RANGE", function(str, range, input) {
                    let msg = `The value of "${str}" is out of range.`;
                    let received = input;
                    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
                        received = addNumericalSeparator(String(input));
                    } else if (typeof input === "bigint") {
                        received = String(input);
                        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
                            received = addNumericalSeparator(received);
                        }
                        received += "n";
                    }
                    msg += ` It must be ${range}. Received ${received}`;
                    return msg;
                }, RangeError);
                function addNumericalSeparator(val) {
                    let res = "";
                    let i = val.length;
                    const start = val[0] === "-" ? 1 : 0;
                    for (;i >= start + 4; i -= 3) {
                        res = `_${val.slice(i - 3, i)}${res}`;
                    }
                    return `${val.slice(0, i)}${res}`;
                }
                // CHECK FUNCTIONS
                // ===============
                function checkBounds(buf, offset, byteLength) {
                    validateNumber(offset, "offset");
                    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
                        boundsError(offset, buf.length - (byteLength + 1));
                    }
                }
                function checkIntBI(value, min, max, buf, offset, byteLength) {
                    if (value > max || value < min) {
                        const n = typeof min === "bigint" ? "n" : "";
                        let range;
                        if (byteLength > 3) {
                            if (min === 0 || min === BigInt(0)) {
                                range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
                            } else {
                                range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
                            }
                        } else {
                            range = `>= ${min}${n} and <= ${max}${n}`;
                        }
                        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
                    }
                    checkBounds(buf, offset, byteLength);
                }
                function validateNumber(value, name) {
                    if (typeof value !== "number") {
                        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
                    }
                }
                function boundsError(value, length, type) {
                    if (Math.floor(value) !== value) {
                        validateNumber(value, type);
                        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
                    }
                    if (length < 0) {
                        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
                    }
                    throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
                }
                // HELPER FUNCTIONS
                // ================
                const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
                function base64clean(str) {
                    // Node takes equal signs as end of the Base64 encoding
                    str = str.split("=")[0];
                    // Node strips out invalid characters like \n and \t from the string, base64-js does not
                    str = str.trim().replace(INVALID_BASE64_RE, "");
                    // Node converts strings with length < 2 to ''
                    if (str.length < 2) return "";
                    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
                    while (str.length % 4 !== 0) {
                        str = str + "=";
                    }
                    return str;
                }
                function utf8ToBytes(string, units) {
                    units = units || Infinity;
                    let codePoint;
                    const length = string.length;
                    let leadSurrogate = null;
                    const bytes = [];
                    for (let i = 0; i < length; ++i) {
                        codePoint = string.charCodeAt(i);
                        // is surrogate component
                        if (codePoint > 55295 && codePoint < 57344) {
                            // last char was a lead
                            if (!leadSurrogate) {
                                // no lead yet
                                if (codePoint > 56319) {
                                    // unexpected trail
                                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                                    continue;
                                } else if (i + 1 === length) {
                                    // unpaired lead
                                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                                    continue;
                                }
                                // valid lead
                                leadSurrogate = codePoint;
                                continue;
                            }
                            // 2 leads in a row
                            if (codePoint < 56320) {
                                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                                leadSurrogate = codePoint;
                                continue;
                            }
                            // valid surrogate pair
                            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
                        } else if (leadSurrogate) {
                            // valid bmp char, but last char was a lead
                            if ((units -= 3) > -1) bytes.push(239, 191, 189);
                        }
                        leadSurrogate = null;
                        // encode utf8
                        if (codePoint < 128) {
                            if ((units -= 1) < 0) break;
                            bytes.push(codePoint);
                        } else if (codePoint < 2048) {
                            if ((units -= 2) < 0) break;
                            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
                        } else if (codePoint < 65536) {
                            if ((units -= 3) < 0) break;
                            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                        } else if (codePoint < 1114112) {
                            if ((units -= 4) < 0) break;
                            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                        } else {
                            throw new Error("Invalid code point");
                        }
                    }
                    return bytes;
                }
                function asciiToBytes(str) {
                    const byteArray = [];
                    for (let i = 0; i < str.length; ++i) {
                        // Node's code seems to be doing this and not & 0x7F..
                        byteArray.push(str.charCodeAt(i) & 255);
                    }
                    return byteArray;
                }
                function utf16leToBytes(str, units) {
                    let c, hi, lo;
                    const byteArray = [];
                    for (let i = 0; i < str.length; ++i) {
                        if ((units -= 2) < 0) break;
                        c = str.charCodeAt(i);
                        hi = c >> 8;
                        lo = c % 256;
                        byteArray.push(lo);
                        byteArray.push(hi);
                    }
                    return byteArray;
                }
                function base64ToBytes(str) {
                    return base64.toByteArray(base64clean(str));
                }
                function blitBuffer(src, dst, offset, length) {
                    let i;
                    for (i = 0; i < length; ++i) {
                        if (i + offset >= dst.length || i >= src.length) break;
                        dst[i + offset] = src[i];
                    }
                    return i;
                }
                // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
                // the `instanceof` check but they should be treated as of that type.
                // See: https://github.com/feross/buffer/issues/166
                function isInstance(obj, type) {
                    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
                }
                function numberIsNaN(obj) {
                    // For IE11 support
                    return obj !== obj; // eslint-disable-line no-self-compare
                }
                // Create lookup table for `toString('hex')`
                // See: https://github.com/feross/buffer/issues/219
                const hexSliceLookupTable = function() {
                    const alphabet = "0123456789abcdef";
                    const table = new Array(256);
                    for (let i = 0; i < 16; ++i) {
                        const i16 = i * 16;
                        for (let j = 0; j < 16; ++j) {
                            table[i16 + j] = alphabet[i] + alphabet[j];
                        }
                    }
                    return table;
                }();
                // Return not function with Error if BigInt not supported
                function defineBigIntMethod(fn) {
                    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
                }
                function BufferBigIntNotDefined() {
                    throw new Error("BigInt not supported");
                }
                /***/
            },
            /***/ "./node_modules/clone/clone.js": 
            /*!*************************************!*\
  !*** ./node_modules/clone/clone.js ***!
  \*************************************/
            /***/ (module, __unused_webpack_exports, __webpack_require__) => {
                /* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
                var clone = function() {
                    "use strict";
                    function _instanceof(obj, type) {
                        return type != null && obj instanceof type;
                    }
                    var nativeMap;
                    try {
                        nativeMap = Map;
                    } catch (_) {
                        // maybe a reference error because no `Map`. Give it a dummy value that no
                        // value will ever be an instanceof.
                        nativeMap = function() {};
                    }
                    var nativeSet;
                    try {
                        nativeSet = Set;
                    } catch (_) {
                        nativeSet = function() {};
                    }
                    var nativePromise;
                    try {
                        nativePromise = Promise;
                    } catch (_) {
                        nativePromise = function() {};
                    }
                    /**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
 * @param `includeNonEnumerable` - set to true if the non-enumerable properties
 *    should be cloned as well. Non-enumerable properties on the prototype
 *    chain will be ignored. (optional - false by default)
*/
                    function clone(parent, circular, depth, prototype, includeNonEnumerable) {
                        if (typeof circular === "object") {
                            depth = circular.depth;
                            prototype = circular.prototype;
                            includeNonEnumerable = circular.includeNonEnumerable;
                            circular = circular.circular;
                        }
                        // maintain two arrays for circular references, where corresponding parents
                        // and children have the same index
                        var allParents = [];
                        var allChildren = [];
                        var useBuffer = typeof Buffer != "undefined";
                        if (typeof circular == "undefined") circular = true;
                        if (typeof depth == "undefined") depth = Infinity;
                        // recurse this function so we don't reset allParents and allChildren
                        function _clone(parent, depth) {
                            // cloning null always returns null
                            if (parent === null) return null;
                            if (depth === 0) return parent;
                            var child;
                            var proto;
                            if (typeof parent != "object") {
                                return parent;
                            }
                            if (_instanceof(parent, nativeMap)) {
                                child = new nativeMap();
                            } else if (_instanceof(parent, nativeSet)) {
                                child = new nativeSet();
                            } else if (_instanceof(parent, nativePromise)) {
                                child = new nativePromise(function(resolve, reject) {
                                    parent.then(function(value) {
                                        resolve(_clone(value, depth - 1));
                                    }, function(err) {
                                        reject(_clone(err, depth - 1));
                                    });
                                });
                            } else if (clone.__isArray(parent)) {
                                child = [];
                            } else if (clone.__isRegExp(parent)) {
                                child = new RegExp(parent.source, __getRegExpFlags(parent));
                                if (parent.lastIndex) child.lastIndex = parent.lastIndex;
                            } else if (clone.__isDate(parent)) {
                                child = new Date(parent.getTime());
                            } else if (useBuffer && Buffer.isBuffer(parent)) {
                                if (Buffer.allocUnsafe) {
                                    // Node.js >= 4.5.0
                                    child = Buffer.allocUnsafe(parent.length);
                                } else {
                                    // Older Node.js versions
                                    child = new Buffer(parent.length);
                                }
                                parent.copy(child);
                                return child;
                            } else if (_instanceof(parent, Error)) {
                                child = Object.create(parent);
                            } else {
                                if (typeof prototype == "undefined") {
                                    proto = Object.getPrototypeOf(parent);
                                    child = Object.create(proto);
                                } else {
                                    child = Object.create(prototype);
                                    proto = prototype;
                                }
                            }
                            if (circular) {
                                var index = allParents.indexOf(parent);
                                if (index != -1) {
                                    return allChildren[index];
                                }
                                allParents.push(parent);
                                allChildren.push(child);
                            }
                            if (_instanceof(parent, nativeMap)) {
                                parent.forEach(function(value, key) {
                                    var keyChild = _clone(key, depth - 1);
                                    var valueChild = _clone(value, depth - 1);
                                    child.set(keyChild, valueChild);
                                });
                            }
                            if (_instanceof(parent, nativeSet)) {
                                parent.forEach(function(value) {
                                    var entryChild = _clone(value, depth - 1);
                                    child.add(entryChild);
                                });
                            }
                            for (var i in parent) {
                                var attrs;
                                if (proto) {
                                    attrs = Object.getOwnPropertyDescriptor(proto, i);
                                }
                                if (attrs && attrs.set == null) {
                                    continue;
                                }
                                child[i] = _clone(parent[i], depth - 1);
                            }
                            if (Object.getOwnPropertySymbols) {
                                var symbols = Object.getOwnPropertySymbols(parent);
                                for (var i = 0; i < symbols.length; i++) {
                                    // Don't need to worry about cloning a symbol because it is a primitive,
                                    // like a number or string.
                                    var symbol = symbols[i];
                                    var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
                                    if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                                        continue;
                                    }
                                    child[symbol] = _clone(parent[symbol], depth - 1);
                                    if (!descriptor.enumerable) {
                                        Object.defineProperty(child, symbol, {
                                            enumerable: false
                                        });
                                    }
                                }
                            }
                            if (includeNonEnumerable) {
                                var allPropertyNames = Object.getOwnPropertyNames(parent);
                                for (var i = 0; i < allPropertyNames.length; i++) {
                                    var propertyName = allPropertyNames[i];
                                    var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
                                    if (descriptor && descriptor.enumerable) {
                                        continue;
                                    }
                                    child[propertyName] = _clone(parent[propertyName], depth - 1);
                                    Object.defineProperty(child, propertyName, {
                                        enumerable: false
                                    });
                                }
                            }
                            return child;
                        }
                        return _clone(parent, depth);
                    }
                    /**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
                    clone.clonePrototype = function clonePrototype(parent) {
                        if (parent === null) return null;
                        var c = function() {};
                        c.prototype = parent;
                        return new c();
                    };
                    // private utility functions
                    function __objToStr(o) {
                        return Object.prototype.toString.call(o);
                    }
                    clone.__objToStr = __objToStr;
                    function __isDate(o) {
                        return typeof o === "object" && __objToStr(o) === "[object Date]";
                    }
                    clone.__isDate = __isDate;
                    function __isArray(o) {
                        return typeof o === "object" && __objToStr(o) === "[object Array]";
                    }
                    clone.__isArray = __isArray;
                    function __isRegExp(o) {
                        return typeof o === "object" && __objToStr(o) === "[object RegExp]";
                    }
                    clone.__isRegExp = __isRegExp;
                    function __getRegExpFlags(re) {
                        var flags = "";
                        if (re.global) flags += "g";
                        if (re.ignoreCase) flags += "i";
                        if (re.multiline) flags += "m";
                        return flags;
                    }
                    clone.__getRegExpFlags = __getRegExpFlags;
                    return clone;
                }();
                if (true && module.exports) {
                    module.exports = clone;
                }
                /***/
            },
            /***/ "./node_modules/events/events.js": 
            /*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
            /***/ module => {
                "use strict";
                // Copyright Joyent, Inc. and other Node contributors.
                //
                // Permission is hereby granted, free of charge, to any person obtaining a
                // copy of this software and associated documentation files (the
                // "Software"), to deal in the Software without restriction, including
                // without limitation the rights to use, copy, modify, merge, publish,
                // distribute, sublicense, and/or sell copies of the Software, and to permit
                // persons to whom the Software is furnished to do so, subject to the
                // following conditions:
                //
                // The above copyright notice and this permission notice shall be included
                // in all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                // USE OR OTHER DEALINGS IN THE SOFTWARE.
                var R = typeof Reflect === "object" ? Reflect : null;
                var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply(target, receiver, args) {
                    return Function.prototype.apply.call(target, receiver, args);
                };
                var ReflectOwnKeys;
                if (R && typeof R.ownKeys === "function") {
                    ReflectOwnKeys = R.ownKeys;
                } else if (Object.getOwnPropertySymbols) {
                    ReflectOwnKeys = function ReflectOwnKeys(target) {
                        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
                    };
                } else {
                    ReflectOwnKeys = function ReflectOwnKeys(target) {
                        return Object.getOwnPropertyNames(target);
                    };
                }
                function ProcessEmitWarning(warning) {
                    if (console && console.warn) console.warn(warning);
                }
                var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
                    return value !== value;
                };
                function EventEmitter() {
                    EventEmitter.init.call(this);
                }
                module.exports = EventEmitter;
                module.exports.once = once;
                // Backwards-compat with node 0.10.x
                EventEmitter.EventEmitter = EventEmitter;
                EventEmitter.prototype._events = undefined;
                EventEmitter.prototype._eventsCount = 0;
                EventEmitter.prototype._maxListeners = undefined;
                // By default EventEmitters will print a warning if more than 10 listeners are
                // added to it. This is a useful default which helps finding memory leaks.
                var defaultMaxListeners = 10;
                function checkListener(listener) {
                    if (typeof listener !== "function") {
                        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
                    }
                }
                Object.defineProperty(EventEmitter, "defaultMaxListeners", {
                    enumerable: true,
                    get: function() {
                        return defaultMaxListeners;
                    },
                    set: function(arg) {
                        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
                            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
                        }
                        defaultMaxListeners = arg;
                    }
                });
                EventEmitter.init = function() {
                    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
                        this._events = Object.create(null);
                        this._eventsCount = 0;
                    }
                    this._maxListeners = this._maxListeners || undefined;
                };
                // Obviously not all Emitters should be limited to 10. This function allows
                // that to be increased. Set to zero for unlimited.
                EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
                    if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
                        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
                    }
                    this._maxListeners = n;
                    return this;
                };
                function _getMaxListeners(that) {
                    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
                    return that._maxListeners;
                }
                EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
                    return _getMaxListeners(this);
                };
                EventEmitter.prototype.emit = function emit(type) {
                    var args = [];
                    for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
                    var doError = type === "error";
                    var events = this._events;
                    if (events !== undefined) doError = doError && events.error === undefined; else if (!doError) return false;
                    // If there is no 'error' event listener then throw.
                    if (doError) {
                        var er;
                        if (args.length > 0) er = args[0];
                        if (er instanceof Error) {
                            // Note: The comments on the `throw` lines are intentional, they show
                            // up in Node's output if this results in an unhandled exception.
                            throw er; // Unhandled 'error' event
                        }
                        // At least give some kind of context to the user
                        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
                        err.context = er;
                        throw err; // Unhandled 'error' event
                    }
                    var handler = events[type];
                    if (handler === undefined) return false;
                    if (typeof handler === "function") {
                        ReflectApply(handler, this, args);
                    } else {
                        var len = handler.length;
                        var listeners = arrayClone(handler, len);
                        for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
                    }
                    return true;
                };
                function _addListener(target, type, listener, prepend) {
                    var m;
                    var events;
                    var existing;
                    checkListener(listener);
                    events = target._events;
                    if (events === undefined) {
                        events = target._events = Object.create(null);
                        target._eventsCount = 0;
                    } else {
                        // To avoid recursion in the case that type === "newListener"! Before
                        // adding it to the listeners, first emit "newListener".
                        if (events.newListener !== undefined) {
                            target.emit("newListener", type, listener.listener ? listener.listener : listener);
                            // Re-assign `events` because a newListener handler could have caused the
                            // this._events to be assigned to a new object
                            events = target._events;
                        }
                        existing = events[type];
                    }
                    if (existing === undefined) {
                        // Optimize the case of one listener. Don't need the extra array object.
                        existing = events[type] = listener;
                        ++target._eventsCount;
                    } else {
                        if (typeof existing === "function") {
                            // Adding the second element, need to change to array.
                            existing = events[type] = prepend ? [ listener, existing ] : [ existing, listener ];
                            // If we've already got an array, just append.
                        } else if (prepend) {
                            existing.unshift(listener);
                        } else {
                            existing.push(listener);
                        }
                        // Check for listener leak
                        m = _getMaxListeners(target);
                        if (m > 0 && existing.length > m && !existing.warned) {
                            existing.warned = true;
                            // No error code for this since it is a Warning
                            // eslint-disable-next-line no-restricted-syntax
                            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners " + "added. Use emitter.setMaxListeners() to " + "increase limit");
                            w.name = "MaxListenersExceededWarning";
                            w.emitter = target;
                            w.type = type;
                            w.count = existing.length;
                            ProcessEmitWarning(w);
                        }
                    }
                    return target;
                }
                EventEmitter.prototype.addListener = function addListener(type, listener) {
                    return _addListener(this, type, listener, false);
                };
                EventEmitter.prototype.on = EventEmitter.prototype.addListener;
                EventEmitter.prototype.prependListener = function prependListener(type, listener) {
                    return _addListener(this, type, listener, true);
                };
                function onceWrapper() {
                    if (!this.fired) {
                        this.target.removeListener(this.type, this.wrapFn);
                        this.fired = true;
                        if (arguments.length === 0) return this.listener.call(this.target);
                        return this.listener.apply(this.target, arguments);
                    }
                }
                function _onceWrap(target, type, listener) {
                    var state = {
                        fired: false,
                        wrapFn: undefined,
                        target: target,
                        type: type,
                        listener: listener
                    };
                    var wrapped = onceWrapper.bind(state);
                    wrapped.listener = listener;
                    state.wrapFn = wrapped;
                    return wrapped;
                }
                EventEmitter.prototype.once = function once(type, listener) {
                    checkListener(listener);
                    this.on(type, _onceWrap(this, type, listener));
                    return this;
                };
                EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
                    checkListener(listener);
                    this.prependListener(type, _onceWrap(this, type, listener));
                    return this;
                };
                // Emits a 'removeListener' event if and only if the listener was removed.
                EventEmitter.prototype.removeListener = function removeListener(type, listener) {
                    var list, events, position, i, originalListener;
                    checkListener(listener);
                    events = this._events;
                    if (events === undefined) return this;
                    list = events[type];
                    if (list === undefined) return this;
                    if (list === listener || list.listener === listener) {
                        if (--this._eventsCount === 0) this._events = Object.create(null); else {
                            delete events[type];
                            if (events.removeListener) this.emit("removeListener", type, list.listener || listener);
                        }
                    } else if (typeof list !== "function") {
                        position = -1;
                        for (i = list.length - 1; i >= 0; i--) {
                            if (list[i] === listener || list[i].listener === listener) {
                                originalListener = list[i].listener;
                                position = i;
                                break;
                            }
                        }
                        if (position < 0) return this;
                        if (position === 0) list.shift(); else {
                            spliceOne(list, position);
                        }
                        if (list.length === 1) events[type] = list[0];
                        if (events.removeListener !== undefined) this.emit("removeListener", type, originalListener || listener);
                    }
                    return this;
                };
                EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
                EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
                    var listeners, events, i;
                    events = this._events;
                    if (events === undefined) return this;
                    // not listening for removeListener, no need to emit
                    if (events.removeListener === undefined) {
                        if (arguments.length === 0) {
                            this._events = Object.create(null);
                            this._eventsCount = 0;
                        } else if (events[type] !== undefined) {
                            if (--this._eventsCount === 0) this._events = Object.create(null); else delete events[type];
                        }
                        return this;
                    }
                    // emit removeListener for all listeners on all events
                    if (arguments.length === 0) {
                        var keys = Object.keys(events);
                        var key;
                        for (i = 0; i < keys.length; ++i) {
                            key = keys[i];
                            if (key === "removeListener") continue;
                            this.removeAllListeners(key);
                        }
                        this.removeAllListeners("removeListener");
                        this._events = Object.create(null);
                        this._eventsCount = 0;
                        return this;
                    }
                    listeners = events[type];
                    if (typeof listeners === "function") {
                        this.removeListener(type, listeners);
                    } else if (listeners !== undefined) {
                        // LIFO order
                        for (i = listeners.length - 1; i >= 0; i--) {
                            this.removeListener(type, listeners[i]);
                        }
                    }
                    return this;
                };
                function _listeners(target, type, unwrap) {
                    var events = target._events;
                    if (events === undefined) return [];
                    var evlistener = events[type];
                    if (evlistener === undefined) return [];
                    if (typeof evlistener === "function") return unwrap ? [ evlistener.listener || evlistener ] : [ evlistener ];
                    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
                }
                EventEmitter.prototype.listeners = function listeners(type) {
                    return _listeners(this, type, true);
                };
                EventEmitter.prototype.rawListeners = function rawListeners(type) {
                    return _listeners(this, type, false);
                };
                EventEmitter.listenerCount = function(emitter, type) {
                    if (typeof emitter.listenerCount === "function") {
                        return emitter.listenerCount(type);
                    } else {
                        return listenerCount.call(emitter, type);
                    }
                };
                EventEmitter.prototype.listenerCount = listenerCount;
                function listenerCount(type) {
                    var events = this._events;
                    if (events !== undefined) {
                        var evlistener = events[type];
                        if (typeof evlistener === "function") {
                            return 1;
                        } else if (evlistener !== undefined) {
                            return evlistener.length;
                        }
                    }
                    return 0;
                }
                EventEmitter.prototype.eventNames = function eventNames() {
                    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
                };
                function arrayClone(arr, n) {
                    var copy = new Array(n);
                    for (var i = 0; i < n; ++i) copy[i] = arr[i];
                    return copy;
                }
                function spliceOne(list, index) {
                    for (;index + 1 < list.length; index++) list[index] = list[index + 1];
                    list.pop();
                }
                function unwrapListeners(arr) {
                    var ret = new Array(arr.length);
                    for (var i = 0; i < ret.length; ++i) {
                        ret[i] = arr[i].listener || arr[i];
                    }
                    return ret;
                }
                function once(emitter, name) {
                    return new Promise(function(resolve, reject) {
                        function errorListener(err) {
                            emitter.removeListener(name, resolver);
                            reject(err);
                        }
                        function resolver() {
                            if (typeof emitter.removeListener === "function") {
                                emitter.removeListener("error", errorListener);
                            }
                            resolve([].slice.call(arguments));
                        }
                        eventTargetAgnosticAddListener(emitter, name, resolver, {
                            once: true
                        });
                        if (name !== "error") {
                            addErrorHandlerIfEventEmitter(emitter, errorListener, {
                                once: true
                            });
                        }
                    });
                }
                function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
                    if (typeof emitter.on === "function") {
                        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
                    }
                }
                function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
                    if (typeof emitter.on === "function") {
                        if (flags.once) {
                            emitter.once(name, listener);
                        } else {
                            emitter.on(name, listener);
                        }
                    } else if (typeof emitter.addEventListener === "function") {
                        // EventTarget does not have `error` event semantics like Node
                        // EventEmitters, we do not listen for `error` events here.
                        emitter.addEventListener(name, function wrapListener(arg) {
                            // IE does not have builtin `{ once: true }` support so we
                            // have to do it manually.
                            if (flags.once) {
                                emitter.removeEventListener(name, wrapListener);
                            }
                            listener(arg);
                        });
                    } else {
                        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
                    }
                }
                /***/
            },
            /***/ "./node_modules/ieee754/index.js": 
            /*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
            /***/ (__unused_webpack_module, exports) => {
                /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
                exports.read = function(buffer, offset, isLE, mLen, nBytes) {
                    var e, m;
                    var eLen = nBytes * 8 - mLen - 1;
                    var eMax = (1 << eLen) - 1;
                    var eBias = eMax >> 1;
                    var nBits = -7;
                    var i = isLE ? nBytes - 1 : 0;
                    var d = isLE ? -1 : 1;
                    var s = buffer[offset + i];
                    i += d;
                    e = s & (1 << -nBits) - 1;
                    s >>= -nBits;
                    nBits += eLen;
                    for (;nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
                    m = e & (1 << -nBits) - 1;
                    e >>= -nBits;
                    nBits += mLen;
                    for (;nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
                    if (e === 0) {
                        e = 1 - eBias;
                    } else if (e === eMax) {
                        return m ? NaN : (s ? -1 : 1) * Infinity;
                    } else {
                        m = m + Math.pow(2, mLen);
                        e = e - eBias;
                    }
                    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
                };
                exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
                    var e, m, c;
                    var eLen = nBytes * 8 - mLen - 1;
                    var eMax = (1 << eLen) - 1;
                    var eBias = eMax >> 1;
                    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                    var i = isLE ? 0 : nBytes - 1;
                    var d = isLE ? 1 : -1;
                    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
                    value = Math.abs(value);
                    if (isNaN(value) || value === Infinity) {
                        m = isNaN(value) ? 1 : 0;
                        e = eMax;
                    } else {
                        e = Math.floor(Math.log(value) / Math.LN2);
                        if (value * (c = Math.pow(2, -e)) < 1) {
                            e--;
                            c *= 2;
                        }
                        if (e + eBias >= 1) {
                            value += rt / c;
                        } else {
                            value += rt * Math.pow(2, 1 - eBias);
                        }
                        if (value * c >= 2) {
                            e++;
                            c /= 2;
                        }
                        if (e + eBias >= eMax) {
                            m = 0;
                            e = eMax;
                        } else if (e + eBias >= 1) {
                            m = (value * c - 1) * Math.pow(2, mLen);
                            e = e + eBias;
                        } else {
                            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                            e = 0;
                        }
                    }
                    for (;mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, 
                    mLen -= 8) {}
                    e = e << mLen | m;
                    eLen += mLen;
                    for (;eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, 
                    eLen -= 8) {}
                    buffer[offset + i - d] |= s * 128;
                }
                /***/;
            },
            /***/ "?c549": 
            /*!***************************!*\
  !*** constants (ignored) ***!
  \***************************/
            /***/ () => {
                /* (ignored) */
                /***/},
            /***/ "?77a7": 
            /*!**********************!*\
  !*** http (ignored) ***!
  \**********************/
            /***/ () => {
                /* (ignored) */
                /***/},
            /***/ "?37c5": 
            /*!***********************!*\
  !*** https (ignored) ***!
  \***********************/
            /***/ () => {
                /* (ignored) */
                /***/},
            /***/ "./node_modules/long/umd/index.js": 
            /*!****************************************!*\
  !*** ./node_modules/long/umd/index.js ***!
  \****************************************/
            /***/ (module, exports) => {
                var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // GENERATED FILE. DO NOT EDIT.
                var Long = function(exports) {
                    "use strict";
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.default = void 0;
                    /**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
                    // WebAssembly optimizations to do native i64 multiplication and divide
                    var wasm = null;
                    try {
                        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([ 0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11 ])), {}).exports;
                    } catch (e) {// no wasm support :(
                    }
                    /**
   * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
   *  See the from* functions below for more convenient ways of constructing Longs.
   * @exports Long
   * @class A Long class for representing a 64 bit two's-complement integer value.
   * @param {number} low The low (signed) 32 bits of the long
   * @param {number} high The high (signed) 32 bits of the long
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @constructor
   */
                    function Long(low, high, unsigned) {
                        /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
                        this.low = low | 0;
                        /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
                        this.high = high | 0;
                        /**
     * Whether unsigned or not.
     * @type {boolean}
     */
                        this.unsigned = !!unsigned;
                    } // The internal representation of a long is the two given signed, 32-bit values.
                    // We use 32-bit pieces because these are the size of integers on which
                    // Javascript performs bit-operations.  For operations like addition and
                    // multiplication, we split each number into 16 bit pieces, which can easily be
                    // multiplied within Javascript's floating-point representation without overflow
                    // or change in sign.
                    //
                    // In the algorithms below, we frequently reduce the negative case to the
                    // positive case by negating the input(s) and then post-processing the result.
                    // Note that we must ALWAYS check specially whether those values are MIN_VALUE
                    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
                    // a positive number, it overflows back into a negative).  Not handling this
                    // case would often result in infinite recursion.
                    //
                    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
                    // methods on which they depend.
                    /**
   * An indicator used to reliably determine if an object is a Long or not.
   * @type {boolean}
   * @const
   * @private
   */
                    Long.prototype.__isLong__;
                    Object.defineProperty(Long.prototype, "__isLong__", {
                        value: true
                    });
                    /**
   * @function
   * @param {*} obj Object
   * @returns {boolean}
   * @inner
   */
                    function isLong(obj) {
                        return (obj && obj["__isLong__"]) === true;
                    }
                    /**
   * @function
   * @param {*} value number
   * @returns {number}
   * @inner
   */
                    function ctz32(value) {
                        var c = Math.clz32(value & -value);
                        return value ? 31 - c : c;
                    }
                    /**
   * Tests if the specified object is a Long.
   * @function
   * @param {*} obj Object
   * @returns {boolean}
   */
                    Long.isLong = isLong;
                    /**
   * A cache of the Long representations of small integer values.
   * @type {!Object}
   * @inner
   */
                    var INT_CACHE = {};
                    /**
   * A cache of the Long representations of small unsigned integer values.
   * @type {!Object}
   * @inner
   */
                    var UINT_CACHE = {};
                    /**
   * @param {number} value
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
                    function fromInt(value, unsigned) {
                        var obj, cachedObj, cache;
                        if (unsigned) {
                            value >>>= 0;
                            if (cache = 0 <= value && value < 256) {
                                cachedObj = UINT_CACHE[value];
                                if (cachedObj) return cachedObj;
                            }
                            obj = fromBits(value, 0, true);
                            if (cache) UINT_CACHE[value] = obj;
                            return obj;
                        } else {
                            value |= 0;
                            if (cache = -128 <= value && value < 128) {
                                cachedObj = INT_CACHE[value];
                                if (cachedObj) return cachedObj;
                            }
                            obj = fromBits(value, value < 0 ? -1 : 0, false);
                            if (cache) INT_CACHE[value] = obj;
                            return obj;
                        }
                    }
                    /**
   * Returns a Long representing the given 32 bit integer value.
   * @function
   * @param {number} value The 32 bit integer in question
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
                    Long.fromInt = fromInt;
                    /**
   * @param {number} value
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
                    function fromNumber(value, unsigned) {
                        if (isNaN(value)) return unsigned ? UZERO : ZERO;
                        if (unsigned) {
                            if (value < 0) return UZERO;
                            if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
                        } else {
                            if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
                            if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
                        }
                        if (value < 0) return fromNumber(-value, unsigned).neg();
                        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
                    }
                    /**
   * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
   * @function
   * @param {number} value The number in question
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
                    Long.fromNumber = fromNumber;
                    /**
   * @param {number} lowBits
   * @param {number} highBits
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
                    function fromBits(lowBits, highBits, unsigned) {
                        return new Long(lowBits, highBits, unsigned);
                    }
                    /**
   * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
   *  assumed to use 32 bits.
   * @function
   * @param {number} lowBits The low 32 bits
   * @param {number} highBits The high 32 bits
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */
                    Long.fromBits = fromBits;
                    /**
   * @function
   * @param {number} base
   * @param {number} exponent
   * @returns {number}
   * @inner
   */
                    var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)
                    /**
   * @param {string} str
   * @param {(boolean|number)=} unsigned
   * @param {number=} radix
   * @returns {!Long}
   * @inner
   */
                    function fromString(str, unsigned, radix) {
                        if (str.length === 0) throw Error("empty string");
                        if (typeof unsigned === "number") {
                            // For goog.math.long compatibility
                            radix = unsigned;
                            unsigned = false;
                        } else {
                            unsigned = !!unsigned;
                        }
                        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return unsigned ? UZERO : ZERO;
                        radix = radix || 10;
                        if (radix < 2 || 36 < radix) throw RangeError("radix");
                        var p;
                        if ((p = str.indexOf("-")) > 0) throw Error("interior hyphen"); else if (p === 0) {
                            return fromString(str.substring(1), unsigned, radix).neg();
                        } // Do several (8) digits each time through the loop, so as to
                        // minimize the calls to the very expensive emulated div.
                        var radixToPower = fromNumber(pow_dbl(radix, 8));
                        var result = ZERO;
                        for (var i = 0; i < str.length; i += 8) {
                            var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
                            if (size < 8) {
                                var power = fromNumber(pow_dbl(radix, size));
                                result = result.mul(power).add(fromNumber(value));
                            } else {
                                result = result.mul(radixToPower);
                                result = result.add(fromNumber(value));
                            }
                        }
                        result.unsigned = unsigned;
                        return result;
                    }
                    /**
   * Returns a Long representation of the given string, written using the specified radix.
   * @function
   * @param {string} str The textual representation of the Long
   * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
   * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
   * @returns {!Long} The corresponding Long value
   */
                    Long.fromString = fromString;
                    /**
   * @function
   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
   * @param {boolean=} unsigned
   * @returns {!Long}
   * @inner
   */
                    function fromValue(val, unsigned) {
                        if (typeof val === "number") return fromNumber(val, unsigned);
                        if (typeof val === "string") return fromString(val, unsigned); // Throws for non-objects, converts non-instanceof Long:
                        return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
                    }
                    /**
   * Converts the specified value to a Long using the appropriate from* function for its type.
   * @function
   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long}
   */
                    Long.fromValue = fromValue; // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
                    // no runtime penalty for these.
                    /**
   * @type {number}
   * @const
   * @inner
   */
                    var TWO_PWR_16_DBL = 1 << 16;
                    /**
   * @type {number}
   * @const
   * @inner
   */
                    var TWO_PWR_24_DBL = 1 << 24;
                    /**
   * @type {number}
   * @const
   * @inner
   */
                    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
                    /**
   * @type {number}
   * @const
   * @inner
   */
                    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
                    /**
   * @type {number}
   * @const
   * @inner
   */
                    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
                    /**
   * @type {!Long}
   * @const
   * @inner
   */
                    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
                    /**
   * @type {!Long}
   * @inner
   */
                    var ZERO = fromInt(0);
                    /**
   * Signed zero.
   * @type {!Long}
   */
                    Long.ZERO = ZERO;
                    /**
   * @type {!Long}
   * @inner
   */
                    var UZERO = fromInt(0, true);
                    /**
   * Unsigned zero.
   * @type {!Long}
   */
                    Long.UZERO = UZERO;
                    /**
   * @type {!Long}
   * @inner
   */
                    var ONE = fromInt(1);
                    /**
   * Signed one.
   * @type {!Long}
   */
                    Long.ONE = ONE;
                    /**
   * @type {!Long}
   * @inner
   */
                    var UONE = fromInt(1, true);
                    /**
   * Unsigned one.
   * @type {!Long}
   */
                    Long.UONE = UONE;
                    /**
   * @type {!Long}
   * @inner
   */
                    var NEG_ONE = fromInt(-1);
                    /**
   * Signed negative one.
   * @type {!Long}
   */
                    Long.NEG_ONE = NEG_ONE;
                    /**
   * @type {!Long}
   * @inner
   */
                    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
                    /**
   * Maximum signed value.
   * @type {!Long}
   */
                    Long.MAX_VALUE = MAX_VALUE;
                    /**
   * @type {!Long}
   * @inner
   */
                    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
                    /**
   * Maximum unsigned value.
   * @type {!Long}
   */
                    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
                    /**
   * @type {!Long}
   * @inner
   */
                    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
                    /**
   * Minimum signed value.
   * @type {!Long}
   */
                    Long.MIN_VALUE = MIN_VALUE;
                    /**
   * @alias Long.prototype
   * @inner
   */
                    var LongPrototype = Long.prototype;
                    /**
   * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
   * @this {!Long}
   * @returns {number}
   */
                    LongPrototype.toInt = function toInt() {
                        return this.unsigned ? this.low >>> 0 : this.low;
                    };
                    /**
   * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
   * @this {!Long}
   * @returns {number}
   */
                    LongPrototype.toNumber = function toNumber() {
                        if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
                        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
                    };
                    /**
   * Converts the Long to a string written in the specified radix.
   * @this {!Long}
   * @param {number=} radix Radix (2-36), defaults to 10
   * @returns {string}
   * @override
   * @throws {RangeError} If `radix` is out of range
   */
                    LongPrototype.toString = function toString(radix) {
                        radix = radix || 10;
                        if (radix < 2 || 36 < radix) throw RangeError("radix");
                        if (this.isZero()) return "0";
                        if (this.isNegative()) {
                            // Unsigned Longs are never negative
                            if (this.eq(MIN_VALUE)) {
                                // We need to change the Long value before it can be negated, so we remove
                                // the bottom-most digit in this base and then recurse to do the rest.
                                var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
                                return div.toString(radix) + rem1.toInt().toString(radix);
                            } else return "-" + this.neg().toString(radix);
                        } // Do several (6) digits each time through the loop, so as to
                        // minimize the calls to the very expensive emulated div.
                        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
                        var result = "";
                        while (true) {
                            var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
                            rem = remDiv;
                            if (rem.isZero()) return digits + result; else {
                                while (digits.length < 6) digits = "0" + digits;
                                result = "" + digits + result;
                            }
                        }
                    };
                    /**
   * Gets the high 32 bits as a signed integer.
   * @this {!Long}
   * @returns {number} Signed high bits
   */
                    LongPrototype.getHighBits = function getHighBits() {
                        return this.high;
                    };
                    /**
   * Gets the high 32 bits as an unsigned integer.
   * @this {!Long}
   * @returns {number} Unsigned high bits
   */
                    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
                        return this.high >>> 0;
                    };
                    /**
   * Gets the low 32 bits as a signed integer.
   * @this {!Long}
   * @returns {number} Signed low bits
   */
                    LongPrototype.getLowBits = function getLowBits() {
                        return this.low;
                    };
                    /**
   * Gets the low 32 bits as an unsigned integer.
   * @this {!Long}
   * @returns {number} Unsigned low bits
   */
                    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
                        return this.low >>> 0;
                    };
                    /**
   * Gets the number of bits needed to represent the absolute value of this Long.
   * @this {!Long}
   * @returns {number}
   */
                    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
                        if (this.isNegative()) // Unsigned Longs are never negative
                        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
                        var val = this.high != 0 ? this.high : this.low;
                        for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
                        return this.high != 0 ? bit + 33 : bit + 1;
                    };
                    /**
   * Tests if this Long's value equals zero.
   * @this {!Long}
   * @returns {boolean}
   */
                    LongPrototype.isZero = function isZero() {
                        return this.high === 0 && this.low === 0;
                    };
                    /**
   * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
   * @returns {boolean}
   */
                    LongPrototype.eqz = LongPrototype.isZero;
                    /**
   * Tests if this Long's value is negative.
   * @this {!Long}
   * @returns {boolean}
   */
                    LongPrototype.isNegative = function isNegative() {
                        return !this.unsigned && this.high < 0;
                    };
                    /**
   * Tests if this Long's value is positive or zero.
   * @this {!Long}
   * @returns {boolean}
   */
                    LongPrototype.isPositive = function isPositive() {
                        return this.unsigned || this.high >= 0;
                    };
                    /**
   * Tests if this Long's value is odd.
   * @this {!Long}
   * @returns {boolean}
   */
                    LongPrototype.isOdd = function isOdd() {
                        return (this.low & 1) === 1;
                    };
                    /**
   * Tests if this Long's value is even.
   * @this {!Long}
   * @returns {boolean}
   */
                    LongPrototype.isEven = function isEven() {
                        return (this.low & 1) === 0;
                    };
                    /**
   * Tests if this Long's value equals the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
                    LongPrototype.equals = function equals(other) {
                        if (!isLong(other)) other = fromValue(other);
                        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
                        return this.high === other.high && this.low === other.low;
                    };
                    /**
   * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
                    LongPrototype.eq = LongPrototype.equals;
                    /**
   * Tests if this Long's value differs from the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
                    LongPrototype.notEquals = function notEquals(other) {
                        return !this.eq(
                        /* validates */
                        other);
                    };
                    /**
   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
                    LongPrototype.neq = LongPrototype.notEquals;
                    /**
   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
                    LongPrototype.ne = LongPrototype.notEquals;
                    /**
   * Tests if this Long's value is less than the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
                    LongPrototype.lessThan = function lessThan(other) {
                        return this.comp(
                        /* validates */
                        other) < 0;
                    };
                    /**
   * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
                    LongPrototype.lt = LongPrototype.lessThan;
                    /**
   * Tests if this Long's value is less than or equal the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
                    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
                        return this.comp(
                        /* validates */
                        other) <= 0;
                    };
                    /**
   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
                    LongPrototype.lte = LongPrototype.lessThanOrEqual;
                    /**
   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
                    LongPrototype.le = LongPrototype.lessThanOrEqual;
                    /**
   * Tests if this Long's value is greater than the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
                    LongPrototype.greaterThan = function greaterThan(other) {
                        return this.comp(
                        /* validates */
                        other) > 0;
                    };
                    /**
   * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
                    LongPrototype.gt = LongPrototype.greaterThan;
                    /**
   * Tests if this Long's value is greater than or equal the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
                    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
                        return this.comp(
                        /* validates */
                        other) >= 0;
                    };
                    /**
   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
                    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
                    /**
   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {boolean}
   */
                    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
                    /**
   * Compares this Long's value with the specified's.
   * @this {!Long}
   * @param {!Long|number|string} other Other value
   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
   *  if the given one is greater
   */
                    LongPrototype.compare = function compare(other) {
                        if (!isLong(other)) other = fromValue(other);
                        if (this.eq(other)) return 0;
                        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
                        if (thisNeg && !otherNeg) return -1;
                        if (!thisNeg && otherNeg) return 1; // At this point the sign bits are the same
                        if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1; // Both are positive if at least one is unsigned
                        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
                    };
                    /**
   * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
   * @function
   * @param {!Long|number|string} other Other value
   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
   *  if the given one is greater
   */
                    LongPrototype.comp = LongPrototype.compare;
                    /**
   * Negates this Long's value.
   * @this {!Long}
   * @returns {!Long} Negated Long
   */
                    LongPrototype.negate = function negate() {
                        if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
                        return this.not().add(ONE);
                    };
                    /**
   * Negates this Long's value. This is an alias of {@link Long#negate}.
   * @function
   * @returns {!Long} Negated Long
   */
                    LongPrototype.neg = LongPrototype.negate;
                    /**
   * Returns the sum of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|string} addend Addend
   * @returns {!Long} Sum
   */
                    LongPrototype.add = function add(addend) {
                        if (!isLong(addend)) addend = fromValue(addend); // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
                        var a48 = this.high >>> 16;
                        var a32 = this.high & 65535;
                        var a16 = this.low >>> 16;
                        var a00 = this.low & 65535;
                        var b48 = addend.high >>> 16;
                        var b32 = addend.high & 65535;
                        var b16 = addend.low >>> 16;
                        var b00 = addend.low & 65535;
                        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
                        c00 += a00 + b00;
                        c16 += c00 >>> 16;
                        c00 &= 65535;
                        c16 += a16 + b16;
                        c32 += c16 >>> 16;
                        c16 &= 65535;
                        c32 += a32 + b32;
                        c48 += c32 >>> 16;
                        c32 &= 65535;
                        c48 += a48 + b48;
                        c48 &= 65535;
                        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
                    };
                    /**
   * Returns the difference of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|string} subtrahend Subtrahend
   * @returns {!Long} Difference
   */
                    LongPrototype.subtract = function subtract(subtrahend) {
                        if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
                        return this.add(subtrahend.neg());
                    };
                    /**
   * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
   * @function
   * @param {!Long|number|string} subtrahend Subtrahend
   * @returns {!Long} Difference
   */
                    LongPrototype.sub = LongPrototype.subtract;
                    /**
   * Returns the product of this and the specified Long.
   * @this {!Long}
   * @param {!Long|number|string} multiplier Multiplier
   * @returns {!Long} Product
   */
                    LongPrototype.multiply = function multiply(multiplier) {
                        if (this.isZero()) return this;
                        if (!isLong(multiplier)) multiplier = fromValue(multiplier); // use wasm support if present
                        if (wasm) {
                            var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
                            return fromBits(low, wasm["get_high"](), this.unsigned);
                        }
                        if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
                        if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
                        if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
                        if (this.isNegative()) {
                            if (multiplier.isNegative()) return this.neg().mul(multiplier.neg()); else return this.neg().mul(multiplier).neg();
                        } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg(); // If both longs are small, use float multiplication
                        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
                        // We can skip products that would overflow.
                        var a48 = this.high >>> 16;
                        var a32 = this.high & 65535;
                        var a16 = this.low >>> 16;
                        var a00 = this.low & 65535;
                        var b48 = multiplier.high >>> 16;
                        var b32 = multiplier.high & 65535;
                        var b16 = multiplier.low >>> 16;
                        var b00 = multiplier.low & 65535;
                        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
                        c00 += a00 * b00;
                        c16 += c00 >>> 16;
                        c00 &= 65535;
                        c16 += a16 * b00;
                        c32 += c16 >>> 16;
                        c16 &= 65535;
                        c16 += a00 * b16;
                        c32 += c16 >>> 16;
                        c16 &= 65535;
                        c32 += a32 * b00;
                        c48 += c32 >>> 16;
                        c32 &= 65535;
                        c32 += a16 * b16;
                        c48 += c32 >>> 16;
                        c32 &= 65535;
                        c32 += a00 * b32;
                        c48 += c32 >>> 16;
                        c32 &= 65535;
                        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
                        c48 &= 65535;
                        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
                    };
                    /**
   * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
   * @function
   * @param {!Long|number|string} multiplier Multiplier
   * @returns {!Long} Product
   */
                    LongPrototype.mul = LongPrototype.multiply;
                    /**
   * Returns this Long divided by the specified. The result is signed if this Long is signed or
   *  unsigned if this Long is unsigned.
   * @this {!Long}
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Quotient
   */
                    LongPrototype.divide = function divide(divisor) {
                        if (!isLong(divisor)) divisor = fromValue(divisor);
                        if (divisor.isZero()) throw Error("division by zero"); // use wasm support if present
                        if (wasm) {
                            // guard against signed division overflow: the largest
                            // negative number / -1 would be 1 larger than the largest
                            // positive number, due to two's complement.
                            if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
                                // be consistent with non-wasm code path
                                return this;
                            }
                            var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
                            return fromBits(low, wasm["get_high"](), this.unsigned);
                        }
                        if (this.isZero()) return this.unsigned ? UZERO : ZERO;
                        var approx, rem, res;
                        if (!this.unsigned) {
                            // This section is only relevant for signed longs and is derived from the
                            // closure library as a whole.
                            if (this.eq(MIN_VALUE)) {
                                if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
                                 else if (divisor.eq(MIN_VALUE)) return ONE; else {
                                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                                    var halfThis = this.shr(1);
                                    approx = halfThis.div(divisor).shl(1);
                                    if (approx.eq(ZERO)) {
                                        return divisor.isNegative() ? ONE : NEG_ONE;
                                    } else {
                                        rem = this.sub(divisor.mul(approx));
                                        res = approx.add(rem.div(divisor));
                                        return res;
                                    }
                                }
                            } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
                            if (this.isNegative()) {
                                if (divisor.isNegative()) return this.neg().div(divisor.neg());
                                return this.neg().div(divisor).neg();
                            } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
                            res = ZERO;
                        } else {
                            // The algorithm below has not been made for unsigned longs. It's therefore
                            // required to take special care of the MSB prior to running it.
                            if (!divisor.unsigned) divisor = divisor.toUnsigned();
                            if (divisor.gt(this)) return UZERO;
                            if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
                            return UONE;
                            res = UZERO;
                        } // Repeat the following until the remainder is less than other:  find a
                        // floating-point that approximates remainder / other *from below*, add this
                        // into the result, and subtract it from the remainder.  It is critical that
                        // the approximate value is less than or equal to the real value so that the
                        // remainder never becomes negative.
                        rem = this;
                        while (rem.gte(divisor)) {
                            // Approximate the result of division. This may be a little greater or
                            // smaller than the actual value.
                            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or
                            // the smallest non-fractional digit, whichever is larger.
                            var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), 
                            // Decrease the approximation until it is smaller than the remainder.  Note
                            // that if it is too large, the product overflows and is negative.
                            approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
                            while (approxRem.isNegative() || approxRem.gt(rem)) {
                                approx -= delta;
                                approxRes = fromNumber(approx, this.unsigned);
                                approxRem = approxRes.mul(divisor);
                            } // We know the answer can't be zero... and actually, zero would cause
                            // infinite recursion since we would make no progress.
                            if (approxRes.isZero()) approxRes = ONE;
                            res = res.add(approxRes);
                            rem = rem.sub(approxRem);
                        }
                        return res;
                    };
                    /**
   * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Quotient
   */
                    LongPrototype.div = LongPrototype.divide;
                    /**
   * Returns this Long modulo the specified.
   * @this {!Long}
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */
                    LongPrototype.modulo = function modulo(divisor) {
                        if (!isLong(divisor)) divisor = fromValue(divisor); // use wasm support if present
                        if (wasm) {
                            var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
                            return fromBits(low, wasm["get_high"](), this.unsigned);
                        }
                        return this.sub(this.div(divisor).mul(divisor));
                    };
                    /**
   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */
                    LongPrototype.mod = LongPrototype.modulo;
                    /**
   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
   * @function
   * @param {!Long|number|string} divisor Divisor
   * @returns {!Long} Remainder
   */
                    LongPrototype.rem = LongPrototype.modulo;
                    /**
   * Returns the bitwise NOT of this Long.
   * @this {!Long}
   * @returns {!Long}
   */
                    LongPrototype.not = function not() {
                        return fromBits(~this.low, ~this.high, this.unsigned);
                    };
                    /**
   * Returns count leading zeros of this Long.
   * @this {!Long}
   * @returns {!number}
   */
                    LongPrototype.countLeadingZeros = function countLeadingZeros() {
                        return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
                    };
                    /**
   * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.
   * @function
   * @param {!Long}
   * @returns {!number}
   */
                    LongPrototype.clz = LongPrototype.countLeadingZeros;
                    /**
   * Returns count trailing zeros of this Long.
   * @this {!Long}
   * @returns {!number}
   */
                    LongPrototype.countTrailingZeros = function countTrailingZeros() {
                        return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
                    };
                    /**
   * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.
   * @function
   * @param {!Long}
   * @returns {!number}
   */
                    LongPrototype.ctz = LongPrototype.countTrailingZeros;
                    /**
   * Returns the bitwise AND of this Long and the specified.
   * @this {!Long}
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */
                    LongPrototype.and = function and(other) {
                        if (!isLong(other)) other = fromValue(other);
                        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
                    };
                    /**
   * Returns the bitwise OR of this Long and the specified.
   * @this {!Long}
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */
                    LongPrototype.or = function or(other) {
                        if (!isLong(other)) other = fromValue(other);
                        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
                    };
                    /**
   * Returns the bitwise XOR of this Long and the given one.
   * @this {!Long}
   * @param {!Long|number|string} other Other Long
   * @returns {!Long}
   */
                    LongPrototype.xor = function xor(other) {
                        if (!isLong(other)) other = fromValue(other);
                        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
                    };
                    /**
   * Returns this Long with bits shifted to the left by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
                    LongPrototype.shiftLeft = function shiftLeft(numBits) {
                        if (isLong(numBits)) numBits = numBits.toInt();
                        if ((numBits &= 63) === 0) return this; else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned); else return fromBits(0, this.low << numBits - 32, this.unsigned);
                    };
                    /**
   * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
                    LongPrototype.shl = LongPrototype.shiftLeft;
                    /**
   * Returns this Long with bits arithmetically shifted to the right by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
                    LongPrototype.shiftRight = function shiftRight(numBits) {
                        if (isLong(numBits)) numBits = numBits.toInt();
                        if ((numBits &= 63) === 0) return this; else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned); else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
                    };
                    /**
   * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
                    LongPrototype.shr = LongPrototype.shiftRight;
                    /**
   * Returns this Long with bits logically shifted to the right by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
                    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
                        if (isLong(numBits)) numBits = numBits.toInt();
                        if ((numBits &= 63) === 0) return this;
                        if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
                        if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
                        return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
                    };
                    /**
   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
                    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
                    /**
   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Shifted Long
   */
                    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
                    /**
   * Returns this Long with bits rotated to the left by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
                    LongPrototype.rotateLeft = function rotateLeft(numBits) {
                        var b;
                        if (isLong(numBits)) numBits = numBits.toInt();
                        if ((numBits &= 63) === 0) return this;
                        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
                        if (numBits < 32) {
                            b = 32 - numBits;
                            return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
                        }
                        numBits -= 32;
                        b = 32 - numBits;
                        return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
                    };
                    /**
   * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
                    LongPrototype.rotl = LongPrototype.rotateLeft;
                    /**
   * Returns this Long with bits rotated to the right by the given amount.
   * @this {!Long}
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
                    LongPrototype.rotateRight = function rotateRight(numBits) {
                        var b;
                        if (isLong(numBits)) numBits = numBits.toInt();
                        if ((numBits &= 63) === 0) return this;
                        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
                        if (numBits < 32) {
                            b = 32 - numBits;
                            return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
                        }
                        numBits -= 32;
                        b = 32 - numBits;
                        return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
                    };
                    /**
   * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.
   * @function
   * @param {number|!Long} numBits Number of bits
   * @returns {!Long} Rotated Long
   */
                    LongPrototype.rotr = LongPrototype.rotateRight;
                    /**
   * Converts this Long to signed.
   * @this {!Long}
   * @returns {!Long} Signed long
   */
                    LongPrototype.toSigned = function toSigned() {
                        if (!this.unsigned) return this;
                        return fromBits(this.low, this.high, false);
                    };
                    /**
   * Converts this Long to unsigned.
   * @this {!Long}
   * @returns {!Long} Unsigned long
   */
                    LongPrototype.toUnsigned = function toUnsigned() {
                        if (this.unsigned) return this;
                        return fromBits(this.low, this.high, true);
                    };
                    /**
   * Converts this Long to its byte representation.
   * @param {boolean=} le Whether little or big endian, defaults to big endian
   * @this {!Long}
   * @returns {!Array.<number>} Byte representation
   */
                    LongPrototype.toBytes = function toBytes(le) {
                        return le ? this.toBytesLE() : this.toBytesBE();
                    };
                    /**
   * Converts this Long to its little endian byte representation.
   * @this {!Long}
   * @returns {!Array.<number>} Little endian byte representation
   */
                    LongPrototype.toBytesLE = function toBytesLE() {
                        var hi = this.high, lo = this.low;
                        return [ lo & 255, lo >>> 8 & 255, lo >>> 16 & 255, lo >>> 24, hi & 255, hi >>> 8 & 255, hi >>> 16 & 255, hi >>> 24 ];
                    };
                    /**
   * Converts this Long to its big endian byte representation.
   * @this {!Long}
   * @returns {!Array.<number>} Big endian byte representation
   */
                    LongPrototype.toBytesBE = function toBytesBE() {
                        var hi = this.high, lo = this.low;
                        return [ hi >>> 24, hi >>> 16 & 255, hi >>> 8 & 255, hi & 255, lo >>> 24, lo >>> 16 & 255, lo >>> 8 & 255, lo & 255 ];
                    };
                    /**
   * Creates a Long from its byte representation.
   * @param {!Array.<number>} bytes Byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @param {boolean=} le Whether little or big endian, defaults to big endian
   * @returns {Long} The corresponding Long value
   */
                    Long.fromBytes = function fromBytes(bytes, unsigned, le) {
                        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
                    };
                    /**
   * Creates a Long from its little endian byte representation.
   * @param {!Array.<number>} bytes Little endian byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {Long} The corresponding Long value
   */
                    Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
                        return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
                    };
                    /**
   * Creates a Long from its big endian byte representation.
   * @param {!Array.<number>} bytes Big endian byte representation
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {Long} The corresponding Long value
   */
                    Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
                        return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
                    };
                    var _default = Long;
                    exports.default = _default;
                    return "default" in exports ? exports.default : exports;
                }({});
                if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
                    return Long;
                }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else {}
                /***/
            }
            /******/
        };
        /************************************************************************/
        /******/ // The module cache
        /******/
        var __webpack_module_cache__ = {};
        /******/
        /******/ // The require function
        /******/
        function __webpack_require__(moduleId) {
            /******/ // Check if module is in cache
            /******/ var cachedModule = __webpack_module_cache__[moduleId];
            /******/
            if (cachedModule !== undefined) {
                /******/ return cachedModule.exports;
                /******/
            }
            /******/ // Create a new module (and put it into the cache)
            /******/
            var module = __webpack_module_cache__[moduleId] = {
                /******/ // no module.id needed
                /******/ // no module.loaded needed
                /******/ exports: {}
                /******/
            };
            /******/
            /******/ // Execute the module function
            /******/
            __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            /******/
            /******/ // Return the exports of the module
            /******/
            return module.exports;
            /******/
        }
        /******/
        /************************************************************************/
        /******/ /* webpack/runtime/global */
        /******/ (() => {
            /******/ __webpack_require__.g = function() {
                /******/ if (typeof globalThis === "object") return globalThis;
                /******/
                try {
                    /******/ return this || new Function("return this")();
                    /******/
                } catch (e) {
                    /******/ if (typeof window === "object") return window;
                    /******/
                }
                /******/
            }();
            /******/
        })();
        /******/
        /************************************************************************/
        /******/
        /******/ // startup
        /******/ // Load entry module and return exports
        /******/ // This entry module used 'module' so it can't be inlined
        /******/
        var __webpack_exports__ = __webpack_require__("./index.js");
        /******/
        /******/
        return __webpack_exports__;
        /******/
    })();
});